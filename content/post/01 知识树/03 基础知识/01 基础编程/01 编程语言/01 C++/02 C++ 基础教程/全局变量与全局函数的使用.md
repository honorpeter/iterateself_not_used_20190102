# 需要补充的

- 关于这个之前弄明白了，但是一段时间不写，有有点不确定，要好好总结下。
- 还是有必要找权威的资料系统的总结下的，c++ primer 看下这部分的内容，总结进来。


# extern用法，全局变量，全局函数与头文件（重复定义）



用 `#include` 可以包含其他头文件中变量、函数的声明，为什么还要extern关键字,如果我想引用一个全局变量或 函数a，我只要直接在源文件中包含#include<xxx.h> (xxx.h包含了a的声明)不就可以了么，为什么还要用extern呢？？这个问题一直也是似是而非的困扰着我许多年了，今天上网狠狠查了一下总算小有 所获了：

**头文件**

首先说下头文件，其实头文件对计算机而言没什么作用，她只是在预编译时在#include的地方展开一下，没别的意义了，其实头文件主要是给别人看的。

我做过一个实验，将头文件的后缀改成xxx.txt，然后在引用该头文件的地方用 `#include"xxx.txt"`，编译，链接都很顺利的过去了，由此可知，头文件仅仅为阅读代码作用，没其他的作用了！

不管是C还是C++，你把你的函数，变量或者结构体，类啥的放在你的.c或者.cpp文件里。然后编译成lib,dll,obj,.o等等，然后别人用的时候 最基本的gcchisfile.cpp yourfile.o|obj|dll|lib 等等。

但对于我们程序员而言，他们怎么知道你的lib,dll...里面到底有什么东西？要看你的头文件。你的头文件就是对用户的说明。函数，参数，各种各样的接口的说明。

​    那既然是说明，那么头文件里面放的自然就是关于函数，变量，类的“声明”了。记着，是“声明”，不是“定义”。

那么，我假设大家知道声明和定义的区别。所以，最好不要傻嘻嘻的在头文件里定义什么东西。比如全局变量：


```
#ifndef _XX_头文件.H
#define _XX_头文件.H
int A;
#endif
```


那么，很糟糕的是，这里的intA是个全局变量的定义，所以如果这个头文件被多次引用的话，你的A会被重复定义

显 然语法上错了。只不过有了这个#ifndef的条件编译，所以能保证你的头文件只被引用一次，不过也许还是会岔子，但若多个c文件包含这个头文件时还是会出错的，因为宏名有效范围仅限于本c源文件，所以在这多个c文件编译时是不会出错的，但在链接时就会报错，说你多处定义了同一个变量，

Linking...

incl2.obj : error LNK2005: "int glb" (?glb@@3HA)already defined in incl1.obj

Debug/incl.exe : fatal error LNK1169: one or more multiplydefined symbols found

注意！！！

extern

这个关键字真的比较可恶，在声明的时候，这个extern居然可以被省略，所以会让你搞不清楚到底是声明还是定义，下面分变量和函数两类来说：

**（1）变量**

尤其是对于变量来说。

extern int a;//声明一个全局变量a

int a; //定义一个全局变量a



extern int a =0 ;//定义一个全局变量a并给初值。

int a =0;//定义一个全局变量a,并给初值，



第四个 等于 第 三个，都是定义一个可以被外部使用的全局变量，并给初值。

糊涂了吧，他们看上去可真像。但是定义只能出现在一处。也就是说，不管是int a;还是extern int a=0;还是int a=0;都只能出现一次，而那个extern int a可以出现很多次。

当你要引用一个全局变量的时候，你就要声明，extern int a;这时候extern不能省略，因为省略了，就变成int a;这是一个定义，不是声明。

**（2）函数**

​     函数，函数，对于函数也一样，也是定义和声明，定义的时候用extern，说明这个函数是可以被外部引用的，声明的时候用extern说明这是一个声明。 但由于函数的定义和声明是有区别的，定义函数要有函数体，声明函数没有函数体，所以函数定义和声明时都可以将extern省略掉，反正其他文件也是知道这个函数是在其他地方定义的，所以不加extern也行。两者如此不同，所以省略了extern也不会有问题。

​    比如：


```
int fun(void)
{
  return 0;
}
```


很好，我们定义了一个全局函数


```
int fun(void);
```
我们对它做了个声明，然后后面就可以用了

加不加extern都一样

我们也可以把对fun的声明放在一个头文件里，最后变成这样


```
int fun(void);//函数声明，所以省略了extern，完整些是externint fun(void);
int fun(void)
{
  return 0;
}//一个完整的全局函数定义，因为有函数体，extern同样被省略了。
```
然后，一个客户，一个要使用你的fun的客户，把这个头文件包含进去，ok，一个全局的声明。没有问题。

但是，对应的，如果是这个客户要使用全局变量，那么要extern 某某变量；不然就成了定义了。

**总结下：**

**对变量而言，如果你想在本源文件中使用另一个源文件的变量，就需要在使用前用extern声明该变量，或者在头文件中用extern声明该变量；**

**对函数而言，如果你想在本源文件中使用另一个源文件的函数，就需要在使用前用声明该函数，声明函数加不加extern都没关系，所以在头文件中函数可以不用加extern。**



# 相关资料

- [extern用法，全局变量，全局函数与头文件（重复定义）](https://blog.csdn.net/yexiaozi_007/article/details/8128212)
- [在C++中如何使用全局变量？](https://www.zhihu.com/question/24389589) vczh 的答案好好理解下。还是有点不清楚。
- [C++全局变量的声明和定义](https://blog.csdn.net/candyliuxj/article/details/7853938)
