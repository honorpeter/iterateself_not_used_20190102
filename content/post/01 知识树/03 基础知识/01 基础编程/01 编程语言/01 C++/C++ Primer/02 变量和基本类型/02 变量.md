---
title: 02 变量
toc: true
date: 2018-08-03 19:56:18
---


##### 2.2变量

变量提供一个具名的、可供程序操作的存储空间。C#中的每个变量都有其数据类型， 数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变 量能参与的运算。对C++程序员来说，“变量(variable)”和“对象(object)” 一般可以互 换使用。

^6 2.2.1变量定义

变量定义的基本形式是：首先是类型说明符(type specifier),随后紧跟由一个或多个 变量名组成的列表，其中变量名以逗号分隔，最后以分号结束。列表中毎个变量名的类型 都由类型说明符指定，定义时还可以为一个或多个变量赋初值：

int sum = 0, value, // sum、value 和 units_sold 都是 int units_sold = 0;    // sum 和 units_sold 初值为 0

Sales_item item;    // item 的类型是 Sales_item (参见 1.5.1 节，第 17 页)

// string是一种库类型，表示一个可变长的字符序列

std: : string book ("0-201-78345-X") ; //book 通过一个 string 字面值初始化

book的定义用到了库类型std: : string，像iostream (参见1.2节，第6页) 一样，string也是在命名空间std中定义的，我们将在第3章中对string类型做更详 细的介绍。眼下，只需了解string是一种表示可变长字符序列的数据类型就可以了。C++ 库提供了几种初始化string对象的方法，其中一种是把字面值拷贝给string对象(参 见2.1.3节，第36页)，因此在上例中，book被初始化为0-201-78345-X。

术语：何为对象?

C++程序员们在很多场合都会使用对象(object)这个名词。通常情况下，对象是指 一块能存储数据并具有某种类型的内存空间。

一些人仅在与类有关的场景下才使用“对象”这个词。另一些人则已把命名的对象 和未命名的对象区分开来，他们把命名了的对象叫做变量还有一些人把对象和值区分 开来，其中对象指能被程序修改的数据，而值(value)指只读的数据。

本书遵循大多数人的习惯用法，即认为对象是具有某种数据类型的内存空间我们 在使用对象这个词时，并不严格区分是类还是内置类型，也不区分是否命名或是否只读。

初始值

当对象在创建时获得了一个特定的值，我们说这个对象被初始化(initialized) 了。用 于初始化变量的值可以是任意复杂的表达式。当一次定义了两个或多个变量时，对象的名 字随着定义也就马上可以使用了。因此在同一条定义语句中，可以用先定义的变量值去初 始化后定义的其他变量。

//正确：price先被定义并赋值，随后被用于初始化discount double price = 109.99, discount = price * 0.16;

//正确：调用函教applyDiscount，然后用函数的返回值初始化salePrice double salePrice = applyDiscount(price, discount);

在C++语言中，初始化是一个异常复杂的问题，我们也将反复讨论这个问题。很多柷 序员对于用等号=来初始化变量的方式倍感困惑，这种方式容易让人认为初始化玷赋值的 一种。事实上在C++语言中，初始化和赋值是两个完全不同的操作。然而在很多编稈语j 中二者的区别几乎可以忽略不计，即使在C++语言中有时这种区别也无关紧要，所以人们 特别容易把二者混为一谈。需耍强调的是，这个概念至关重耍，我们也将在后面不||: •次＜^J 提及这一点。

/]\ 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含 ^SninG义是把对象的当前值擦除，而以一个新值来替代

列表初始化

C++语言定义了初始化的好几种不同形式，这也是初始化问题复杂性的-个体现。例 如，要想定义一个名为units_sold的int变量并初始化为0,以下的4条语句都可以 做到这一点：

int units_sold =0; int units_sold = {0}; int units_sold{0}; int units_sold(0);

作为C++11新标准的一部分，用花括号来初始化变量得到了全面应用，而在此之前，

这种初始化的形式仅在某些受限的场合下才能使用。出于3.3.1节(第88迈)将耍介绍的 原因，这种初始化的形式被称为列表初始化(list initialization)。现在，无论是初始化对象 还是某些时候为对象赋新值，都可以使用这样一组由花括号括起来的初始值了。

当用于内置类型的变量时，这种初始化形式有--个重要特点：如果我们使用列农初始 化且初始值存在丢失信息的风险，则编译器将报错：

long double Id = 3.1415926536;

int a{Id}, b = {Id};    //错误：转换未执行，因为存在丢失信息的危险

int c（ld） , d = Id;    //正确：转换执行，且确实丢失了部分值

使用long double的值初始化int变量吋可能丢失数据，所以编译器拒绝了 a和b的初 始化请求。其中，至少Id的小数部分会丢失掉，而且int也可能存不下Id的整数部分。

刚刚所介绍的看起来无关紧要，毕竟我们不会故意用long double的值去初始化 int变量。然而，像第16章介绍的一样，这种初始化有可能在不经意间发生。我们将在 3.2.1节（第76页）和3.3.1节（第88页）对列表初始化做更多介绍。

默认初始化

如果定义变量时没有指定初值，则变量被默认初始化（default initialized）,此时变量 被赋予了 "默认值”，默认值到底是什么由变量类型决定，同时定义变量的位置也会对此 有影响。

nr>    如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数

体之外的变量被初始化为0。然而如6.1.1节（第185页）所示，一种例外情况是，定义 在函数体内部的内置类型变量将不被初始化（uninitialized）。一个未被初始化的内置类型 变量的值是未定义的（参见2.1.2节，第33页），如果试图拷贝或以其他形式访问此类值 将引发错误。

每个类各自决定其初始化对象的方式。而且，是否允许不经初始化就定义对象也由类 自己决定。如果类允许这种行为，它将决定对象的初始值到底是什么。

绝大多数类都支持无须显式初始化而定义对象，这样的类提供了一个合适的默认值。 例如，以刚刚所见为例，string类规定如果没有指定初值则生成一个空串：

std: : string empty; // empty非显式地初始化为一个空串 Sales_item item;    //被默认初始化的Sales_item对象

一些类要求每个对象都显式初始化，此时如果创建了一个该类的对象而未对其做明确 的初始化操作，将引发错误。

![img](C++  Primer 5-15.jpg)



定义于函数体内的内置类型的对象如果没有初始化，则其值未定义类的对象 如果没有显式地初始化，则其值由类确定：

###### 2.2.1节练习

练习2.9:解释下列定义的含义。对于非法的定义，请说明错在何处并将其改正。

(a) std: :cin » int input_value;    (b) int i = { 3.14 };

(c)double salary = wage = 9999.99; (d) int i = 3.14;

练习2.10：下列变量的初值分别是什么？

std::string global_str; int global_int; int main()

{

int local_int;

std::string local_str;

}

提示：未初始化变量引发运行吋故障

未初始化的变量含有一个不确定的值，使用未初始化变量的值是一种错误的编程行 为并且很难调试。尽管大多数编译器都能对一部分使用未初始化变量的行为提出警告， 但严格来说，编译器并未被要求检查此类错误。

使用未初始化的变量将带来无法预计的后果。有时我们足够幸运，一访问此类对象 程序就崩溃并报错，此时只要找到崩溃的位置就很容易发现变量没被初始化的问题。另 外一些时候，程序会一直执行完并产生错误的结果。更糟糕的情况是，程序结果时对时 错、无法把握。而且，往无关的位置添加代码还会导致我们误以为程序对了，其实结果 仍旧有错。/

^建议初始化每一个内置类型的变量。虽然并非必须这么做，但如果我们不能确 保初始化后程序安全，那么这么做不失为一种简单可靠的方法。

###### 2.2.2突量声明和定义的关系

为了允许把程序拆分成多个逻辑部分来编写，C++语言支持分离式编译(separate compilation)机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。

如果将程序分为多个文件，则需要有在文件间共享代码的方法。例如，一个文件的代 码可能需要使用另一个文件中定义的变量-一个实际的例子是std: : cout和std: : cin,

它们定义于标准库，却能被我们写的程序使用。

为了支持分离式编译，C++语言将声明和定义区分开来。声明(declaration)使得名字 为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义 (definition)负责创建与名字关联的实体。

变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义 还申请存储空间，也可能会为变量赋一个初始值。

如果想声明一个变量而非定义它，就在变量名前添加关键字extern,而且不要显式 地初始化变量：

extern int i; II声明i而非定义i int j;    //声明并定义j

任何包含了显式初始化的声明即成为定义。我们能给由extern关键字标记的变量赋 一个初始值，但是这么做也就抵消了 extern的作用。extern语句如果包含初始值就不 再是声明，而变成定义了：

extern double pi = 3.1416; // 定义 在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。

![img](C++  Primer 5-16.jpg)



变量能且只能被定义一次，但是可以被多次声明。

声明和定义的区别看起来也许微不足道，但实际上却非常重要。如果要在多个文件中 使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现在且只能出现在 一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。

关于C++语言对分离式编译的支持我们将在2.6.3节(第67页)和6.1.3节(第186 <50

页)中做更详细的介绍。

| 2.2.2节练习                                                  |      |
| ------------------------------------------------------------ | ---- |
| 练习2.11:指出下面的语句是声明还是定义：(a)    extern int ix = 1024;(b)    int iy;(c)    extern int iz; | •    |

K键概念：静态类哦

C++是一种静态类型(statically typed )语言，其含义是在编译阶段检查类型。其中， 检查类型的过程称为类型检查(type checking k

我们已经知道，对象的类型决定了对象所能参与的运算。在C++语言中，编译器负 责检查数据类型是否支持要执行的运算，如果试图执行类型不支持的运算，编译器将报 错并且不会生成可执行文件。

程序越复杂，静态类型检查越有助于发现问题然而，前提是编译器必须知道每一 个实体对象的类型，这就要求我们在使用某个变量之前必须声明其类型:，

###### 2.2.3标识符

C++的标识符(identifier)由字母、数字和下画线组成，其巾必须以字母或下画线开 头。标识符的长度没有限制，但是对大小写字母敏感：

//定义4个不同的int变量

int somename, someName, SomeName, SOMENAME;

如表2.3和表2.4所示，C++语言保留了一些名字供语言本身使用，这些名字不能被用 作标识符。

同吋，C科也为标准库保留了一些名字。用户自定义的标识符中不能连续出现两个下 画线，也不能以下画线紧连大写字母开头。此外，定义在函数体外的标识符不能以下画线 开头。

变量命名规范

变量命名有许多约定俗成的规范，下面的这些规范能有效提高程序的可读性：

标识符要能体现实际含义。

•变量名一般用小写字母，如index,不要使用Index或INDEX。

•用户自定义的类名一般以大写字母开头，如Sales_item。

•如果标识符由多个单词组成，则单词间应有明显区分，如Student_lOan或 studentLoan,不要使用 studentloano

对于命名规范来说，若能坚持，必将有效..

表2.3: C++关键字

| alignas    | continue     | friend    | register         | true     |
| ---------- | ------------ | --------- | ---------------- | -------- |
| alignof    | decltype     | goto      | reinterpret_cast | try      |
| asm        | default      | if        | return           | typedef  |
| auto       | delete       | inline    | short            | typeid   |
| bool       | do           | int       | signed           | typename |
| break      | double       | long      | sizeof           | union    |
| case       | dynamic cast | mutable   | static           | unsigned |
| catch      | else         | namespace | static_assert    | using    |
| char       | enum         | new       | static cast      | virtual  |
| charl6 t   | explicit     | noexcept  | struct           | void     |
| char32 t   | export       | nullptr   | switch           | volatile |
| class      | extern       | operator  | template         | wchar_t  |
| const      | false        | private   | this             | while    |
| constexpr  | float        | protected | thread local     |          |
| const cast | for          | public    | throw            |          |

|        |        | 表 2.4: | C++操作符替代名 |       |        |
| ------ | ------ | ------- | --------------- | ----- | ------ |
| and    | bitand | compl   | not_eq          | or_eq | xor eq |
| and eq | bitor  | not     | or              | xor   |        |

###### 2.2.3节练习

练习2.12：请指出下面的名字中哪些是非法的？

(a) int double = 3.14;    (b) int

(c) int catch-22;    (d) int l_or_2 = 1;

(e) double Double = 3.14;

###### 2.2.4名字的件:用域

不论是在程序的什么位置，使用到的每个名字都会指向一个特定的实体：变量、函数、 类型等。然而，同一个名字如果出现在程序的不同位置，也可能指向的是不同实体。

<48~|



作用域(scope)是程序的一部分，在其中名字有其特定的含义。C++语言中大多数作 用域都以花括号分隔。

同一个名字在不同的作用域中可能指向不同的实体。名字的有效区域始于名字的声明 语句，以声明语句所在的作用域末端为结束，

一个典型的示例来自T 1.4.2节(第11页)的程序：

^include <iostream> int main()

{

int sum = 0;

// sum用于存放从1到10所有数的和 for (int val = 1; val <= 10; ++val)

sum += val; // 等价于 sum = sum + val

std: :cout « "Sum of 1 to 10 inclusive is •’

« sum << std::endl;

return 0;

}

这段程序定义了 3个名字：main、sum和val,同时使用了命名空间名字std,该空间 提供了 2个名字cout和cin供程序使用。

名字main定义于所有花括号之外，它和其他大多数定义在函数体之外的名字一样拥 有全局作用域(global scope)。一旦声明之后，全局作用域内的名字在整个程序的范围内 都可使用。名字sum定义于main函数所限定的作用域之内，从声明sum开始直到main 函数结束为止都可以访问它，但是出了 main函数所在的块就无法访问了，因此说变量sum 拥有块作用域(block scope)。名字val定义于for语句内，在for语句之内可以访问 val,但是在main函数的其他部分就不能访问它了。

建议：当你第•次使用变量吋再定义它

一般来说，在对象第一次被使用的地方附近定义它是一种好的选择，因为这样做有 助于更容易地找到变量的定义。更重要的是，当变量的定义与它第一次被使用的地方很 近时，我们也会赋给它一个比较合理的初始值

嵌套的作用域

作用域能彼此包含，被包含(或者说被嵌套)的作用域称为内层作用域(innerscope), 包含着别的作用域的作用域称为外层作用域(outer scope)o

作用域中一旦声明了某个名字，它所嵌套着的所有作用域中都能访问该名字。同时， 允许在内层作用域中重新定义外层作用域已有的名字：

| 49 〉    #include <iostream>

//该程序仅用于说明：函数内部不宜定义与全局变量同名的新变量 int reused = 42; II reused拥有全局作用域

int main()

{

int unique = 0; // unique 拥有块作用域

//输出#1:使用全局变量reused;输出42 0

std: : cout << reused « *' " << unique « std: : endl;

int reused =0; //新建局部变量reused，覆盖了全局变量reused

//输出#2:使用局部变量reused;输出0 0

std::cout « reused << " " « unique « std::endl;

//输出#3:显式地访问全局变量reused;输出42 0

std: : cout « :: reused « ” ’’ << unique << std: : endl;

return 0;

}

输出#1出现在局部变量reused定义之前，因此这条语句使用全局作用域中定义的名字 reused,输出42 0。输出#2发生在局部变量reused定义之后，此时局部变量reused 正在作用域内(in scope),因此第二条输出语句使用的是局部变量reused而非全局变量， 输出0 0。输出#3使用作用域操作符(参见1.2节，第7页)来覆盖默认的作用域规则， 因为全局作用域本身并没有名字，所以当作用域操作符的左侧为空时，向全局作用域发出 请求获取作用域操作符右侧名字对应的变量。结果是，第三条输出语句使用全局变量 reused,输出 42 0。

![img](C++  Primer 5-17.jpg)



如果函数有可能用到某全局变量，则不宜再定义一个同名的局部变量


###### 2.2.4节练习

练习2.13：下面程序中j的值是多少？

int i = 42; int main()

int i = 100; int j = i;

练习2.14：下面的程序合法吗？如果合法，它将输出什么？

int i = 100, sum = 0;

for (int i = 0; i != 10; ++i)

sum += i;

std::cout << i << " " « sum « std::endl;
