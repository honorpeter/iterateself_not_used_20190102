---
title: 03 复合类型
toc: true
date: 2018-08-03 19:55:09
---

##### 2.3复合类喂

复合类型(compound type)是指基于其他类型定义的类型。C++语言有几种复合类型， 本章将介绍其中的两种：引用和指针。

与我们已经掌握的变量声明相比，定义复合类型的变量要复杂很多。2.2节(第38页) 提到，一条简单的声明语句由一个数据类型和紧随其后的一个变量名列表组成。其实更通 用的描述是，一条声明语句由一个基本数据类型(base type)和紧随其后的一个声明符 (declarator)列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关 的某种类型，

目前为止，我们所接触的声明语句中，声明符其实就是变量名，此时变量的类型也就 是声明的基本数据类型。其实还可能有更复杂的声明符，它基于基本数据类型得到更复杂 的类型，并把它指定给变量。

2.3.1 引用

C++11中新增了一种引用：所谓的"右值引用(rvalue reference)”，我们将在

13.6.1节(第471页)做更详细的介绍、这种引用主要用于内置类：严格来说，

当我们使用术语“引用(reference)’’时，指的其实是“左值引用(lvalue reference。

引用(reference)为对象起了另外一个名字，引用类型引用(refers to)另外一种类型。 通过将声明符写成&d的形式来定义引用类型，其中d是声明的变量名：

int ival = 1024;

int SrefVal = ival;    // refVal 指向 ival (是 ival 的另一个名字)

int &refVal2;    //报错：引用必须被初始化

-般在初始化变量时，初始值会被拷贝到新建的对象中=然而定义引用时，程序把引用和 它的初始值绑定(bind)在一起，而不是将初始值拷51给引用。一旦初始化完成，引用将 和它的初始值对象一直绑定在一起=因为无法令引用重新绑定到另外一个对象，因此引用 必须初始化。

引用即别名

![img](C++  Primer 5-18.jpg)



引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字

定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的：

refVal = 2;    //把2賦给refVal指向的对象，此处即是赋给了 ival

int ii = refVal; // 与 ii = ival 执行结果^羊

EH＞为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取了与 引用绑定的对象的值。同理，以引用作为初始值，实际上是以与引用绑定的对象作为初 始值：

//正确：refVal3绑定到了那个与refVal绑定的对象上，这里就是绑定到ival上 int &refVal3 = refVal;

//利用与refVal绑定的对象的值初始化变量i

int i = refVal; //正确：i被初始化为ival的值

因为引用本身不是一个对象，所以不能定义引用的引用。

引用的定义

允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号&开头： int i = 1024, i2 = 2048; // i 和 i2 都是 int

int &r = i, r2 = i2;    // r是一个引用，与i绑定在一起，r2是int

int i3 = 1024, &ri = i3; // i3 是 int, ri 是一个引用，与 i3 绑定在一起 int &r3 = i3, &r4 = i2;    // r3 和 r4 都是引用

除了 2.4.1节(第55页)和15.2.3节(第534页)将要介绍的两种例外情况，其他所 有引用的类型都要和与之绑定的对象严格匹配。而且，引用只能绑定在对象上，而不能与 字面值或某个表达式的计算结果绑定在一起，相关原因将在2.4.1节详述：

int &refVal4 = 10;    //错误：引用类型的初始值必须是一个对象

double dval = 3.14;

int &refVal5 = dval;    //错误：此处引用类型的初始值必须是:Lnt型对象

###### 2.3.1节练习

练习2.15:下面的哪个定义是不合法的？为什么？

(a) int ival = 1.01;    (b) int &rvall = 1.01;

(c) int &rval2 = ival;    (d) int &rval3;

练习2.16：考查下面的所有赋值然后冋答：哪些赋值是不合法的？为什么？哪些赋值是 合法的？它们执行了什么样的操作？

int i = 0, &rl = i;    double d = 0, &r2 = d;

(a)r2 = 3.14159;    (b) r2 = rl;

(c) i = r2;    (d) rl = d;

练习2.17：执行下面的代码段将输出什么结果？

int i, &ri = i; i = 5; ri = 10;

std::cout << i « " " << ri << std::endl;

###### 2.3.2 指针    50

指针（pointer）是“指向（point to）”另外一种类型的复合类型。与引用类似，指针 也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。其一,指针本身 就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不 同的对象。其二，指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的 指针如果没有被初始化，也将拥有一个不确定的值，

WARNING



指^十通常难以理解，即使是有经验的程序员也常常因为调试指针引发的错误而 被备受折麼.、

定义指针类型的方法将声明符写成*d的形式，其中d是变量名。如果在一条语句中 定义了几个指针变量，每个变量前面都必须有符号*:

int *ipl, *ip2;    // ipl和ip2都是指向int型对象的指针

double dp, *dp2;    // dp2是指向double型对象的指针，dp是double型对象

获取对象的地址

指针存放某个对象的地址，要想获取该地址，需要使用取地址符（操作符&）: int ival = 42;

int *p = &ival; // p存放变量ival的地址，或者说p是指向变量ival的指针

第二条语句把p定义为一个指向int的指针，随后初始化P令其指向名为ival的int 对象。因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。

除了 2.4.2节（第56页）和15.2.3节（第534页）将要介绍的两种例外情况，其他所 有指针的类型都要和它所指向的对象严格匹配：

| double dval; double *pd = &dval; double *pd2 = pd; | //正确 //正确 |
| -------------------------------------------------- | ------------- |
| int *pi = pd;                                      | //错误        |
| pi = &dval;                                        | //错误        |



初始值是double型对象的地址

初始值是指向double对象的指针

指针pi的类型和pd的类型不匹配

试图把double型对象的地址赋给int型指针

因为在声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以者必须匹 配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。

指针值

指针的值（即地址）应属下列4种状态之一: 1.指向一个对象。

2 .指向紧邻对象所占空间的下一个位置。

3-空指针，意味着指针没有指向任何对象。

4.无效指针，也就是上述情况之外的其他值。

试图拷贝或以其他方式访问无效指针的值都将引发错误。编译器并不负责检查此类错误， ES3>这一点和试图使用未经初始化的变量是一样的。访问无效指针的后果无法预计，因此程序

员必须清楚任意给定的指针是否有效。

尽管第2种和第3种形式的指针是有效的，但其使用同样受到限制。显然这些指针没 有指向任何具体对象，所以试图访问此类指针（假定的）对象的行为不被允许。如果这样 做了，后果也无法预计。

利用指针访问对象

如果指针指向了一个对象，则允许使用解引用符（操作符*）来访问该对象： int ival = 42;

int *p = &ival; // p存放着变量ival的地址，或者说p是指向变量ival的指针 cout « *p;    //由符号*得到指针p所指的对象，输出42

对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所 指的对象赋值：

*p = 0;    //由符号*得到指针p所指的对象，即可经由p为变量ival賦值

cout « *p;    // 输出 0

如上述程序所示，为+p赋值实际上是为p所指的对象赋值。

![img](C++  Primer 5-20.jpg)



解引用操作仅适用于那些确实指向了某个对象的有效指针

又键概念：某拽符'4■打多艰穴义

像&和*这样的符号，既能用作表达式里的运算符，也能作为声明的一部分出现，符 号的上下文决定了符号的意义：

| int  | i =  | 42;  |      |                  |
| ---- | ---- | ---- | ---- | ---------------- |
| int  | &r = | :i;  | //   | &紧随类型名出现  |
| int  | *p； |      | //   | *紧随类型名出现  |
| P =  | &i ; |      | //   | &出现在表达式中  |
| *P = | =i； |      | //   | *出现在表达式中  |
| int  | &r2  | =*p; | //   | &是声明的一■部分 |



因此是声明的一部分，r是一个引用 因此是声明的一部分，p是一个指针 是一个取地址符

是一个解引用符 *是一个解引用符



在声明语句中，&和*用于组成复合类型；在表达式中，它们的角色又转变成运算符。在 不同场景下出现的虽然是同一个符号，但是由于含义截然不同，所以我们完全可以把它 当作不同的符号来看待。

空指针

空指针（null pointer）不指向任何对象，在试图使用一个指针之前代码可以首先检查 它是否为空。以下列出几个生成空指针的方法：

I 54 >    int *pl = nullptr;    // 等价于 int *pl = 0;

int *p2 = 0;    //直接将p2初始化为字面常量0

// 需要首先#include cstdlib

int *p3 = NULL;    // 等价于 int *p3 = 0;

fgjT］得到空指针最直接的办法就是用字面值nullptr来初始化指针，这也是C++11新标准刚 刚引入的一种方法。nullptr是一种特殊类型的字面值，它可以被转换成（参见2.1.2节，

第32页）任意其他的指针类型。另一种办法就如对P2的定义一样，也可以通过将指针初 始化为字面值0来生成空指针。

过去的程序还会用到一个名为NULL的预处理变量（preprocessor variable）来给指针 赋值，这个变量在头文件cstdlib中定义，它的值就是0。

2.6.3节（第68页）将稍微介绍一点关于预处理器的知识，现在只要知道预处理器是 运行于编译过程之前的一段程序就可以了。预处理变量不属于命名空间std,它由预处理 器负责管理，因此我们可以直接使用预处理变量而无须在前面加上std::.

当用到一个预处理变量时，预处理器会自动地将它替换为实际值，因此用NULL初始 化指针和用0初始化指针是一样的，在新标准下，现在的C++程序最好使用nullptr, 同时尽量避免使用NULL。

把int变量直接赋给指针是错误的操作，即使int变量的值恰好等于0也不行。 int zero = 0;

pi = zero;    //错误：不能把int变量直接赋给指针

迸议：初始化所有指针

使用未经初始化的指针是引发运行时错误的一大原因。

和其他变量一样，访问未经初始化的指针所引发的后果也是无法预计的、通常这一 行为将造成程序崩溃，而且一旦崩溃，要想定位到出错位置将是特别棘手的问题。_

在大多数编译器环境下，如果使用了未经初始化的指针，则该指针所占内存空间的 当前内容将被看作-■个地址值。访问该指针，相当于去访问一个本不存在的位置上的本 不存在的对象。糟糕的是，如果指针所占内存空间中恰好有内容，而这些内容又被当作 了某个地址，我们就很难分清它到底是合法的还是非法的了。

因此建议初始化所有的指针，并且在可能的情况下，尽量等定义了对象之后再定义 指向它的指针。如果实在不清楚指针应该指向何处，就把它初始化为nullptr或者0, 这样程序就能检测并知道它没有指向任何具体的对象了。

赋值和指针

指针和引用都能提供对其他对象的间接访问，然而在具体实现细节上二者有很大不 同，其中最重要的一点就是引用本身并非一个对象。一旦定义了引用，就无法令其再绑定＜55~| 到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象。

指针和它存放的地址之间就没有这种限制了。和其他任何变量（只要不是引用）一样，

给指针赋值就是令它存放一个新的地址，从而指向一个新的对象：

int i = 42; int *pi = 0; int *pi2 = &i; int *pi3;



pi3 = pi2; pi2 = 0;



// pi被初始化，但没有指向任何对象

// pi2被初始化，存有i的地址

//如果pi3定义于块内，则pi3的值是无法确定的

// pi3和pi2指向同一个对象i //现在pi2不指向任何对象了

有时候要想搞清楚一条赋值语句到底是改变了指针的值还是改变了指针所指对象的 值不太容易，最好的办法就是记住赋值永远改变的是等号左侧的对象。当写出如下语句时, // pi的值被改变，现在pi指向了 ival

pi = &ival;



意思是为pi赋一个新的值，也就是改变了那个存放在pi内的地址值。相反的，如果写 出如下语句，

*pi = 0;    II ival的值被改变，指针pi并没有改变

则*pi （也就是指针pi指向的那个对象）发生改变=

其他指针操作

只要指针拥有一个合法值，就能将它用在条件表达式中。和采用算术值作为条件（参 见2.1.2节，第32页）遵循的规则类似，如果指针的值是0,条件取false:

int ival = 1024; int *pi = 0; int *pi2 = &ival; if (pi)

// ... if (pi2)

// ...



II pi合法，是一个空指针

II pi2是一个合法的指针，存放着ival的地址 // pi的值是0，因此条件的值是false

// pi2指向ival，因此它的值不是0,条件的值是true

任何非0指针对应的条件值都是true。

对于两个类型相同的合法指针，可以用相等操作符（==）或不相等操作符（!=）来比 较它们，比较的结果是布尔类型=如果两个指针存放的地址值相同，则它们相等；反之它 们不相等。这里两个指针存放的地址值相同（两个指针相等）有三种可能：它们都为空、 都指向同一个对象，或者都指向了同一个对象的下一地址。需要注意的是，一个指针指向 某对象，同时另一个指针指向另外对象的下一地址，此时也有可能出现这两个指针值相同 的情况，即指针相等。

因为上述操作要用到指针的值，所以不论是作为条件出现还是参与比较运算，都必须 使用合法指针，使用非法指针作为条件或进行比较都会引发不可预计的后果。

3.5.3节（第105页）将介绍更多关于指针的操作。

rsT> void* 指针

void*是一种特殊的指针类型，可用于存放任意对象的地址，一个void*指针存放着 一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象 并不了解：

double obj = 3.14, *pd = &obj;

II正确：void*能存放任意类型对象的地址

void *pv = &obj ;    // obj可以是任意类型的对象

pv = pd;    // pv可以存放任意类4!的指针

利用void*指针能做的事儿比较有限：拿它和别的指针比较、作为函数的输入或输出，或 者赋给另外一个void*指针。不能直接操作void*指针所指的对象，因为我们并不知道 这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。

概括说来，以void*的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间 中所存的对象，关于这点将在19.1.1节（第726页）有更详细的介绍，4.11.3节（第144 页）将讲述获取void*指针所存地址的方法。

2.3.2节练习_

练习2.18：编写代码分别更改指针的值以及指针所指对象的值。

练习2.19：说明指针和引用的主要区别。

练习2.20:请叙述下面这段代码的作用。

int i = 42; int *pl = &i;

*pl = *pl * *pl;

练习2.21:请解释下述定义。在这些定义中有非法的吗？如果有，为什么？ int i = 0;

(a) double* dp = &i;    (b) int *ip = i; (c) int *p = &i;

练习2.22:假设P是一个int型指针，请说明下述代码的含义。

if (p)    // ...

if (*p)    // ...

练习2.23:给定指针p,你能知道它是否指向了一个合法的对象吗？如果能，叙述判断 的思路；如果不能，也请说明原因。

练习2.24：在下面这段代码中为什么p合法而1P非法？

int i = 42;    void *p = &i;    long *lp = &i;

2.3.3理解复合类型的声明    ®

如前所述，变量的定义包括一个基本数据类型(base type)和一组声明符。在同一条<57H 定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同。也就是说，一 条定义语句可能定义出不同类型的变量：

// i是一个int型的数，p是一个int型指针，r是一个int型引用 i = 1024, *p = &i, &r = i;

int

WARNING



很多程序员容易迷惑于基本数据类型和类型修饰符的关系，其实后者不过是声 明符的一部分罢了。

定义多个变量    <§

经常有一种观点会误以为，在定义语句中，类型修饰符(*或&)作用于本次定义的全 部变量。造成这种错误看法的原因有很多，其中之一是我们可以把空格写在类型修饰符和 变量名中间：

int* p;    //合法但是容易产生误导

我们说这种写法可能产生误导是因为int*放在一起好像是这条语句中所有变量共同的类 型一样。其实恰恰相反，基本数据类型是int而非int*。*仅仅是修饰了 p而已，对该 声明语句中的其他变量，它并不产生任何作用：

int* pi, p2;    // pi 是指向 int 的指针，p2 是 int

涉及指针或引用的声明，一般有两种写法。第一种把修饰符和变量标识符写在一起：

int *pl, *p2; // pi和p2都是指向int的指针

这种形式着重强调变量具有的复合类型。第二种把修饰符和类型名写在一起，并且每条语 句只定义一个变量：

int* pi;    //pi是指向int的指针

int* p2;    // p2是指向int的指针

这种形式着重强调本次声明定义了一种复合类型。

![img](C++  Primer 5-22.jpg)



上述两种定义指针或引用的不同方法没有孰对孰错之分，关键是选择并坚持其 中的一种写法，不要总是变来变去。

本书采用第一种写法，将* （或是&）与变量名连在一起。

指向指针的指针

一般来说，声明符中修饰符的个数并没有限制。当有多个修饰符连写在一起时，按照 □£＞其逻辑关系详加解释即可。以指针为例，指针是内存中的对象，像其他对象一样也有自己

的地址，因此允许把指针的地址再存放到另一个指针当中。

通过*的个数可以区分指针的级别。也就是说，**表示指向指针的指针，***表示指 向指针的指针的指针，以此类推：

int ival = 1024;

int *pi = &ival; //pi 指向一个 int 型的数 int **ppi = &pi; // ppi才旨向一个int型的才旨4十

此处pi是指向int型数的指针，而ppi是指向int型指针的指针，下图描述了它们之 间的关系。

ppi pi    ival

——4 —1——4    1024

解引用int型指针会得到一个int型的数，同样，解引用指向指针的指针会得到一 个指针。此时为了访问最原始的那个对象，需要对指针的指针做两次解引用：

cout << «

«

«

«



"The value of ival\n"

"direct value: " « ival « "\n" "indirect value: " « *pi << ”\n" "doubly indirect value: " << **ppi endl;

该程序使用三种不同的方式输出了变量ival的值：第一种直接输出；第二种通过int型 指针pi输出；第三种两次解引用ppi,取得ival的值。

指向指针的引用

引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对 指针的引用：

int i = 42; int *p; int *&r = p;



=&i; r = 0;



// p是一个int型指针 // r是一个对指针p的引用

r引用了 一个指针，因此给r賦值&i就是令p指向i 解引用r得到i，也就是p指向的对象，将i的值改为0

要理解r的类型到底是什么，最简单的办法是从右向左阅读r的定义。离变量名最近的符 号(此例中是&r的符号S)对变量的类型有最直接的影响，因此r是一个引用。声明符的 其余部分用以确定r引用的类型是什么，此例中的符号★说明r引用的是一个指针。最后, 声明的基本数据类型部分指出r引用的是一个int指针。

![img](C++  Primer 5-23.jpg)



面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它 的真实含义。

###### 2.3.3节结;习

<593



练习2.25：说明下列变量的类型和值。

(a) int* ip, i, &r = i; (b) int i, *ip = 0; (c) int* ip, ip2;
