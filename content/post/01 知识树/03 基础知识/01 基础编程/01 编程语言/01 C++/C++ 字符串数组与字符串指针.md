---
title: C++ 字符串数组与字符串指针
toc: true
date: 2018-08-05 19:12:49
---
# 字符串数组与字符串指针


TODO

- 还是再深入理解下。


在C语言中，对字符串的操作主要有两种方式，

一是使用字符数组，`char str[]`
二是使用字符指针。

那么二者有什么区别呢？下面将分述二者的使用，最后进行比较。

### 一、字符数组

​使用`char str[]`定义一个字符数组`str`，中括号内可以写上数字表示数组大小，也可以不写。如果不写数字，则必须为字符数组提供初始值，以便编译器进行内存分配。

可以使用字符串字面值(string literal)来初始化字符数组，也可使用字符字面值(character literal)初始化，如：

```cpp
char str1[10]="Hello";
char str2[]="World";
char str3[]={'H','e','l','l','o'};
```


只能对字符数组元素的赋值，而不能用赋值语句对整个数组赋值，如：

```cpp
char str4[10];
str4={'H','e','l','l','o'};    // 错误
str4="Hello";                  // 错误
str4[0]='H';str4[1]='e';str4[2]='l';str4[3]='l';str4[4]='o';   // 正确
```


可以使用循环将字符数组中的字符一个一个输出，也可以使用 `cout<<str1` 直接输出整个数组。

需要注意的是，上述代码中 `str1` 和 `str2` 是C风格字符串，而`str3`不是。C 风格字符串，是指以`\0`结尾的字符数组。C++为了兼容C，而保留了C中字符串的使用方法。

`str1`和`str2`使用字符串字面值进行初始化，字符串字面值使用`\0`表示字符串结束。因此`str2`长度为6，需要将`\0`计算在内。使用`strlen`函数，计算的是字符串的实际长度，不包含`\0`。<span style="color:red;">这些不统一真的会令人觉得麻烦，还是说有什么深意？确认下。</span>

而`str3`则不一样，它没有`\0`作为结束标志，因而不是C风格字符串，使用`cout<<str3`可能会出现意想不到的结果。

### 二、字符指针

可以使用 `char *str` 指向一个字符串。如：

```cpp
char *ptr="C++";
char strArr[]="C++";
char *ptr2=strArr;
```


使用`cout<<ptr`即可输出整个字符串，而使用`cout<<*ptr`则输出字符串的首字符。

字符指针也可指向 C 风格字符串，如`ptr`就是指向的C风格字符串。如果让`ptr`指向上节中的`str3`，输出`ptr`会出现同样的意想不到的结果。毕竟数组名其实就是一种指针。

三、区别

前面简单介绍了一下两种操作字符串的方法，这部分进行比较，是本文的重点。如下代码：


```cpp
char s[]="abc";
char *ptr="abc";
cout<<s<<endl;               // abc
cout<<*s<<endl;              // a
cout<<&s<<endl;              // 地址
cout<<(s+1)<<endl;           // bc
cout<<*(s+1)<<endl;          // b
cout<<&s[1]<<endl<<endl;     // a
cout<<ptr<<endl;             // abc
cout<<*ptr<<endl;            // a
cout<<&ptr<<endl;            // 地址
cout<<(ptr+1)<<endl;         // bc
cout<<*(ptr+1)<<endl;        // b
cout<<&ptr[1]<<endl;         // a
```


这些代码应该能够说明`char s[]`和`char *ptr`之间的相似点了。它们都是指向字符串的指针。

下面说二者的不同之处。如下一段代码：

```cpp
char ss[]="C++";
ss[0]='c';                  // 合法
char *p="C++";
p[0]='c';                   // 合法但不正确
```

该段代码在 VS2010 下编译可以通过，但是运行时程序会停止工作，为什么呢？原因在于`p[0]='c'`这一语句。该语句试图修改`p`指向的字符串的首个字符，出现了错误。

原因在于两种方式对字符数组操作的机制不同。使用`char *p="C++"`语句后，编译器在内存的文字常量区分配一块内存，保存`"C++""`这一字符串字面值，然后在栈上分配内存保存`p`，`p`的内容为`"C++"`的地址。`p[0]='c'`试图修改常量`"C++"`，程序当然就会崩溃了。而`char ss[]="C++"`语句，定义了一个数组，编译器为其在栈上分配了内存空间，因而可以进行修改操作。

因此，可以总结如下：

- `char ss[]`定义了一个数组，`ss`可认为是一个常指针，`ss`不可改变，但`ss`指向的内容可以发生改变。

- `char *p`定义了一个可变指针，`p`可以指向其它对象。但对于`char *p="abc"`这样的情况，`p`指向的是常量，故内容不能改变。


如下代码进一步说明`char ss[]`和`char *p`的区别：


```cpp
char *strA()
{
    char str[]="Hello";
​    return str;
}
```


调用该函数，不一定能够得到正确的结果。因为`str`定义了一个局部数据，是局部变量，存在于函数`strA`中的栈帧中。当函数调用完成后，栈帧恢复到函数`strA`调用前的状态，临时空间被重置，为函数分配的栈空间被收回，`str`所指向的地址也就不存在了。

将上述代码修改：

```cpp
char *strA()
{
​    char *str="Hello";
​    return str;
}
```


该函数能够正常运行，因为`str`指向的字符串字面值被保存在只读的数据段，是全局的，当函数调用完成后，`str`指向的地址未发生变化。<span style="color:red;">厉害。再深入理解下。</span>

综上，可以看出使用`char []`较容易出错，可能出现不确定的结果。C++提供的`string`类相比之下，要安全的多了。



## REF

- [字符串数组 和 字符串指针 的区别](https://blog.csdn.net/qq_35212671/article/details/53440439)
