---
title: 03 1880年至2010年美国婴儿姓名
toc: true
date: 2018-08-03 11:34:56
---

# 14.3 US Baby Names 1880–2010（1880年至2010年美国婴儿姓名）

这个数据是从1880年到2010年婴儿名字频率数据。我们先看一下这个数据长什么样子：

![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180803/068i0DjEd1.png?imageslim)

个数据集可以用来做很多事，例如：

- 计算指定名字的年度比例
- 计算某个名字的相对排名
- 计算各年度最流行的名字，以及增长或减少最快的名字
- 分析名字趋势：元音、辅音、长度、总体多样性、拼写变化、首尾字母等
- 分析外源性趋势：圣经中的名字、名人、人口结构变化等

之后的教程会涉及到其中一些。另外可以去官网直接下载姓名数据，[Popular Baby Names](https://www.ssa.gov/oact/babynames/limits.html)。

下载National data之后，会得到names.zip文件，解压后，可以看到一系列类似于yob1880.txt这样名字的文件，说明这些文件是按年份记录的。这里使用Unix head命令查看一下文件的前10行：


```python
!head -n 10 ../datasets/babynames/yob1880.txt
```























由于这是一个非常标准的以逗号隔开的格式（即CSV文件），所以可以用pandas.read_csv将其加载到DataFrame中：


```python
import pandas as pd
```


```python
# Make display smaller
pd.options.display.max_rows = 10
```


```python
names1880 = pd.read_csv('../datasets/babynames/yob1880.txt', names=['names', 'sex', 'births'])
```


```python
names1880
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>names</th>
      <th>sex</th>
      <th>births</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Mary</td>
      <td>F</td>
      <td>7065</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Anna</td>
      <td>F</td>
      <td>2604</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Emma</td>
      <td>F</td>
      <td>2003</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Elizabeth</td>
      <td>F</td>
      <td>1939</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Minnie</td>
      <td>F</td>
      <td>1746</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>1995</th>
      <td>Woodie</td>
      <td>M</td>
      <td>5</td>
    </tr>
    <tr>
      <th>1996</th>
      <td>Worthy</td>
      <td>M</td>
      <td>5</td>
    </tr>
    <tr>
      <th>1997</th>
      <td>Wright</td>
      <td>M</td>
      <td>5</td>
    </tr>
    <tr>
      <th>1998</th>
      <td>York</td>
      <td>M</td>
      <td>5</td>
    </tr>
    <tr>
      <th>1999</th>
      <td>Zachariah</td>
      <td>M</td>
      <td>5</td>
    </tr>
  </tbody>
</table>
<p>2000 rows × 3 columns</p>
</div>



这些文件中仅含有当年出现超过5次以上的名字。为了简单化，我们可以用births列的sex分组小计，表示该年度的births总计：


```python
names1880.groupby('sex').births.sum()
```




    sex
    F     90993
    M    110493
    Name: births, dtype: int64



由于该数据集按年度被分割成了多个文件，所以第一件事情就是要将所有数据都组装到一个DataFrame里面，并加上一个year字段。使用pandas.concat可以做到：


```python
# 2010是最后一个有效统计年度
years = range(1880, 2011)

pieces = []
columns = ['name', 'sex', 'births']

for year in years:
    path = '../datasets/babynames/yob%d.txt' % year
    frame = pd.read_csv(path, names=columns)

    frame['year'] = year
    pieces.append(frame)

# 将所有数据整合到单个DataFrame中
names = pd.concat(pieces, ignore_index=True)
```

这里要注意几件事。

- 第一，concat默认是按行将多个DataFrame组合到一起的；
- 第二，必须指定ignore_index=True，因为我们不希望保留read_csv所返回的原始索引。

现在我们得到了一个非常大的DataFrame，它含有全部的名字数据。现在names这个DataFrame看上去是：


```python
names
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>name</th>
      <th>sex</th>
      <th>births</th>
      <th>year</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Mary</td>
      <td>F</td>
      <td>7065</td>
      <td>1880</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Anna</td>
      <td>F</td>
      <td>2604</td>
      <td>1880</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Emma</td>
      <td>F</td>
      <td>2003</td>
      <td>1880</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Elizabeth</td>
      <td>F</td>
      <td>1939</td>
      <td>1880</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Minnie</td>
      <td>F</td>
      <td>1746</td>
      <td>1880</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>1690779</th>
      <td>Zymaire</td>
      <td>M</td>
      <td>5</td>
      <td>2010</td>
    </tr>
    <tr>
      <th>1690780</th>
      <td>Zyonne</td>
      <td>M</td>
      <td>5</td>
      <td>2010</td>
    </tr>
    <tr>
      <th>1690781</th>
      <td>Zyquarius</td>
      <td>M</td>
      <td>5</td>
      <td>2010</td>
    </tr>
    <tr>
      <th>1690782</th>
      <td>Zyran</td>
      <td>M</td>
      <td>5</td>
      <td>2010</td>
    </tr>
    <tr>
      <th>1690783</th>
      <td>Zzyzx</td>
      <td>M</td>
      <td>5</td>
      <td>2010</td>
    </tr>
  </tbody>
</table>
<p>1690784 rows × 4 columns</p>
</div>



有了这些数据后，我们就可以利用groupby或pivot_table在year和sex界别上对其进行聚合了：


```python
total_births = names.pivot_table('births', index='year',
                                columns='sex', aggfunc=sum)
```


```python
total_births.tail()
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>sex</th>
      <th>F</th>
      <th>M</th>
    </tr>
    <tr>
      <th>year</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2006</th>
      <td>1896468</td>
      <td>2050234</td>
    </tr>
    <tr>
      <th>2007</th>
      <td>1916888</td>
      <td>2069242</td>
    </tr>
    <tr>
      <th>2008</th>
      <td>1883645</td>
      <td>2032310</td>
    </tr>
    <tr>
      <th>2009</th>
      <td>1827643</td>
      <td>1973359</td>
    </tr>
    <tr>
      <th>2010</th>
      <td>1759010</td>
      <td>1898382</td>
    </tr>
  </tbody>
</table>
</div>




```python
import seaborn as sns
%matplotlib inline
```


```python
total_births.plot(title='Total births by sex and year', figsize=(15, 8))
```




    <matplotlib.axes._subplots.AxesSubplot at 0x1289ad710>




![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180708/30A8Ik5DAA.png?imageslim)

下面我们来插入一个prop列，用于存放指定名字的婴儿数相对于总出生数的比列。prop值为0.02表示每100名婴儿中有2名取了当前这个名字。因此，我们先按year和sex分组，然后再将新列加到各个分组上：


```python
def add_prop(group):
    group['prop'] = group.births / group.births.sum()
    return group
names = names.groupby(['year', 'sex']).apply(add_prop)
```


```python
names
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>name</th>
      <th>sex</th>
      <th>births</th>
      <th>year</th>
      <th>prop</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Mary</td>
      <td>F</td>
      <td>7065</td>
      <td>1880</td>
      <td>0.077643</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Anna</td>
      <td>F</td>
      <td>2604</td>
      <td>1880</td>
      <td>0.028618</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Emma</td>
      <td>F</td>
      <td>2003</td>
      <td>1880</td>
      <td>0.022013</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Elizabeth</td>
      <td>F</td>
      <td>1939</td>
      <td>1880</td>
      <td>0.021309</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Minnie</td>
      <td>F</td>
      <td>1746</td>
      <td>1880</td>
      <td>0.019188</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>1690779</th>
      <td>Zymaire</td>
      <td>M</td>
      <td>5</td>
      <td>2010</td>
      <td>0.000003</td>
    </tr>
    <tr>
      <th>1690780</th>
      <td>Zyonne</td>
      <td>M</td>
      <td>5</td>
      <td>2010</td>
      <td>0.000003</td>
    </tr>
    <tr>
      <th>1690781</th>
      <td>Zyquarius</td>
      <td>M</td>
      <td>5</td>
      <td>2010</td>
      <td>0.000003</td>
    </tr>
    <tr>
      <th>1690782</th>
      <td>Zyran</td>
      <td>M</td>
      <td>5</td>
      <td>2010</td>
      <td>0.000003</td>
    </tr>
    <tr>
      <th>1690783</th>
      <td>Zzyzx</td>
      <td>M</td>
      <td>5</td>
      <td>2010</td>
      <td>0.000003</td>
    </tr>
  </tbody>
</table>
<p>1690784 rows × 5 columns</p>
</div>



在执行这样的分组处理时，一般都应该做一些有效性检查（sanity check），比如验证所有分组的prop的综合是否为1。由于这是一个浮点型数据，所以我们应该用np.allclose来检查这个分组总计值是否够近似于（可能不会精确等于）1：


```python
names.groupby(['year', 'sex']).prop.sum()
```




    year  sex
    1880  F      1.0
          M      1.0
    1881  F      1.0
          M      1.0
    1882  F      1.0
                ...
    2008  M      1.0
    2009  F      1.0
          M      1.0
    2010  F      1.0
          M      1.0
    Name: prop, Length: 262, dtype: float64



这样就算完活了。为了便于实现进一步的分析，我们需要取出该数据的一个子集：每对sex/year组合的前1000个名字。这又是一个分组操作：


```python
def get_top1000(group):
    return group.sort_values(by='births', ascending=False)[:1000]

grouped = names.groupby(['year', 'sex'])
top1000 = grouped.apply(get_top1000)

# Drop the group index, not needed
top1000.reset_index(inplace=True, drop=True)
```

如果喜欢DIY的话，也可以这样：


```python
pieces =[]
for year, group in names.groupby(['year', 'sex']):
    pieces.append(group.sort_values(by='births', ascending=False)[:1000])

top1000 = pd.concat(pieces, ignore_index=True)
```


```python
top1000
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>name</th>
      <th>sex</th>
      <th>births</th>
      <th>year</th>
      <th>prop</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Mary</td>
      <td>F</td>
      <td>7065</td>
      <td>1880</td>
      <td>0.077643</td>
    </tr>
    <tr>
      <th>1</th>2
      <td>Anna</td>
      <td>F</td>
      <td>2604</td>
      <td>1880</td>
      <td>0.028618</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Emma</td>
      <td>F</td>
      <td>2003</td>
      <td>1880</td>
      <td>0.022013</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Elizabeth</td>
      <td>F</td>
      <td>1939</td>
      <td>1880</td>
      <td>0.021309</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Minnie</td>
      <td>F</td>
      <td>1746</td>
      <td>1880</td>
      <td>0.019188</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>261872</th>
      <td>Camilo</td>
      <td>M</td>
      <td>194</td>
      <td>2010</td>
      <td>0.000102</td>
    </tr>
    <tr>
      <th>261873</th>
      <td>Destin</td>
      <td>M</td>
      <td>194</td>
      <td>2010</td>
      <td>0.000102</td>
    </tr>
    <tr>
      <th>261874</th>
      <td>Jaquan</td>
      <td>M</td>
      <td>194</td>
      <td>2010</td>
      <td>0.000102</td>
    </tr>
    <tr>
      <th>261875</th>
      <td>Jaydan</td>
      <td>M</td>
      <td>194</td>
      <td>2010</td>
      <td>0.000102</td>
    </tr>
    <tr>
      <th>261876</th>
      <td>Maxton</td>
      <td>M</td>
      <td>193</td>
      <td>2010</td>
      <td>0.000102</td>
    </tr>
  </tbody>
</table>
<p>261877 rows × 5 columns</p>
</div>



接下来针对这个top1000数据集，我们就可以开始数据分析工作了

# 1 Analyzing Naming Trends（分析命名趋势）

有了完整的数据集和刚才生成的top1000数据集，我们就可以开始分析各种命名趋势了。首先将前1000个名字分为男女两个部分：



```python
boys = top1000[top1000.sex=='M']
girls = top1000[top1000.sex=='F']
```

这是两个简单的时间序列，只需要稍作整理即可绘制出相应的图标，比如每年叫做John和Mary的婴儿数。我们先生成一张按year和name统计的总出生数透视表：


```python
total_births = top1000.pivot_table('births', index='year',
                                   columns='name', aggfunc=sum)

total_births
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>name</th>
      <th>Aaden</th>
      <th>Aaliyah</th>
      <th>Aarav</th>
      <th>Aaron</th>
      <th>Aarush</th>
      <th>Ab</th>
      <th>Abagail</th>
      <th>Abb</th>
      <th>Abbey</th>
      <th>Abbie</th>
      <th>...</th>
      <th>Zoa</th>
      <th>Zoe</th>
      <th>Zoey</th>
      <th>Zoie</th>
      <th>Zola</th>
      <th>Zollie</th>
      <th>Zona</th>
      <th>Zora</th>
      <th>Zula</th>
      <th>Zuri</th>
    </tr>
    <tr>
      <th>year</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1880</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>102.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>71.0</td>
      <td>...</td>
      <td>8.0</td>
      <td>23.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>7.0</td>
      <td>NaN</td>
      <td>8.0</td>
      <td>28.0</td>
      <td>27.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1881</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>94.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>81.0</td>
      <td>...</td>
      <td>NaN</td>
      <td>22.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>10.0</td>
      <td>NaN</td>
      <td>9.0</td>
      <td>21.0</td>
      <td>27.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1882</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>85.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>80.0</td>
      <td>...</td>
      <td>8.0</td>
      <td>25.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>9.0</td>
      <td>NaN</td>
      <td>17.0</td>
      <td>32.0</td>
      <td>21.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1883</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>105.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>79.0</td>
      <td>...</td>
      <td>NaN</td>
      <td>23.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>10.0</td>
      <td>NaN</td>
      <td>11.0</td>
      <td>35.0</td>
      <td>25.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1884</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>97.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>98.0</td>
      <td>...</td>
      <td>13.0</td>
      <td>31.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>14.0</td>
      <td>6.0</td>
      <td>8.0</td>
      <td>58.0</td>
      <td>27.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>2006</th>
      <td>NaN</td>
      <td>3737.0</td>
      <td>NaN</td>
      <td>8279.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>297.0</td>
      <td>NaN</td>
      <td>404.0</td>
      <td>440.0</td>
      <td>...</td>
      <td>NaN</td>
      <td>5145.0</td>
      <td>2839.0</td>
      <td>530.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2007</th>
      <td>NaN</td>
      <td>3941.0</td>
      <td>NaN</td>
      <td>8914.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>313.0</td>
      <td>NaN</td>
      <td>349.0</td>
      <td>468.0</td>
      <td>...</td>
      <td>NaN</td>
      <td>4925.0</td>
      <td>3028.0</td>
      <td>526.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2008</th>
      <td>955.0</td>
      <td>4028.0</td>
      <td>219.0</td>
      <td>8511.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>317.0</td>
      <td>NaN</td>
      <td>344.0</td>
      <td>400.0</td>
      <td>...</td>
      <td>NaN</td>
      <td>4764.0</td>
      <td>3438.0</td>
      <td>492.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2009</th>
      <td>1265.0</td>
      <td>4352.0</td>
      <td>270.0</td>
      <td>7936.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>296.0</td>
      <td>NaN</td>
      <td>307.0</td>
      <td>369.0</td>
      <td>...</td>
      <td>NaN</td>
      <td>5120.0</td>
      <td>3981.0</td>
      <td>496.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2010</th>
      <td>448.0</td>
      <td>4628.0</td>
      <td>438.0</td>
      <td>7374.0</td>
      <td>226.0</td>
      <td>NaN</td>
      <td>277.0</td>
      <td>NaN</td>
      <td>295.0</td>
      <td>324.0</td>
      <td>...</td>
      <td>NaN</td>
      <td>6200.0</td>
      <td>5164.0</td>
      <td>504.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>258.0</td>
    </tr>
  </tbody>
</table>
<p>131 rows × 6868 columns</p>
</div>



接下来使用DataFrame中的plot方法：


```python
total_births.info()
```

    <class 'pandas.core.frame.DataFrame'>
    Int64Index: 131 entries, 1880 to 2010
    Columns: 6868 entries, Aaden to Zuri
    dtypes: float64(6868)
    memory usage: 6.9 MB



```python
subset = total_births[['John', 'Harry', 'Mary', 'Marilyn']]
```


```python
subset.plot(subplots=True, figsize=(12, 10), grid=False,
            title="Number of births per year")
```




    array([<matplotlib.axes._subplots.AxesSubplot object at 0x1132a4828>,
           <matplotlib.axes._subplots.AxesSubplot object at 0x116933080>,
           <matplotlib.axes._subplots.AxesSubplot object at 0x117d24710>,
           <matplotlib.axes._subplots.AxesSubplot object at 0x117d70b70>], dtype=object)




![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180708/f7eCmchcH0.png?imageslim)

## 评价命名多样性的增长

上图反应的降低情况可能意味着父母愿意给小孩起常见的名字越来越少。这个假设可以从数据中得到验证。一个办法是计算最流行的1000个名字所占的比例，我们按year和sex进行聚合并绘图：


```python
import numpy as np
```


```python
table = top1000.pivot_table('prop', index='year',
                           columns='sex', aggfunc=sum)
```


```python
table.plot(title='Sum of table1000.prop by year and sex',
           yticks=np.linspace(0, 1.2, 13), xticks=range(1880, 2020, 10),
           figsize=(15, 8))
```




```
<matplotlib.axes._subplots.AxesSubplot at 0x11b325128>
```




![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180708/Flmk6IegFf.png?imageslim)

从图中可以看出，名字的多样性确实出现了增长（前1000项的比例降低）。另一个办法是计算占总出生人数前50%的不同名字的数量，这个数字不太好计算。我们只考虑2010年男孩的名字：


```python
df = boys[boys.year == 2010]
```


```python
df
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>name</th>
      <th>sex</th>
      <th>births</th>
      <th>year</th>
      <th>prop</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>260877</th>
      <td>Jacob</td>
      <td>M</td>
      <td>21875</td>
      <td>2010</td>
      <td>0.011523</td>
    </tr>
    <tr>
      <th>260878</th>
      <td>Ethan</td>
      <td>M</td>
      <td>17866</td>
      <td>2010</td>
      <td>0.009411</td>
    </tr>
    <tr>
      <th>260879</th>
      <td>Michael</td>
      <td>M</td>
      <td>17133</td>
      <td>2010</td>
      <td>0.009025</td>
    </tr>
    <tr>
      <th>260880</th>
      <td>Jayden</td>
      <td>M</td>
      <td>17030</td>
      <td>2010</td>
      <td>0.008971</td>
    </tr>
    <tr>
      <th>260881</th>
      <td>William</td>
      <td>M</td>
      <td>16870</td>
      <td>2010</td>
      <td>0.008887</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>261872</th>
      <td>Camilo</td>
      <td>M</td>
      <td>194</td>
      <td>2010</td>
      <td>0.000102</td>
    </tr>
    <tr>
      <th>261873</th>
      <td>Destin</td>
      <td>M</td>
      <td>194</td>
      <td>2010</td>
      <td>0.000102</td>
    </tr>
    <tr>
      <th>261874</th>
      <td>Jaquan</td>
      <td>M</td>
      <td>194</td>
      <td>2010</td>
      <td>0.000102</td>
    </tr>
    <tr>
      <th>261875</th>
      <td>Jaydan</td>
      <td>M</td>
      <td>194</td>
      <td>2010</td>
      <td>0.000102</td>
    </tr>
    <tr>
      <th>261876</th>
      <td>Maxton</td>
      <td>M</td>
      <td>193</td>
      <td>2010</td>
      <td>0.000102</td>
    </tr>
  </tbody>
</table>
<p>1000 rows × 5 columns</p>
</div>



对prop降序排列后，我们想知道前面多少个名字的人数加起来才够50%。虽然编写一个for循环也能达到目的，但NumPy有一种更聪明的矢量方式。先计算prop的累计和cumsum，，然后再通过searchsorted方法找出0.5应该被插入在哪个位置才能保证不破坏顺序：


```python
prop_cumsum = df.sort_values(by='prop', ascending=False).prop.cumsum()
```


```python
prop_cumsum[:10]
```




    260877    0.011523
    260878    0.020934
    260879    0.029959
    260880    0.038930
    260881    0.047817
    260882    0.056579
    260883    0.065155
    260884    0.073414
    260885    0.081528
    260886    0.089621
    Name: prop, dtype: float64




```python
prop_cumsum.searchsorted(0.5)
```




    array([116])



由于数组索引是从0开始的，因此我们要给这个结果加1，即最终结果为117。拿1900年的数据来做个比较，这个数字要小得多：


```python
df = boys[boys.year == 1900]
in1900 = df.sort_values(by='prop', ascending=False).prop.cumsum()
in1900[-10:]
```




    41853    0.979223
    41852    0.979277
    41851    0.979330
    41850    0.979383
    41849    0.979436
    41848    0.979489
    41847    0.979542
    41846    0.979595
    41845    0.979648
    41876    0.979702
    Name: prop, dtype: float64




```python
in1900.searchsorted(0.5) + 1
```




    array([25])



现在就可以对所有year/sex组合执行这个计算了。按这两个字段进行groupby处理，然后用一个函数计算各分组的这个值：


```python
def get_quantile_count(group, q=0.5):
    group = group.sort_values(by='prop', ascending=False)
    return group.prop.cumsum().searchsorted(q) + 1

diversity = top1000.groupby(['year', 'sex']).apply(get_quantile_count)
diversity = diversity.unstack('sex')
```

现在，这个diversity有两个时间序列（每个性别各一个，按年度索引）。通过IPython，可以看到其内容，还可以绘制图标


```python
diversity.head()
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>sex</th>
      <th>F</th>
      <th>M</th>
    </tr>
    <tr>
      <th>year</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1880</th>
      <td>[38]</td>
      <td>[14]</td>
    </tr>
    <tr>
      <th>1881</th>
      <td>[38]</td>
      <td>[14]</td>
    </tr>
    <tr>
      <th>1882</th>
      <td>[38]</td>
      <td>[15]</td>
    </tr>
    <tr>
      <th>1883</th>
      <td>[39]</td>
      <td>[15]</td>
    </tr>
    <tr>
      <th>1884</th>
      <td>[39]</td>
      <td>[16]</td>
    </tr>
  </tbody>
</table>
</div>



可以看到上面表格中的值为list，如果不加diversity=diversity.astype(float)的话，会报错显示，“no numeric data to plot” error。通过加上这句来更改数据类型，就能正常绘图了：


```python
diversity = diversity.astype('float')
diversity
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>sex</th>
      <th>F</th>
      <th>M</th>
    </tr>
    <tr>
      <th>year</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1880</th>
      <td>38.0</td>
      <td>14.0</td>
    </tr>
    <tr>
      <th>1881</th>
      <td>38.0</td>
      <td>14.0</td>
    </tr>
    <tr>
      <th>1882</th>
      <td>38.0</td>
      <td>15.0</td>
    </tr>
    <tr>
      <th>1883</th>
      <td>39.0</td>
      <td>15.0</td>
    </tr>
    <tr>
      <th>1884</th>
      <td>39.0</td>
      <td>16.0</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>2006</th>
      <td>209.0</td>
      <td>99.0</td>
    </tr>
    <tr>
      <th>2007</th>
      <td>223.0</td>
      <td>103.0</td>
    </tr>
    <tr>
      <th>2008</th>
      <td>234.0</td>
      <td>109.0</td>
    </tr>
    <tr>
      <th>2009</th>
      <td>241.0</td>
      <td>114.0</td>
    </tr>
    <tr>
      <th>2010</th>
      <td>246.0</td>
      <td>117.0</td>
    </tr>
  </tbody>
</table>
<p>131 rows × 2 columns</p>
</div>




```python
diversity.plot(title='Number of popular names in top 50%', figsize=(15, 8))
```




    <matplotlib.axes._subplots.AxesSubplot at 0x11b3b7eb8>




![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180708/Fm9gl7Ei8F.png?imageslim)

从图中可以看出，女孩名字的多样性总是比男孩高，而且还变得越来越高。我们可以自己分析一下具体是什么在驱动这个多样性（比如拼写形式的变化）。

## “最后一个字母”的变革

一位研究人员指出：近百年来，男孩名字在最后一个字母上的分布发生了显著的变化。为了了解具体的情况，我们首先将全部出生数据在年度、性别以及末字母上进行了聚合：


```python
# 从name列中取出最后一个字母
get_last_letter = lambda x: x[-1]
last_letters = names.name.map(get_last_letter)
last_letters.name = 'last_letter'

table = names.pivot_table('births', index=last_letters,
                          columns=['sex', 'year'], aggfunc=sum)
```


```python
print(type(last_letters))
print(last_letters[:5])
```

```
<class 'pandas.core.series.Series'>
0    y
1    a
2    a
3    h
4    e
Name: last_letter, dtype: object
```


然后，我们选出具有一个代表性的三年，并输出前几行：


```python
subtable = table.reindex(columns=[1910, 1960, 2010], level='year')
subtable.head()
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th>sex</th>
      <th colspan="3" halign="left">F</th>
      <th colspan="3" halign="left">M</th>
    </tr>
    <tr>
      <th>year</th>
      <th>1910</th>
      <th>1960</th>
      <th>2010</th>
      <th>1910</th>
      <th>1960</th>
      <th>2010</th>
    </tr>
    <tr>
      <th>last_letter</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>108376.0</td>
      <td>691247.0</td>
      <td>670605.0</td>
      <td>977.0</td>
      <td>5204.0</td>
      <td>28438.0</td>
    </tr>
    <tr>
      <th>b</th>
      <td>NaN</td>
      <td>694.0</td>
      <td>450.0</td>
      <td>411.0</td>
      <td>3912.0</td>
      <td>38859.0</td>
    </tr>
    <tr>
      <th>c</th>
      <td>5.0</td>
      <td>49.0</td>
      <td>946.0</td>
      <td>482.0</td>
      <td>15476.0</td>
      <td>23125.0</td>
    </tr>
    <tr>
      <th>d</th>
      <td>6750.0</td>
      <td>3729.0</td>
      <td>2607.0</td>
      <td>22111.0</td>
      <td>262112.0</td>
      <td>44398.0</td>
    </tr>
    <tr>
      <th>e</th>
      <td>133569.0</td>
      <td>435013.0</td>
      <td>313833.0</td>
      <td>28655.0</td>
      <td>178823.0</td>
      <td>129012.0</td>
    </tr>
  </tbody>
</table>
</div>



接下来我们需要安总出生数对该表进行规范化处理，一遍计算出个性别各末字母站总出生人数的比例：


```python
subtable.sum()
```




    sex  year
    F    1910     396416.0
         1960    2022062.0
         2010    1759010.0
    M    1910     194198.0
         1960    2132588.0
         2010    1898382.0
    dtype: float64




```python
letter_prop = subtable / subtable.sum()
letter_prop
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th>sex</th>
      <th colspan="3" halign="left">F</th>
      <th colspan="3" halign="left">M</th>
    </tr>
    <tr>
      <th>year</th>
      <th>1910</th>
      <th>1960</th>
      <th>2010</th>
      <th>1910</th>
      <th>1960</th>
      <th>2010</th>
    </tr>
    <tr>
      <th>last_letter</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>0.273390</td>
      <td>0.341853</td>
      <td>0.381240</td>
      <td>0.005031</td>
      <td>0.002440</td>
      <td>0.014980</td>
    </tr>
    <tr>
      <th>b</th>
      <td>NaN</td>
      <td>0.000343</td>
      <td>0.000256</td>
      <td>0.002116</td>
      <td>0.001834</td>
      <td>0.020470</td>
    </tr>
    <tr>
      <th>c</th>
      <td>0.000013</td>
      <td>0.000024</td>
      <td>0.000538</td>
      <td>0.002482</td>
      <td>0.007257</td>
      <td>0.012181</td>
    </tr>
    <tr>
      <th>d</th>
      <td>0.017028</td>
      <td>0.001844</td>
      <td>0.001482</td>
      <td>0.113858</td>
      <td>0.122908</td>
      <td>0.023387</td>
    </tr>
    <tr>
      <th>e</th>
      <td>0.336941</td>
      <td>0.215133</td>
      <td>0.178415</td>
      <td>0.147556</td>
      <td>0.083853</td>
      <td>0.067959</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>v</th>
      <td>NaN</td>
      <td>0.000060</td>
      <td>0.000117</td>
      <td>0.000113</td>
      <td>0.000037</td>
      <td>0.001434</td>
    </tr>
    <tr>
      <th>w</th>
      <td>0.000020</td>
      <td>0.000031</td>
      <td>0.001182</td>
      <td>0.006329</td>
      <td>0.007711</td>
      <td>0.016148</td>
    </tr>
    <tr>
      <th>x</th>
      <td>0.000015</td>
      <td>0.000037</td>
      <td>0.000727</td>
      <td>0.003965</td>
      <td>0.001851</td>
      <td>0.008614</td>
    </tr>
    <tr>
      <th>y</th>
      <td>0.110972</td>
      <td>0.152569</td>
      <td>0.116828</td>
      <td>0.077349</td>
      <td>0.160987</td>
      <td>0.058168</td>
    </tr>
    <tr>
      <th>z</th>
      <td>0.002439</td>
      <td>0.000659</td>
      <td>0.000704</td>
      <td>0.000170</td>
      <td>0.000184</td>
      <td>0.001831</td>
    </tr>
  </tbody>
</table>
<p>26 rows × 6 columns</p>
</div>



有了这个字母比例数据后，就可以生成一张各年度各性别的条形图了：


```python
import matplotlib.pyplot as plt
```


```python
fig, axes = plt.subplots(2, 1, figsize=(10, 8))
letter_prop['M'].plot(kind='bar', rot=0, ax=axes[0], title='Male')
letter_prop['F'].plot(kind='bar', rot=0, ax=axes[1], title='Femal', legend=False)
```




    <matplotlib.axes._subplots.AxesSubplot at 0x11bb53b00>




![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180708/h8C3bCkHbi.png?imageslim)

从上图可以看出来，从20世纪60年代开始，以字母'n'结尾的男孩名字出现了显著的增长。回到之前创建的那个完整表，按年度和性别对其进行规范化处理，并在男孩名字中选取几个字母，最后进行转置以便将各个列做成一个时间序列：


```python
letter_prop = table / table.sum()
letter_prop.head()
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th>sex</th>
      <th colspan="10" halign="left">F</th>
      <th>...</th>
      <th colspan="10" halign="left">M</th>
    </tr>
    <tr>
      <th>year</th>
      <th>1880</th>
      <th>1881</th>
      <th>1882</th>
      <th>1883</th>
      <th>1884</th>
      <th>1885</th>
      <th>1886</th>
      <th>1887</th>
      <th>1888</th>
      <th>1889</th>
      <th>...</th>
      <th>2001</th>
      <th>2002</th>
      <th>2003</th>
      <th>2004</th>
      <th>2005</th>
      <th>2006</th>
      <th>2007</th>
      <th>2008</th>
      <th>2009</th>
      <th>2010</th>
    </tr>
    <tr>
      <th>last_letter</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>0.345587</td>
      <td>0.343440</td>
      <td>0.338764</td>
      <td>0.341251</td>
      <td>0.338550</td>
      <td>0.341270</td>
      <td>0.339703</td>
      <td>0.335258</td>
      <td>0.332764</td>
      <td>0.328706</td>
      <td>...</td>
      <td>0.020162</td>
      <td>0.020019</td>
      <td>0.019177</td>
      <td>0.019505</td>
      <td>0.018481</td>
      <td>0.017635</td>
      <td>0.016747</td>
      <td>0.016189</td>
      <td>0.015927</td>
      <td>0.014980</td>
    </tr>
    <tr>
      <th>b</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>...</td>
      <td>0.026256</td>
      <td>0.025418</td>
      <td>0.024368</td>
      <td>0.023171</td>
      <td>0.021645</td>
      <td>0.020778</td>
      <td>0.020357</td>
      <td>0.019655</td>
      <td>0.019693</td>
      <td>0.020470</td>
    </tr>
    <tr>
      <th>c</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>0.000046</td>
      <td>0.000045</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>...</td>
      <td>0.013972</td>
      <td>0.014048</td>
      <td>0.014042</td>
      <td>0.013514</td>
      <td>0.013083</td>
      <td>0.012991</td>
      <td>0.012983</td>
      <td>0.012458</td>
      <td>0.012186</td>
      <td>0.012181</td>
    </tr>
    <tr>
      <th>d</th>
      <td>0.006693</td>
      <td>0.006601</td>
      <td>0.006806</td>
      <td>0.007211</td>
      <td>0.007100</td>
      <td>0.006478</td>
      <td>0.006967</td>
      <td>0.007035</td>
      <td>0.007266</td>
      <td>0.007703</td>
      <td>...</td>
      <td>0.031352</td>
      <td>0.028794</td>
      <td>0.027069</td>
      <td>0.026118</td>
      <td>0.025420</td>
      <td>0.025075</td>
      <td>0.024451</td>
      <td>0.023574</td>
      <td>0.023398</td>
      <td>0.023387</td>
    </tr>
    <tr>
      <th>e</th>
      <td>0.366819</td>
      <td>0.370616</td>
      <td>0.374582</td>
      <td>0.373159</td>
      <td>0.372722</td>
      <td>0.372896</td>
      <td>0.372802</td>
      <td>0.372324</td>
      <td>0.373675</td>
      <td>0.373736</td>
      <td>...</td>
      <td>0.074927</td>
      <td>0.074603</td>
      <td>0.073396</td>
      <td>0.071710</td>
      <td>0.070799</td>
      <td>0.069748</td>
      <td>0.069445</td>
      <td>0.069362</td>
      <td>0.068663</td>
      <td>0.067959</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 262 columns</p>
</div>




```python
dny_ts = letter_prop.loc[['d', 'n', 'y'], 'M'].T
dny_ts.head()
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>last_letter</th>
      <th>d</th>
      <th>n</th>
      <th>y</th>
    </tr>
    <tr>
      <th>year</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1880</th>
      <td>0.083055</td>
      <td>0.153213</td>
      <td>0.075760</td>
    </tr>
    <tr>
      <th>1881</th>
      <td>0.083247</td>
      <td>0.153214</td>
      <td>0.077451</td>
    </tr>
    <tr>
      <th>1882</th>
      <td>0.085340</td>
      <td>0.149560</td>
      <td>0.077537</td>
    </tr>
    <tr>
      <th>1883</th>
      <td>0.084066</td>
      <td>0.151646</td>
      <td>0.079144</td>
    </tr>
    <tr>
      <th>1884</th>
      <td>0.086120</td>
      <td>0.149915</td>
      <td>0.080405</td>
    </tr>
  </tbody>
</table>
</div>



有了这个时间序列的DataFrame后，就可以通过其plot方法绘制出一张趋势图：


```python
dny_ts.plot(figsize=(10, 8))
```




    <matplotlib.axes._subplots.AxesSubplot at 0x11bbb0390>




![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180708/G3g34a56KG.png?imageslim)

## 变成女孩名字的男孩名字（以及相反的情况）

另一个有趣的趋势是，早年流行于男孩的名字近年来“变性了”，列入Lesley或Leslie。回到top1000数据集，找出其中以"lesl"开头的一组名字：


```python
all_names = pd.Series(top1000.name.unique())
lesley_like = all_names[all_names.str.lower().str.contains('lesl')]
lesley_like
```




    632     Leslie
    2294    Lesley
    4262    Leslee
    4728     Lesli
    6103     Lesly
    dtype: object



然后利用这个结果过滤其他的名字，并按名字分组计算出生数以查看相对频率：


```python
filtered = top1000[top1000.name.isin(lesley_like)]
filtered.groupby('name').births.sum()
```




    name
    Leslee      1082
    Lesley     35022
    Lesli        929
    Leslie    370429
    Lesly      10067
    Name: births, dtype: int64



接下来，我们按性别和年度进行聚合，并按年度进行规范化处理：


```python
table = filtered.pivot_table('births', index='year',
                             columns='sex', aggfunc='sum')

table = table.div(table.sum(1), axis=0)
```


```python
table
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>sex</th>
      <th>F</th>
      <th>M</th>
    </tr>
    <tr>
      <th>year</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1880</th>
      <td>0.091954</td>
      <td>0.908046</td>
    </tr>
    <tr>
      <th>1881</th>
      <td>0.106796</td>
      <td>0.893204</td>
    </tr>
    <tr>
      <th>1882</th>
      <td>0.065693</td>
      <td>0.934307</td>
    </tr>
    <tr>
      <th>1883</th>
      <td>0.053030</td>
      <td>0.946970</td>
    </tr>
    <tr>
      <th>1884</th>
      <td>0.107143</td>
      <td>0.892857</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>2006</th>
      <td>1.000000</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2007</th>
      <td>1.000000</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2008</th>
      <td>1.000000</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2009</th>
      <td>1.000000</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2010</th>
      <td>1.000000</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
<p>131 rows × 2 columns</p>
</div>



现在，我们可以轻松绘制一张分性别的年度曲线图了：


```python
table.plot(style={'M': 'k-', 'F': 'k--'}, figsize=(10, 8))
```




    <matplotlib.axes._subplots.AxesSubplot at 0x11f0640b8>




![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180708/fkAEc8mac8.png?imageslim)
