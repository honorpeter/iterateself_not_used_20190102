---
title: 07 映像和集合类型
toc: true
date: 2018-06-26 21:19:54
---
本章中，我们来讨论Python语言中的映射类型和集合类型。和前面的章节一样，我们首先做一 个介绍，然后在来讨论可用操作符，工厂函数、内建函数(BIF)和方法。然后我们再来看看每种数据 类型的详细用法。

Edit By Vheavens

Enter choice: D

You picked: [q]



### 7.6集合类型

数学上，把set称做由不同的元素组成的集合，集合(set)的成员通常被称做集合元素(set elements)。Python把这个概念引入到它的集合类型对象里。集合对象是一组无序排列的可哈希的值。 是的，集合成员可以做字典中的键。数学集合转为Python的集合对象很有效，集合关系测试和union、 intersection等操作符在Python里也同样如我们所预想地那样工作。

和其他容器类型一样，集合支持用 in 和 not in 操作符检查成员， 由 len() 内建函数得到集 合的基数(大小)，用for循环迭代集合的成员。但是因为集合本身是无序的，你不可以为集合创建 索引或执行切片(slice)操作，也没有键(keys)可用来获取集合中元素的值。

集合(sets)有两种不同的类型，可变集合(set)和不可变集合(frozenset)。如你所想，对可 变集合(set)你可以添加和删除元素，对不可变集合(frozenset)则不允许这样做。请注意，可变 集合(set)不是可哈希的，因此既不能用做字典的键也不能做其他集合中的元素。不可变集合

(frozenset)则正好相反，即，他们有哈希值，能被用做字典的键或是作为集合中的一个成员。

集合(Sets)最早出现在Python2.3版本中，通过集合(sets)模块来创建，并通过ImmutableSet 类和Set类进行访问。而后来，大家都认为把它们作为内建的数据类型是个更好的主意，因此这些 类被用C重写改进后包含进Python2.4。关于集合类型和这些类改进的更多内容，可阅读此文获得详 情：PEP 218，链接地址：<http://python.org/peps/pep-0218.html>.

虽然现在集合类型已经是Python的基本数据类型了，但它经常会以用户自定义类的形式出现在 各种Python程序中，就像复数一样(复数从Python1.4版本起成为python的一个数据类型)，这样 重复的劳动已数不胜数了。在现在的Python版本之前，(即使集合类型对许多人的程序来说并不是 最理想的数据结构，)许多人仍然试图给列表和字典这样的Python标准类型添加集合功能，这样可 以把它们作为真正集合类型的代理来使用。因此现在的使用者有包括“真正”集合类型在内的多种 选择。

在我们详细讲述Python的集合对象之前，我们必须理解Python中的一些数学符号(见表7.3)， 这样对术语和功能有一个清晰的了解。

表 7.3 集合操作符和关系符号

![img](07Python38c3160b-762.jpg)



数学符号    Python符号



![img](07Python38c3160b-764.jpg)



![img](07Python38c3160b-765.jpg)



![img](07Python38c3160b-766.jpg)



![img](07Python38c3160b-767.jpg)



![img](07Python38c3160b-768.jpg)



说明

| e    | in     | 是...的成员                 |
| ---- | ------ | --------------------------- |
|      | not in | 不是...的成员               |
|      |        | 等于                        |
|      | !=     | 不等于                      |
| (=   | <      | 是...的(产格)子集           |
|      | <=     | 是...的子集(包括非严格子集) |
| =>   | >      | 是...的(产格)超集           |
| □    |        | 是...的超集(包括非严格超集) |
| n    | &      | 交集合集                    |
| or \ |        | 差补或相对补集              |
| A    | A      | 对称差分                    |



### 7.6集合类型

#### 如何创建集合类型和给集合赋值

集合与列表( [ ] )和字典( { } ) 不同，没有特别的语法格式。列表和字典可以分别用他们自 己的工厂方法 list() 和 dict() 创建，这也是集合被创建的唯一方法 - 用集合的工厂方法 set() 和 frozenset():

\>>> s = set('cheeseshop')

\>>> s

，/ r? ?    ，    ，    ，t ，    ，    ，    ，    ， j 1 \

set(['c'， 'e'， 'h'， 'o'， 'p'， 's'])

\>>> t = frozenset('bookshop')

\>>> t

frozenset(['b'， 'h'， 'k'， 'o'， 'p'， 's']) >>> type(s)

<type 'set'>

\>>> type(t)

<type 'frozenset'>

\>>> len(s)

6

\>>> len(s) == len(t)

![img](07Python38c3160b-769.jpg)



![img](07Python38c3160b-770.jpg)



True

\>>> s == t

False

#### 如何访问集合中的值

你可以遍历查看集合成员或检查某项元素是否是一个集合中的成员

\>>> 'k' in s

False

\>>> 'k' in t

True

\>>> 'c' not in t

True

\>>> for i in s:

... print i

![img](07Python38c3160b-771.jpg)



c

![img](07Python38c3160b-772.jpg)



e

h

o

p

s

#### 如何更新集合 用各种集合内建的方法和操作符添加和删除集合的成员

\>>> s.add('z')

\>>> s

set(['c', 'e', 'h', 'o >>> s.update('pypi') >>> s

丄 / r，    ，    ，    ，    ，    •，    1    >

set(['c', 'e', 'i', 'h' >>> s.remove('z')

\>>> s

丄 / r，    ，    ，    ，    ，    •，    1    >

set(['c', 'e', 'i', 'h'

\>>> s -= set('pypi') >>> s



，，    ，，    ，，刁 \

'p', 's', 'z'])



，， ，， ，， ，，\

'p', 's', 'y', 'z'])



，， ，， ，，\

'p', 's', 'y'])



![img](07Python38c3160b-773.jpg)



set(['c', 'e', 'h', 'o', 's'])



我们之前提到过，只有可变集合能被修改。试图修改不可变集合会引发异常。

\>>> t.add('z')

Traceback (most recent call last):

File "<stdin>", line 1, in ?

AttributeError: 'frozenset' object has no attribute 'add'

#### 如何删除集合中的成员和集合

前面我们看到如何删除集合成员。如果如何删除集合本身，可以像删除任何Python对象一样， 令集合超出它的作用范围，或调用del将他们直接清除出当前的名字空间。如果它的引用计数为零，

也会被标记以便被垃圾回收。

\>>> del s >>>

![img](07Python38c3160b-775.jpg)



### 7.7 集合类型操作符



![img](07Python38c3160b-776.jpg)



![img](07Python38c3160b-777.jpg)



### 7.7.1标准类型操作符(所有的集合类型)

#### 成员关系 (in, not in)

就序列而言，Python中的in和not in操作符决定某个元素是否是一个集合中的成员。

\>>> s = set('cheeseshop')

\>>> t = frozenset('bookshop')

\>>> 'k' in s

False

\>>> 'k' in t

True

\>>> 'c' not in t

True

#### 集合等价/不等价

![img](07Python38c3160b-778.jpg)



等价/不等价被用于在相同或不同的集合之间做比较。两个集合相等是指，对每个集合而言，当

且仅当其中一个集合中的每个成员同时也是另一个集合中的成员。

你也可以说每个集合必须是另一个集合的一个子集，S卩，s <=t和s >=t的值均为真(True), 或(s <= t and s>= t)的值为真(True)。集合等价/不等价与集合的类型或集合成员的顺序无关，

只与集合的元素有关。

\>>> s == t False

\>>> s != t True

\>>> u = frozenset(s)

\>>> s == u True

\>>> set('posh') == set('shop')

True

#### 子集/超集

Sets用Python的比较操作符检查某集合是否是其他集合的超集或子集。“小于”符号(〈，〈=) 用来判断子集，“大于”符号( >，>=)用来判断超集。

“小于”和“大于”意味着两个集合在比较时不能相等。等于号允许非严格定义的子集和超 集。

Sets 支持严格( 〈 )子集和非严格 ( 〈= ) 子集， 也支持严格( > )超集和非严格 ( >= ) 超集。只有当第一个集合是第二个集合的严格子集时，我们才称第一个集合“小于”第二个集合， 同理，只有当第一个集合是第二个集合的严格超集时，我们才称第一个集合“大于”第二个集合。

\>>> set('shop') 〈 set('cheeseshop')

True

\>>> set('bookshop') >= set('shop')

True

### 7.7.2集合类型操作符(所有的集合类型)

联合( | )

联合(union)操作和集合的OR(又称可兼析取(inclusive disjunction))其实是等价的，两个集 合的联合是一个新集合，该集合中的每个元素都至少是其中一个集合的成员，卩，属于两个集合其 中之一的成员。联合符号有一个等价的方法，unionO.

\>>> s | t

set（［’c’， ’b’， ’e’， ’h’， ’k’， ’o’， ’p’， ’s’］）

#### 交集（ & ）

你可以把交集操作比做集合的AND（或合取）操作。两个集合的交集是一个新集合，该集合中的每 个元素同时是两个集合中的成员，即，属于两个集合的成员。交集符号有一个等价的方法， intersection（）.

\>>> s & t

set（［’h’， ’s’， ’o’， ’p’］

#### 差补/相对补集（ - ）

两个集合（s和t）的差补或相对补集是指一个集合C，该集合中的元素，只属于集合s，而不属 于集合t。差符号有一个等价的方法，differenceO.

\>>> s - t

set（［’c’， ’e’］）

对称差分（"）    丄

和其他的布尔集合操作相似，对称差分是集合的XOR（又称”异或“ （exclusive disjunction））. _

两个集合（s和t）的对称差分是指另外一个集合C，该集合中的元素，只能是属于集合s或者集合t 的成员，不能同时属于两个集合。对称差分有一个等价的方法，symmetric_difference（）.

\>>> s ' t

set（［’k’， ’b’， ’e’， ’c’］）

#### 混合集合类型操作

上面的示例中，左边的s是可变集合，而右边的t是一个不可变集合.注意上面使用集合操作 运算符所产生的仍然是可变集合，但是如果左右操作数的顺序反过来，结果就不一样了:

\>>> t | s

frozenset（［’c’， ’b’， ’e’， ’h’， ’k’， ’o’， ’p’， ’s’］）

\>>> t s

frozenset（［’c’， ’b’， ’e’， ’k’］）

\>>> t - s frozenset（［’k’， ’b’］）

如果左右两个操作数的类型相同，既都是可变集合或不可变集合， 则所产生的结果类型是相同

的，但如果左右两个操作数的类型不相同（左操作数是set，右操作数是frozenset，或相反情况），

则所产生的结果类型与左操作数的类型相同，上例中可以证明这一点。还要注意，加号不是集合类

型的运算符:

\>>> v = s + t

Traceback (most recent call last):

File "<stdin>", line 1, in ?

TypeError: unsupported operand type(s) for +: 'set' and 'set'

\>>> v = s | t

\>>> v

set(['c', 'b', 'e', 'h', 'k', 'o', 'p', 's'])

\>>> len(v)

8

\>>> s < v

True

### 7.7.3集合类型操作符(仅适用于可变集合)

#### (Union) Update ( |=)

这个更新方法从已存在的集合中添加(可能多个)成员，此方法和updateO等价.

»> s = setCcheeseshop'

\>>> u = frozenset(s)

\>>> s |= set('pypi')

\>>> s

set(['c', 'e', 'i', 'h', 'o', 'p', 's', 'y'])

#### 保留/交集更新( &= )

保留(或交集更新)操作保留与其他集合的共有成员。此方法和intersection_update()等价.

\>>> s = set(u)

\>>> s &= set('shop')

\>>> s

set(['h', 's', 'o', 'p'])

#### 差更新(-=)

对集合s和t进行差更新操作s-=t，差更新操作会返回一个集合，该集合中的成员是集合s去 除掉集合t中元素后剩余的元素。此方法和difference_update()等价.

\>>> s = set(u)

\>>> s -= set('shop')

\>>> s

set(['c'， 'e'])



#### 对称差分更新("=)

对集合s和t进行对称差分更新操作(s~=t)，对称差分更新操作会返回一个集合，该集合中的成 员仅是原集合s或仅是另一集合t中的成员。此方法和symmetric_difference_update()等价.

\>>> s = set(u)

\>>> t = frozenset('bookshop')

\>>> s t

\>>> s

set(['c'， 'b'， 'e'， 'k'])

### 7.8 内建函数

![img](07Python38c3160b-786.jpg)



7.8.1标准类型函数



![img](07Python38c3160b-787.jpg)



#### len()

把集合作为参数传递给内建函数len()，返回集合的基数(或元素的个数)。

#### >>> s = set(u)

\>>> s

set(['p'， 'c'， 'e'， 'h'， 's'， 'o']) >>> len(s)

#### 6

### 7.8.2集合类型工厂函数

#### set() and frozenset()

set()和frozensetO工厂函数分别用来生成可变和不可变的集合。如果不提供任何参数，默认 会生成空集合。如果提供一个参数，则该参数必须是可迭代的，卩，一个序列，或迭代器，或支持 迭代的一个对象，例如：一个文件或一个字典。

![img](07Python38c3160b-788.jpg)



![img](07Python38c3160b-789.jpg)



\>>> set()

set([])

\>>> set([])

set([])

\>>> set(())

set([])

\>>> set('shop')

set(['h'， 's'， 'o'， 'p'])

\>>>

\>>> frozenset(['foo'， 'bar']) frozenset(['foo'， 'bar'])

\>>>

\>>> f = open('numbers'， 'w')

\>>> for i in range(5):

... f.write('%d\n' % i)

\>>> f.close()

\>>> f = open('numbers'， 'r')

\>>> set(f)

![img](07Python38c3160b-790.jpg)



set(['0\n'， '3\n'， '1\n'， '4\n'， '2\n'])

\>>> f.close()

### 7.9 集合类型内建方法

### 7.9.1方法(所有的集合方法)

我们已看到很多和内建方法等价的操作符，表 7.4 做了小结：

内建方法copy()没有等价的操作符。和同名的字典方法一样，copy()方法比用像set()， frozensetO，或dict()这样的工厂方法复制对象的副本要快。

表7.4 集合类型方法

方法名称    操作



s.issubset(t)

s.issuperset(t)

s.union(t)

s.intersection(t)



如果s是t的子集，则返回True，否则返回False 如果t是s的超集，则返回True，否则返回False 返回一个新集合，该集合是s和t的并集

返回一个新集合，该集合是s和t的交集

![img](07Python38c3160b-791.jpg)



s.difference(t)    返回一个新集合，该集合是s的成员，但不是t的成员

s.symmetric_difference(t)返回一个新集合，该集合是s或t的成员，但不是s和t共有的



成员

s.copy()    返回一个新集合，它是集合s的浅复制

### 7.9.2方法(仅适用于可变集合)

表 7.5 总结了所有可变集合的内建方法，和上面的方法相似，我们已经看过许多和它们等价的 操作符。

新的方法有 add(), remove(), discard(), pop(), clear(). 这些接受对象的方法，参数必 须是可哈希的。

### 7.9.3操作符和内建方法比较

![img](07Python38c3160b-793.jpg)



像你看到的， 很多内建的方法几乎和操作符等价。我们说"几乎等价"，意思是它们间是有一个 重要区别：当用操作符时，操作符两边的操作数必须是集合。在使用内建方法时，对象也可以是 迭代类型的。为什么要用这种方式来实现呢？ Python的文档里写明：采用易懂的 set(’abc’).intersection(’cbs’)可以避免用 set(’abc’)[and] ’cbs’ 这样蓉易出错的构建方 _ 法。

表 7.5 可变集合类型的方法

方法名

s.update(t)

s.intersection_update(t)

s.difference_update(t)



操作

用t中的元素修改s,即，s现在包含s或t的成员 s中的成员是共同属于s和t的元素。 s中的成员是属于s但不包含在t中的元素

s.symmetric_difference_update(t) s中的成员更新为那些包含在s或t中，但不

s.add(obj)

s.remove(obj)

s.discard(obj)

s.pop()

s.clear()



和t共有的元素 在集合s中添加对象obj

从集合s中删除对象obj;如果obj不是集合s中的元素(obj not in s)，将引发KeyError错误

如果obj是集合s中的元素，从集合s中删除对象obj;

删除集合s中的任意一个对象，并返回它 删除集合s中的所有元素

### 7.10 操作符、函数/方法

![img](07Python38c3160b-794.jpg)



![img](07Python38c3160b-795.jpg)



![img](07Python38c3160b-796.jpg)



![img](07Python38c3160b-797.jpg)



![img](07Python38c3160b-798.jpg)



![img](07Python38c3160b-799.jpg)



集合类型总结表

表 7.6 中，我们总结了所有的集合类型的操作符、函数和方法

### 7.11 相关模块



集合（set）模块从2.3版本引进，可继承Set或ImmuteablSet来生成子类。虽然从Python2.4 起使用集合类型，但是集合模块不会弃用。



![img](07Python38c3160b-800.jpg)



| 表7.6 集合类型操作符、函数和方法 |                                            |                                                              |
| -------------------------------- | ------------------------------------------ | ------------------------------------------------------------ |
| 函数/方法名                      | 等价运算符                                 | 说明                                                         |
| 所有集合类型len（s）             |                                            | 集合基数：集合s中元素的个数                                  |
| set([obj])                       |                                            | 可变集合工厂函数；obj必须是支持迭代的，由obj中               |
| frozenset([obj])                 |                                            | 的元素创建集合，否则创建一个空集合 不可变集合工厂函数；执行方式和setO方法相同， |
|                                  | obj in s                                   | 但它返回的是不可变集合 成员测试：obj是s中的一个元素吗？      |
|                                  | obj not in s                               | 非成员测试：obj不是s中的一个元素吗？                         |
|                                  | s == t                                     | 等价测试：测试s和t是否具有相同的元素？                       |
|                                  | s != t                                     | 不等价测试: 与==相反                                         |
|                                  | s 〈 t                                     | （严格意义上）子集测试；s != t而且s中所有                    |
| s.issubset(t)                    | s 〈= t                                    | 的元素都是t的成员子集测试（允许不严格意义上的子集）：s中所有的元素 |
|                                  | s > t                                      | 都是t的成员（严格意义上）超集测试：s != t而且t中所有的元素   |
| s.issuperset(t)                  | s >= t                                     | 都是s的成员超集测试（允许不严格意义上的超集）：t中所有的元素 |
| s.union(t)                       | s \| t                                     | 都是s的成员合并操作：s或t中的元素                            |
| s.intersec- tion(t)    s & t     | 交集操作：s和t中的元素                     |                                                              |
| s.difference(t)                  | s - t                                      | 差分操作：s中的元素，而不是t中的元素                         |
| s.symmetric_difference(t)s " t   | 对称差分操作：s或t中的元素，但不是s和t共有 |                                                              |
| s.copy()                         |                                            | 的元素复制操作:返回s的（浅复制）副本                         |

Table 7.6 集合类型，函数和方法（继续）



![img](07Python38c3160b-801.jpg)



![img](07Python38c3160b-802.jpg)



![img](07Python38c3160b-803.jpg)



函数/方法名字

仅用于可变集合

s.update(t)

操作符

等价描述



|= t



s.intersection_update(t) s &= t s.difference_update(t) s -= t s.symmetric_



difference

update(t)



(Union)修改操作：将t中的成员添加s 交集修改操作：s中仅包括s和t中共有的成员

差修改操作：s中包括仅属于s但不属于t的成员



s.add(obj)

s.remove(obj)

s.discard(obj)



s.pop()

s.clear()



对称差分修改操作：s中包括仅属于s或仅属于t的 成员

加操作：将obj添加到s

删除操作：将obj从s中删除；如果s中不存在 obj，将引发 KeyError

丢弃操作: remove() 的 友 好 版 本 - 如 果s    中存在obj，

从s中删除它

Pop操作：移除并返回s中的任意一个元素 清除操作：移除s中的所有元素



以下是一些你可能认为有用的在线参考文章：

<http://en.wikipedia.org/wiki/Set> <http://www.geocities.com/basicmathsets/set.htmlhttp://www.math.uah.edu/stat/foundations/Sets.xhtml>



![img](07Python38c3160b-805.jpg)



### 7.12 练习

7-1. 字典方法。哪个字典方法可以用来把两个字典合并到一起？

7-2. 字典的键。我们知道字典的值可以是任意的Python对象，那字典的键又如何呢？请试 着将除数字和字符串以外的其他不同类型的对象作为字典的键，看一看，哪些类型可以，哪些不行？ 对那些不能作字典的键的对象类型，你认为是什么原因呢？

7-3. 字典和列表的方法。

(a)    创建一个字典，并把这个字典中的键按照字母顺序显示出来。

(b)    现在根据已按照字母顺序排序好的键，显示出这个字典中的键和值。

(c)    同(b)，但这次是根据已按照字母顺序排序好的字典的值，显示出这个字典中的键和值。(注 意：对字典和哈希表来说，这样做一般没有什么实际意义，因为大多数访问和排序(如果需要)都是 基于字典的键，这里只把它作为一个练习。)

7-4.    建立字典。给定两个长度相同的列表，比如说，列表［1，2，3，...］和［'abc'，’def'，

'ghi'，...］，用这两个列表里的所有数据组成一个字典，像这样：{1:'abc'，2: 'def'，3: ’ ghi'，...}

![img](07Python38c3160b-806.jpg)



7-5. userpw2.py.下面的问题和例题7.1中管理名字-密码的键值对数据的程序有关。

(a)修改那个脚本，使它能记录用户上次的登录日期和时间(用time模块)，并与用户密码一起

保存起来。程序的界面有要求用户输入用户名和密码的提示。无论户名是否成功登录，都应有提示， 在户名成功登录后，应更新相应用户的上次登录时间戳。如果本次登录与上次登录在时间上相差不 超过4个小时，则通知该用户： “You already logged in at: <last_ login_timestamp>.”

(b)    添加一个“管理”菜单，其中有以下两项:(1)删除一个用户 (2)显示系统中所有用户的名 字和他们的密码的清单。

(c)    口令目前没有加密。请添加一段对口令加密的代码(请参考crypt, rotor,或其它加密模块)

(d)    为程序添加图形界面，例如，用Tkinter写。

(e)    要求用户名不区分大小写。

(f)    加强对用户名的限制，不允许符号和空白符。

(g)    合并“新用户”和‘‘老用户”两个选项。如果一个新用户试图用一个不存在的用户名登录， 询问该用户是否是新用户，如果回答是肯定的，就创建该帐户。否则，按照老用户的方式登录。

7-6. 列表和字典。创建一个简单的股票证券投资数据系统。其中应至少包含四项数据：股市 行情显示器符号，所持有的股票，购买价格及当前价位 - 你可以随意添加其他数据项，比如收益率， 52周最高指数、最低指数，等等。

用户每次输入各列的数据构成一个输出行。每行数据构成一个列表。还有一个总列表，包括了 所有行的数据。数据输入完毕后，提示用户选择一列数据项进行排序。把该数据项抽取出来作为字 典的键，字典的值就是该键对应行的值的列表。提醒读者：被选择用来排序的数据项必须是非重复 的键，否则就会丢失数据，因为字典不允许一个键有多个值。

![img](07Python38c3160b-808.jpg)



你还可以选择其他计算输出，比如，盈亏比率，目前证券资产价值等。

7-7. 颠倒字典中的键和值。用一个字典做输入，输出另一个字典，用前者的键做值，前者的 值做键。

7-8. 人力资源。创建一个简单的雇员姓名和编号的程序。让用户输入一组雇员姓名和编号。 你的程序可以提供按照姓名排序输出的功能，雇员姓名显示在前面，后面是对应的雇员编号。附加 题：添加一项功能，按照雇员编号的顺序输出数据。

7-9. 翻译

(a)编写一个字符翻译程序(功能类似于Unix中的tr命令)。我们将这个函数叫做tr()它有 三个字符串做参数: 源字符串、目的字符串、基本字符串，语法定义如下：

def tr(srcstr, dststr, string)

srcstr的内容是你打算“翻译”的字符集合，dsrstr是翻译后得到的字符集合，而string是 你打算进行翻译操作的字符串。举例来说，如果 srcstr == 'abc', dststr == 'mno', string == ’abcdef’，那么 tr()的输出将是'mnodef'.注意这里 len(srcstr) == len(dststr).

在这个练习里，你可以使用内建函数chr()和ord(),但它们并不一定是解决这个问题所必不 可少的函数。

(b) 在这个函数里增加一个标志符参数，来处理不区分大小写的翻译问题。



![img](07Python38c3160b-810.jpg)



(c)修改你的程序，使它能够处理删除字符的操作。字符串srcstr中不能够映射到字符串dststr 中字符的多余字符都将被过滤掉。换句话说，这些字符没有映射到dststr字符串中的任何字符，因 此就从函数返回的字符里被过滤掉了。举例来说：如果 srcstr == 'abcdef'， dststr == 'mno'， string == 'abcdefghi'，那么 tr()将输出'mnoghi'.注意这里 len(srcstr) >= len(dststr).

7-10. 加密。

(a)    用上一个练习的思路编写一个〃rot13"翻译器。"rot13"是一个古老而又简单的加密方法， 它把字母表中的每个字母用其后的第13个字母来代替。字母表中前半部分字母将被映射到后半部分， 而后半部分字母将被映射到前半部分，大小写保持不变。举例来说，’a'将被替换为’n’，’X’将被替 换为'K';数字和符号不进行翻译。

(b)    在你的解决方案的基础上加一个应用程序，让它提示用户输入准备加密的字符串(这个算法 同时也可以对加密后的字符串进行解密)，如下所示:

% rot13.py

Enter string to rot13: This is a short sentence. Your string to en/decrypt was is a short sentence.].

[This



[Guvf



The rot13 string is: [Guvf vf n fubeg fragrapr.].

%

![img](07Python38c3160b-811.jpg)



% rot13.py

Enter string to rot13: Guvf vf n fubeg fragrapr. Your string to en/decrypt was vf n fubeg fragrapr.].

The rot13 string is: [This is a short sentence.].

7-11. 定义。什么组成字典中合法的键? 举例说明字典中合法的键和非法的键。

7-12. 定义。

(a)    在数学上，什么是集合？

(b)    在Python中，关于集合类型的定义是什么？

7-13. 随机数。修改练习5-17的代码：使用random模块中的randintO或randrangeO方 法生成一个随机数集合：从0到9(包括9)中随机选择，生成1到10个随机数。这些数字组成集合 A(A可以是可变集合，也可以不是)。同理，按此方法生成集合B。每次新生成集合A和B后，显示

结果 A | B 和 A & B

7-14. 用户验证。修改前面的练习，要求用户输入A | B和A& B的结果，并告诉用户他(或 她)的答案是否正确，而不是将A | B和A&B的结果直接显示出来。如果用户回答错误，允许他(或 她)修改解决方案，然后重新验证用户输入的答案。如果用户三次提交的答案均不正确，程序将显示 正确结果。

附加题：运用你关于集合的知识，创建某个集合的潜在子集，并询问用户此潜在子集是否真是

该集合的子集，要求和主程序一样有显示更正和答案的功能。



![img](07Python38c3160b-813.jpg)



7-15. 编写计算器。这个练习取材于http://math.hws.edu/在线免费Java教材中的练习 12.2。编写一个程序允许用户选择两个集合:A和B，及运算操作符。例如，in，not in，&，|，~，＜， 〈=，＞，＞=，==，！=，等.（你自己定义集合的输入语法，它们并不一定要像Java示例中那样用方括 号括住。）解析输入的字符串，按照用户选择的运算进行操作。你写的程序代码应该比Java版本的 该程序更简洁。
