---
title: 13 面向对象编程
toc: true
date: 2018-06-26 21:19:51
---
面向对象编程

本章主题 *引言

•面向对象编程

•类

•实例

•绑定与方法调用 •子类，派生和继承 •内建函数 •定制类 •私有性 •授权与包装 •新式类的高级特性 •相关模块

![img](07Python38c3160b-1531.jpg)



![img](07Python38c3160b-1532.jpg)



![img](07Python38c3160b-1533.jpg)



![img](07Python38c3160b-1534.jpg)



![img](07Python38c3160b-1535.jpg)



![img](07Python38c3160b-1536.jpg)



![img](07Python38c3160b-1537.jpg)



![img](07Python38c3160b-1538.png)



在我们的描绘中，类最终解释了面向对象编程思想（OOP）。本章中，我们首先将给出一个总体上 的概述，涵盖了 Python中使用类和OOP的所有主要方面。其余部分针对类，类实例和方法进行详细 探讨。我们还将描述Python中有关派生或子类化及继承机理。最后，Python可以在特定功能方面定 制类，例如重载操作符，模拟Python类型等。我们将展示如何实现这些特殊的方法来自定义你的类，

以让它们表现得更像Python的内建类型。

然而，除了这些外，Python的面向对象编程（00P）还有一些令人兴奋的变动。在版本2.2中， Python社区最终统一了类型（types）和类（classes），新式类具备更多高级的OOP特性，扮演了一个 经典类（或者说旧式类）超集的角色，后者是Python诞生时所创造的类对象。

下面，我们首先介绍在两种风格的类（译者注：新式类和旧式类）中都存在的核心特性，然后讲

解那些只有新式类才拥有的的高级特性。

### 13.1 介绍

在摸清OOP和类的本质之前，我们首先讲一些高级主题，然后通过几个简单的例子热一热身。 如果你刚学习面向对象编程，你可以先跳过这部分内容，直接进入第13.2节。如果你对有关面向对 象编程已经熟悉了，并且想了解它在Python中是怎样表现的，那么先看一下这部分内容，然后再进

入13.3节，看个究竟！

在Python中，面向对象编程主要有两个主题，就是类和类实例（见图13-1）

#### 类与实例

类与实例相互关联着：类是对象的定义，而实例是"真正的实物"，它存放了类中所定义的对象

的具体信息。

![img](07Python38c3160b-1539.jpg)



下面的示例展示了如何创建一个类 class MyNewObjectType(bases): 'define MyNewObjectType class'



class_suite #类体

关键字是class,紧接着是一个类名。随后是定义类的类体代码。这里通常由各种各样的定义和 声明组成。新式类和经典类声明的最大不同在于，所有新式类必须继承至少一个父类，参数bases

可以是一个（单继承）或多个（多重继承）用于继承的父类。

object是“所有类之母”如果你的类没有继承任何其他父类，object将作为默认的父类。它 位于所有类继承结构的最上层。如果你没有直接或间接的子类化一个对象，那么你就定义了一个经 典类：

class MyNewObjectType:

'define MyNewObjectType classic class' class_suite

如果你没有指定一个父类，或者如果所子类化的基本类没有父类，你这样就是创建了一个经典 类。很多Python类都还是经典类。即使经典类已经过时了，在以后的Python版本中，仍然可以使 用它们。不过我们强烈推荐你尽可能使用新式类，尽管对于学习来说，两者都行。

-4*

![img](07Python38c3160b-1541.jpg)



![img](07Python38c3160b-1542.jpg)



![img](07Python38c3160b-1544.jpg)



![img](07Python38c3160b-1545.jpg)



![img](07Python38c3160b-1546.jpg)



![img](07Python38c3160b-1547.jpg)



![img](07Python38c3160b-1548.jpg)



图 13-1 左边的工厂制造机器相当于类，而生产出来的玩具就是它们各个类的实例。尽管每个 实例都有一个基本的结构，但各自的属性像颜色或尺寸可以改变-----这就好比实例的属性。

创建一个实例的过程称作实例化，过程如下（注意：没有使用new关键字）：

myFirstObject = MyNewObjectType（）

类名使用我们所熟悉的函数操作符（（）），以“函数调用”的形式出现。然后你通常会把这个新

建的实例赋给一个变量。赋值在语法上不是必须的，但如果你没有把这个实例保存到一个变量中，

它就没用了，会被自动垃圾收集器回收，因为任何引用指向这个实例。这样，你刚刚所做的一切，

就是为那个实例分配了一块内存，随即又释放了它。

只要你需要，类可以很简单，也可以很复杂。最简单的情况，类仅用作名称空间（namespaces） （参见第 11章）。这意味着你把数据保存在变量中，对他们按名称空间进行分组，使得他们处于同

样的关系空间中-----所谓的关系是使用标准 Python 句点属性标识。比如，你有一个本身没有任何

属性的类，使用它仅对数据提供一个名字空间，让你的类拥有像Pascal中的记录集（records）和C 语言中的结构体（structures） 一样的特性，或者换句话说，这样的类仅作为容器对象来共享名字

空间。

示例如下：

class MyData(object): pass



![img](07Python38c3160b-1550.jpg)



![img](07Python38c3160b-1551.jpg)



![img](07Python38c3160b-1552.jpg)



![img](07Python38c3160b-1553.jpg)



![img](07Python38c3160b-1554.jpg)



注意有的地方在语法构成上需要有一行语句，但实际上不需要做任何操作，这时候可以使用pass 语句。这种情况，必要的代码就是类体，但我们暂不想提供这些。上面定义的类没有任何方法或属 性。下面我们创建一个实例，它只使用类作为名称空间容器。

\>>> mathObj = MyData() >>> mathObj.x = 4 >>> mathObj.y = 5 >>> mathObj.x + mathObj.y 9

\>>> mathObj.x * mathObj.y 20

我们当然也可以使用变量“x” “y”来完成同样的事情，但本例中，实例名字mathObj将mathObj.x 和mathObj.y关联起来。这就是我们所说的使用类作为名字空间容器。mathObj.x和mathObj.y是 实例属性，因为它们不是类MyData的属性，而是实例对象（mathObj）的独有属性。本章后面，我 们将看到这些属性实质上是动态的：你不需要在构造器中，或其它任何地方为它们预先声明或者赋值。

#### 方法

我们改进类的方式之一就是给类添加功能。类的功能有一个更通俗的名字叫方法。在Python 中，方法定义在类定义中，但只能被实例所调用。也就是说，调用一个方法的最终途径必须是这样

的：（1）定义类（和方法），（2）创建一个实例（3）最后一步，用这个实例调用方法。例如：

class MyDataWithMethod（object）: # 定义类 def printFoo（self）: # 定义方法 print 'You invoked printFoo（）!'

你可能注意到了 self参数，它在所有的方法声明中都存在。这个参数代表实例对象本身，当你 用实例调用方法时，由解释器悄悄地传递给方法的，所以，你不需要自己传递self进来，因为它是 自动传入的。举例说明一下，假如你有一个带两参数的方法，所有你的调用只需要传递第二个参数， Python把self作为第一个参数传递进来，如果你犯错的话，也不要紧。Python将告诉你传入的参 数个数有误。总之，你只会犯一次错，下一次———你当然就记得了！

这种需要在每个方法中给出实例（self）的要求对于那些使用C++或Java的人，可能是一种新 的体验，所以请意识到这点。

Python的哲学本质上就是要明白清晰。在其它语言中，self称为“this”。可以在13.7节的“核 心笔记”中找到有关self更多内容。一般的方法会需要这个实例（self）而静态方法或类方法不会， 其中类方法需要类而不是实例。在第13.8节中可以看到有关静态方法和类方法的更多内容。



![img](07Python38c3160b-1556.jpg)



![img](07Python38c3160b-1557.jpg)



![img](07Python38c3160b-1558.jpg)



![img](07Python38c3160b-1559.jpg)



现在我们来实例化这个类，然后调用那个方法：



\>>> myObj = MyDataWithMethod() # 创建实例 >>> myObj.printFoo() # 现在调用方法 You invoked printFoo()!

在本节结束时，我们用一个稍复杂的例子来总结一下这部分内容，这个例子给出如何处理类(和 实例)，还介绍了一个特殊的方法__init__()，子类化及继承。

对于已熟悉面向对象编程的人来说，_init_()类似于类构造器。如果你初涉OOP世界，可以 认为一个构造器仅是一个特殊的方法，它在创建一个新的对象时被调用。在Python中，__init__() 实际上不是一个构造器。你没有调用“new”来创建一个新对象。(Python根本就没有“new”关键字)。 取而代之，Python创建实例后，在实例化过程中，调用_init_()方法，当一个类被实例化时，就 可以定义额外的行为，比如，设定初始值或者运行一些初步诊断代码———主要是在实例被创建后， 实例化调用返回这个实例之前，去执行某些特定的任务或设置。

(我们将把print语句添加到方法中，这样我们就清楚什么时候方法被调用了。通常，我们不把

输入或输出语句放入函数中，除非预期代码体具有输出的特性。)

#### 创建一个类(类定义)

class AddrBookEntry(object): # 类定义

'address book entry class' def __init__(self, nm, ph): # 定义构造器

self.name = nm # 设置 name self.phone = ph # 设置 phone print 'Created instance for:', self.name

def updatePhone(self, newph): # 定义方法 self.phone = newph

print 'Updated phone# for:', self.name

在 AddrBookEntry 类的定义中，定义了两个方法：__init__()和 updatePhone()。__init__() 在实例化时被调用，即，在AddrBookEntryO被调用时。你可以认为实例化是对__init__()的一种隐 式的调用，因为传给AddrBookEntryO的参数完全与__init__0接收到的参数是一样的(除了 self， 它是自动传递的)。

回忆一下，当方法在实例中被调用时，self (实例对象)参数自动由解释器传递，所以在上面 的_^^_()中，需要的参数是nm和ph，它们分别表示名字和电话号码。_init_()在实例化时， 设置这两个属性，以便，在实例从实例化调用中返回时，这两个属性对程序员是可见的了。你可能



已猜到，updatePhoneO方法的目的是替换地址本条目的电话号码属性。



#### 创建实例(实例化)

»> john    = AddrBookEntry(John    Doe'    ’408-555-1212’)林为 John    Doe    创建实例

\>>> jane    二 AddrBookEntry(Jane    Doe'    ’650-555-1212’)    #*Jane    Doe    创建实例

这就是实例化调用，它会自动调用_init__(Kself把实例对象自动传入__init__()。你可以 在脑子里把方法中的self用实例名替换掉。在上面第一个例子中，当对象john被实例化后，它的 john.name就被设置了，你可在下面得到证实。

另外，如果不存在默认的参数，那么传给__init__()的两个参数在实例化时是必须的。

#### 访问实例属性

\>>> john

<__main__.AddrBookEntry instance at 80ee610> >>> john.name

![img](07Python38c3160b-1563.jpg)



’John Doe’

![img](07Python38c3160b-1564.jpg)



\>>> john.phone ’408-555-1212’

\>>> jane.name ’Jane Doe’

\>>> jane.phone

’650-555-1212’

一旦实例被创建后，就可以证实一下，在实例化过程中，我们的实例属性是否确实被__init__() 设置了。我们可以通过解释器“转储”实例来查看它是什么类型的对象。(我们以后将学到如何定制 类来获得想要的 Python 对象字符串的输出形式，而不是现在看到的默认的 Python 对象字符串

(<...>))

#### 方法调用(通过实例)

\>>> john. updatePhone(415-555-1212,) #更新John Doe 的电话

\>>> john.phone

’415-555-1212’

updatePhoneO方法需要一个参数(不计self在内)：新的电话号码。在updatePhoneO之后， 立即检查实例属性，可以证实已生效。

![img](07Python38c3160b-1565.jpg)



创建子类



靠继承来进行子类化是创建和定制新类类型的一种方式，新的类将保持已存在类所有的特性，

而不会改动原来类的定义(指对新类的改动不会影响到原来的类，译者注)。对于新的类类型来说，

这个新的子类可以定制只属于它的特定功能。除了与父类或基类的关系外，子类与通常的类没有什

么区别，也像一般类一样进行实例化。注意下面，子类声明中提到了父类:

class EmplAddrBookEntry(AddrBookEntry):

’Employee Address Book Entry class’#员工地址本类

def __init__(self, nm, ph, id, em):

AddrBookEntry.__init__(self, nm, ph)

self.empid = id self.email = em

def updateEmail(self, newem): self.email = newem

print ’Updated e-mail address for:’, self.name

![img](07Python38c3160b-1567.jpg)



现在我们创建了第一个子类，EmplAddrBookEntryaPython中，当一个类被派生出来，子类继 承了基类的属性，所以，在上面的类中，我们不仅定义7_init__()，updatEmail()方法，而且 EmplAddrBookEntry 还从 AddrBookEntry 中继承了 updatePhone()方法。

![img](07Python38c3160b-1568.jpg)



![img](07Python38c3160b-1569.jpg)



如果需要，每个子类最好定义它自己的构造器，不然，基类的构造器会被调用。然而，如果子 类重写基类的构造器，基类的构造器就不会被自动调用了－－这样，基类的构造器就必须显式写出 才会被执行，像我们上面那样，用AddrBookEntry._init_()设置名字和电话号码。我们的子类在 构造器后面几行还设置了另外两个实例属性：员工ID和E-mail地址。

注意，这里我们要显式传递self实例对象给基类构造器，因为我们不是在其实例中调用那个方 法而是在一个子类实例中调用那个方法。因为我们不是通过实例来调用它，这种未绑定的方法调用 需要传递一个适当的实例(self)给方法。

本小节后面的例子，告诉我们如何创建子类的实例，访问它们的属性及调用它的方法，包括从

父类继承而来的方法。

使用子类

\>>> john = EmplAddrBookEntry(’John Doe’, ’408-555-1212’,42, ’john@spam.doe’)

Created instance for: John Doe 林给 John Doe 创建实例

\>>> john

<__main__.EmplAddrBookEntry object at 0x62030>



\>>> john.name 'John Doe'



\>>> john.phone

'408-555-1212'

\>>> john.email

'john@spam.doe'

\>>> john.updatePhone('415-555-1212') Updated phone# for: John Doe

\>>> john.phone

'415-555-1212'

\>>> john.updateEmail('john@doe.spam') Updated e-mail address for: John Doe

\>>> john.email

'john@doe.spam'

#### 核心笔记：命名类、属性和方法

类名通常由大写字母打头。这是标准惯例，可以帮助你识别类，特别是在实例化过程中（有时看

起来像函数调用）。还有，数据属性（译者注：变量或常量）听起来应当是数据值的名字，方法名应

当指出对应对象或值的行为。另一种表达方式是：数据值应该使用名词作为名字，方法使用谓词（动

词加对象）。数据项是操作的对象、方法应当表明程序员想要在对象进行什么操作。在上面我们定义

![img](07Python38c3160b-1572.jpg)



的类中，遵循了这样的方针，数据值像“name” “phone”和“email”，行为如“updatePhone”， “updateEmail”。这就是常说的“混合记法（mixedCase）”或“骆驼记法（camelCase）”。Python规 范推荐使用骆驼记法的下划线方式，比如，“update_phone”，“update_email”。类也要细致命名， 像“AddrBookEntry”，“RepairShop”等等就是很好的名字。

![img](07Python38c3160b-1573.jpg)



我希望你已初步理解如何在Python中进行面向对象编程了。本章其它小节将带你深入面向对象 编程，Python类及实例的方方面面。

### 13.2面向对象编程

编程的发展已经从简单控制流中按步的指令序列进入到更有组织的方式中，依靠代码块可以形

成命名子程序和完成既定的功能。结构化的或过程性编程可以让我们把程序组织成逻辑块，以便重

复或重用。创建程序的过程变得更具逻辑性；选出的行为要符合规范，才可以约束创建的数据。迪

特尔父子（这里指DEITEL系列书籍作者Harvey M.Deitel和Paul James Deitel父子，译者注）认 为结构化编程是“面向行为”的，因为事实上，即使没有任何行为的数据也必须“规定”逻辑性。

然而，如果我们能对数据加上动作呢？如果我们所创建和编写的数据片段，是真实生活中实体

的模型，内嵌数据体和动作呢？如果我们能通过一系列已定义的接口（又称存取函数集合）访问数据

属性，像自动取款机卡或能访问你的银行帐号的个人支票，我们就有了一个“对象”系统，从大的

方面来看，每一个对象既可以与自身进行交互，也可以与其它对象进行交互。

![img](07Python38c3160b-1574.jpg)



面向对象编程踩上了进化的步伐，增强了结构化编程，实现了数据与动作的融合：数据层和逻 辑层现在由一个可用以创建这些对象的简单抽象层来描述。现实世界中的问题和实体完全暴露了本 质，从中提供的一种抽象，可以用来进行相似编码，或者编入能与系统中对象进行交互的对象中。 类提供了这样一些对象的定义，实例即是这些定义的实现。二者对面向对象设计(object-oriented design，00D)来说都是重要的，00D仅意味来创建你采用面向对象方式架构来创建系统。

### 13.2.1面向对象设计与面向对象编程的关系

面向对象设计(00D)不会特别要求面向对象编程语言。事实上，00D可以由纯结构化语言来实 现，比如C，但如果想要构造具备对象性质和特点的数据类型，就需要在程序上作更多的努力。当一 门语言内建00特性，00编程开发就会更加方便高效。

另一方面，一门面向对象的语言不一定会强制你写00方面的程序。例如C++可以被认为“更好 的C”而Java，则要求万物皆类，此外还规定，一个源文件对应一个类定义。然而，在Python中， 类和00P都不是日常编程所必需的。尽管它从一开始设计就是面向对象的，并且结构上支持00P，但 Python没有限定或要求你在你的应用中写00的代码。00P是一门强大的工具，不管你是准备进入， 学习，过渡，或是转向00P，都可以任意支配。

### 13.2.2现实世界中的问题

考虑用00D来工作的一个最重要的原因，在于它直接提供建模和解决现实世界问题和情形的途 径。比如，让你来试着模拟一台汽车维修店，可以让你停车进行维修。我们需要建两个一般实体： 处在一个“系统”中并与其交互的人类，和一个修理店，它定义了物理位置，用于人类活动。因为 前者有更多不同的类型，我将首先对它进行描述，然后描述后者。在此类活动中，一个名为 Person 的类被创建以用来表示所有的人。Person的实例可以包括消费者(Customer)，技工(Mechanic)，还 可能是出纳员(Cashier)。这些实例具有相似的行为，也有独一无二的行为。比如，他们能用声音进 行交流，都有talk()方法，还有drive_car()方法。不同的是，技工有repair_car()方法，而出纳 有 ring_sale()方法。技工有一个 repair_certification 属性，而所有人都有一个 drivers_license 属性。

最后，所有这些实例都是一个检查(overseeing)类RepairShop的参与者，后者具有一个叫 operating_hours的数据属性，它通过时间函数来确定何时顾客来修车，何时职员技工和出纳员来上 班。RepairShop可能还有一个AutoBay类，拥有SmogZone,TireBrakeZone等实例，也许还有一个叫 GeneralRepair 的实例。

我们所编的RepairShop的一个关键点是要展示类和实例加上它们的行为是如何用来对现实生活 场景建模的。同样，你可以把诸如机场，餐厅，晶蕊，医院，其至一个邮订音乐公司想像为类，它 们完全具备各自的参与者和功能性。

![img](07Python38c3160b-1577.jpg)



![img](07Python38c3160b-1578.jpg)



![img](07Python38c3160b-1579.jpg)



![img](07Python38c3160b-1580.jpg)



![img](07Python38c3160b-1581.jpg)



### 13.2.3*常用术语

对于已熟悉有关OOP术语的朋友来说，看Python中是怎么称呼的：

#### 抽象/实现

抽象指对现实世界问题和实体的本质表现，行为和特征建模，建立一个相关的子集，可以用于 描绘程序结构，从而实现这种模型。抽象不仅包括这种模型的数据属性，还定义了这些数据的接口。 对某种抽象的实现就是对此数据及与之相关接口的现实化（realization）。现实化这个过程对于客户 程序应当是透明而且无关的。

#### 封装/接口

封装描述了对数据/信息进行隐藏的观念，它对数据属性提供接口和访问函数。通过任何客户端 直接对数据的访问，无视接口，与封装性都是背道而驰的，除非程序员允许这些操作。作为实现的 一部分，客户端根本就不需要知道在封装之后，数据属性是如何组织的。在Python中，所有的类属

性都是公开的，但名字可能被“混淆”了，以阻止未经授权的访问，但仅此而已，再没有其他预防 措施了。这就需要在设计时，对数据提供相应的接口，以免客户程序通过不规范的操作来存取封装

H的数据属性。

#### 合成

合成扩充了对类的描述，使得多个不同的类合成为一个大的类，来解决现实问题。合成描述了 一个异常复杂的系统，比如一个类由其它类组成，更小的组件也可能是其它的类，数据属性及行为， 所有这些合在一起，彼此是“有一个”的关系。比如，RepairShop “有一个”技工（应该至少有一个 吧），还“有一个”顾客（至少一个）。

这些组件要么通过联合关系组在一块，意思是说，对子组件的访问是允许的（对RepairShop来 说，顾客可能请求一个SmogCheck，客户程序这时就是与RepairShop的组件进行交互），要么是聚合 在一起，封装的组件仅能通过定义好的接口来访问，对于客户程序来说是透明的。继续我的例子， 客户程序可能会建立一个SmogCheck请求来代表顾客，但不能够同RepairShop的SmogZone部分进 行交互，因为SmogZone是由RepairShop内部控制的，只能通过smogCheckCarO方法调用。Python 支持上述两种形式的合成。

#### 派生/继承/继承结构

派生描述了子类的创建，新类保留已存类类型中所有需要的数据和行为，但允许修改或者其它

的自定义操作，都不会修改原类的定义。继承描述了子类属性从祖先类继承这样一种方式。从前面



的例子中，技工可能比顾客多个汽车技能属性，但单独的来看，每个都“是一个”人，所以，不管

对谁而言调用talk()都是合法得，因为它是人的所有实例共有的。继承结构表示多“代”派生，可

以描述成一个“族谱”，连续的子类，与祖先类都有关系。



#### 泛化/特化

泛化表示所有子类与其父类及祖先类有一样的特点，所以子类可以认为同祖先类是“是一个”

的关系，因为一个派生对象(实例)是祖先类的一个“例子”。比如，技工“是一个”人，车“是一

个”交通工具，等等。在上面我们间接提到的族谱图中，我们可以从子类到祖先类画一条线，表示

“是一个”的关系。特化描述所有子类的自定义，也就是，什么属性让它与其祖先类不同。

#### 多态

多态的概念指出了对象如何通过他们共同的属性和动作来操作及访问，而不需考虑他们具体的

类。多态表明了动态(又名，运行时)绑定的存在，允计重载及运行时类型确定和验证。

#### 自省/反射

自省表示给予你，程序员，某种能力来进行像“手工类型检查”的工作，它也被称为反射。这 个性质展示了某对象是如何在运行期取得自身信息的。如果传一个对象给你，你可以查出它有什么 能力，这样的功能不是很好吗？这是一项强大的特性，在本章中，你会时常遇到。如果Python不 支持某种形式的自省功能，dir()和type()内建函数，将很难正常工作。请密切关注这些调用，还

![img](07Python38c3160b-1584.jpg)



有那些特殊属性，像__dict__,__name__及__doc__。可能你对其中一些已经很熟悉了！

### 13.3类

回想一下，类是一种数据结构，我们可以用它来定义对象，后者把数据值和行为特性融合在一 起。类是现实世界的抽象的实体以编程形式出现。实例是这些对象的具体化。可以类比一下，类是 蓝图或者模型，用来产生真实的物体(实例)。因此为什么是术语“class”？这个术语很可能起源 于使用类来识别和归类特定生物所属的生物种族，类还可以派生出相似但有差异的子类。编程中类 的概念就应用了很多这样的特征。

在Python中，类声明与函数声明很相似，头一行用一个相应的关键字，接下来是一个作为它的 定义的代码体，如下所示：

def functionName(args):

'function documentation string' #函数文档字符串 function_suite #函数体

class ClassName(object):



’class documentation string’ #类文档字符串 class_suite #类体



二者都允许你在他们的声明中创建函数，闭包或者内部函数（即函数内的函数），还有在类中定 义的方法。最大的不同在于你运行函数，而类会创建一个对象。类就像一个Python容器类型。在这 部分，我们将特别留意类及它们有什么类型的属性。这只要记住，尽管类是对象（在Python中，一 切皆对象），但正被定义时，它们还不是对象的实现。在下节中会讲到实例，所以拭目以待吧。不过 现在，我们集中讲解类对象。

当你创建一个类，你就实际创建了一个你自己的数据类型。所以这个类的实例都是相似的，但

类之间彼此是有区别的（因此，不同类的实例自然也不可能相同了）。与其玩那些从玩具商那买来的

玩具礼物，为什么不设计并创造你自己的玩具来玩呢？

类还允许派生。你可以创建一个子类，它也是类，而且继续了父类所有的特征和属性。从 Python2.2开始，你也可以从内建类型中派生子类，而不是仅仅从其它类。

### 13.3.1创建类

Python类使用class关键字来创建。简单的类的声明可以是关键字后紧跟类名:

![img](07Python38c3160b-1587.jpg)



class ClassName（bases）:

’class documentation string’ #’类文档字符串’

class_suite #类体

本章前面的概述中提到，基类是一个或多个用于继承的父类的集合；类体由所有声明语句，类

成员定义，数据属性和函数组成。类通常在一个模块的顶层进行定义，以便类实例能够在类所定义

的源代码文件中的任何地方被创建。

### 13.3.2 声明与定义

对于Python函数来说，声明与定义类没什么区别，因为他们是同时进行的，定义（类体）紧跟 在声明（含class关键字的头行［header line］）和可选（但总是推荐使用）的文档字符串后面。同时， 所有的方法也必须同时被定义。如果对00P很熟悉，请注意Python并不支持纯虚函数（像C++）或 者抽象方法（如在JAVA中），这些都强制程序员在子类中定义方法。作为替代方法，你可以简单地 在基类方法中引发NotImplementedError异常，这样可以获得类似的效果。

### 13.4类属性

![img](07Python38c3160b-1588.jpg)



什么是属性呢？属性就是属于另一个对象的数据或者函数元素，可以通过我们熟悉的句点属性 标识法来访问。一些Python类型比如复数有数据属性(实部和虚部)，而另外一些，像列表和字典， 拥有方法(函数属性)。

有关属性的一个有趣的地方是，当你正访问一个属性时，它同时也是一个对象，拥有它自己的 属性，可以访问，这导致了一个属性链，比如，myThing，subThing，subSubThing.等等。常见例子如

下：

•    sys.stdout.write(’foo’)

•    print myModule.myClass. __doc__

•    myList.extend(map(upper，open(’x’).readlines()))

类属性仅与其被定义的类相绑定，并且因为实例对象在日常OOP中用得最多，实例数据属性是 你将会一直用到的主要数据属性。类数据属性仅当需要有更加“静态”数据类型时才变得有用，它 和任何实例都无关，因此，这也是为什么下一节被表为高级主题，你可以选读。(如果你对静态不熟， 它表示一个值，不会因为函数调用完毕而消失，它在每两个函数调用的间隙都存在。或者说，一个 类中的一些数据对所有的实例来说，都是固定的。有关静态数据详细内容，见下一小节.)

接下来的一小节中，我们将简要描述，在Python中，方法是如何实现及调用的。通常，Python 中的所有方法都有一个限制：在调用前，需要创建一个实例。

### 13.4.1类的数据属性

数据属性仅仅是所定义的类的变量。它们可以像任何其它变量一样在类创建后被使用，并且，

要么是由类中的方法来更新，要么是在主程序其它什么地方被更新。

这种属性已为OO程序员所熟悉，即静态变量，或者是静态数据。它们表示这些数据是与它们所 属的类对象绑定的，不依赖于任何类实例。如果你是一位Java或C++程序员，这种类型的数据相当 于在一个变量声明前加上static关键字。

静态成员通常仅用来跟踪与类相关的值。大多数情况下，你会考虑用实例属性，而不是类属性。

在后面，我们正式介绍实例时，将会对类属性及实例属性进行比较。

看下面的例子，使用类数据属性(foo):

\>>> class C(object):

... foo = 100

\>>> print C.foo 100

\>>> C.foo = C.foo + 1

\>>> print C.foo 101



注意，上面的代码中，看不到任何类实例的引用。

Edit By Vheavens

### 13.4.2 方法

方法，比如下面，类MyClass中的myNoActionMethod方法，仅仅是一个作为类定义一部分定义 的函数.(这使得方法成为类属性)。这表示myNoActionMethod仅应用在MyClass类型的对象(实例) 上。这里，myNoActionMethod是通过句点属性标识法与它的实例绑定的。

\>>> class MyClass(object): def myNoActionMethod(self):

pass

\>>> mc = MyClass()

\>>> mc.myNoActionMethod()

任何像函数一样对myNoActionMethod自身的调用都将失败:

\>>> myNoActionMethod() Traceback (innermost last): File "<stdin>", line 1, in ?

![img](07Python38c3160b-1592.jpg)



myNoActionMethod() NameError: myNoActionMethod

引发了 NameError 异常，因为在全局名字空间中，没有这样的函数存在。这就告诉你 myNoActionMethod 是一个方法，表示它属于一个类，而不是全局空间中的名字。如果 myNoActionMethod是在顶层作为函数被定义的，那么我们的调用则会成功。

下面展示的是，甚至由类对象调用此方法也失败了。

\>>> MyClass.myNoActionMethod() Traceback (innermost last):

File "<stdin>", line 1, in ?

MyClass.myNoActionMethod()

TypeError: unbound method must be called with class instance 1st argument

TypeError异常初看起来很让人困惑，因为你知道这种方法是类的一个属性，因此，一定很想知 道为何为失败吧？接下来将会解释这个问题。

#### 绑定(绑定及非绑定方法)

为与OOP惯例保持一致，Python严格要求，没有实例，方法是不能被调用的。这种限制即Python



所描述的绑定概念(binding)，在此，方法必须绑定(到一个实例)才能直接被调用。非绑定的方法 可能可以被调用，但实例对象一定要明确给出，才能确保调用成功。然而，不管是否绑定，方法都 是它所在的类的固有属性，即使它们几乎总是通过实例来调用的。在13.7节中，我们会更深入地探

索本主题。

### 13.4.2决定类的属性

要知道一个类有哪些属性，有两种方法。最简单的是使用dir()内建函数。另外是通过访问类的 字典属性__dict__，这是所有类都具备的特殊属性之一。看一下下面的例子：

\>>> class MyClass(object):

…    ’MyClass class definition'林MyClass类定义

..myVersion = ’11’ # static data 静态数据 ... def showMyVersion(self): # method 方法

... print MyClass.myVersion

根据上面定义的类，让我们使用dir()和特殊类属性_41^__来查看一下类的属性:

\>>> dir(MyClass)

![img](07Python38c3160b-1595.jpg)



[’__class__’, ’__delattr__’, ’__dict__’, ’__doc__’,

![img](07Python38c3160b-1596.jpg)



’__getattribute__’, ’__hash__’, ’__init__’, ’__module__’,

’__new__’, ’__reduce__’, ’__reduce_ex__’, ’__repr__’,

’__setattr__’, ’__str__’, ’__weakref__’, ’myVersion’,

’showMyVersion’]

\>>> MyClass.__dict__

<dictproxy object at 0x62090>

\>>> print MyClass.__dict__

{’showMyVersion’: <function showMyVersion at 0x59370>,

’__dict__’: <attribute ’__dict__’ of ’MyClass’ objects>,

’myVersion’: ’1.1’, ’__weakref__’: <attribute

’__weakref__’ of ’MyClass’ objects>, ’__doc__’:

’MyClass class definition’}

在新式类中，还新增加了一些属性，dir()也变得更健壮。作为比较，可以看下经典类是什么样

的：

\>>> dir(MyClass)



['__doc__'， '__module__'， 'showMyVersion'， 'myVersion']

\>>>

\>>> MyClass.__dict__

{'__doc__': None， 'myVersion': 1， 'showMyVersion':

<function showMyVersion at 950ed0>， '__module__':

'__main__'}

从上面可以看到，dir()返回的仅是对象的属性的一个名字列表，返回的是一个字典， 它的键(keys)是属性名，键值(values)是相应的属性对象的数据值。

结果还显示了 MyClass类中两个熟悉的属性，showMyVersion和myVersion，以及一些新的属 性。这些属性，__doc__及__module__，是所有类都具备的特殊类属性(另外还有__dict__)。。内建 的vars()函数接受类对象作为参数，返回类的_dict__属性的内容。

### 13.4.3特殊的类属性

对任何类C，表13.1显示了类C的所有特殊属性:

表13.1 特殊类属性

| C.   | __name__  | 类C的名字(字符串)              |
| ---- | --------- | ------------------------------ |
| C.   | __doc__   | 类C的文档字符串                |
| C._  | _bases__  | 类C的所有父类构成的元组        |
| C._  | _dict__   | 类C的属性                      |
| C._  | _module__ | 类C定义所在的模块(1.5版本新增) |
| C._  | _class__  | 实例C对应的类(仅新式类中)      |

根据上面定义的类MyClass，有如下结果：

\>>> MyClass.__name__

'MyClass'

\>>> MyClass.__doc__

'MyClass class definition'

\>>> MyClass.__bases__

(<type 'object'>，)

\>>> print MyClass.__dict__

{'__doc__': None， 'myVersion': 1， 'showMyVersion':

<function showMyVersion at 950ed0>， '__module__': '__main__'} >>> MyClass.__module__

'__main__'

\>>> MyClass.__class__

<type 'type'>

__name__是给定类的字符名字。它适用于那种只需要字符串(类对象的名字)，而非类对象本身 的情况。甚至一些内建的类型也有这个属性，我们将会用到其中之一来展示__name__字符串的益处。

类型对象是一个内建类型的例子，它有__name__的属性。回忆一下，type()返回被调用对象的 类型。这可能就是那种我们所说的仅需要一个字符串指明类型，而不需要一个对象的情况。我们能 可以使用类型对象的__name__属性来取得相应的字符串名。如下例示：

\>>> stype = type('What is your quest?')

\>>> stype 林 stype is a type object stype是一个类型对象

<type 'string'>

\>>> stype.__name__ # get type as a string 得到类型名(字符串表示)

'string'

\>>>

\>>> type(3.14159265) # also a type object 又一个类型对象

<type 'float'>

\>>> type(3.14159265).__name__ # get type as a string 得到类型名(字符串表示)

'float'

_doc_是类的文档字符串，与函数及模块的文档字符串相似，必须紧随头行(header line) 后的字符串。文档字符串不能被派生类继承，也就是说派生类必须含有它们自己的文档字符串。

本章后面会讲到，__bases__用来处理继承，它包含了一个由所有父类组成的元组。

前述的_dict_属性包含一个字典，由类的数据属性组成。访问一个类属性的时候，Python解 释器将会搜索字典以得到需要的属性。如果在__dict__中没有找到，将会在基类的字典中进行搜索，

采用“深度优先搜索”顺序。基类集的搜索是按顺序的，从左到右，按其在类定义时，定义父类参

数时的顺序。对类的修改会仅影响到此类的字典；基类的__dict__属性不会被改动的。

Python支持模块间的类继承。为更清晰地对类进行描述，1。1, 1.5版本中引入了_module_， 这样类名就完全由模块名所限定。看一下下面的例子：

\>>> class C(object):

... pass >>> C

<class __main__.C at 0x53f90> >>> C.__module__

'__main__'

类C的全名是“_main_. C”，比如，source_module.class_name。如果类C位于一个导入的

模块中，如mymod，像下面的：

\>>> from mymod import C

\>>> C

<class mymod.C at 0x53ea0>

\>>> C.__module__

’mymod’

在以前的版本中，没有特殊属性__module__，很难简单定位类的位置，因为类没有使用它们的 全名。

最后，由于类型和类的统一性，当访问任何类的__class__属性时，你将发现它就是一个类型对 象的实例。换句话说，一个类已是一种类型了。因为经典类并不认同这种等价性(一个经典类是一 个类对象，一个类型是一个类型对象)，对这些对象来说，这个属性并未定义。

### 13.5实例

如果说类是一种数据结构定义类型，那么实例则声明了一个这种类型的变量。换言之，实例是 有生命的类。就像设计完一张蓝图后，就是设法让它成为现实。实例是那些主要用在运行期时的对 象，类被实例化得到实例，该实例的类型就是这个被实例化的类。在Python2.2版本之前，实例是

H “实例类型”而不考虑它从哪个类而来。    H

### 13.5.1初始化：通过调用类对象来创建实例

很多其它的00语言都提供new关键字，通过new可以创建类的实例。Python的方式更加简单。

一旦定义了一个类，创建实例比调用一个函数还容易------不费吹灰之力。实例化的实现，可以使

用函数操作符，如下示：

\>>> class MyClass(object): # define class 定义类

... pass

\>>> mc = MyClass() # instantiate class 初始化类

可以看到，仅调用("calling")类:MyClassO，就创建了类MyClass的实例mc。返回的对象是你 所调用类的一个实例。当使用函数记法来调用("call")—个类时，解释器就会实例化该对象，并且 调用Python所拥有与构造函数最相近的东西(如果你定义了的话)来执行最终的定制工作，比如设置 实例属性,最后将这个实例返回给你。

#### 核心笔记：Python2.2前后的类和实例

类和类型在2.2版本中就统一了，这使得Python的行为更像其它面向对象编程语言。任何类或

者类型的实例都是这种类型的对象。比如，如果你让Python告诉你，类MyClass的实例me是否是 类MyClass的一个实例。回答是肯定的，Python不会说谎。同样，它会告诉你零是integer类型的

一个实例：

\>>> mc = MyClass()

\>>> type(mc)

<class '__main__.MyClass'>

\>>> type(0)

<type 'int'>

但如果你仔细看，比较MyClass和int，你将会发现二者都是类型(type):

\>>> type(MyClass)

<type 'type'>

\>>> type(int)

<type 'type'>

对比一下，如果在Python早于2.2版本时，使用经典类，此时类是类对象，实例是实例对象。

在这两个对象类型之间没有任何关系，除了实例的__class__属性引用了被实例化以得到该实例的类

把MyClass在Python2.1版本中作为经典类重新定义，并运行相同的调用(注意：int()那时还不具

备工厂功能...它还仅是一个通常的内建函数):

\>>> type(mc)

<type 'instance'>

\>>> type(0)

<type 'int'>

\>>>

\>>> type(MyClass)

<type 'class'>

\>>> type(int)

<type 'builtin_function_or_method'>

为了避免任何混淆，你只要记住当你定义一个类时，你并没有创建一个新的类型，而是仅仅一

个类对象；而对2.2及后续版本，当你定义一个(新式的)类后，你已创建了一个新的类型。

### 13.5.2 __init__() "构造器"方法

当类被调用，实例化的第一步是创建实例对象。一旦对象创建了，Python检查是否实现了 __init__()方法。默认情况下，如果没有定义(或覆盖)特殊方法__init__()，对实例不会施加任 何特别的操作.任何所需的特定操作，都需要程序员实现__init__()，覆盖它的默认行为。如果 __init__()没有实现，则返回它的对象，实例化过程完毕。

然而，如果_init_()已经被实现，那么它将被调用，实例对象作为第一个参数(self)被传递 进去，像标准方法调用一样。调用类时，传进的任何参数都交给了__init__()。实际中，你可以想 像成这样:把创建实例的调用当成是对构造器的调用。

总之，(a)你没有通过调用new来创建实例，你也没有定义一个构造器。是Python为你创建了 对象; (b) __init__()，是在解释器为你创建一个实例后调用的第一个方法，在你开始使用它之前，

这一步可以让你做些准备工作。

__init__()是很多为类定义的特殊方法之一。其中一些特殊方法是预定义的，缺省情况下，不 进行任何操作，比如__init__()，要定制，就必须对它进行重载，还有些方法，可能要按需要去实 现。本章中，我们会讲到很多这样的特殊方法。你将会经常看到__init__()的使用，在此，就不举 例说明了。

### 13.5.3 __new__() “构造器”方法

与__init__()相比，__new__()方法更像一个真正的构造器。类型和类在版本2.2就统一了， Python用户可以对内建类型进行派生，因此，需要一种途径来实例化不可变对象，比如，派生字符 串，数字，等等。

在这种情况下，解释器则调用类的__new__()方法，一个静态方法，并且传入的参数是在类实例 化操作时生成的。__new__0会调用父类的__new__0来创建对象(向上代理)。

为何我们认为_new_() K_init_()更像构造器呢？这是因*_new_()必须返回一个合法 的实例，这样解释器在调用_init_()时，就可以把这个实例作为self传给它。调用父类的_new_()

来创建对象，正像其它语言中使用new关键字一样。

__new__()和__init__()在类创建时，都传入了(相同)参数。13.11.3 节中有个例子使用了 __new__()。

### 13.5.4 __del__() "解构器"方法

同样，有一个相应的特殊解构器(destructor)方法名为__del__0。然而，由于Python具有 垃圾对象回收机制(靠引用计数)，这个函数要直到该实例对象所有的引用都被清除掉后才会执行。 Python中的解构器是在实例释放前提供特殊处理功能的方法，它们通常没有被实现，因为实例很少 被显式释放。

举例

在下面的例子中，我们分别创建(并覆盖)__init__()和__del__()构造及解构函数，然后，初 始化类并给同样的对象分配很多别名。id()内建函数可用来确定引用同一对象的三个别名。最后一 步是使用del语句清除所有的别名，显示何时，调用了多少次解构器。

![img](07Python38c3160b-1608.jpg)



![img](07Python38c3160b-1609.jpg)



![img](07Python38c3160b-1610.jpg)



![img](07Python38c3160b-1611.jpg)



![img](07Python38c3160b-1612.jpg)



class C(P): # class declaration 类声明 def __init__(self): # "constructor" 构造器 print ’initialized’

def __del__(self): # "destructor" 解构器 P.__del__(self) # call parent destructor print ’deleted’ 调用父类解构器来打印

’deleted’

\>>> c1 = C()    # instantiation initialized 实例初始化

\>>> c2 = c1 # create additional alias 创建另外一个别名

\>>> c3 = c1 # create a third alias 创建第三个别名

\>>> id(c1)， id(c2)， id(c3) # all refer to same object 同一对象所有引用

(11938912， 11938912， 11938912)

\>>> del c1 # remove one reference 清除一个引用 >>> del c2 # remove another reference 清除另一个引用

\>>> del c3 # remove final reference deleted # destructor finally invoked 解构器最 后调用

注意，在上面的例子中，解构器是在类C实例所有的引用都被清除掉后，才被调用的，比如， 当引用计数已减少到0。如果你预期你的_del_()方法会被调用，却实际上没有被调用，这意味着， 你的实例对象由于某些原因，其引用计数不为0,这可能有别的对它的引用，而你并不知道这些让 你的对象还活着的引用所在。

![img](07Python38c3160b-1613.jpg)



另外，要注意，解构器只能被调用一次，一旦引用计数为 0，则对象就被清除了。这非常合理 因为系统中任何对象都只被分配及解构一次。

总结：

•不要忘记首先调用父类的_del_()。

•调用del x不表示调用了 x._del_()——前面也看到，它仅仅是减少x的引用计数。

•如果你有一个循环引用或其它的原因，让一个实例的引用逗留不去，该对象的_del_()可

能永远不会被执行。

• _del_()未捕获的异常会被忽略掉(因为一些在_del_()用到的变量或许已经被删除了)。 不要在__del__()中干与实例没任何关系的事情。

•除非你知道你正在干什么，否则不要去实现_del_()。

•如果你定义了__del__，并且实例是某个循环的一部分，垃圾回收器将不会终止这个循环一 一你需要自已显式调用del。

#### 核心笔记：跟踪实例

Python没有提供任何内部机制来跟踪一个类有多少个实例被创建了，或者记录这些实例是些什

么东西。如果需要这些功能，你可以显式加入一些代码到类定义或者__init__()和__del__()中去。



最好的方式是使用一个静态成员来记录实例的个数。靠保存它们的引用来跟踪实例对象是很危险的，

因为你必须合理管理这些引用，不然，你的引用可能没办法释放（因为还有其它的引用）！看下面一

个例子:



class InstCt(object):

count = 0 林 count is class attr count是一个类属性

def _init (self):林 increment count 増加count

InstCt.count += 1

def _del_ (self): # decrement count 减少count

InstCt.count -= 1

def howMany(self): # return count 返回count

return InstCt.count

\>>> a = InstTrack()

\>>> b = InstTrack()

\>>> b.howMany()

2

![img](07Python38c3160b-1616.jpg)



\>>> a.howMany()

2

\>>> del b

\>>> a.howMany()

1

\>>> del a

\>>> InstTrack.count

0

### 13.6实例属性

实例仅拥有数据属性（方法严格来说是类属性），后者只是与某个类的实例相关联的数据值，并

且可以通过句点属性标识法来访问。这些值独立于其它实例或类。当一个实例被释放后，它的属性

同时也被清除了。

### 13.6.1 “实例化”实例属性（或创建一个更好的构造器）

设置实例的属性可以在实例创建后任意时间进行，也可以在能够访问实例的代码中进行。构造 器__init（）__是设置这些属性的关键点之一。

![img](07Python38c3160b-1617.jpg)



![img](07Python38c3160b-1618.jpg)



![img](07Python38c3160b-1619.jpg)



![img](07Python38c3160b-1620.jpg)



![img](07Python38c3160b-1621.jpg)



![img](07Python38c3160b-1622.jpg)



#### 核心笔记：实例属性

能够在“运行时”创建实例属性，是Python类的优秀特性之一，从C++或Java转过来的人会被 小小的震惊一下，因为C++或Java中所有属性在使用前都必须明确定义/声明。

Python不仅是动态类型，而且在运行时，允许这些对象属性的动态创建。这种特性让人爱不释

手。当然，我们必须提醒读者，创建这样的属性时，必须谨慎。

一个缺陷是，属性在条件语句中创建，如果该条件语句块并未被执行，属性也就不存在，而你

在后面的代码中试着去访问这些属性，就会有错误发生。故事的精髓是告诉我们，Python让你体验

从未用过的特性，但如果你使用它了，你还是要小心为好。

#### 在构造器中首先设置实例属性

构造器是最早可以设置实例属性的地方，因为__init__()是实例创建后第一个被调用的方法。 再没有比这更早的可以设置实例属性的机会了。一旦__init__()执行完毕，返回实例对象，即完成 了实例化过程。

#### 默认参数提供默认的实例安装

在实际应用中，带默认参数的_init_()提供一个有效的方式来初始化实例。在很多情况下， 默认值表示设置实例属性的最常见的情况，如果提供了默认值，我们就没必要显式给构造器传值了。 我们在11.5.2节中也提到默认参数的常见好处。需要明白一点，默认参数应当是不变的对象；像 列表(list)和字典(dictionary)这样的可变对象可以扮演静态数据，然后在每个方法调用中来维护 它们的内容。

![img](07Python38c3160b-1623.jpg)



例13.1描述了如何使用默认构造器行为来帮助我们计算在美国一些大都市中的旅馆中寄宿时，

租房总费用。

代码的主要目的是来帮助某人计算出每日旅馆租房费用，包括所有州销售税和房税。缺省为旧

金山附近的普通区域，它有8.5%销售税及10%的房间税。每日租房费用没有缺省值，因此在任何实

例被创建时，都需要这个参数。

例13.1 使用缺省参数进行实例化 (hotel.py)

定义一个类来计算这个假想旅馆租房费用。 __init__()构造器对一些实例属性进行初始化。 calcTotal()方法用来决定是计算每日总的租房费用还是计算所有天全部的租房费。

1    class HotelRoomCalc(object):

2    'Hotel room rate calculator'

3

4 def __init__(self, rt, sales=0.085, rm=0.1):

![img](07Python38c3160b-1624.jpg)



5    '''HotelRoomCalc default arguments:

6    sales tax == 8.5% and room tax == 10%'''

7    self.salesTax = sales

8    self.roomTax = rm

9    self.roomRate = rt

10

11    def calcTotal(self, days=1):

12    'Calculate total; default to daily rate'

13    daily = round((self.roomRate *14    (1 + self.roomTax + self.salesTax)), 2)

15 return float(days) * daily

设置工作是由__init__()在实例化之后完成的，如上第4到8行，其余部分的核心代码是 calcTotal ()方法，从第10到14行。 __init__()的工作即是设置一些参数值来决定旅馆总的基本租

房费用(不包括住房服务，电话费，或其它偶发事情)。calcTotal()可以计算每日所有费用，如果 提供了天数，那么将计算整个旅程全部的住宿费用。内建的round()函数可以大约计算出最接近的费 用(两个小数位)。下面是这个类的用法：

\>>> sfo = HotelRoomCalc(299) # new instance 新的实例 >>> sfo.calcTotal() # daily rate 日租金 354.32

![img](07Python38c3160b-1626.jpg)



\>>> sfo. calcTotal(2) # 2_day rate 2天的租金

708.64

\>>> sea = HotelRoomCalc(189, 0.086, 0.058) # new instance 新的实例 >>> sea.calcTotal()

216.22

\>>> sea.calcTotal(4)

864.88

\>>> wasWkDay = HotelRoomCalc(169, 0.045, 0.02) # new instance 新实例 >>> wasWkEnd = HotelRoomCalc(119, 0.045, 0.02) # new instance 新实例 >>> wasWkDay.calcTotal(5) + wasWkEnd.calcTotal() # 7_day rate 7天的租金

1026.69

最开始的两个假想例子都是在旧金山(San Francisco)，使用了默认值，然后是在西雅图 (Seatt l e) ，这里我们提供了不同的销售税和房间税率。最后一个例子在华盛顿特区 (Washington.D.C)。经过计算更长的假想时间，来扩展通常的用法：停留五个工作日，外加一个周 六，此时有特价，假定是星期天出发回家。

不要忘记，函数所有的灵活性，比如默认参数，也可以应用到方法中去。在实例化时，可变长

度参数也是一个好的特性(当然，这要根据应用的需要)

![img](07Python38c3160b-1627.jpg)



__init__()应当返回 None

你也知道，采用函数操作符调用类对象会创建一个类实例，也就是说这样一种调用过程返回的

对象就是实例，下面示例可以看出:

\>>> class MyClass(object):

... pass

\>>> mc = MyClass()

\>>> mc

<__main__.MyClass instance at 95d390>

如果定义了构造器，它不应当返回任何对象，因为实例对象是自动在实例化调用后返回的。相 应地，__init__()就不应当返回任何对象(应当为None);否则，就可能出现冲突，因为只能返回实 例。试着返回非None的任何其它对象都会导致TypeError异常：

\>>> class MyClass:

... def __init__(self):

... print 'initialized'

... return 1

\>>> mc = MyClass()

![img](07Python38c3160b-1629.jpg)



initialized

![img](07Python38c3160b-1630.jpg)



Traceback (innermost last): File "<stdin>", line 1, in mc = MyClass()

TypeError: __init__() should return None

### 13.6.2查看实例属性

内建函数dir()可以显示类属性，同样还可以打印所有实例属性:

\>>> class C(object):

... pass

\>>> c = C()

\>>> c.foo = 'roger'

\>>> c.bar = 'shrubber'

\>>> dir(c)

['__class__', '__delattr__', '__dict__', '__doc__',

'__getattribute__', '__hash__', '__init__', '__module__' '__new__', '__reduce__', '__reduce_ex__', '__repr__',

'__setattr__', '__str__', '__weakref__', 'bar', 'foo']

与类相似，实例也有一个__dict_Jf殊属性(可以调用vars()并传入一个实例来获取)，它是实 例属性构成的一个字典:



\>>> c.__dict__

{'foo': 'roger', 'bar': 'shrubber'}



### 13.6.3特殊的实例属性

实例仅有两个特殊属性(见表13.2)。对于任意对象I:

表13.2 特殊实例属性

I. __class__    实例化I的类

I. __dict__    I 的属性

现在使用类C及其实例C来看看这些特殊实例属性：

\>>> class C(object): # define class 定义类 ... pass

\>>> c = C() # create instance 创建实例

\>>> dir(c)    # instance has no attributes 实例还没有属性

[]

![img](07Python38c3160b-1633.jpg)



\>>> c.__dict__ # yep, definitely no attributes 也没有属性 {}

»> c. __class__ 林 class that instantiated us 实例化 c 的类

<class '__main__.C'>

你可以看到，c现在还没有数据属性，但我们可以添加一些再来检属性，看是否添加 成功了：

\>>> c.foo = 1 >>> c.bar = 'SPAM'

\>>> '%d can of %s please' % (c.foo, c.bar)

'1 can of SPAM please'

\>>> c.__dict__

{'foo': 1, 'bar': 'SPAM'}

__dict__属性由一个字典组成，包含一个实例的所有属性。键是属性名，值是属性相应的数据 值。字典中仅有实例属性，没有类属性或特殊属性。

核心风格：修改__dict__

对类和实例来说，尽管__dict__属性是可修改的，但还是建议你不要修改这些字典，除非你知

道你的目的。这些修改可能会破坏你的OOP，造成不可预料的副作用。使用熟悉的句点属性标识来访



问及操作属性会更易于接受。需要你直接修改__dict__属性的情况很少，其中之一是你要重载 __setattr__特殊方法。实现__setattr__()本身是一个冒险的经历，满是圈套和陷阱，例如无穷递 归和破坏实例对象。这个故事还是留到下次说吧。



13.6.4内建类型属性

内建类型也是类，它们有没有像类一样的属性呢？那实例有没有呢？对内建类型也可以使用 dir()与任何其它对象一样，可以得到一个包含它属性名字的列表：

\>>> x = 3+0.14j >>> x.__class__

<type 'complex'>

\>>> dir(x)

['__abs__', '__add__', '__class__', '__coerce__',

'__delattr__', '__div__', '__divmod__', '__doc__', '__eq__' '__float__', '__floordiv__', '__ge__', '__getattribute__',

，    ,    ，    ，    丄，，    1    1    ，    ，    ••丄    ，

'__getnewargs__', '__gt__', '__hash__', '__init__',

'__int__', '__le__', '__long__', '__lt__', '__mod__',

， 1 ， ， ， ， ， ， ， ， ，

'__mul__', '__ne__', '__neg__', '__new__', '__nonzero__',

![img](07Python38c3160b-1636.jpg)



，    ，    ，    ，    ，    11，，    1 •    J J    1 •    1    ;

![img](07Python38c3160b-1637.jpg)



'__pos__', '__pow__', '__radd__', '__rdiv__', '__rdivmod__'

，    1    ，    ，    1    ，    ，    ?    ?    -27    1 •    J

'__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__',

， 1 ， ， 1 ， ， ， ， 1 >

'__rmod__', '__rmul__', '__rpow__', '__rsub__',

'__rtruediv__', '__setattr__', '__str__', '__sub__',

'__truediv__', 'conjugate', 'imag', 'real']

\>>>

\>>> [type(getattr(x, i)) for i in ('conjugate', 'imag', 'real')]

[<type 'builtin_function_or_method'>, <type 'float'>,

<type 'float'>]

既然我们知道了一个复数有什么样的属性，我们就可以访问它的数据属性，调用它的方法了

\>>> x.imag

2.0

\>>> x.real

1.0

\>>> x.conjugate()

(1-2j)

试着访问__dict__会失败，因为在内建类型中，不存在这个属性

\>>> x.__dict__



Edit By Vheavens

Edit By Vheavens

Traceback (innermost last): File "<stdin>", line 1, in AttributeError: __dict__



### 13.6.5 实例属性 vs 类属性

我们已在13.4.1节中描述了类数据属性。这里简要提一下，类属性仅是与类相关的数据值，和

实例属性不同，类属性和实例无关。这些值像静态成员那样被引用，即使在多次实例化中调用类，

它们的值都保持不变。不管如何，静态成员不会因为实例而改变它们的值，除非实例中显式改变它

们的值。(实例属性与类属性的比较，类似于自动变量和静态变量，但这只是笼统的类推。在你对自

动变量和静态变量还不是很熟的情况下，不要深究这些。

类和实例都是名字空间。类是类属性的名字空间，实例则是实例属性的。

关于类属性和实例属性，还有一些方面需要指出。你可采用类来访问类属性，如果实例没有同

名的属性的话，你也可以用实例来访问。

#### 访问类属性

类属性可通过类或实例来访问。下面的示例中，类C在创建时，带一个version属性，这样通 瞥过类对象来访问它是很自然的了，比如，C.version。当实例c被创建后，对实例c而言，访问 c.version会失败，不过Python首先会在实例中搜索名字version，然后是类，再就是继承树中的

![img](07Python38c3160b-1640.jpg)



基类。本例中，version在类中被找到了：

\>>> class C(object): # define class 定义类

... version = 1.2 # static member 静态成员

\>>> c = C() # instantiation 实例化

\>>> C.version # access via class 通过类来访问

1.2

\>>> c.version # access via instance 通过实例来访问

1.2

\>>> C.version += 0.1 # update (only) via class 通过类(只能这样)来更新 >>> C.version # class access 类访问

1.3

\>>> c.version # instance access, which 实例访问它，其值已被改变

1.3 # also reflected change

然而，我们只有当使用类引用version时，才能更新它的值，像上面的C.version递增语句。 如果尝试在实例中设定或更新类属性会创建一个实例属性c.version，后者会阻止对类属性 C.versioin的访问，因为第一个访问的就是c.version，这样可以对实例有敦地“遮蔽”类属性



C.version，直到 c.version 被清除掉。

#### 从实例中访问类属性须谨慎

与通常Python变量一样，任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并 且对其赋值。如果类属性中存在同名的属性，有趣的副作用即产生。（经典类和新式类都存在）

\>>> class Foo(object): ... x = 1.5

\>>> foo = Foo（）

\>>> foo.x

1.5

\>>> foo.x = 1.7 # try to update class attr 试着更新类属性

\>>> foo.x # looks good so far... 现在看起来还不错

1.7

\>>> Foo.x # nope, just created a new inst attr 呵呵，没有变，只是创建了一个新的实 例属性

\1. 5

在上面的代码片断中，创建了一个名为version的新实例属性，它覆盖了对类属性的引用。然 而，类属性本身并没有受到伤害，仍然存在于类域中，还可以通过类属性来访问它，如上例可以看 到的。好了，那么如果把这个新的version删除掉，会怎么样呢？为了找到结论，我们将使用del 语句删除c.version。

\>>> del foo.x # delete instance attribute 删除实例属性

\>>> foo.x # can now access class attr again 又可以访问到类属性

1.5

所以，给一个与类属性同名的实例属性赋值，我们会有效地“隐藏”类属性，但一旦我们删除

了这个实例属性，类属性又重见天日。现在再来试着更新类属性，但这次，我们只尝试一下“无辜”

的增量动作：

\>>> foo.x += .2 # try to increment class attr 试着增加类属性

\>>> foo.x

1.7

\>>> Foo.x # nope, same thing 呵呵，照旧

1.5

还是没变。我们同样创建了一个新的实例属性，类属性原封不动。（深入理解Python相关知识： 属性已存于类字典［__dict__］中。通过赋值，其被加入到实例的__dict__中了。）赋值语句右边的表 达式计算出原类的变量，增加0.2，并且把这个值赋给新创建的实例属性。注意下面是一个等价的赋

值方式，但它可能更加清楚些：

foo.x = Foo.x + 0.2

但...在类属性可变的情况下，一切都不同了：

\>>> class Foo(object):

... x = {2003: 'poe2'}

\>>> foo = Foo()

\>>> foo.x

{2003: 'poe2'}

\>>> foo.x[2004] = 'valid path'

\>>> foo.x

{2003: 'poe2', 2004: 'valid path'}

\>>> Foo.x # it works!!! 生效了

{2003: 'poe2', 2004: 'valid path'}

\>>> del foo.x # no shadow so cannot delete 没有遮蔽所以不能删除掉 Traceback (most recent call last): File "<stdin>", line 1, in ?

del foo. x AttributeError: x >>>

#### 类属性持久性 静态成员，如其名所言，任凭整个实例(及其属性)的如何进展，它都不理不采(因此独立于

实例)。同时，当一个实例在类属性被修改后才创建，那么更新的值就将生效。类属性的修改会影响

到所有的实例：

\>>> class C(object):

... spam = 100 # class attribute 类属性

\>>> c1 = C()    # create an instance 创建一个实例

\>>> c1.spam # access class attr thru inst. 通过实例访问类属性 100

\>>> C.spam += 100 # update class attribute 更新类属性 >>> C.spam # see change in attribute 查看属性值改变 200

\>>> c1.spam # confirm change in attribute 在实例中验证属性值改变 200

\>>> c2 = C()    # create another instance 创建另一个实例

\>>> c2.spam # verify class attribute 验证类属性

200

\>>> del c1 # remove one instance 删除一个实例 >>> C.spam += 200 # update class attribute again 再次更新类属性 >>> c2.spam # verify that attribute changed 验证那个属性值改变 400

#### 核心提示：使用类属性来修改自身（不是实例属性）

正如上面所看到的那样，使用实例属性来试着修改类属性是很危险的。原因在于实例拥有它们

自已的属性集，在Python中没有明确的方法来指示你想要修改同名的类属性，比如，没有global

关键字可以用来在一个函数中设置一个全局变量（来代替同名的局部变量）。修改类属性需要使用类

名，而不是实例名。

### 13.7 从这里开始校对__________绑定和方法调用

现在我们需要再次阐述Python中绑定（binding）的概念，它主要与方法调用相关连。我们先 来回顾一下与方法相关的知识。首先，方法仅仅是类内部定义的函数。（这意味着方法是类属性而不 是实例属性）。

其次，方法只有在其所属的类拥有实例时，才能被调用。当存在一个实例时，方法才被认为是 H绑定到那个实例了。没有实例时方法就是未绑定的。

最后，任何一个方法定义中的第一个参数都是变量self，它表示调用此方法的实例对象。

#### 核心笔记：self是什么？

self变量用于在类实例方法中引用方法所绑定的实例。因为方法的实例在任何方法调用中总是 作为第一个参数传递的，self被选中用来代表实例。你必须在方法声明中放上self （你可能已经注 意到了这点），但可以在方法中不使用实例（self）。如果你的方法中没有用到self ,那么请考虑创建

一个常规函数，除非你有特别的原因。毕竟，你的方法代码没有使用实例，没有与类关联其功能，

这使得它看起来更像一个常规函数。在其它面向对象语言中，self可能被称为this。

### 13.7.1调用绑定方法

方法，不管绑定与否，都是由相同的代码组成的。唯一的不同在于是否存在一个实例可以调用 此方法。在很多情况下，程序员调用的都是一个绑定的方法。假定现在有一个 MyClass 类和此类的 一个实例mc，而你想调用MyClass.fooO方法。因为已经有一个实例，你只需要调用mc.fooO就可 以。记得self在每一个方法声明中都是作为第一个参数传递的。当你在实例中调用一个绑定的方法 时，self不需要明确地传入了。这算是〃必须声明self作为第一个参数〃对你的报酬。当你还没有 一个实例并且需要调用一个非绑定方法的时候你必须传递self参数。

![img](07Python38c3160b-1648.jpg)



![img](07Python38c3160b-1649.jpg)



![img](07Python38c3160b-1650.jpg)



![img](07Python38c3160b-1651.jpg)



![img](07Python38c3160b-1652.jpg)



### 13.7.2调用非绑定方法

调用非绑定方法并不经常用到。需要调用一个还没有任何实例的类中的方法的一个主要的场景

是:你在派生一个子类,而且你要覆盖父类的方法，这时你需要调用那个父类中想要覆盖掉的构造方

法。这里是一个本章前面介绍过的例子：

class EmplAddrBookEntry（AddrBookEntry）:

'Employee Address Book Entry class' # 员工地址记录条目 def __init__（self, nm, ph, em）:

AddrBookEntry.__init__（self, nm, ph） self.empid = id self.email = em

EmplAddrBookEntry是AddrBookEntry的子类，我们重载了构造器_init_0。我们想尽可能多 地重用代码，而不是去从父类构造器中剪切，粘贴代码。这样做还可以避免BUG传播，因为任何修

复都可以传递给子类。这正是我们想要的 --- 没有必要一行一行地复制代码。只需要能够调用父类

的构造器即可，但该怎么做呢？

我们在运行时没有AddrBookEntry的实例。那么我们有什么呢？我们有一个EmplAddrBookEntry — 的实例，它与AddrBookEntry是那样地相似，我们难道不能用它代替呢？当然可以！

当一个EmplAddrBookEntry被实例化，并且调用_init_（）时，其与AddrBookEntry的实例 只有很少的差别，主要是因为我们还没有机会来自定义我们的EmplAddrBookEntry实例，以使它与 AddrBookEntry 不同。

这是调用非绑定方法的最佳地方了。我们将在子类构造器中调用父类的构造器并且明确地传递 （父类）构造器所需要的self参数（因为我们没有一个父类的实例）。子类中_init_（）的第一 行就是对父类__init__（）的调用。我们通过父类名来调用它，并且传递给它 self 和其他所需要的

参数。一旦调用返回，我们就能定义那些与父类不同的仅存在我们的（子）类中的（实例）定制。

### 13.8 静态方法和类方法

静态方法和类方法在Python2.2中引入。经典类及新式（new-style）类中都可以使用它。一对内 建函数被引入，用于将作为类定义的一部分的某一方法声明“标记”（tag） “强制类型转换”（cast） 或者“转换”（convert）为这两种类型的方法之一。

如果你有一定的C++或者Java经验，静态方法和这些语言中的是一样的。它们仅是类中的函数（不

![img](07Python38c3160b-1653.jpg)



需要实例)。事实上，在静态方法加入到Python之前，用户只能在全局名字空间中创建函数，作为

这种特性的替代实现 - 有时在这样的函数中使用类对象来操作类(或者是类属性)。使用模块函数

比使用静态类方法更加常见。



回忆一下，通常的方法需要一个实例(self)作为第一个参数，并且对于(绑定的)方法调用来 说，self是自动传递给这个方法的。而对于类方法而言，需要类而不是实例作为第一个参数，它是 由解释器传给方法。类不需要特别地命名，类似self，不过很多人使用cls作为变量名字。

### 13.8.1 staticmethod()和 classmethodO 内建函数

现在让我们看一下在经典类中创建静态方法和类方法的一些例子(你也可以把它们用在新式类

中)：

class TestStaticMethod:

def foo():

print 'calling static method foo()'

foo = staticmethod(foo)

![img](07Python38c3160b-1655.jpg)



class TestClassMethod: def foo(cls):

![img](07Python38c3160b-1656.jpg)



print 'calling class method foo()' print 'foo() is part of class:'， cls.__name__

foo = classmethod(foo)

对应的内建函数被转换成它们相应的类型，并且重新赋值给了相同的变量名。如果没有调用这

两个函数，二者都会在Python编译器中产生错误，显示需要带self的常规方法声明。现在，我们 可以通过类或者实例调用这些函数....这没什么不同：

\>>> tsm = TestStaticMethod()

\>>> TestStaticMethod.foo() calling static method foo()

\>>> tsm.foo()

calling static method foo()

\>>>

\>>> tcm = TestClassMethod()

\>>> TestClassMethod.foo()

calling class method foo()

foo() is part of class: TestClassMethod

\>>> tcm.foo()

![img](07Python38c3160b-1657.jpg)



calling class method foo()

foo() is part of class: TestClassMethod

### 13.8.2 使用函数修饰符

现在，看到像foo=staticmethod(foo)这样的代码会刺激一些程序员。很多人对这样一个没意义 的语法感到心烦，即使van Rossum曾指出过，它只是临时的，有待社区对些语义进行处理。在第11 章“函数”的11.3.6节中，我们了解了函数修饰符，一种在Python2.4中加入的新特征。你可以用 它把一个函数应用到另个函数对象上, 而且新函数对象依然绑定在原来的变量。我们正是需要它来 整理语法。通过使用decorators，我们可以避免像上面那样的重新赋值：

class TestStaticMethod: @staticmethod

def foo():

print 'calling static method foo()

class TestClassMethod:

@classmethod

def foo(cls):

print 'calling class method foo()'

print 'foo() is part of class:', cls.__name__

### 13.9 组合

一个类被定义后，目标就是要把它当成一个模块来使用，并把这些对象嵌入到你的代码中去， 同其它数据类型及逻辑执行流混合使用。有两种方法可以在你的代码中利用类。第一种是组合 (composition)。就是让不同的类混合并加入到其它类中，来增加功能和代码重用性。你可以在一个 大点的类中创建你自已的类的实例，实现一些其它属性和方法来增强对原来的类对象。另一种方法 是通过派生，我们将在下一节中讨论它.

举例来说，让我们想象一个对本章一开始创建的地址本类的加强性设计。如果在设计的过程中， 为names,addresses等等创建了单独的类。那么最后我们可能想把这些工作集成到AddrBookEntry 类中去，而不是重新设计每一个需要的类。这样就节省了时间和精力，而且最后的结果是容易维护 的代码-—一块代码中的bugs被修正，将反映到整个应用中。

这样的类可能包含一个 Name 实例，以及其它的像 StreetAddress, Phone (home, work, telefacsimile, pager, mobile,等等)，Email (home, work,等等。)，还可能需要一些 Date 实 例(birthday，wedding，anniversary，等等)。下面是一个简单的例子：

![img](07Python38c3160b-1660.jpg)



![img](07Python38c3160b-1661.jpg)



![img](07Python38c3160b-1662.jpg)



![img](07Python38c3160b-1663.jpg)



class NewAddrBookEntry（object）: # class definition 类定义

'new address book entry class'

def __init__（self， nm， ph）: # define constructor 定义构造器

self. name = Name（nm） # create Name instance    创建Name 实例

self. phone = Phone（ph）林 create Phone instance    创建Phone 实例

print 'Created instance for:'， self.name



NewAddrBookEntry类由它自身和其它类组合而成。这就在一个类和其它组成类之间定义了一种 “has-a /有一个”的关系。比如，我们的NewAddrBookEntry类“有一个” Name类实例和一个Phone 实例。

创建复合对象就可以实现这些附加的功能，并且很有意义，因为这些类都不相同。每一个类管

理它们自己的名字空间和行为。不过当对象之间有更接近的关系时，派生的概念可能对你的应用程

序来说更有意义，特别是当你需要一些相似的对象，但却有少许不同功能的时候。

### 13.10 子类和派生

当类之间有显著的不同，并且（较小的类）是较大的类所需要的组件时，组合表现得很好，但当 H你设计“相同的类但有一些不同的功能”时，派生就是一个更加合理的选择了。

OOP的更强大方面之一是能够使用一个已经定义好的类，扩展它或者对其进行修改，而不会影响 系统中使用现存类的其它代码片段。OOD允许类特征在子孙类或子类中进行继承。这些子类从基类（或 称祖先类，超类）继承它们的核心属性。而且，这些派生可能会扩展到多代。在一个层次的派生关 系中的相关类（或者是在类树图中垂直相邻）是父类和子类关系。从同一个父类派生出来的这些类 （或者是在类树图中水平相邻）是同胞关系。父类和所有高层类都被认为是祖先。

使用前一节中的例子，如果我们必须创建不同类型的地址本。即，不仅仅是创建地址本的多个 实例，在这种情况下，所有对象几乎是相同的。如果我们希望EmplAddrBookEntry类中包含更多与 工作有关的属性，如员工ID和e-mail地址？这跟PersonalAddrBookEntry类不同，它包含更多基 于家庭的信息，比如家庭地址，关系，生日等等。

两种情况下，我们都不想到从头开始设计这些类，因为这样做会重复创建通用的AddressBook 类时的操作。包含AddressBook类所有的特征和特性并加入需要的定制特性不是很好吗？这就是类 派生的动机和要求。

### 13.10.1 创建子类

![img](07Python38c3160b-1665.jpg)



创建子类的语法看起来与普通(新式)类没有区别，一个类名，后跟一个或多个需要从其中派生

的父类：

class SubClassName (ParentClass1[， ParentClass2， ...]):

'optional class documentation string' class_suite



如果你的类没有从任何祖先类派生，可以使用object作为父类的名字。经典类的声明唯一不同 之处在于其没有从祖先类派生－－－此时，没有圆括号：

class ClassicClassWithoutSuperclasses:

pass

至此，我们已经看到了一些类和子类的例子，下面还有一个简单的例子 class Parent(object): # define parent class 定义父类

def parentMethod(self):

print 'calling parent method'

class Child(Parent): # define child class 定义子类 def childMethod(self):

print 'calling child method'

![img](07Python38c3160b-1667.jpg)



\>>> p = Parent() # instance of parent 父类的实例 >>> p.parentMethod()

calling parent method >>>

\>>> c = Child()# instance of child 子类的实例

\>>> c.childMethod() # child calls its method 子类调用它的方法 calling child method

\>>> c.parentMethod() # calls parent's method 调用父类的方法 calling parent method

### 13.11继承

继承描述了基类的属性如何“遗传”给派生类。一个子类可以继承它的基类的任何属性，不管

是数据属性还是方法。

举个例子如下。P是一个没有属性的简单类。C从P继承而来(因此是它的子类)，也没有属性：

class P(object): # parent class 父类

pass

class C(P): # child class 子类



pass



\>>> c = C() # instantiate child 实例化子类

\>>> c.__class__ # child "is a" parent 子类“是一个”父类 <class '__main__.C'>

\>>> C.__bases__ # child's parent class(es) 子类的父类 (<class '__main__.P'>,)

因为P没有属性，C没有继承到什么。下面我们给P添加一些属性:

class P: # parent class 父类 'P class'

def __init__(self):

print 'created an instance of', \

self.__class__.__name__

class C(P): # child class 子类 pass

现在所创建的P有文档字符串(_doc_)和构造器，当我们实例化P时它被执行，如下面的

![img](07Python38c3160b-1670.jpg)



交互会话所示：

\>>> p = P() # parent instance 父类实例 created an instance of P

\>>> p. __class__ 林 class that created us 显示p所属的类名

<class '__main__.P'>

\>>> P.__bases__ # parent's parent class(es) 父类的父类 (<type 'object'>,)

\>>> P.__doc__ # parent's doc string 父类的文档字符串 'P class'

“created an instance”是由_init_()直接输出的。我们也可显示更多关于父类的信息。我 们现在来实例化C，展示_init_()(构造)方法在执行过程中是如何继承的：

\>>> c = C() # child instance 子类实例 created an instance of C

\>>> c. __class__ 林 class that created us 显示 c所属的类名

<class '__main__.C'>

\>>> C.__bases__ # child's parent class(es) 子类的父类 (<class '__main__.P'>,)

\>>> C.__doc__ # child's doc string 子类的文档字符串

\>>>

![img](07Python38c3160b-1671.jpg)



![img](07Python38c3160b-1672.jpg)



C没有声明_^^_()方法，然而在类C的实例c被创建时，还是会有输出信息。原因在于C继 承了 ？的_^^_()。_^3868_元组列出了其父类P。需要注意的是文档字符串对类，函数/方法， 还有模块来说都是唯一的，所以特殊属性__doc__不会从基类中继承过来。

### 13.11.1 __bases__类属性

在第13.4.4节中，我们概要地介绍了__bases__类属性，对任何(子)类，它是一个包含其父类 (parent)的集合的元组。注意，我们明确指出“父类”是相对所有基类(它包括了所有祖先类) 而言的。那些没有父类的类，它们的__bases__属性为空。下面我们看一下如何使用__bases__的。

»> class A(object): pass 林 define class A 定义类A

\>>> class B(A): pass 林 subclass of A A 的子类

\>>> class C(B): pass # subclass of B (and indirectly，A) B的子类(A 的间接子类)

\>>> class D(A，B): pass # subclass of A and B A， B的子类

\>>> A.__bases__

![img](07Python38c3160b-1673.jpg)



(<type 'object'>，)

\>>> C.__bases__

(<class __main__.B at 8120c90>，)

\>>> D.__bases__

(<class __main__.A at 811fc90>， <class __main__.B at 8120c90>)

在上面的例子中，尽管C是A和B的子类(通过B传递继承关系)但C的父类是B，这从它的 声明中可以看出，所以，只有B会在C._bases_中显示出来。另一方面，D是从两个类A和B中继 承而来的。(多重继承参见13.11.4)

### 13.11.2通过继承覆盖(Overriding)方法

我们在p中再写一个函数，然后在其子类中对它进行覆盖。 class P(object):

def foo(self):

print 'Hi， I am P-foo()'

\>>> p = P()



\>>> p.foo()

Hi， I am P-foo()

现在来创建子类C，从父类P派生:

class C(P):

def foo(self):

print 'Hi， I am C-foo()'

\>>> c = C()

\>>> c.foo()

Hi， I am C-foo()

尽管C继承了P的foo()方法，但因为C定义了它自已的foo()方法，所以P中的foo()方法 被覆盖。覆盖方法的原因之一是，你的子类可能需要这个方法具有特定或不同的功能。所以，你接 下来的问题肯定是：“我还能否调用那个被我覆盖的基类方法呢？”

答案是肯定的，但是这时就需要你去调用一个未绑定的基类方法，明确给出子类的实例，例如

下边:

\>>> P. foo(c)

Hi, I am P-foo()

注意，我们上面已经有了一个P的实例p，但上面的这个例子并没有用它。我们不需要P的实 例调用P的方法，因为已经有一个P的子类的实例c可用。典型情况下，你不会以这种方式调用父类 方法，你会在子类的重写方法里显式地调用基类方法。

class C(P): def foo(self):

P.foo(self)

print 'Hi， I am C-foo()'

注意，在这个(未绑定)方法调用中我们显式地传递了 self. 一个更好的办法是使用super() 内建方法：

class C(P):

def foo(self):

super(C， self).foo() print 'Hi， I am C-foo()

super()不但能找到基类方法，而且还为我们传进self，这样我们就不需要做这些事了。现在我 们只要调用子类的方法，它会帮你完成一切：

![img](07Python38c3160b-1677.jpg)



![img](07Python38c3160b-1678.jpg)



![img](07Python38c3160b-1679.jpg)



![img](07Python38c3160b-1680.jpg)



\>>> c = C()

\>>> c.foo()

Hi, I am P-foo() Hi, I am C-foo()



核心笔记：重写__init__不会自动调用基类的__init__

类似于上面的覆盖非特殊方法，当从一个带构造器 __init()__的类派生，如果你不去覆盖 __init__()，它将会被继承并自动调用。但如果你在子类中覆盖了__init__()，子类被实例化时，

基类的__init__()就不会被自动调用。这可能会让了解JAVA的朋友感到吃惊。

class P(object): def __init__(self):

print "calling P's constructor"

class C(P): def __init__(self):

print "calling C's constructor"

\>>> c = C()

![img](07Python38c3160b-1682.jpg)



calling C's constructor

![img](07Python38c3160b-1683.jpg)



如果你还想调用基类的 __init__()，你需要像上边我们刚说的那样，明确指出，使用一个子

类的实例去调用基类(未绑定)方法。相应地更新类C，会出现下面预期的执行结果：

class C(P): def __init__(self):

P.__init__(self)

print "calling C's constructor"

\>>> c = C()

calling P's constructor calling C's constructor

上边的例子中，子类的__init__()方法首先调用了基类的的__init__()方法。这是相当普遍(不 是强制)的做法，用来设置初始化基类，然后可以执行子类内部的设置。这个规则之所以有意义的 原因是,你希望被继承的类的对象在子类构造器运行前能够很好地被初始化或作好准备工作，因为它 (子类)可能需要或设置继承属性。

对C++熟悉的朋友，可能会在派生类构造器声明时，通过在声明后面加上冒号和所要调用的所有 基类构造器这种形式来调用基类构造器。而在JAVA中，不管程序员如何处理，子类构造器都会去调

用基类的的构造器。

Python使用基类名来调用类方法，对应在JAVA中，是用关键字super来实现的，这就是super() 内建函数引入到Python中的原因，这样你就可以“依葫芦画瓢”了：

class C(P):



def __init__(self): super(C， self).__init__() print "calling C's constructor"

使用super()的漂亮之处在于，你不需要明确给出任何基类名字...“跑腿事儿”它帮你干了！ 使用super()的重点，是你不需要明确提供父类。这意味着如果你改变了类继承关系，你只需要改一 行代码(class语句本身)而不必在大量代码中去査找所有被修改的那个类的名字。

### 13.11.3 从标准类型派生

经典类中，一个最大的问题是，不能对标准类型进行子类化。幸运的是，在2.2以后的版本中， 随着类型(types)和类(class)的统一和新式类的引入，这一点已经被修正。下面，介绍两个子 类化Python类型的相关例子，其中一个是可变类型，另一个是不可变类型。

不可变类型的例子

假定你想在金融应用中，应用一个处理浮点数的子类。每次你得到一个贷币值(浮点数给出的)，

你都需要通过四舍五入，变为带两位小数位的数值。(当然，Decimal类比起标准浮点类型来说是个 用来精确保存浮点值的更佳方案，但你还是需要［有时候］对其进行舍入操作！)你的类开始可以 这样写：

class RoundFloat(float): def __new__(cls， val):

return float.__new__(cls， round(val， 2))

我们覆盖了__new__0特殊方法来定制我们的对象，使之和标准Python浮点数(float)有一些 区别：我们使用round()内建函数对原浮点数进行舍入操作，然后实例化我们的float，RoundFloat。 我们是通过调用父类的构造器来创建真实的对象的，float._new_()。注意，所有的_new()_* 法都是类方法，我们要显式传入类传为第一个参数，这类似于常见的方法如_化^_()中需要的self。

现在的例子还非常简单，比如，我们知道有一个float我们仅仅是从一种类型中派生而来等等. 通常情况下，最好是使用super()内建函数去捕获对应的父类以调用它的__new()__方法，下面，对 它进行这方面的修改：

class RoundFloat(float):

def __new__(cls， val):

return super(RoundFloat， cls).__new__(cls， round(val， 2))

这个例子还远不够完整，所以，请留意本章我们将使它有更好的表现。下面是一些样例输出

\>>> RoundFloat(1.5955) 1.6



\>>> RoundFloat(1.5945) 1.59

\>>> RoundFloat(-1.9955) -2.0

#### 可变类型的例子

子类化一个可变类型与此类似，你可能不需要使用__new__() (或甚至__init__())，因为通常 设置不多。一般情况下，你所继承到的类型的默认行为就是你想要的。下例中，我们简单地创建一 个新的字典类型，它的keys()方法会自动排序结果：

class SortedKeyDict(dict): def keys(self):

return sorted(super( SortedKeyDict， self).keys())

回忆一下，字典(dictionary)可以由 dict()，dict(mapping)，dict(sequence_of_2_tuples)， 或者dict(**kwargs)来创建，看看下面使用新类的例子：

![img](07Python38c3160b-1688.jpg)



d = SortedKeyDict((('zheng-cai'， 67)， ('hui-jun'， 68)，('xin-yi'， 2))) print 'By iterator:'.ljust(12)， [key for key in d] print 'By keys():'.ljust(12)， d.keys()

把上面的代码全部加到一个脚本中，然后运行，可以得到下面的输出：

By iterator: ['zheng-cai'， 'xin-yi'， 'hui-jun']

By keys(): ['xin-yi'， 'hui-jun'， 'zheng-cai']

在上例中，通过keys迭代过程是以散列顺序的形式，而使用我们(重写的)keys()方法则将 keys变为字母排序方式了。

一定要谨慎，而且要意识到你正在干什么。如果你说，“你的方法调用super()过于复杂”取而 代之的是，你更喜欢keys()简简单单(也容易理解)....，像这样：

def keys(self): return sorted(self.keys())

这是本章后面的练习13-19。

![img](07Python38c3160b-1689.jpg)



![img](07Python38c3160b-1690.jpg)



![img](07Python38c3160b-1691.jpg)



![img](07Python38c3160b-1692.jpg)



![img](07Python38c3160b-1693.jpg)



![img](07Python38c3160b-1694.jpg)



### 13.11.4多重继承

同C++—样，Python允许子类继承多个基类。这种特性就是通常所说的多重继承。概念容易， 但最难的工作是，如何正确找到没有在当前(子)类定义的属性。当使用多重继承时，有两个不同 的方面要记住。首先，还是要找到合适的属性。另一个就是当你重写方法时，如何调用对应父类方 法以“发挥他们的作用”，同时，在子类中处理好自己的义务。我们将讨论两个方面，但侧重后者，

讨论方法解析顺序。

#### 方法解释顺序(MRO)

在Python 2.2以前的版本中，算法非常简单：深度优先，从左至右进行搜索，取得在子类中使 用的属性。其它Python算法只是覆盖被找到的名字，多重继承则取找到的第一个名字。

由于类，类型和内建类型的子类，都经过全新改造， 有了新的结构，这种算法不再可行. 这样

一种新的MR0算法被开发出来，在2.2版本中初次登场，是一个好的尝试，但有一个缺陷(看下面 的核心笔记)。这在2.3版本中立即被修改，也就是今天还在使用的版本。

精确顺序解释很复杂，超出了本文的范畴，但你可以去阅读本节后面的参考书目提到的有关内 容。这里提一下，新的查询方法是采用广度优先，而不是深度优先。

#### 核心笔记：Python 2.2使用一种唯一但不完善的MRO

Python 2.2是首个使用新式MRO的版本，它必须取代经典类中的算法，原因在上面已谈到过。

在2.2版本中，算法基本思想是根据每个祖先类的继承结构，编译出一张列表，包括搜索到的类，

按策略删除重复的。然而，在Python核心开发人员邮件列表中，有人指出，在维护单调性方面失败 过(顺序保存)，必须使用新的C3算法替换，也就是从2.3版开始使用的新算法。

下面的示例，展示经典类和新式类中，方法解释顺序有什么不同。

简单属性查找示例

下面这个例子将对两种类的方案不同处做一展示。脚本由一组父类，一组子类，还有一个子孙

类组成。

class P1: #(object): # parent class 1 父类1 def foo(self):

print 'called P1-foo()'

class P2: #(object): # parent class 2 父类2

def foo(self):



print 'called P2-foo()'



def bar(self): print 'called P2-bar()'

class C1(P1, P2):林 child 1 der. from P1, P2 #子类1，从 P1，P2 派生

pass

class C2(P1，P2):林 child 2 der. from P1, P2 #子类2,从 P1，P2 派生

def bar(self):

print 'called C2-bar()'

class GC(C1， C2): # define grandchild class #定义子孙类 pass 林 derived from C1 and C2 林从 C1，C2派生

![img](07Python38c3160b-1697.jpg)



![img](07Python38c3160b-1698.jpg)



![img](07Python38c3160b-1699.jpg)



图13-2 父类，子类及子孙类的关系图，还有它们各自定义的方法

在图13-2中，我们看到父类，子类及子孙类的关系。P1中定义了foo()，P2定义了foo()和bar()， C2定义了 bar()。下面举例说明一下经典类和新式类的行为。

#### 经典类

首先来使用经典类。通过在交互式解释器中执行上面的声明，我们可以验证经典类使用的解释

顺序，深度优先，从左至右：

\>>> gc = GC()

\>>> gc.foo() # GC ==> C1 ==> P1 called P1-foo()

\>>> gc.bar() # GC ==> C1 ==> P1 ==> P2 called P2-bar()

当调用foo()时，它首先在当前类(GC)中查找。如果没找到，就向上查找最亲的父类，C1。查找 未遂，就继渎沿树上访到父类P1，foo()被找到。

![img](07Python38c3160b-1700.jpg)



同样，对bar()来说，它通过搜索GC，C1，P1然后在P2中找到。因为使用这种解释顺序的缘故， C2.bar()根本就不会被搜索了。

现在，你可能在想，“我更愿意调用C2的bar()方法，因为它在继承树上和我更亲近些，这样才 会更合适。”在这种情况下，你当然还可以使用它，但你必须调用它的合法的全名，采用典型的非绑 定方式去调用，并且提供一个合法的实例：

\>>> C2.bar(gc)

called C2-bar()

#### 新式类

取消类P1和类P2声明中的对(object)的注释，重新执行一下。新式方法的查询有一些不同:

\>>> gc = GC()

\>>> gc.foo() # GC ==> C1 ==> C2 ==> P1 called P1-foo()

\>>> gc. bar() # GC ==> C1 ==> C2 called C2~bar()

与沿着继承树一步一步上溯不同，它首先查找同胞兄弟，采用一种广度优先的方式。当查找 foo()它检查GC，然后是C1和C2，然后在P1中找到。如果P1中没有，查找将会到达P2afoo() 的底线是，包括经典类和新式类都会在P1中找到它，然而它们虽然是同归，但殊途！

然而，bar()的结果是不同的。它搜索GC和C1，紧接着在C2中找到了。这样，就不会再继续搜 索到祖父P1和P2。这种情况下，新的解释方式更适合那种要求查找GC更亲近的bar()的方案。当 然，如果你还需要调用上一级，只要按前述方法，使用非绑定的方式去做，即可。

\>>> P2.bar(gc)

called P2-bar()

新式类也有一个__mro__属性，告诉你查找顺序是怎样的：

\>>> GC.__mro__

(<class '__main__.GC'>， <class '__main__.C1'>， <class '__main__.C2'>， <class '__main__.P1'>， <class '__main__.P2'>， <type 'object'>)

菱形效应为难MRO

![img](07Python38c3160b-1703.jpg)



![img](07Python38c3160b-1704.jpg)



![img](07Python38c3160b-1705.jpg)



![img](07Python38c3160b-1706.jpg)



![img](07Python38c3160b-1707.jpg)



经典类方法解释不会带来很多问题。它很容易解释，并理解。大部分类都是单继承的，多重继 承只限用在对两个完全不相关的类进行联合。这就是术语mixin类(或者“mix-ins”的由来。

#### 为什么经典类MRO会失败

在版本2.2中，类型与类的统一，带来了一个新的“问题”，波及所有从object (所有类型的祖 先类)派生出来的(根)类，一个简单的继承结构变成了一个菱形。从Guido van Rossum的文章 中得到下面的灵感，打个比方，你有经典类B和C，C覆盖了构造器，B没有，D从B和C继承而来：

class B: pass

class C:

def __init__(self):

print "the default constructor"

![img](07Python38c3160b-1708.jpg)



class D(B， C): pass

![img](07Python38c3160b-1709.jpg)



当我们实例化D，得到:

\>>> d = D()

the default constructor

图13.3为B，C和D的类继承结构，现在把代码改为采用新式类的方式，问题也就产生了:

class B(object): pass

class C(object): def __init__(self):

print "the default constructor"

![img](07Python38c3160b-1710.jpg)



图13.3 继承的问题是由于在新式类中，需要出现基类，这样就在继承结构中，形成了一个 菱形。D的实例上溯时，不应当错过C，但不能两次上溯到A (因为B和C都从A派生)。去读读Guido van Rossum的文章中有关〃协作方法〃的部分，可以得到更深地理解。

代码中仅仅是在两个类声明中加入了(object)对吗？没错，但从图中，你可以看出，继承结 构已变成了一个菱形；真正的问题就存在于MR0 了。如果我们使用经典类的MR0,当实例化D时，不

再得到C. __init__()之结果.....而是得到object. __init__()!这就是为什么MR0需要修改的真正

原因。

尽管我们看到了，在上面的例子中，类GC的属性查找路径被改变了，但你不需要担心会有大量 的代码崩溃。经典类将沿用老式MR0,而新式类将使用它自己的MR0。还有，如果你不需要用到新 式类中的所有特性，可以继续使用经典类进行开发，不会有问题的。

#### 总结

经典类，使用深度优先算法。因为新式类继承自object，新的菱形类继承结构出现，问题也就 接着而来了，所以必须新建一个MRO。

你可以在下面的链接中读在更多有关新式类、MR0的文章：

Guido van Rossum的有关类型和类统一的文章：

<http://www.python.org/download/releases/2.2.3/descrintro>

PEP 252：使类型看起来更像类

<http://www.python.org/doc/peps/pep-0252>

“Python 2.2 新亮点” 文档 <http://www.python.org/doc/2.2.3/whatsnew>

论文：Python 2.3方法解释顺序

<http://python.org/download/releases/2.3/mro/>

![img](07Python38c3160b-1714.jpg)



![img](07Python38c3160b-1715.jpg)



![img](07Python38c3160b-1716.jpg)



![img](07Python38c3160b-1717.jpg)



![img](07Python38c3160b-1718.jpg)

 13.12 类、实例和其他对象的内建函数

### 13.12.1 issubclass()

issubclass() 布尔函数判断一个类是另一个类的子类或子孙类。它有如下语法

issubclass(sub， sup)

issubclass()返回True的情况:给出的子类sub确实是父类sup的一个子类(反之，则为False)。 这个函数也允许“不严格”的子类，意味着，一个类可视为其自身的子类，所以，这个函数如果当 sub就是sup，或者从sup派生而来，则返回True。(一个“严格的”子类是严格意义上的从一个类 派生而来的子类。)

从Python 2.3开始，issubclassO的第二个参数可以是可能的父类组成的tuple (元组)，这时， 只要第一个参数是给定元组中任何一个候选类的子类时，就会返回True。

### 13.12.2 isinstance()

isinstance()布尔函数在判定一个对象是否是另一个给定类的实例时，非常有用。它有如下 语法：

isinstance(obj1， obj2)

isinstance()在obj1是类obj2的一个实例，或者是obj2的子类的一个实例时，返回True (反之，则为False)，看下面的例子：

\>>> class C1(object): pass

\>>> class C2(object): pass

\>>> c1 = C1()

\>>> c2 = C2()

\>>> isinstance(c1， C1) True

\>>> isinstance(c2， C1) False

\>>> isinstance(c1， C2) False

\>>> isinstance(c2， C2) True

\>>> isinstance(C2， c2) Traceback (innermost last):

![img](07Python38c3160b-1719.jpg)



File "<stdin>", line 1, in ? isinstance(C2, c2)

TypeError: second argument must be a class

注意：第二个参数应当是类；不然，你会得到一个TypeError。但如果第二个参数是一个类型对 象，则不会出现异常。这是允许的，因为你也可以使用isinstanceO来检查一个对象objl是否是 obj2的类型，比如：

\>>> isinstance(4, int)

True

\>>> isinstance(4, str)

False

\>>> isinstance('4', str)

True

如果你对Java有一定的了解，那么你可能知道Java中有个等价函数叫instanceofO，但由于 性能上的原因，instanceofO并不被推荐使用。调用Python的isinstanceO不会有性能上的问题， 主要是因为它只用来来快速搜索类族集成结构，以确定调用者是哪个类的实例，还有更重要的是，

它是用C写的！

同issubclassO—样，isinstanceO也可以使用一个元组(tuple)作为第二个参数。这个特 ” 性是从Python 2.2版本中引进的。如果第一个参数是第二个参数中给定元组的任何一个候选类型

或类的实例时，就会返回True。你还可以在595页，第13.16.1节中了解到更多有isinstanceO的 内容。

### 13.12.3 hasattr(), getattr(),setattr(), delattr()

*attr()系列函数可以在各种对象下工作，不限于类(class)和实例(instances)。然而，因 为在类和实例中使用极其频繁，就在这里列出来了。需要说明的是，当使用这些函数时，你传入你 正在处理的对象作为第一个参数，但属性名，也就是这些函数的第二个参数，是这些属性的字符串

名字。换句话说，在操作obj.attr时，就相当于调用*3七灶(^上、《^....)系列函数------下面

的例子讲得很清楚。

hasattrO函数是Boolean型的，它的目的就是为了决定一个对象是否有一个特定的属性，一 般用于访问某属性前先作一下检查。getattrO和setattrO函数相应地取得和赋值给对象的属性， getattrO会在你试图读取一个不存在的属性时，引发AttributeError异常，除非给出那个可选的 默认参数。setattrO将要么加入一个新的属性，要么取代一个已存在的属性。而delattrO函数会 从一个对象中删除属性。

Here are some examples using all the *attr() BIFs:

下面一些例子使用到7*attr()系列函数:



\>>> class myClass(object): ... def __init__(self): ... self.foo = 100

\>>> myInst = myClass()

\>>> hasattr(myInst, 'foo')

True

\>>> getattr(myInst, 'foo')

100

\>>> hasattr(myInst, 'bar') False

\>>> getattr(myInst, 'bar') Traceback (most recent call last):

File "<stdin>", line 1, in ?

getattr(myInst, 'bar')

AttributeError: myClass instance has no attribute 'bar'

\>>> getattr(c, 'bar', 'oops!')

'oops!'

![img](07Python38c3160b-1723.jpg)



\>>> setattr(myInst, 'bar', 'my attr')

![img](07Python38c3160b-1724.jpg)



\>>> dir(myInst)

['__doc__', '__module__', 'bar', 'foo']

\>>> getattr(myInst, 'bar') # same as myInst.bar #等同于 myInst.bar

'my attr'

\>>> delattr(myInst, 'foo')

\>>> dir(myInst)

['__doc__', '__module__', 'bar']

\>>> hasattr(myInst, 'foo')

False

### 13.12.4 dir()

前面用到dir()是在练习2-12,2-13和4-7。在这些练习中，我们用dir()列出一个模块所有属 性的信息。现在你应该知道dir()还可以用在对象上。

在Python 2.2中，dir()得到了重要的更新。因为这些改变，那些__members__和__methods__ 数据属性已经被宣告即将不支持。dir()提供的信息比以前更加详尽。根据文档，“除了实例变量名 和常用方法外，它还显示那些通过特殊标记来调用的方法，像__iadd__(+=)，__len__(len())， __ne__ (!=)。”在Python文档中有详细说明。

![img](07Python38c3160b-1725.jpg)



•    dir()作用在实例上(经典类或新式类)时，显示实例变量，还有在实例所在的类及所有它 的基类中定义的方法和类属性。

•    dir()作用在类上(经典类或新式类)时，则显示类以及它的所有基类中的内容。 但它不会显示定义在元类(metaclass)中的类属性。

•    dir()作用在模块上时，则显示模块的_」1^_的内容。(这没改动)。

•    dir()不带参数时，则显示调用者的局部变量。(也没改动)。

•关于更多细节:对于那些覆盖了属性的对象，就使用它们；出于向后兼 容的考虑，如果已定义了__members__和__methods__，则使用它们。

### 13.12.5 super()

superO函数在Python2.2版本新式类中引入。这个函数的目的就是帮助程序员找出相应的父类， 然后方便调用相关的属性。一般情况下，程序员可能仅仅采用非绑定方式调用祖先类方法。使用 superO可以简化搜索一个合适祖先的任务，并且在调用它时，替你传入实例或类型对象。

在第13.11.4节中，我们描述了文档解释顺序(MRO)，用于在祖先类中查找属性。对于每个定 义的类，都有一个名为_mro_的属性，它是一个元组，按照他们被搜索时的顺序，列出了备搜索 的类。语法如下：

super(type[ obj])

给出type，super()“返回此type的父类”如果你希望父类被绑定，你可以传入obj参数(obj 必须是type类型的).否则父类不会被绑定。obj参数也可以是一个类型，但它应当是type的一个子 类。通常，当给出obj时：

•如果obj是一个实例，isinstance(obj，type)就必须返回True

•如果obj是一个类或类型，issubclass(obj，type)就必须返回True

事实上，superO是一个工厂函数，它创造了一个super object，为一个给定的类使用__mro__ 去查找相应的父类。很明显，它从当前所找到的类开始搜索MR0。更多详情，请再看一下Guido van Rossum有关统一类型和类的文章，他甚至给出了一个superO的纯Python实现，这样，你可以加深 其印象，知道它是如何工作的！

最后想到.... superO的主要用途，是来查找父类的属性，比如， super(MyClass，self).__init__0。如果你没有执行这样的查找，你可能不需要使用superO。

有很多如何使用superO的例子分散在本章中。记得阅读一下第13.11.2节中有关superO的重 要提示，尤其是那节中的核心笔记。

![img](07Python38c3160b-1728.jpg)



![img](07Python38c3160b-1729.jpg)



![img](07Python38c3160b-1730.jpg)



![img](07Python38c3160b-1731.jpg)



![img](07Python38c3160b-1732.jpg)



### 13.12.6 vars()

vars()内建函数与dir()相似，只是给定的对象参数都必须有一个__dict__属性。vars()返回一 个字典，它包含了对象存储于其__dict__中的属性(键)及值。如果提供的对象没有这样一个属性， 则会引发一个TypeError异常。如果没有提供对象作为vars()的一个参数，它将显示一个包含本地 名字空间的属性(键)及其值的字典，也就是，locals()。我们来看一下例子，使用类实例调用vars():

class C(object): pass

\>>> c = C()

\>>> c.foo = 100

\>>> c.bar = 'Python'

\>>> c.__dict__

{'foo': 100, 'bar': 'Python'}

\>>> vars(c)

{’foo’： 100，’bar’： 'Python'

表13.3概括了类和类实例的内建函数。    -

表13.3类，实例及其它对象的内建函数

内建函数

issubclass(sub, sup) isinstance(obj1, obj2)

hasattr(obj, attr)



描述

如果类sub是类sup的子类，则返回True，反之，为False。

如果实例obj1是类obj2或者obj2子类的一个实例;或者如果obj1 是obj2的类型，则返回True;反之，为False。

如果obj有属性attr (用字符串给出)，返回True，反之，返回 表13.3 类，实例及其它对象的内建函数(续)

内建函数

getattr(obj, attr[, default])

setattr(obj, attr, val)

delattr(obj, attr)



描述

获取obj的attr属性；与返回obj.attr类似；如果attr 不是obj的属性，如果提供了默认值，则返回默认值；不然， 就会引发一个AttributeError异常。

设置obj的attr属性值为val，替换任何已存在的属性值；

不然，就创建属性；类似于obj.attr=val 从obj中删除属性attr (以字符串给出)；类似于del obj.attr。

dir(obj=None)



返回obj的属性的一个列表；如果没有给定obj，dir()则

![img](07Python38c3160b-1735.jpg)



![img](07Python38c3160b-1736.jpg)



![img](07Python38c3160b-1737.jpg)



![img](07Python38c3160b-1738.jpg)



显示局部名字空间空间中的属性，也就是locals().keys() super(type, obj=None) a    返回一个表示父类类型的代理对象；如果没有传入obj，

则返回的super对象是非绑定的；反之，如果obj是一个 type ， issubclass(obj，type)必为 True ;否则， isinstance(obj,type)就必为 True。

vars(obj=None)    返回obj的属性及其值的一个字典；如果没有给出obj，

vars()显示局部名字空间字典(属性及其值)，也就是 locals()。

a. Python2.2中新增；仅对新式类有效

### 13.13 用特殊方法定制类

我们已在本章前面部分讲解了方法的两个重要方面：首先，方法必须在调用前被绑定(到它们 相应类的某个实例中)；其次，有两个特殊方法可以分别作为构造器和析够器的功能，分别名为 __init__()和__del__()。

事实上，__init__()和__del__0只是可自定义特殊方法集中的一部分。它们中的一些有预定 义的默认行为，而其它一些则没有，留到需要的时候去实现。这些特殊方法是Python中用来扩充

■©一类的强有力的方式。它们可以实现：

•模拟标准类型 •重载操作符

特殊方法允许类通过重载标准操作符+,*, 甚至包括分段下标及映射操作操作[] 来模拟标准 类型。如同其它很多保留标识符，这些方法都是以双下划线(__)开始及结尾的。表13.4列出了所有 特殊方法及其它的描述。

表13.4 用来定制类的特殊方法

| 特殊方法   | 描述              |                                 |                                                              |
| ---------- | ----------------- | ------------------------------- | ------------------------------------------------------------ |
| 基本定制型 |                   |                                 |                                                              |
| C._        | _init_            | _(self[, arg1,                  | ...]) 构造器(带一些可选的参数)                               |
| C._        | _new__            | (self[, arg1, .                 | ..])a    构造器(带一些可选的参数)；通常用在设置不变数据类型的子类。 |
| C._        | _del__            | (self)                          | 解构器                                                       |
| C._        | _str__            | (self)                          | 可打印的字符输出；内建str()及print语句                       |
| C._        | _repr_            | _(self)                         | 运行时的字符串输出；内建repr()和‘‘操作符                     |
| C._        | _unicode__(self)b | Unicode字符串输出；内建unicodeO |                                                              |

![img](07Python38c3160b-1739.jpg)



![img](07Python38c3160b-1740.jpg)



C.__call__(self， *args) C.__nonzero__(self)

C.__len__(self)

表示可调用的实例

为object定义False值；内建bool（）（从2.2版开始） “长度”（可用于类）；内建len（）



（待续）



表13.4 可以定制类的特殊方法（续）



特殊方法

对象(值)比较 c

C.__cmp__(self， obj)

C.__lt__(self， obj) and C.__gt__(self， obj) and C.__eq__(self， obj) and 属性

C.__getattr__(self， attr)

C.__setattr__(self， attr， val) C.__delattr__(self， attr)

C.__getattribute__(self， attr) C.__get__(self， attr) a C.__set__(self， attr， val) a C.__delete__(self， attr) a 定制类/模拟类型

数值类型：二进制操作符 C.__*add__(self， obj)

C.__*sub__(self， obj)

C.__*mul__(self， obj)

C.__*div__(self， obj)

C.__*truediv__(self， obj) e C.__*floordiv__(self， obj) e C.__*mod__(self， obj)

C.__*divmod__(self， obj)

C.__*pow__(self， obj[， mod])

C.__*lshift__(self， obj)



描述

对象比较；内建cmp（）

小于/小于或等于；对应＜及＜=操作符

大于/大于或等于；对应＞及＞=操作符

等于/不等于；对应==，!=及＜＞操作符

获取属性；内建getattr（）仅当属性没有找到时调用 设置属性

删除属性

a    获取属性；内建getattr（）总是被调用

（描述符）获取属性 （描述符）设置属性 （描述符）删除属性



加；+操作符

减；-操作符

乘；*操作符

除；/操作符

True 除；/操作符 Floor除；//操作符



取模/取余；%操作符

除和取模；内建divmodO 乘幂；内建pow（）;**操作符 左移位；＜＜操作符



表13.4 可定制类的特殊方法（续）



描述



特殊方法

定制类/模拟类型

数值类型：二进制操作符



![img](07Python38c3160b-1743.jpg)



![img](07Python38c3160b-1744.jpg)



![img](07Python38c3160b-1745.jpg)



![img](07Python38c3160b-1746.jpg)



![img](07Python38c3160b-1747.jpg)



![img](07Python38c3160b-1748.jpg)



C.__*rshift__(self, obj) C.__*and__(self, obj)

C.__*or__(self, obj)

C.__*xor__(self, obj) 数值类型：一元操作符 C.__neg__(self)

C.__pos__(self)

C.__abs__(self)

C.__invert__(self) 数值类型：数值转换 C.__complex__(self, com) C.__int__(self)

C.__long__(self)

C.__float__(self)



数值类型：基本表示法(String)



右移；＞＞操作符 按位与；&操作符 按位或；|操作符 按位与或；~操作符

一元负

一元正

绝对值；内建abs()

按位求反；~操作符

转为complex(复数)；内建complexO 转为int;内建int()

转为long;内建long()

转为 float;内建 float()



![img](07Python38c3160b-1749.jpg)



C.__oct__(self)

C.__hex__(self) 数值类型：数值压缩

C.__coerce__(self, num) C.__index__(self)g

索引等等)



八进制表示；内建oct()

十六进制表示；内建hex()

压缩成同样的数值类型；内建coerceO 在有必要时,压缩可选的数值类型为整型(比如：用于切片



![img](07Python38c3160b-1750.jpg)



续

表13.4 定制类的特殊方法(续)



序列类型



C.__len__(self)

C.__getitem__(self, ind)

C.__setitem__(self, ind,val) C.__delitem__(self, ind) 特殊方法



序列中项的数目

得到单个序列元素

设置单个序列元素

删除单个序列元素

描述



序列类型

C.__getslice__(self, ind1,ind2) C.__setslice__(self, i1, i2,val) C.__delslice__(self, ind1,ind2) C.__contains__(self, val) f C.__*add__(self,obj)

C.__*mul__(self,obj)

C.__iter__(self) e    创



得到序列片断

设置序列片断

删除序列片断

测试序列成员；内建in关键字 串连;+操作符 重复;*操作符 !迭代类；内建iter()



![img](07Python38c3160b-1751.jpg)



![img](07Python38c3160b-1752.jpg)



![img](07Python38c3160b-1753.jpg)



![img](07Python38c3160b-1754.jpg)



![img](07Python38c3160b-1755.jpg)



![img](07Python38c3160b-1756.jpg)



映射类型

C.__len__(self)

C.__hash__(self)

C.__getitem__(self,key)

C.__setitem__(self,key,val) C.__delitem__(self,key)

C.__missing__(self,key)



mapping中的项的数目

散列(hash)函数值

得到给定键(key)的值

设置给定键(key)的值 删除给定键(key)的值

给定键如果不存在字典中，则提供一个默认值

a.    Python 2.2中新引入；仅用于新式类中。

b.    Python 2.3中新引入。

c.    除了cmp()外，其余全是在Python新引入的。

d.    ""*""代表'’(selp OP obj)，’ r'(obj OP self)，或’i'(原位(in-place)操作，Py2.0 新增)，

例如    __add__, __radd__, or __iadd__.

e.    Python 2.2中新引入。

f.    “*” either nothing (self OP obj)， “r” (obj OP self )， or “i” for in-place operation (new in Python 1.6)， i.e.， __add__， __radd__， or __iadd__.

g.    Python 2.5中新引入。

基本的定制和对象(值)比较特殊方法在大多数类中都可以被实现，且没有同任何特定的类型 模型绑定。延后设置，也就是所谓的Rich比较，在Python2.1中加入。属性组帮助管理您的类的

H实例属性。这同样独立于模型。还有一个，_getattribute_()，它仅用在新式类中，我们将在后 面的章节中对它进行描述。

![img](07Python38c3160b-1757.jpg)



特殊方法中数值类型部分可以用来模拟很多数值操作，包括那些标准(一元和二进制)操作符，

类型转换，基本表示法，及压缩。也还有用来模拟序列和映射类型的特殊方法。实现这些类型的特

殊方法将会重载操作符，以使它们可以处理你的类类型的实例。

另外，除操作符__*truediv__()和__*floordiv__()在Python2.2中加入，用来支持Python除 操作符中待定的更改---可查看5.5.3节。基本上，如果解释器启用新的除法，不管是通过一个开关 来启动Python，还是通过〃from __future__ import division〃，单斜线除操作(/)表示的将是ture 除法，意思是它将总是返回一个浮点值，不管操作数是否为浮点数或者整数(复数除法保持不变)。 双斜线除操作(//)将提供大家熟悉的浮点除法，从标准编译型语言像C/C++及Java过来的工程师 一定对此非常熟悉。同样，这些方法只能处理实现了这些方法并且启用了新的除操作的类的那些符 号。

表格中，在它们的名字中，用星号通配符标注的数值二进制操作符则表示这些方法有多个版本， 在名字上有些许不同。星号可代表在字符串中没有额外的字符，或者一个简单的“r”指明是一个右 结合操作。没有“r”，操作则发生在对于self OP obj的格式；“r”的出现表明格式obj OP self。 比如，__add__(self，obj)是针对 self+obj 的调用，而__radd__(self，obj)则针对 obj+self 来调用。

![img](07Python38c3160b-1758.jpg)



增量赋值，起于Python 2.0,介绍了“原位”操作符。一个“i”代替星号的位置，表示左结合 操作与赋值的结合，相当是在self=self OP obj。举例，__iadd__（self，obj）相当于self=self+obj 的调用。



随着Python 2.2中新式类的引入，有一些更多的方法增加了重载功能。然而，在本章开始部分

提到过，我们仅关注经典类和新式类都适应的核心部分，本章的后续部分，我们介绍新式类的高级

特性。

### 13.13.1 简单定制（RoundFloat2）

我们的第一个例子很普通。在某种程度上，它基于我们前面所看到的从Python类型中派生出的 派生类RoundFloat。达个例子很简单。事实上，我们甚至不想去派生任何东西（当然，除object外）... 我们也不想采用与floats有关的所有“好东西”。不，这次，我们想创建一个苗条的例子，这样你 可以对类定制的工作方式有一个更好的理解。这种类的前提与其它类是一样的：我们只要一个类来

保存浮点数，四舍五入，保留两位小数位。

class RoundFloatManual(object):

def __init__(self， val):

![img](07Python38c3160b-1760.jpg)



assert isinstance(val， float)， \

![img](07Python38c3160b-1761.jpg)



"Value must be a float!"

self.value = round(val， 2)

这个类仅接收一个浮点值----它断言了传递给构造器的参数类型必须为一个浮点数----并且将

其保存为实例属性值。让我们来试试，创建这个类的一个实例：

\>>> rfm = RoundFloatManual(42)

Traceback (most recent call last):

File "<stdin>"， line 1， in ?

File "roundFloat2.py"， line 5， in __init__

assert isinstance(val， float)， \ AssertionError: Value must be a float!

\>>> rfm = RoundFloatManual(4.2)

\>>> rfm

<roundFloat2.RoundFloatManual object at 0x63030>

\>>> print rfm

<roundFloat2.RoundFloatManual object at 0x63030>

你已看到，它因输入非法，而“噎住”，但如果输入正确时，就没有任何输出了。可是，当把这



个对象转存在交互式解释器中时，看一下发生了什么。我们得到一些信息，却不是我们要找的。(我 们想看到数值，对吧？)调用print语句同样没有明显的帮助。



不幸的是，print (使用str())和真正的字符串对象表示(使用repr())都没能显示更多有关 我们对象的信息。一个好的办法是，去实现__str__()和__repr__()二者之一，或者两者都实现，这 样我们就能“看到”我们的对象是个什么样子了。换句话说，当你想显示你的对象，实际上是想看 到有意义的东西，而不仅仅是通常的Python对象字符串(〈object object at id〉)。让我们来添加 一个__str()__方法,以覆盖默认的行为：

def __str__(self)： return str(self.value)

现在我们得到下面的：

\>>> rfm = RoundFloatManual(5.590464)

\>>> rfm

〈roundFloat2.RoundFloatManual object at 0x5eff0>

\>>> print rfm

5.59

\>>> rfm = RoundFloatManual(5.5964)

![img](07Python38c3160b-1764.jpg)



\>>> print rfm 5.6

我们还有一些问题...一个问题是仅仅在解释器中转储(dump)对象时，仍然显示的是默认对象符 号，但这样做也算不错。如果我们想修复它，只需要覆盖_repr_()。因为字符串表示法也是Python 对象，我们可以让__repr__()和__str__()的输出一致。

为了完成这些，只要把__str__()的代码复制给__repr__()。这是一个简单的例子，所以它没有 真正对我们造成负面影响，但作为程序员，你知道那不是一个最好的办法。如果_str_()中存在bug， 那么我们会将bug也复制给__repr__ () 了。

最好的方案，在__str__()中的代码也是一个对象，同所有对象一样，引用可以指向它们，所以， 我们可以仅仅让__repr__()作为__str__()的一个别名：

__repr__ = __str__

在带参数5.5964的第二个例子中，我们看到它舍入值刚好为5.6，但我们还是想显示带两位小

数的数。来玩玩一个更好的妙计吧，看下面：

def __str__(self)：

return ’%.2f’ % self.value

![img](07Python38c3160b-1765.jpg)



这里就同时具备str()和repr()的输出了:

\>>> rfm = RoundFloatManual(5.5964)

\>>> rfm

5.60

\>>> print rfm

5.60



例 13.2 基本定制(roundFloat2.py)

1    #!/usr/bin/env python

2

3    class RoundFloatManual(object):

4    def __init__(self， val):

5    assert isinstance(val， float)， \

6    〃Value must be a float!〃

7    self.value = round(val， 2)

8

9 def __str__(self):

![img](07Python38c3160b-1767.jpg)



10    return '%.2f' % self.value

![img](07Python38c3160b-1768.jpg)



11

12 __repr__ = __str__

在本章开始部分，最初的RoundFloat例子，我们没有担心所有细致对象的显示问题；原因是 _8打_()和_代卩『_()作为float类的一部分已经为我们定义好了。我们所要做的就是去继承它们。 增强版本“手册”中需要另外的工作。你发现派生是多么的有益了吗？我们甚至不需要知道解释器 在继承树上要执行多少步才能找到一个已声明的你正在使用却没有考虑过的方法。我们将在例13.2 中列出这个类的全部代码。

现在开始一个稍复杂的例子。

### 13.13.2 数值定制(Time60)

作为第一个实际的例子，我们可以想象需要创建一个简单的应用，用来操作时间，精确到小时 和分。我们将要创建的这个类可用来跟踪职员工作时间，isp用户在线时间，数据库总的运行时间(不 包括备份及升级时的停机时间)，在扑克比赛中玩家总时间，等等。

在Time60类中，我们将整数的小时和分钟作为输入传给构造器。

class Time60(object):    # ordered pair 顺序对



def __init__(self， hr， min):    # constructor 构造器

self.hr = hr    # assign hours 给小时赋值

self.min = min    # assign minutes 给分赋值

#### 显示

同样，如前面的例子所示，在显示我们的实例的时候，我们需要一个有意义的输出，那么就要 覆盖__str__()(如果有必要的话，__repr__()也要覆盖)。我们都习惯看小时和分，用冒号分隔开的 格式，比如， “4:30”，表示四个小时，加半个小时(4个小时及30分钟)：

def __str__(self): return '%d:%d' % (self.hr， self.min)

用此类，可以实例化一些对象。在下面的例子中，我们启动一个工时表来跟踪对应构造器的计

费小时数：

\>>> mon = Time60(10， 30)

\>>> tue = Time60(11， 15)

\>>>

\>>> print mon， tue

10:30 11:15

输出不错，正是我们想看到的。下一步干什么呢？可考虑与我们的对象进行交互。比如在时间 片的应用中，有必要把Time60的实例放到一起让我们的对象执行所有有意义的操作。我们更喜欢像 这样的：

\>>> mon + tue

21:45

#### 加法

Python的重载操作符很简单。像加号(+)我们只需要重载_&44_()方法，如果合适，还可以

用__radd__()及__iadd__()。稍后有更多有关这方面的描述。实现__add__()听起来不难----只要把

分和小时加在一块。大多数复杂性源于我们怎么处理这个新的总数。如果我们想看到“21:45”，就 必须认识到这是另一个Time60对象，我们没有修改mon或tue，所以，我们的方法就应当创建另一 个对象并填入计算出来的总数。

实现__add__()特殊方法时，首先计算出个别的总数，然后调用类构造器返回一个新的对象：

def __add__(self， other):

return self.__class__(self.hr + other.hr, self.min + other.min)



和正常情况下一样，新的对象通过调用类来创建。唯一的不同点在于，在类中，你一般不直接 调用类名，而是使用self 的_class_属性，即实例化self的那个类，并调用它。由于 self. __class__与 Time60 相同，所以调用 self. __class__()与调用 Time60()是一回事。

不管怎样，这是一个更面向对象的方式。另一个原因是，如果我们在创建一个新对象时，处处 使用真实的类名，然后，决定将其改为别的名字，这时，我们就不得不非常小心地执行全局搜索并 替换。如果靠使用self._class_，就不需要做任何事情，只需要直接改为你想要的类名。

好了，我们现在来使用加号重载，“增加” Time60对象：

\>>> mon = Time60(10, 30)

\>>> tue = Time60(11, 15)

\>>> mon + tue

〈time60.Time60 object at 0x62190>

\>>> print mon + tue

21:45

![img](07Python38c3160b-1773.jpg)



哎哟，我们忘记添加一个别名__repr__给__str__了，这很容易修复。你可能会问，“当我们试 着在重载情况下使用一个操作符，却没有定义相对应的特殊方法时还有很多需要优化和重要改良的 地方，会发生什么事呢？”答案是一个TypeError异常：

![img](07Python38c3160b-1774.jpg)



![img](07Python38c3160b-1775.jpg)



\>>> mon - tue

Traceback (most recent call last): File "〈stdin>", line 1, in TypeError: unsupported operand type(s) for -: 'Time60' and 'Time60'

#### 原位加法

有了增量赋值(在Python 2.0中引入)，我们也许还有希望覆盖“原位”操作，比如，_iadd_()。 这是用来支持像mon += tue这样的操作符，并把正确的结果赋给mon。重载一个__i*__()方法的唯 一秘密是它必须返回self。把下面的片断加到我们例子中，以修复上面的repr()问题，并支持增量 赋值：

__repr__ = __str__

def __iadd__(self, other):

self.hr += other.hr

self.min += other.min

return self



![img](07Python38c3160b-1777.jpg)



![img](07Python38c3160b-1778.jpg)



![img](07Python38c3160b-1779.jpg)



![img](07Python38c3160b-1780.jpg)



![img](07Python38c3160b-1781.jpg)



下面是结果输出：

\>>> mon =Time60(10，30) >>> tue =Time60(11，15)

\>>> mon

10:30

\>>> id(mon)

401872

\>>> mon += tue >>> id(mon)

401872

\>>> mon

21:45

注意，使用id()内建函数是用来确定一下，在原位加的前后，我们确实是修改了原来的对象， 而没有创建一个新的对象。对一个具有巨大潜能的类来说，这是很好的开始。在例 13.3中给出了 Time60的类的完全定义

例13.3中级定制(time60.py)

![img](07Python38c3160b-1782.jpg)



![img](07Python38c3160b-1783.jpg)



1 #!/usr/bin/env python 2

3    class Time60(object):

4    'Time60 - track hours and minutes'

5

6    def __init__(self， hr， min):

7    'Time60 constructor - takes hours and minutes'

8    self.hr = hr

9    self.min = min

10

11    def __str__(self):

12    'Time60 - string representation'

13    return '%d:%d' % (self.hr， self.min)

14

15    __repr__ = __str__

16

17    def __add__(self， other):

18    'Time60 - overloading the addition operator'

19    return self.__class__(self.hr + other.hr，self.min + other.min)

![img](07Python38c3160b-1784.jpg)



![img](07Python38c3160b-1785.jpg)



21

22    def __iadd__(self， other):

23    'Time60 - overloading in-place addition

24    self.hr += other.hr

25    self.min += other.min

26    return self

例13.4随机序列迭代器(randSeq.py)

1    #!/usr/bin/env python

2

3    from random import choice

4

5    class RandSeq(object):

6    def __init__(self， seq):

7    self.data = seq

8

9    def __iter__(self):

10    return self

![img](07Python38c3160b-1786.jpg)



11

12    def next(self):

13    return choice(self.data)

#### 升华

现在暂不管它了，但在这个类中，还有很多需要优化和改良的地方。比如，如果我们不传入两

个分离的参数，而传入一个2值元组给构造器作为参数，是不是更好些呢？如果是像“10:30”这样

的字符串的话，结果会怎样？

答案是肯定的，你可以这样做，在Python中很容易做到，但不是像很多其他面向对象语言一样 通过重载构造器来实现.Python不允许用多个签名重载可调用对象.所以实现这个功能的唯一的方式 是使用单一的构造器，并由isinstanceO和（可能的）type（）内建函数执行自省功能。

能支持多种形式的输入，能够执行其它操作像减法等，可以让我们的应用更健壮，灵活。当然 这些是可选的，就像“蛋糕上的冰”，但我们首先应该担心的是两个中等程度的缺点：1.当比十分钟 还少时，格式并不是我们所希望的，2. 不支持60进制（基数60）的操作：

\>>> wed = Time60(12， 5)

\>>> wed

12:5



\>>> thu = Time60(10, 30) >>> fri = Time60(8, 45) >>> thu + fri 18:75

1.源自拉丁语的基数是60的名字；有时，六十进制会被用到，这是一种希腊词根“hexe”和拉 丁 “gesmal” 的混合。

显示wed结果是“12:05”，把thu和fri加起来结果会是“19:15”。修改这些缺陷，实现上面 的改进建议可以实际性地提高你编写定制类技能。这方面的更新，更详细的描述在本章的练习13.20 中。

我们希望，你现在对于操作符重载，为什么要使用操作符重载，以及如何使用特殊方法来实现

它已有了一个更好的理解了。接下来为选看章节内容，让我们来了解更多复杂的类定制的情况。

Edit By Vheavens

### 13.13.3 迭代器(RandSeq 和 Anylter)

#### RandSeq

我们正式介绍迭代器是在第8章，但在全书中都在用它。它可以一次一个的遍历序列(或者是 类似序列对象)中的项。在第8章中，我们描述了如何利用一个类中的_iter_()和next()方法， 来创建一个迭代器。我们在此展示两个例子。

第一个例子是RandSeq(RANDom SEQuence的缩写)。我们给我们的类传入一个初始序列，然后 让用户通过next()去迭代(无穷)。

__init__0方法执行前述的赋值操作。__iter__()仅返回self，这就是如何将一个对象声明为 迭代器的方式，最后，调用next()来得到迭代器中连续的值。这个迭代器唯一的亮点是它没有终点。

这个例子展示了一些我们可以用定制类迭代器来做的与众不同的事情。一个是无穷迭代。因为 我们无损地读取一个序列，所以它是不会越界的。每次用户调用next()时，它会得到下一个迭代值， 但我们的对象永远不会引发Stoplteration异常。我们来运行它，将会看到下面的输出：

\>>> from randseq import RandSeq >>> for eachItem in RandSeq(

... ('rock', 'paper', 'scissors')):

... print eachItem

scissors

![img](07Python38c3160b-1790.jpg)



scissors

rock

paper

paper

scissors

例13.5任意项的迭代器(anylter.py)

1    #!/usr/bin/env python

2

3    class AnyIter(object):

4    def __init__(self, data, safe=False):

5    self.safe = safe

6    self.iter = iter(data)

7

8    def __iter__(self):

9    return self

![img](07Python38c3160b-1791.jpg)



10

def next(self, howmany=1): retval = []

for eachItem in range(howmany):

try:

retval.append(self.iter.next())

except StopIteration:

if self.safe: break

else:

raise

return retval



![img](07Python38c3160b-1792.jpg)



11

12

13

14

15

16 17 18 19 20 21

#### AnyIter

在第二个例子中，我们的确创建了一个迭代器对象，我们传给next()方法一个参数，控制返回 条目的数目，而不是去一次一个地迭代每个项。下面是我们的代码(ANY number of items ITERator)：

和RandSeq类的代码一样，类Anylter很容易领会。我们在上面描述了基本的操作...它同其它 迭代器一样工作，只是用户可以请求一次返回N个迭代的项，而不仅是一个项。

我们给出一个迭代器和一个安全标识符(safe)来创建这个对象。如果这个标识符(safe)为真



(True)，我们将在遍历完这个迭代器前，返回所获取的任意条目，但如果这个标识符为假(False)， 则在用户请求过多条目时，将会引发一个异常。错综复杂的核心在于next()特别是它如何退出的 (14-21行) 。

在next()的最后一部分中，我们创建用于返回的一个列表项，并且调用对象的next()方法来获 得每一项条目。如果我们遍历完列表，得到一个StopIteration异常，这时则检查安全标识符(safe)。 如果不安全(即，self.safe=False)，则将异常抛还给调用者(raise);否则，退出(break)并返回 (return)已经保存过的所有项。

\>>> a = AnyIter(range(10))

\>>> i = iter(a)

\>>> for j in range(1，5):

\>>> print j， ':'， i.next(j)

1 : [0]

2 : [1， 2]

3    : [3， 4， 5]

4    : [6， 7， 8， 9]

上面程序的运行没有问题，因为迭代器正好符合项的个数。当情况出现偏差，会发生什么呢？ 让我们首先试试“不安全(unsafe)”的模式，这也就是紧随其后创建我们的迭代器：

\>>> i = iter(a)

\>>> i.next(14)

Traceback (most recent call last):

File "<stdin>"， line 1， in ?

File "anyIter.py"， line 15， in next retval.append(self.iter.next())

StopIteration

因为超出了项的支持量，所以出现了 StopIteration异常，并且这个异常还被重新引发回调用 者(第20行)。如果我们使用“安全(safe)”模式重建迭代器，再次运行一次同一个例子的话，我 们就可以在项失控出现前得到迭代器所得到的元素：

\>>> a = AnyIter(range(10)， True)

\>>> i = iter(a)

\>>> i.next(14)

[0， 1， 2， 3， 4， 5， 6， 7， 8， 9]

### 13.13.4 *多类型定制(NumStr)

现在创建另一个新类，NumStr，由一个数字-字符对组成，相应地，记为n和s，数值类型使用 整型（integer）。尽管这组顺序对的“合适的”记号是（n,s），但我们选用［n::s］来表示它，有点 不同。暂不管记号，这两个数据元素只要我们模型考虑好了，就是一个整体。可以创建我们的新类 了，叫做NumStr，有下面的特征：

#### 初始化

类应当对数字和字符串进行初始化；如果其中一个（或两）没有初始化，则使用0和空字符串， 也就是，。=0且8=’’，作为默认。

#### 加法

我们定义加法操作符，功能是把数字加起来，把字符连在一起；要点部分是字符串要按顺序相 连。比如，NumStr1=［n1::s1］且 NumStr2=［n2::s2］。则 NumStr1+NumStr2 表示［n1+n2::s1+s2］， 其中，＋代表数字相加及字符相连接。

#### 乘法

类似的，定义乘法操作符的功能为，数字相乘，字符累积相连，也就是， NumStr1*NumStr2=［n1*n::s1*n］。

#### False 值

当数字的数值为0且字符串为空时，也就是当NumStr=［0::’’］时，这个实体即有一个false值。

#### 比较

比较一对NumStr对象，比如，［n1::s1］ vs. ［n2::s2］，我们可以发现九种不同的组合（即，n1>n2 and s1<s2, n1 = =n2 and s1〉s2，等等）。对数字和字符串，我们一般按照标准的数值和字典顺 序的进行比较，即，如果obj1<obj2，普通比较cmp（obj1,obj2）的返回值是一个小于0的整数，当 obj1>obj2时，比较的返回值大于0，当两个对象有相同的值时，比较的返回值等于0。

我们的类的解决方案是把这些值相加，然后返回结果。有趣的是cmp（）不会总是返回-1,0,或 1。上面提到过，它是一个小于，等于或大于0的整数。

为了能够正确的比较对象，我们需要让_cmp__（）在（n1>n2）且（s1>s2）时，返回1，在（n1〈n2） 且（s1〈s2）时，返回-1,而当数值和字符串都一样时，或是两个比较的结果正相反时（即（n1〈n2）且 （s1>s2），或相反），返回0.反之亦然。

例13.6多类型类定制（numstr.py）

![img](07Python38c3160b-1798.jpg)



![img](07Python38c3160b-1799.jpg)



9    def

10 11 12

13

14

15

16 17

18

19

20

21

22

23

24

25

26 27 28 29

30

31

32

33

34

35

36



1    #!/usr/bin/env python

2

3    class NumStr(object):

4

5    def __init__(self, num=0, string=''):

6    self.__num = num

7    self.__string = string

8



__str__(self): # define for str() return '[%d :: %r]' % \ self.__num, self.__string)

__repr__ = __str__

def __add__(self, other): # define for s+o if isinstance(other, NumStr):

return self.__class__(self.__num + \ other.__num, \

self.__string + other.__string)

else:

raise TypeError, \

'Illegal argument type for built-in operation'

def __mul__(self, num): # define for o*n if isinstance(num, int):

return self.__class__(self.__num * num self.__string * num)

else:

raise TypeError, \

'Illegal argument type for built-in operation

def __nonzero__(self): # False if both are return self.__num or len(self.__string)

def __norm_cval(self, cmpres):# normalize cmp() return cmp(cmpres, 0)

![img](07Python38c3160b-1800.jpg)



37    def __cmp__(self, other): # define for cmp()

38    return self.__norm_cval(

39    cmp(self.__num, other.__num)) + \

![img](07Python38c3160b-1801.jpg)



40

41

self.__norm_cval(

cmp(self.__string， other.__string))



根据上面的特征，我们列出numstr.py的代码，执行一些例子:

\>>> a = NumStr(3， 'foo')

\>>> b = NumStr(3， 'goo')

\>>> c = NumStr(2， 'foo')

\>>> d = NumStr()

\>>> e = NumStr(string='boo')

\>>> f = NumStr(1)

\>>> a

[3 :: 'foo'] >>> b

[3 :: 'goo']

\>>> c

[2 :: 'foo']

![img](07Python38c3160b-1803.jpg)



\>>> d

![img](07Python38c3160b-1804.jpg)



[0 :: '']

\>>> e

[0 :: 'boo']

\>>> f

[1 :: '']

\>>> a < b

True

\>>> b < c

False

\>>> a == a

True

\>>> b * 2

[6 :: 'googoo']

\>>> a * 3

[9 :: 'foofoofoo']

\>>> b + e

[3 :: 'gooboo']

\>>> e + b

[3 :: 'boogoo']

\>>> if d: 'not false' # also bool(d)

![img](07Python38c3160b-1805.jpg)



\>>> if e: 'not false' # also bool(e)

'not false'

\>>> cmp(a,b) -1

\>>> cmp(a,c) 1

\>>> cmp(a,a) 0

逐行解释

#### 第1-7行

脚本的开始部分为构造器_init_()，通过调用NumStrO时传入的值来设置实例，完成自身初 始化。如果有参数缺失，属性则使用false值，即默认的0或空字符，这取决于参数情况。

一个重要怪癖是命名属性时，双下划线的使用。我们在下一节中会看到，这是在信息隐藏时，

强加一个级别，尽管不够成熟。程序员导入一个模块时，就不能直接访问到这些数据元素。我们正

试着执行一种OO设计中的封装特性，只有通过存取函数才能访问。如果这种语法让你感觉有点怪 异，不舒服的话，你可以从实例属性中删除所有双下划线，程序同样可以良好地运行。

所有的由双下划线(_)开始的属性都被“混淆”(mangled)了，导致这些名字在程序运行时 很难被访问到。但是它们并没有用一种难于被逆向工程的方法来“混淆”。事实上，“混淆”属性的 方式已众所周知，很容易被发现。这里主要是为了防止这些属性在被外部模块导入时，由于被意外 使用而造成的名字冲突。我们将名字改成含有类名的新标志符，这样做，可以确保这些属性不会被 无意“访问”。更多信息，请参见13.14节中关于私有成员的内容。

#### 第9-12行

我们把顺序对的字符串表示形式确定为“[num::’str’]”，这样不论我们的实例用str()还是包 含在print语句中时候，我们都可以用_8灶_()来提供这种表示方式。我们想强调一点，第二个元 素是一个字符串，如果用户看到由引号标记的字符串时，会更加直观。要做到这点，我们使用“reprO” 表示法对代码进行转换，把“％s”替换成“％r”。这相当于调用repr()或者使用单反引号来给出字符 串的可求值版本--可求值版本的确要有引号：

\>>> print a

[3 :: ’foo’]

如果在self.__string中没有调用repr()(去掉单反引号或使用“％s”)将导致字符串引号丢

失：

return ’[%d :: %s]’ % (self.__num, self.__string)

现在对实例再次调用print，结果: >>> print a

[3 :: foo]



没有引号，看起来会如何呢？不能信服“foo”是一个字符串，对吧？它看起来更像一个变量。 连作者可能也不能确定。(我们快点悄悄回到这一变化之前，假装从来没看到这个内容。)

代码中__str__()函数后的第一行是把这个函数赋给另一个特殊方法名，__repr__。我们决定我 们的实例的一个可求值的字符串表示应当与可打印字符串表示是一样的。而不是去定义一个完整的 新函数，成为__str__()的副本，我们仅去创建一个别名，复制其引用。当你实现__str__()后，一 旦使用那个对象作为参数来应用内建str()函数，解释器就会调用这段代码.对_代口『_()及repr()

也一样。

如果不去实现_repr_()我们的结果会有什么不同呢？如果赋值被取消，只有调用str()的 print语句才会显示对象的内容。而可求值字符串表示恢复成默认的Python标准形式 <...some_object_ information...>

\>>> print a # calls str(a)

![img](07Python38c3160b-1809.jpg)



[3 :: 'foo']

![img](07Python38c3160b-1810.jpg)



\>>> a # calls repr(a) <NumStr.NumStr instance at 122640>

#### 第14-21行

我们想加到我们的类中的一个特征就是加法操作，前面已提到过。Python用于定制类的特征之 一是，我们可以重载操作符，以使定制的这些类型更“实用”。调用一个函数，像“add(obj1，obj2)” 是为“add”对象obj1和ojb2,这看起来好像加法，但如果能使用加号(+)来调用相同的操作是不是 更具竞争力呢？像这样，obj1+obj2。

重载加号，需要去为self(SELF)和其它操作数实现(OTHER)_add_()._add_()函数考虑 Self+Other的情况，但我们不需要定义__radd__()来处理Other+Self，因为这可以由Other的 __add__()去考虑。数值加法不像字符串那样结果受到(操作数)顺序的影响.

加法操作把两个部分中的每一部分加起来，并用这个结果对形成一个新的对象----通过将结果

做为参数调用self._class_()来实例化(同样，在前面已解释过).碰到任何类型不正确的对象时， 我们会引发一个TypeError异常.

#### 第23-29行

我们也可以重载星号[靠实现__mul__()]，执行数值乘法和字符串重复，并同样通过实例化来创 建一个新的对象。因为重复只允许整数在操作数的右边，因此也必执行此规则。基于同样的原因， 我们在此也没有实现__rmul__()。

![img](07Python38c3160b-1812.jpg)



![img](07Python38c3160b-1813.jpg)



![img](07Python38c3160b-1814.jpg)



![img](07Python38c3160b-1815.jpg)



![img](07Python38c3160b-1816.jpg)



#### 第31-32行

Python对象任何时候都有一个Boolean值。对标准类型而言，对象有一个false值的情况为： 它是一个类似于0的数值，或是一个空序列，或者映射。就我们的类而言，我们选择数值必须为0， 字符串要为空 作为一个实例有一个 false 值的条件。覆盖__nonzero__()方法，就是为此目的。其 它对象，像严格模拟序列或映射类型的对象，使用一个长度为0作为false值。这些情况，你需要 实现__len__()方法，以实现那个功能。

#### 第34-41行

__norm_cval() (“normalize cmp() value的缩写”)不是一个特殊方法。它是一个帮助我们 重载_cmp_()的助手函数:唯一的目的就是把cmp()返回的正值转为1，负值转为-kcmp()基于比 较的结果，通常返回任意的正数或负数(或0)，但为了我们的目的，需要严格规定返回值为-1，0和1。 对整数调用cmp()及与0比较，结果即是我们所需要的，相当于如下代码片断：

def __norm_cval(self， cmpres): if cmpres 〈 0:

return -1

elif cmpres > 0:

![img](07Python38c3160b-1817.jpg)



return 1

![img](07Python38c3160b-1818.jpg)



else:

return 0

两个相似对象的实际比较是比较数字，比较字符串，然后返回这两个比较结果的和。

### 13.14 私有化

默认情况下，属性在Python中都是“public”，类所在模块和导入了类所在模块的其他模块的 代码都可以访问到。很多00语言给数据加上一些可见性，只提供访问函数来访问其值。这就是熟知 的实现隐藏，是对象封装中的一个关键部分。

大多数00语言提供“访问控制符”来限定成员函数的访问。

#### 双下划线(__)

Python为类元素(属性和方法)的私有性提供初步的形式。由双下划线开始的属性在运行时被 “混淆”，所以直接访问是不允许的。实际上，会在名字前面加上下划线和类名。比如，以例 13.6(numstr.py)中的self.__num属性为例，被“混淆”后，用于访问这个数据值的标识就变成了 self._NumStr__num。把类名加上后形成的新的“混淆”结果将可以防止在祖先类或子孙类中的同名

冲突。

尽管这样做提供了某种层次上的私有化，但算法处于公共域中并且很容易被“击败”。这更多的



是一种对导入源代码无法获得的模块或对同一模块中的其他代码的保护机制.

这种名字混淆的另一个目的,是为了保护__XXX 变量不与父类名字空间相冲突。如果在类中有一 f__XXX属性，它将不会被其子类中的__XXX属性覆盖。(回忆一下，如果父类仅有一个XXX属性， 子类也定义了这个，这时，子类的XXX就是覆盖了父类的XXX，这就是为什么你必须使用PARENT.XXX 来调用父类的同名方法。)使用__XXX，子类的代码就可以安全地使用_乂乂乂，而不必担心它会影响 到父类中的__XXX。

单下划线(_)

与我们在第十二章发现的那样，简单的模块级私有化只需要在属性名前使用一个单下划线字符。 这就防止模块的属性用“from mymodule import *”来加载。这是严格基于作用域的，所以这同样 适合于函数。

在Python 2.2中引进的新式类，增加了一套全新的特征，让程序员在类及实例属性提供保护 的多少上拥有大量重要的控制权。尽管 Python 没有在语法上把 private,protected,friend 或 protected friend等特征内建于语言中，但是可以按你的需要严格地定制访问权。我们不可能涵盖 所有的内容，但会在本章后面给你一些有关新式类属性访问的建议。

### 13.15 *授权

### 13.15.1 包装

“包装”在Python编程世界中经常会被提到的一个术语。它是一个通用的名字，意思是对一 个已存在的对象进行包装，不管它是数据类型，还是一段代码，可以是对一个已存在的对象，增加 新的，删除不要的，或者修改其它已存在的功能。

在Python 2.2版本前，从Python标准类型子类化或派生类都是不允许的。即使你现在可以对 新式类这样做，这一观念仍然很流行。你可以包装任何类型作为一个类的核心成员，以使新对象的 行为模仿你想要的数据类型中已存在的行为，并且去掉你不希望存在的行为；它可能会要做一些额 外的事情。这就是“包装类型”。在附录中，我们还将讨论如何扩充Python，包装的另一种形式。

包装包括定义一个类，它的实例拥有标准类型的核心行为。换句话说，它现在不仅能唱能跳，

还能够像原类型一样步行，说话。图15-4举例说明了在类中包装的类型看起像个什么样子。在图的

中心为标准类型的核心行为，但它也通过新的或最新的功能，甚至可能通过访问实际数据的不同方

法得到提高。

类对象(其表现像类型)

你还可以包装类，但这不会有太多的用途，因为已经有用于操作对象的机制，并且在上面已描

述过，对标准类型有对其进行包装的方式。你如何操作一个已存的类，模拟你需要的行为，删除你

不喜欢的，并且可能让类表现出与原类不同的行为呢？我们前面已讨论过，就是采用派生。

| Customization Wrapper |                |      |
| --------------------- | -------------- | ---- |
|                       | S tandard Type |      |
|                       |                |      |

图13-4 包装类型

### 13.15.2 实现授权

授权是包装的一个特性，可用于简化处理有关dictating功能，采用已存在的功能以达到最大 限度的代码重用。

包装一个类型通常是对已存在的类型的一些定制。我们在前面提到过，这种做法可以新建，修

改或删除原有产品的功能。其它的则保持原样，或者保留已存功能和行为。授权的过程，即是所有

更新的功能都是由新类的某部分来处理，但已存在的功能就授权给对象的默认属性。

实现授权的关键点就是覆盖__getattr__0方法，在代码中包含一个对getattrO内建函数的调 用。特别地，调用getattrO以得到默认对象属性(数据属性或者方法)并返回它以便访问或调用。 特殊方法__getattr__()的工作方式是，当搜索一个属性时，任何局部对象首先被找到(定制的对象)。 如果搜索失败了，则_getattr_()会被调用，然后调用getattrO得到一个对象的默认行为。

换言之，当引用一个属性时，Python解释器将试着在局部名称空间中查找那个名字，比如一个 自定义的方法或局部实例属性。如果没有在局部字典中找到，则搜索类名称空间，以防一个类属性 被访问。最后，如果两类搜索都失败了，搜索则对原对象开始授权请求，此时，__getattr__()会被 调用。

#### 包装对象的简例

看一个例子。这个类已乎可以包装任何对象，提供基本功能，比如使用repr()和str()来处理

字符串表示法。另外定制由get()方法处理，它删除包装并且返回原始对象。所以保留的功能都授权 给对象的本地属性，在必要时，可由__getattr__()获得。

下面是包装类的例子：

class WrapMe(object): def __init__(self， obj):

self.__data = obj def get(self):

return self.__data def __repr__(self):

return ‘self.__data‘ def __str__(self):

return str(self.__data) def __getattr__(self， attr):

return getattr(self.__data， attr)

在第一个例子中，我们将用到复数，因为所有Python数值类型，只有复数拥有属性：数据属性，

及conjugate()内建方法(求共轭复数，译者注！)。记住，属性可以是数据属性，还可以是函数或 万法：    L

\>>> wrappedComplex 二 WrapMe(3. 5+4. 2j)

\>>> wrappedComplex # wrapped object: repr()包装的对象：repr()

(3.5+4.2j)

\>>> wrappedComplex.real # real attribute 实部属性

3.5

\>>> wrappedComplex.imag # imaginary attribute 虚部属性

42.2

\>>> wrappedComplex. conjugate()    # conjugateQ method conjugateQ万法

(3.5-4.2j)

\>>> wrappedComplex.get() # actual object 实际对象

(3.5+4.2j)

一旦我们创建了包装的对象类型，只要由交互解释器调用repr()，就可以得到一个字符串表示。 然后我们继续访问了复数的三种属性，我们的类中一种都没有定义。在例子中，寻找实部，虚部及 共轭复数的定义...they are not there!

对这些属性的访问，是通过getattr()方法，授权给对象.最终调用get()方法没有授权，因为 它是为我们的对象定义的----它返回包装的真实的数据对象。

下一个使用我们的包装类的例子用到一个列表。我们将会创建对象，然后执行多种操作，每次

授权给列表方法。

\>>> wrappedList = WrapMe([123, ’foo’, 45.67])

\>>> wrappedList.append(’bar’)

\>>> wrappedList.append(123)

\>>> wrappedList

[123, ’foo’, 45.67, ’bar’, 123]

\>>> wrappedList.index(45.67)

2

\>>> wrappedList.count(123)

2

\>>> wrappedList.pop()

123

\>>> wrappedList [123, ’foo’, 45.67, ’bar’]

注意，尽管我们正在我们的例子中使用实例，它们展示的行为与它们包装的数据类型非常相似。 然后，需要明白，只有已存在的属性是在此代码中授权的。

特殊行为没有在类型的方法列表中，不能被访问，因为它们不是属性。一个例子是，对列表的 切片操作，它是内建于类型中的，而不是像appendO方法那样作为属性存在的。从另一个角度来说， 切片操作符是序列类型的一部分，并不是通过__getitem__()特殊方法来实现的。

\>>> wrappedList[3]

Traceback (innermost last): File "<stdin>"， line 1， in ?

File "wrapme.py"， line 21， in __getattr__

return getattr(self.data， attr)

AttributeError: __getitem__

AttributeError异常出现的原因是切片操作调用了_getitem_()方法，且_getitme_()没有 作为一个类实例方法进行定义，也不是列表对象的方法。回忆一下，什么时候调用getattr()呢？当 在实例或类字典中的完整搜索失败后，就调用它来查找一个成功的匹配。你在上面可以看到，对 getattr()的调用就是失败的那个，触发了异常。

然而，我们还有一种〃作弊〃的方法，访问实际对象[通过我们的get()方法]和它的切片能力.

\>>> realList = wrappedList.get() >>> realList[3]

’bar’

![img](07Python38c3160b-1828.jpg)



![img](07Python38c3160b-1829.jpg)



![img](07Python38c3160b-1830.jpg)



![img](07Python38c3160b-1831.jpg)



![img](07Python38c3160b-1832.jpg)



你现在可能知道为什么我们实现get()方法了----仅仅是为了我们需要取得对原对象进行访问 这种情况，我们可以从访问调用中直接访问对象的属性，而忽略局部变量(realList):

\>>> wrappedList.get()[3]

'bar'

get()方法返回一个对象，随后被索引以得到切片片断。

\>>> f = WrapMe(open('/etc/motd'))

\>>> f

<wrapMe.WrapMe object at 0x40215dac>

\>>> f.get()

<open file '/etc/motd', mode 'r' at 0x40204ca0> >>> f.readline()

'Have a lot of fun...\012'

\>>> f.tell()

21

\>>> f.seek(0)

\>>> print f.readline(),

![img](07Python38c3160b-1833.jpg)



Have a lot of fun...

\>>> f.close()

\>>> f.get()

<closed file '/etc/motd', mode 'r' at 0x40204ca0>

一旦你熟悉了对象的属性，你就能够开始理解一些信息片断从何而来，能够利用新得到的知识

来重复功能：

\>>> print "<%s file %s, mode %s at %x>" % \

... (f.closed and 'closed' or 'open', 'f.name',

'f.mode', id(f.get()))

<closed file '/etc/motd', mode 'r' at 80e95e0>

这总结了我们的简单包装类的例子。我们还刚开始接触使用类型模拟来进行类自定义。你将会 发现你可以进行无限多的改进，来进一步增加你的代码的用途。一种改进方法是为对象添加时间戳。 在下一小节中，我们将对我们的包装类增加另一个维度(dimension):

#### 更新简单的包裹类

创建时间，修改时间，及访问时间是文件的几个常见属性，但没人说,你不能为对象加上这类信

息。毕竟，一些应用能因有这些额外信息而受益。



![img](07Python38c3160b-1835.jpg)



![img](07Python38c3160b-1836.jpg)



![img](07Python38c3160b-1837.jpg)



![img](07Python38c3160b-1838.jpg)



![img](07Python38c3160b-1839.jpg)



如果你对使用这三类时间顺序(chronological)数据还不熟，我们将会对它们进行解释。创建时 间(或’ctime’)是实例化的时间，修改时间(或’mtime’)指的是核心数据升级的时间［通常会调 用新的set()方法］，而访问时间(或’atime’)是最后一次对象的数据值被获取或者属性被访问时的 时间戳。

更新我们前面定义的类，可以创建一个模块twrapme.py，看例13.7。

如何更新这些代码呢？好，首先，你将会发现增加了三个新方法：gettimeval()，gettimestr()， 及set()。我们还增加数行代码，根据所执行的访问类型，更新相应的时间戳。

例13.7包装标准类型(twrapme.py)

类定义包装了任何内建类型，增加时间属性；get()，set()，还有字符串表示的方法；并授权 所有保留的属性，访问这些标准类型。

1    #!/usr/bin/env python

2

3    from time import time， ctime

![img](07Python38c3160b-1840.jpg)



4

5    class TimedWrapMe(object):

6

23

24    def gettimestr(self， t_type):



| 7    | def __init__(self， obj):         |                         |
| ---- | --------------------------------- | ----------------------- |
| 8    | self.__data 二 obj                |                         |
| 9    | self.__ctime 二 self.__mtime 二 \ |                         |
| 10   | self.__atime 二 time()            |                         |
| 11   |                                   |                         |
| 12   | def get(self):                    |                         |
| 13   | self.__atime 二 time()            |                         |
| 14   | return self.__data                |                         |
| 15   |                                   |                         |
| 16   | def gettimeval(self， t_type):    |                         |
| 17   | if not isinstance(t_type， str)   | or \                    |
| 18   | t_type[0] not in ’cma’:           |                         |
| 19   | raise TypeError， \               |                         |
| 20   | "argument of ’c’， ’m’，          | ， ， ，1"or ’a’ req’d" |
| 21   | return getattr(self， ’_%s__      | %stime’ % \             |
| 22   | (self.__class__.__name_           | _， t_type[0]))         |

| 25   | return ctime(self.gettimeval(t_type))   |
| ---- | --------------------------------------- |
| 26   |                                         |
| 27   | def set(self, obj):                     |
| 28   | self.__data = obj                       |
| 29   | self.__mtime = self.__atime = time()    |
| 30   |                                         |
| 31   | def __repr__(self): # repr()            |
| 32   | self.__atime = time()                   |
| 33   | return ‘self.__data‘                    |
| 34   |                                         |
| 35   | def __str__(self): # str()              |
| 36   | self.__atime = time()                   |
| 37   | return str(self.__data)                 |
| 38   |                                         |
| 39   | def __getattr__(self, attr): # delegate |
| 40   | self.__atime = time()                   |
| 41   | return getattr(self.__data, attr)       |

![img](07Python38c3160b-1842.jpg)



![img](07Python38c3160b-1843.jpg)



gettimevalO方法带一个简单的字符参数，“c”，“m”或“a”，相应地，对应于创建，修改或 访问时间，并返回相应的时间，以一个浮点值保存。gettimestrO仅仅返回一个经time.ctimeO 函数格式化的打印良好的字符串形式的时间。

![img](07Python38c3160b-1844.jpg)



![img](07Python38c3160b-1845.jpg)



为新的模块作一个测试驱动。我们已看到授权是如何工作的，所以，我们将包装没有属性的对

象，来突出刚加入的新的功能。在例子中，我们包装了一个整数，然后，将其改为字符串。

\>>> timeWrappedObj = TimedWrapMe(932) >>> timeWrappedObj.gettimestr('c') ‘Wed Apr 26 20:47:41 2006'

\>>> timeWrappedObj.gettimestr('m') 'Wed Apr 26 20:47:41 2006'

\>>> timeWrappedObj.gettimestr('a') 'Wed Apr 26 20:47:41 2006'

\>>> timeWrappedObj

932

\>>> timeWrappedObj.gettimestr('c') 'Wed Apr 26 20:47:41 2006'

\>>> timeWrappedObj.gettimestr('m') 'Wed Apr 26 20:47:41 2006'

\>>> timeWrappedObj.gettimestr('a') 'Wed Apr 26 20:48:05 2006'

![img](07Python38c3160b-1846.jpg)



![img](07Python38c3160b-1847.jpg)



![img](07Python38c3160b-1848.jpg)



![img](07Python38c3160b-1849.jpg)



![img](07Python38c3160b-1850.jpg)



![img](07Python38c3160b-1851.jpg)



你将注意到，一个对象在第一次被包装时，创建，修改，及最后一次访问时间都是一样的。一 旦对象被访问，访问时间即被更新，但其它的没有动。如果使用set()来置换对象，则修改和最后一 次访问时间会被更新。例子中，最后是对对象的读访问操作。

\>>> timeWrappedObj.set('time is up!') >>> timeWrappedObj.gettimestr('m') 'Wed Apr 26 20:48:35 2006'

\>>> timeWrappedObj

'time is up!'

\>>> timeWrappedObj.gettimestr('c') 'Wed Apr 26 20:47:41 2006'

\>>> timeWrappedObj.gettimestr('m') 'Wed Apr 26 20:48:35 2006'

\>>> timeWrappedObj.gettimestr('a') 'Wed Apr 26 20:48:46 2006'

#### 改进包装一个特殊对象

下一个例子，描述了一个包装文件对象的类。我们的类与一般带一个异常的文件对象行为完全 H 一样：在写模式中，字符串只有全部为大写时，才写入文件。

这里，我们要解决的问题是，当你正在写一个文本文件，其数据将会被一台旧电脑读取。很多

老式机器在处理时，严格要求大写字母，所以，我们要实现一个文件对象，其中所有写入文件的文

本会自动转化为大写，程序员就不必担心了。

事实上，唯一值得注意的不同点是并不使用open()内建函数，而是调用CapOpen类时行初始化。 尽管，参数同open()完全一样。

例13.8展示那段代码，文件名是capOpen.py。下面看一下例子中是如何使用这个类的：

\>>> f = CapOpen('/tmp/xxx'， 'w')

\>>> f.write('delegation example\n')

\>>> f.write('faye is good\n')

\>>> f.write('at delegating\n')

\>>> f.close()

\>>> f

<closed file '/tmp/xxx'， mode 'w' at 12c230>

例13.8包装文件对象(capOpen.py)



![img](07Python38c3160b-1853.jpg)



![img](07Python38c3160b-1854.jpg)



![img](07Python38c3160b-1855.jpg)



![img](07Python38c3160b-1856.jpg)



![img](07Python38c3160b-1857.jpg)



这个类扩充了Python FAQs中的一个例子，提供一个文件类对象，定制write()方法，同时，给 文件对象授权其它的功能。

1    #!/usr/bin/env python

2

3    class CapOpen(object):

4    def —init__ (self fn, mode二r’ buf=~l):

5    self.file 二 open(fn, mode, buf)

6

7    def __str__(self):

8    return str(self.file)

9

10    def __repr__(self):

11    return ’self.file’

12

13    def write(self, line):

14    self.file.write(line.upper())

15

![img](07Python38c3160b-1858.jpg)



16    def __getattr__(self, attr):

17    return getattr(self.file, attr)

可以看到，唯一不同的是第一次对CapOpen()的调用，而不是open()。如果你正与一个实际文 件对象，而非行为像文件对象的类实例进行交互，那么其它所有代码与你本该做的是一样的。除了 write()，所有属性都已授权给文件对象。为了确定代码是否正确，我们加载文件，并显示其内容。

(注：可以使用open()或CapOpen()，这里因在本例中用到，所以选用CapOpen()。)

\>>> f 二 CapOpen(’/tmp/xxx’, ’r’)

\>>> for eachLine in f:

... print eachLine,

DELEGATION EXAMPLE FAYE IS GOOD

AT DELEGATING

Edit By Vheavens

### 13.16 新式类的高级特性 (Python 2.2+)

### 13.16.1 新式类的通用特性

我们已提讨论过有关新式类的一些特性。由于类型和类的统一，这些特性中最重要的是能够子 类化Python数据类型。其中一个副作用是，所有的Python内建的“casting”或转换函数现在都

![img](07Python38c3160b-1859.jpg)



是工厂函数。当这些函数被调用时，你实际上是对相应的类型进行实例化。



下面的内建函数，跟随Python多日，都已‘‘悄悄地”(也许没有)转化为工厂函数:

•    int(), long(), float(), complex()

•    str(), unicode()

•    list(), tuple()

•    type()

还有，加入了一些新的函数来管理这些“散兵游勇”:

•    basestring()1

•    dict()

•    bool()

•    set(),2 frozenset()2

•    object()

•    classmethod()

•    staticmethod()

•    super()

•    property()

•    file()

![img](07Python38c3160b-1861.jpg)



这些类名及工厂函数使用起来，很灵活。不仅能够创建这些类型的新对象，它们还可以用来作 为基类，去子类化类型，现在还可以用于isinstance()内建函数。使用isinstance()能够用于替 换用烦了的旧风格，而使用只需少量函数调用就可以得到清晰代码的新风格。比如，为测试一个对 象是否是一个整数，旧风格中，我们必须调用type()两次或者import相关的模块并使用其属性；但 现在只需要使用isinstance()，甚至在性能上也有所超越：

OLD (not as good):

•    if type(obj)二二 type(0)…

•    if type(obj)二二 types.IntType…

BETTER:

• if type(obj) is type(0)…

EVEN BETTER:

•    if isinstance(obj, int)…

•    if isinstance(obj, (int, long))…

•    if type(obj) is int…

记住：尽管isinstance()很灵活，但它没有执行“严格匹配”比较----如果obj是一个给定类 型的实例或其子类的实例，也会返回True。但如果想进行严格匹配，你仍然需要使用is操作符。

![img](07Python38c3160b-1862.jpg)



\1.    Python 2.3中新增。

\2.    Python 2.4中新增。



请复习13.12.2节中有关isinstance()的深入解释，还有在第4章中介绍这些调用是如何随同 Python的变化而变化的。

### 13.16.2 __slots__类属性

字典位于实例的“心脏”    性跟踪所有实例属性。举例来说，你有一个实例inst.它

有一个属性foo，那使用inst.foo来访问它与使用inst. __diet__['foo']来访问是一致的。

字典会占据大量内存，如果你有一个属性数量很少的类，但有很多实例，那么正好是这种情况。 为内存上的考虑，用户现在可以使用__slots__属性来替代__dict__。

基本上，__slots__是一个类变量，由一序列型对象组成，由所有合法标识构成的实例属性的集 合来表示。它可以是一个列表，元组或可迭代对象。也可以是标识实例能拥有的唯一的属性的简单 字符串。任何试图创建一个其名不在_slots_中的名字的实例属性都将导致AttributeError异常：

class SlottedClass(object):

![img](07Python38c3160b-1864.jpg)



__slots__ = ('foo'， 'bar')

\>>> c = SlottedClass()

\>>>

\>>> c.foo = 42

\>>> c.xxx = "don't think so" Traceback (most recent call last): File "<stdin>"， line 1， in ?

AttributeError: 'SlottedClass' object has no attribute

， ，

'xxx'

这种特性的主要目的是节约内存。其副作用是某种类型的"安全"，它能防止用户随心所欲的动态 增加实例属性。带__slots__属性的类定义不会存在__dict__了(除非你在__slots__中增加 '_dict_’元素)。更多有关_slots_的信息，请参见Python (语言)参考手册中有关数据模型章 节。

### 13.16.3 特殊方法__getattribute__()

Python 类有一个名为__getattr__()的特殊方法，它仅当属性不能在实例的__dict__或它的类 (类的__dict__)，或者祖先类(其__dict__)中找到时，才被调用。我们曾在实现授权中看到过使 用__getattr__()。

![img](07Python38c3160b-1865.jpg)



很多用户碰到的问题是，他们想要一个适当的函数来执行每一个属性访问，不光是当属性不能 找到的情况。这就是__getattribute__()用武之处了。它使用起来，类似__getattr__()，不同之处 在于，当属性被访问时，它就一直都可以被调用，而不局限于不能找到的情况。

如果类同时定义了__getattribute__()及__getattr__()方法,除非明确从__get-attribute__() 调用，或__getattribute__()引发了 AttributeError异常，否则后者不会被调用.

如果你将要在此(译者注:__getattribute__()中)访问这个类或其祖先类的属性，请务必小心。 如果你在__getattribute__()中不知何故再次调用了__getattribute__()，你将会进入无穷递归。 为避免在使用此方法时引起无穷递归，为了安全地访问任何它所需要的属性，你总是应该调用祖先类 的同名方法；比如，super(obj，self).__getattribute__(attr)。此特殊方法只在新式类中有效。 同_slots__—样，你可以参考Python (语言)参考手册中数据模型章节，以得到更多有关 __getattribute__()的信息。

### 13.16.4 描述符

描述符是Python新式类中的关键点之一。它为对象属性提供强大的API。你可以认为描述符是 表示对象属性的一个代理。当需要属性时，可根据你遇到的情况，通过描述符(如果有)或者采用

H常规方式(句点属性标识法)来访问它。

如你的对象有代理，并且这个代理有一个“get”属性(实际写法为_get_)，当这个代理被调

用时，你就可以访问这个对象了。当你试图使用描述符(set)给一个对象赋值或删除一个属性 (delete)时，这同样适用。

#### __get__()，__set__()，__delete__()特殊方法

严格来说，描述符实际上可以是任何(新式)类，这种类至少实现了三个特殊方法 __get__()，__set__()及__delete__()中的一个，这三个特殊方法充当描述符协议的作用。刚才提到 过，_get_()可用于得到一个属性的值，_set_()是为一个属性进行赋值的，在采用del语句(或 其它，其引用计数递减)明确删除掉某个属性时会调__delete__()方法。三者中，后者很少被实现。

还有，也不是所有的描述符都实现了__set__()方法。它们被当作方法描述符，或更准确来说是， 非数据描述符来被引用。那些同时覆盖__get__()及__set__()的类被称作数据描述符，它比非数据 描述符要强大些。

The signatures for __get__()， __set__()， and __delete__() look like this:

__get__()，__set__()及__delete__()的原型，如下：

• def _get__ (self, obj, typ=None) ==>    value

• def _set__ (self, obj val) ==>    None

• def _delete__ (self, obj) ==>    None

如果你想要为一个属性写个代理，必须把它作为一个类的属性，让这个代理来为我们做所有的

工作。当你用这个代理来处理对一个属性的操作时，你会得到一个描述符来代理所有的函数功能。

我们在前面的一节中已经讲过封装的概念。这里我们会进一步来探讨封装的问题。现在让我们来处

理更加复杂的属性访问问题，而不是将所有任务都交给你所写的类中的对象们。

#### __getattribute__() 特殊方法(二)

使用描述符的顺序很重要，有一些描述符的级别要高于其它的。整个描述符系统的心脏是 __getattribute__()，因为对每个属性的实例都会调用到这个特殊的方法。这个方法被用来查找类 的属性，同时也是你的一个代理，调用它可以进行属性的访问等操作。

回顾一下上面的原型，如果一个实例调用了__get__()方法，这就可能传入了一个类型或类的对 象。举例来说，给定类X和实例x, x.foo由__getattribute__0转化成:

type(x).__dict__['foo'].__get__(x, type(x))

如果类调用了_get_()方法，那么None将作为对象被传入(对于实例，传入的是self)：

X.__dict__['foo'].__get__(None, X)

最后，如果super()被调用了，比如，给定Y为X的子类，然后用super(Y，obj).foo在 obj._class_._mro_中紧接类Y沿着继承树来查找类X，然后调用：

X.__dict__['foo'].__get__(obj, X)

然后，描述符会负责返回需要的对象。

#### 优先级别

由于__getattribute__()的实现方式很特别，我们在此对__getattribute__()方法的执行方式

做一个介绍。因此了解以下优先级别的排序就非常重要了：

•类属性 •数据描述符 •实例属性 •非数据描述符 •默认为__getattr__()

描述符是一个类属性，因此所有的类属性皆具有最高的优先级。你其实可以通过把一个描述符 的引用赋给其它对象来替换这个描述符。比它们优先级别低一等的是实现了__get__()和__set__() 方法的描述符。如果你实现了这个描述符，它会像一个代理那样帮助你完成所有的工作！

否则，它就默认为局部对象的__dict__的值，也就是说，它可以是一个实例属性。接下来是非 数据描述符。可能第一次听起来会吃惊，有人可能认为在这条“食物链”上非数据描述符应该比实 例属性的优先级更高，但事实并非如此。非数据描述符的目的只是当实例属性值不存在时，提供一 个值而已。这与以下情况类似：当在一个实例的__dict__中找不到某个属性时，才去调用 __getattr__()。

关于__getattr__()的说明，如果没有找到非数据描述符，那么__getattribute__()将会抛出一 个AttributeError异常，接着会调用__getattr__0做为最后一步操作，否则AttributeError会返 回给用户。

#### 描述符举例

让我们来看一个简单的例子...用一个描述符禁止对属性进行访问或赋值的请求。事实上，以下 所有示例都忽略了全部请求，但它们的功能逐步增多，我们希望你通过每个示例逐步掌握描述符的 使用：

class DevNull1(object):

def _get__ (self, obj, typ=None):

pass

def __set__(self, obj, val): pass

我们建立一个类，这个类使用了这个描述符，给它赋值并显示其值

\>>> class C1(object):

... foo 二 DevNull1()

\>>> c1 二 C1()

\>>> c1.foo 二 'bar'

\>>> print 'c1.foo contains:', c1.foo

c1.foo contains: None

That was not too terribly exciting … how about one where the descriptor methods at least give some output to show what is going on?

这并没有什么有趣的 ... 让我们来看看在这个描述符中写一些输出语句会怎么样？

class DevNull2(object):

def __get__(self, obj, typ=None):

print 'Accessing attribute... ignoring' def __set__(self, obj, val):

print 'Attempt to assign %r... ignoring' % (val)

现在我们来看看修改后的结果:

\>>> class C2(object):

... foo = DevNull2()

\>>> c2 = C2()

\>>> c2.foo = 'bar'

Attempt to assign 'bar'... ignoring

\>>> x = c2.foo

Accessing attribute... ignoring >>> print 'c2.foo contains:', x

c2.foo contains: None

最后，我们在描述符所在的类中添加一个占位符，占位符包含有关于这个描述符的有用信息：

class DevNull3(object):

def __init__(self, name=None):

self.name = name

def __get__(self, obj, typ=None):

print 'Accessing [%s]... ignoring' %

self.name)

def __set__(self, obj, val):

print 'Assigning %r to [%s]... ignoring' %

val, self.name)

下面的输出结果表明我们前面提到的优先级层次结构的重要性，尤其是我们说过，一个完整的

数据描述符比实例的属性具有更高的优先级：

\>>> class C3(object):

... foo = DevNull3('foo')

\>>> c3 = C3()

\>>> c3.foo = 'bar'

Assigning 'bar' to [foo]... ignoring

\>>> x = c3.foo Accessing [foo]... ignoring >>> print ’c3.foo contains:’, x c3.foo contains: None

\>>> print ’Let us try to sneak it into c3 instance...’

Let us try to sneak it into c3 instance...

\>>> c3.__dict__[’foo’] = ’bar’

\>>> x = c3.foo

Accessing [foo]... ignoring >>> print ’c3.foo contains:’, x c3.foo contains: None

\>>> print "c3.__dict__[’foo’] contains: %r" % \ c3.__dict__[’foo’], "... why?!?"

c3.__dict__[’foo’] contains: ’bar’ ... why?!?

请注意我们是如何给实例的属性赋值的。给实例属性c3.foo赋值为一个字符串“bar”。但由于 数据描述符比实例属性的优先级高，所赋的值“bar”被隐藏或覆盖了。

同样地，由于实例属性比非数据描述符的优先级高，你也可以将非数据描述符隐藏。这就和你 给一个实例属性赋值，将对应类的同名属性隐藏起来是同一个道理：

\>>> class FooFoo(object):

... def foo(self):

...    print ’Very important foo() method.’

\>>>

\>>> bar = FooFoo()

\>>> bar.foo()

Very important foo() method.

\>>>

\>>> bar.foo = ’It is no longer here.’

\>>> bar.foo

’It is no longer here.’

\>>>

\>>> del bar.foo >>> bar.foo()

Very important foo() method.

这是一个直白的示例。我们将foo做为一个函数调用，然后又将它作为一个字符串访问，但我 们也可以使用另一个函数，而且保持相同的调用机制:

![img](07Python38c3160b-1876.jpg)



![img](07Python38c3160b-1877.jpg)



![img](07Python38c3160b-1878.jpg)



![img](07Python38c3160b-1879.jpg)



\>>> def barBar():

... print 'foo() hidden by barBar()



\>>> bar.foo 二 barBar

\>>> bar.foo()

foo() hidden by barBar()

\>>>

\>>> del bar.foo

\>>> bar.foo()

Very important foo() method.

要强调的是：函数是非数据描述符，实例属性有更高的优先级，我们可以遮蔽任一个非数据描

述符，只需简单的把一个对象赋给实例（使用相同的名字）就可以了。

我们最后这个示例完成的功能更多一些，它尝试用文件系统保存一个属性的内容，这是个雏形

版本。

#### 第1-10行

在引入相关模块后，我们编写一个描述符类，类中有一个类属性（saved）,它用来记录描述符 访问的所有属性。描述符创建后，它将注册并且记录所有从用户处接收的属性名。

#### 第12-26行

在获取描述符的属性之前，我们必须确保用户给它们赋值后才能使用。如果上述条件成立，接 着我们将尝试打开pickle文件以读取其中所保存的值。如果文件打开失败，将引发一个异常。文件 打开失败的原因可能有以下几种：文件已被删除了（或从未创建过），或是文件已损坏，或是由于某 种原因，不能被pickle模块反串行化。

#### 第18-38行

将属性保存到文件中需要经过以下几个步骤：打开用于写入的pickle文件（可能是首次创建一 个新的文件，也可能是删掉旧的文件），将对象串行化到磁盘，注册属性名，使用户可以读取这些属 性值。如果对象不能被pickle｛待统一命名｝，将引发一个异常。注意，如果你使用的是Python2.5 以前的版本，你就不能合并try-except和try-finally语句（第30-38行）。

例13.9使用文件来存储属性（descr.py）

这个类是一个雏形，但它展示了描述符的一个有趣的应用－－可以在一个文件系统上保存属性

的内容。

1    #!/usr/bin/env python

2



![img](07Python38c3160b-1882.jpg)



![img](07Python38c3160b-1883.jpg)



3    import os

4    import pickle

5

6    class FileDescr(object):

7    saved = []

8 9



10

11

12

13

14

15 16 17 18 19 20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40

41

42



def __init__(self, name=None): self.name = name

def __get__(self, obj, typ=None):

if self.name not in FileDescr.saved:

raise AttributeError, \

"%r used before assignment" % self.name

try:

f = open(self.name, 'r')

val = pickle.load(f)

f.close()

return val

except(pickle.InpicklingError, IOError, EOFError, AttributeError,

ImportError, IndexError), e:

raise AttributeError, \

"could not read %r: %s" % self.name

def __set__(self, obj, val):

f = open(self.name, 'w')

try:

try:

pickle.dump(val, f) FileDescr.saved.append(self.name)

except (TypeError, pickle.PicklingError), e: raise AttributeError, \

"could not pickle %r" % self.name

finally:

f.close()

def __delete__(self, obj):

try:

![img](07Python38c3160b-1884.jpg)



os.unlink(self.name)



43    FileDescr.saved.remove(self.name)

44    except (OSError, ValueError), e:

45    pass



#### 第40-45行

最后，如果属性被删除了，文件会被删除，属性名字也会被注销。以下是这个类的用法示例

\>>> class MyFileVarClass(object):

foo = FileDescr('foo')

bar = FileDescr('bar') >>> fvc = MyFileVarClass()

\>>> print fvc.foo

Traceback (most recent call last): File "<stdin>", line 1, in ?

File "descr.py", line 14, in __get__

raise AttributeError, \

![img](07Python38c3160b-1887.jpg)



AttributeError: 'foo' used before assignment >>>

![img](07Python38c3160b-1888.jpg)



\>>> fvc.foo = 42 >>> fvc.bar = 'leanna'

\>>>

\>>> print fvc.foo, fvc.bar

42 leanna

\>>>

\>>> del fvc.foo

\>>> print fvc.foo, fvc.bar

Traceback (most recent call last): File "<stdin>", line 1, in ?

File "descr.py", line 14, in __get__

raise AttributeError, \

AttributeError: 'foo' used before assignment

\>>>

\>>> fvc.foo = __builtins__ Traceback (most recent call last):

File "<stdin>", line 1, in ?

File "descr.py", line 35, in __set__

raise AttributeError, \ AttributeError: could not pickle 'foo

属性访问没有什么特别的，程序员并不能准确判断一个对象是否能被打包后存储到文件系统中

(除非如最后示例所示，将模块pickle，我们不该这样做)。我们也编写了异常处理的语句来处理文



件损坏的情况。在本例中，我们第一次在描述符中实现__delete__()方法。



请注意，在示例中，我们并没有用到obj的实例。别把obj和self搞混淆，这个self是指描 述符的实例，而不是类的实例。

#### 描述符总结

你已经看到描述符是怎么工作的。静态方法、类方法、属性(见下面一节)，甚至所有的函数都

是描述符。想一想：函数是Python中常见的对象。有内置的函数、用户自定义的函数、类中定义的 方法、静态方法、类方法。这些都是函数的例子。 它们之间唯一的区别在于调用方式的不同。通常， 函数是非绑定的。虽然静态方法是在类中被定义的，它也是非绑定的。但方法必须绑定到一个实例 上，类方法必须绑定到一个类上，对不？一个函数对象的描述符可以处理这些问题，描述符会根据 函数的类型确定如何“封装”这个函数和函数被绑定的对象，然后返回调用对象。它的工作方式是 这样的：函数本身就是一个描述符，函数的__get__()方法用来处理调用对象，并将调用对象返回给 你。描述符具有非常棒的适用性，因此从来不会对Python自己的工作方式产生影响。

#### 属性和property^)内建函数

![img](07Python38c3160b-1891.jpg)



属性是一种有用的特殊类型的描述符。它们是用来处理所有对实例属性的访问，其工作方式和 我们前面说过的描述符相似。“一般”情况下，当你使用点属性符号来处理一个实例属性时，其实 你是在修改这个实例的__dict__属性。

![img](07Python38c3160b-1892.jpg)



![img](07Python38c3160b-1893.jpg)



表面上来看，你使用propertyO访问和一般的属性访问方法没有什么不同，但实际上这种访问 的实现是不同的-它使用了函数(或方法)。在本章的前面，你已看到在Python的早期版本中，我 们一般用__getattr__() 和 __setattr__() 来处理和属性相关的问题。属性的访问会涉及到以上特 殊的方法(和_getattribute__0)，但是如果我们用propertyO来处理这些问题，你就可以写一个 和属性有关的函数来处理实例属性的获取(getting),赋值(setting),和删除(deleting)操作，而不 必再使用那些特殊的方法了(如果你要处理大量的实例属性，使用那些特殊的方法将使代码变得很臃 肿)。

propertyO内建函数有四个参数，它们是：

property(fget=None, fset=None, fdel=None, doc=None)

请注意propertyO的一般用法是，将它写在一个类定义中，propertyO接受一些传进来的函数 (其实是方法)作为参数。实际上，propertyO是在它所在的类被创建时被调用的，这些传进来的(作 为参数的)方法是非绑定的，所以这些方法其实就是函数！

下面的一个例子：在类中建立一个只读的整数属性，用逐位异或操作符将它隐藏起来：

![img](07Python38c3160b-1894.jpg)



class ProtectAndHideX(object):

def __init__(self, x):



assert isinstance(x, int), \ '"x" must be an integer!

self.__x = ~x

def get_x(self): return ~self.__x

x = property(get_x)

我们来运行这个例子，会发现它只保存我们第一次给出的值，而不允许我们对它做第二次修改：

\>>> inst = ProtectAndHideX('foo') Traceback (most recent call last):

File "<stdin>", line 1, in ?

File "prop.py", line 5, in __init__

![img](07Python38c3160b-1896.jpg)



assert isinstance(x, int), \ AssertionError: "x" must be an integer! >>> inst = ProtectAndHideX(10)

![img](07Python38c3160b-1897.jpg)



\>>> print 'inst.x =', inst.x inst.x = 10

\>>> inst.x = 20

Traceback (most recent call last):

File "<stdin>", line 1, in ?

AttributeError: can't set attribute

下面是另一个关于setter的例子:

class HideX(object):

def __init__(self, x): self.x = x

def get_x(self): return ~self.__x

def set_x(self, x):

assert isinstance(x, int), \

'"x" must be an integer! self.__x = ~x



![img](07Python38c3160b-1899.jpg)



![img](07Python38c3160b-1900.jpg)



![img](07Python38c3160b-1901.jpg)



![img](07Python38c3160b-1902.jpg)



x = property(get_x, set_x)



本示例的输出结果：

\>>> inst = HideX(20)

\>>> print inst.x 20

\>>> inst.x = 30 >>> print inst.x 30

属性成功保存到x中并显示出来，是因为在调用构造器给x赋初始值前，在getter中已经将~1 赋给了 self. __x.

你还可以给自己写的属性添加一个文档字符串，参见下面这个例子：

from math import pi class PI(object):

![img](07Python38c3160b-1904.jpg)



def get_pi(dummy):

return pi



![img](07Python38c3160b-1905.jpg)



![img](07Python38c3160b-1906.jpg)



pi = property(get_pi, doc='Constant "pi"')

为了说明这是可行的实现方法，我们在property中使用的是一个函数而不是方法。注意在调用 函数时self作为第一个(也是唯一的)参数被传入，所以我们必须加一个伪变量把self丢弃。下面 是本例的输出：

\>>> inst = PI()

\>>> inst.pi

3.1415926535897931

\>>> print PI.pi.__doc__

Constant "pi"

你明白properties是如何把你写的函数(fget, fset和fdel)影射为描述符的_get__(), __set__(), 和__delete__()方法的吗？你不必写一个描述符类，并在其中定义你要调用的这些方法 只要把你写的函数(或方法)全部传递给propertyO就可以了。

在你写的类定义中创建描述符方法的一个弊端是它会搞乱类的名字空间。不仅如此，这种做法



也不会像propertyO那样很好地控制属性访问。如果不用propertyO这种控制属性访问的目的就不 可能实现。我们的第二个例子没有强制使用propertyO,因为它允许对属性方法的访问（由于在类定 义中包含属性方法）:



\>>> inst.set_x(40) # can we require inst.x = 40?

\>>> print inst.x

40

APNPC（ActiveState Programmer Network Python Cookbook） （http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/205183）上的一条精明的办

法解决了以下问题：

•    “借用”一个函数的名字空间

•编写一个用作内部函数的方法作为propertyO的（关键字）参数 •（用localsO）返回一个包含所有的（函数/方法）名和对应对象的字典 •把字典传入propertyO，然后

•去掉临时的名字空间

这样，方法就不会再把类的名字空间搞乱了，因为定义在内部函数中的这些方法属于其它的 名字空间。由于这些方法所属的名字空间已超出作用范围，用户是不能够访问这些方法的，所以通 过使用属性propertyO来访问属性就成为了唯一可行的办法。根据APNPC上方法，我们来修改这个

![img](07Python38c3160b-1909.jpg)



类：

class HideX(object):

def __init__(self, x): self.x = x

@property

def x():

def fget(self):

return ~self.__x

def fset(self, x):

assert isinstance(x, int), \ '"x" must be an integer!

self.__x = ~x

return locals()

我们的代码工作如初，但有两点明显不同：（1） 类的名字空间更加简洁，只有 ['__doc



’ __init__', ’ __module__', 'x'], (2),用户不能再通过 inst.set_x(40)给属性赋值...必须 使用init.x = 40.我们还使用函数修饰符(@property)将函数中的x赋值到一个属性对象。由于 修饰符是从Python 2.4版本开始引入的，如果你使用的是Python的早期版本2.2.x或2.3.x，请 将修饰去掉，在x()的函数声明后添加x = property(**x())。

### 13.16.5 Metaclasses 和__metaclass__

#### 元类(Metaclasses)是什么？

元类可能是添加到新风格类中最难以理解的功能了。元类让你来定义某些类是如何被创建的， 从根本上说，赋予你如何创建类的控制权。(你甚至不用去想类实例层面的东西。)早在 Python1.5 的时代，人们就在谈论这些功能(当时很多人都认为不可能实现)，但现在终于实现了。

从根本上说，你可以把元类想成是一个类中类，或是一个类，它的实例是其它的类。实际上， 当你创建一个新类时，你就是在使用默认的元类，它是一个类型对象。(对传统的类来说，它们的元 类是types.ClassType.)当某个类调用type()函数时，你就会看到它到底是谁的实例：

![img](07Python38c3160b-1912.jpg)



class C(object): pass



class CC: pass



![img](07Python38c3160b-1913.jpg)



\>>> type(C)

<type 'type'>

\>>>

\>>> type(CC)

<type 'classobj'>

\>>>

\>>> import types

\>>> type(CC) is types.ClassType True

#### 什么时候使用元类?

元类一般用于创建类。在执行类定义时，解释器必须要知道这个类的正确的元类。解释器会先 寻找类属性__metaclass__，如果此属性存在，就将这个属性赋值给此类作为它的元类。如果此属性 没有定义，它会向上查找父类中的__metaclass__. 所有新风格的类如果没有任何父类，会从对象或 类型中继承。(type (object)当然是类型).

![img](07Python38c3160b-1914.jpg)



如果还没有发现__metaclass__属性，解释器会检查名字为__metaclass__的全局变量，如果它 存在，就使用它作为元类。否则，这个类就是一个传统类，并用types.ClassType作为此类的元类。 （注意：在这里你可以运用一些技巧... 如果你定义了一个传统类，并且设置它的__metaclass__ = type，其实你是在将它升级为一个新风格的类!）

在执行类定义的时候，将检查此类正确的（一般是默认的）元类，元类（通常）传递三个参数（到构

造器）:类名，从基类继承数据的元组，和（类的）属性字典。

#### 谁在用元类?

元类这样的话题对大多数人来说属于理论化或纯面向对象思想的范畴，认为它在实际编程中没

有什么实际意义。从某种意义上讲这种想法是正确的；但最重要的请铭记在心的是，元类的最终使

用者不是用户，正是程序员自己。你通过定义一个元类来“迫使”程序员按照某种方式实现目标类，

这将既可以简化他们的工作，也可以使所编写的程序更符合特定标准。

#### 元类何时被创建?

前面我们已提到创建的元类用于改变类的默认行为和创建方式。大多数Python用户都无须创 建或明确地使用元类。创建一个新风格的类或传统类的通用做法是使用系统自己所提供的元类的默

J    认方式。

用户一般都不会觉察到元类所提供的创建类（或元类实例化）的默认模板方式。虽然一般我们并

不创建元类，还是让我们来看下面一个简单的例子。（关于更多这方面的示例请参见本节末尾的文档

列表。）

#### 元类示例1

我们第一个关于元类的示例非常简单（希望如此）。它只是在用元类创建一个类时，显示时间标

签。（你现在该知道，这发生在类被创建的时候。）

看下面这个脚本。它包含的print语句散落在代码各个地方，便于我们了解所发生的事情：

\#!/usr/bin/env python

from time import ctime

print '*** Welcome to Metaclasses!' print '\tMetaclass declaration first.'

class MetaC(type):



def __init__(cls, name, bases, attrd):

super(MetaC, cls).__init__(name, bases, attrd) print '*** Created class %r at: %s' % (name, ctime())

print '\tClass "Foo" declaration next.'

class Foo(object):

__metaclass__ = MetaC def __init__(self):

print '*** Instantiated class %r at: %s' % ( self.__class__.__name__, ctime())

print '\tClass "Foo" instantiation next.'

f = Foo()

print '\tDONE'

当我们执行此脚本时，将得到以下输出:

![img](07Python38c3160b-1918.jpg)



![img](07Python38c3160b-1919.jpg)



*** Welcome to Metaclasses! Metaclass declaration first. Class "Foo" declaration next.

*** Created class 'Foo' at: Tue May 16 14:25:53 2006

Class "Foo" instantiation next.

*** Instantiated class 'Foo' at: Tue May 16 14:25:53 2006

DONE

当你明白了一个类的定义其实是在完成某些工作的事实以后，你就容易理解这是怎么一回事情

了。

#### 元类示例2

在第二个示例中，我们将创建一个元类，要求程序员在他们写的类中提供一个__str__()方法的 实现，这样用户就可以看到比我们在本章前面所见到的一般Python对象字符串(〈object object at id>)更有用的信息。

如果您还没有在类中覆盖__repr__()方法，元类会(强烈)提示您这么做，但这只是个警告。如 果未实现_8灶_()方法，将引发一个TypeError的异常，要求用户编写一个同名方法。以下是关于 元类的代码:

from warnings import warn

![img](07Python38c3160b-1920.jpg)



class ReqStrSugRepr(type):



def __init__(cls, name, bases, attrd): super(ReqStrSugRepr, cls).__init__(

name, bases, attrd)

if '__str__' not in attrd:

raise TypeError("Class requires overriding of __str__()")

if '__repr__' not in attrd:

warn('Class suggests overriding of __repr__()\n', stacklevel=3)

我们编写了三个关于元类的示例，其中一个(Foo)重载了特殊方S_str_(WB_repr_()，另一 个(Bar)只实现了特殊方法_str_ ()，还有一个(FooBar)没有实现_str_ ()和_repr_ ()，这种 情况是错误的。完整的程序见示例13.10.

执行此脚本，我们得到如下输出：

$ python meta.py

![img](07Python38c3160b-1922.jpg)



*** Defined ReqStrSugRepr (meta)class

*** Defined Foo class



![img](07Python38c3160b-1923.jpg)



sys:1: UserWarning: Class suggests overriding of __repr__()

*** Defined Bar class

Traceback (most recent call last): File "meta.py", line 43, in ? class FooBar(object):

File "meta.py", line 12, in __init__ raise TypeError(

TypeError: Class requires overriding of __str__()

示例13.10 元类示例 (meta.py)

这个模块有一个元类和三个受此元类限定的类。每创建一个类，将打印一条输出语句

1    #!/usr/bin/env python

2

3 from warnings import warn

![img](07Python38c3160b-1924.jpg)



![img](07Python38c3160b-1925.jpg)



4

5    class ReqStrSugRepr(type):

6



| 7    | def __init__(cls， name， bases， attrd):       |       |
| ---- | ----------------------------------------------- | ----- |
| 8    | super(ReqStrSugRepr， cls).__init__(            |       |
| 9    | name， bases， attrd)                           |       |
| 10   |                                                 |       |
| 11   | if '__str__' not in attrd:                      |       |
| 12   | raise TypeError(                                |       |
| 13   | "Class requires overriding of _                 | _str_ |
| 14   |                                                 |       |
| 15   | if '__repr__' not in attrd:                     |       |
| 16   | warn(                                           |       |
| 17   | 'Class suggests overriding of _                 | _repr |
| 18   | stacklevel=3)                                   |       |
| 19   |                                                 |       |
| 20   | print '*** Defined ReqStrSugRepr (meta)class\n' |       |
| 21   |                                                 |       |
| 22   | class Foo(object):                              |       |
| 23   | __metaclass__ = ReqStrSugRepr                   |       |
| 24   |                                                 |       |
| 25   | def __str__(self):                              |       |
| 26   | return 'Instance of class:'， \                 |       |
| 27   | self.__class__.__name__                         |       |
| 28   |                                                 |       |
| 29   | def __repr__(self):                             |       |
| 30   | return self.__class__.__name__                  |       |
| 31   |                                                 |       |
| 32   | print '*** Defined Foo class\n'                 |       |
| 33   |                                                 |       |
| 34   | class Bar(object):                              |       |
| 35   | __metaclass__ = ReqStrSugRepr                   |       |
| 36   |                                                 |       |
| 37   | def __str__(self):                              |       |
| 38   | return 'Instance of class:'， \                 |       |
| 39   | self.__class__.__name__                         |       |
| 40   |                                                 |       |
| 41   | print '*** Defined Bar class\n'                 |       |
| 42   |                                                 |       |
| 43   | class FooBar(object):                           |       |

()")

()\n'，



![img](07Python38c3160b-1927.jpg)



![img](07Python38c3160b-1928.jpg)



44    __metaclass__ = ReqStrSugRepr

45

46    print '*** Defined FooBar class\n

注意我们是如何成功声明Foo定义的；定义Bar时，提示警告__repr__（）未实现；FooBar的创 建没有通过安全检查，以致程序最后没有打印出关于FooBar的语句。另外要注意的是我们并没有创 建任何测试类的实例... 这些甚至根本不包括在我们的设计中。但别忘了这些类本身就是我们自己 的元类的实例。这个示例只显示了元类强大功能的一方面。

关于元类的在线文档众多，包括Python文档PEPs 252和253，《What’s New in Python 2.2》 文档，Guido van Rossum 所写的名为 “Unifying Types and Classes in Python 2.2” 的文章。在 Python 2.2.3发布的主页上你也可以找到相关文档的链接地址。

Edit By Vheavens

### 13.17 相关模块和文档

我们在本章已经对核心语言做了讲述，而Python语言中有几个扩展了核心语言功能的经典类。 这些类为Python数据类型的子类化提供了方便。

模块好比速食品，方便即食。我们曾提到类可以有特殊的方法，如果实现了这些特殊方法，就 H可以对类进行定制，这样当对一个标准类型封装时，可以给实例带来和类型一样的使用效果。

UserList和UserDict，还有新的UserString（从Python1.6版本开始引入）分别代表对列表、字 典、字符串对象进行封装的类定义模块。这些模块的主要用处是提供给用户所需要的功能，这样你 就不必自己动手去实现它们了，同时还可以作为基类，提供子类化和进一步定制的功能。Python语 言已经为我们提供了大量有用的内建类型，但这种"由你自己定制"类型的附加功能使得Python语言 更加强大。

在第四章里，我们介绍了 Python语言的标准类型和其它内建类型。types模块是进一步学习 Python类型方面知识的好地方，其中的一些内容已超出了本书的讨论范围。types模块还定义了一 些可以用于进行比较操作的类型对象。（这种比较操作在Python中很常见，因为它不支持方法的重 载 - 这简化的语言本身，同时又提供了一些工具，为貌似欠缺的地方添加功能.）

下面的代码检查传递到foo函数的数据对象是否是一个整数或一个字符串，不允许其他类型出 现（否则会引发一个异常）:

def foo(data):

if isinstance(data, int):

print 'you entered an integer'

elif isinstance(data, str):

print 'you entered a string' else:

raise TypeError, 'only integers or strings!



最后一个相关模块是operator模块。这个模块提供了 Python中大多数标准操作符的函数版本。

在某些情况下，这种接口类型比标准操作符的硬编码方式更通用。

请看下边的示例。在你阅读代码时，请设想一下如果此实现中使用的是一个个操作符的话，那

会多写多少行代码啊？

\>>> from operator import * # import all operators >>> vec1 = [12, 24]

\>>> vec2 = [2, 3, 4]

\>>> opvec = (add, sub, mul, div) # using +, -, *, / >>> for eachOp in opvec: # loop thru operators ...    for i in vec1:

...    for j in vec2:

...    print '%s(%d, %d) = %d' % \

...    (eachOp.__name__, i, j, eachOp(i, j))

![img](07Python38c3160b-1932.jpg)



add(12, 2) = 14 add(12, 3) = 15 add(12, 4) = 16 add(24, 2) = 26 add(24, 3) = 27 add(24, 4) = 28 sub(12, 2) = 10 sub(12, 3) = 9 sub(12, 4) = 8 sub(24, 2) = 22 sub(24, 3) = 21 sub(24, 4) = 20 mul(12, 2) = 24 mul(12, 3) = 36 mul(12, 4) = 48 mul(24, 2) = 48 mul(24, 3) = 72 mul(24, 4) = 96 div(12, 2) = 6 div(12, 3) = 4

![img](07Python38c3160b-1933.jpg)



div（12， 4） = 3

div（24， 2） = 12 div（24， 3） = 8 div（24， 4） = 6



上面这段代码定义了三个向量，前两个包含着操作数，最后一个代表程序员打算对两个操作数

进行的一系列操作。最外层循环遍历每个操作运算，而最内层的两个循环用每个操作数向量中的元

素组成各种可能的有序数据对。最后，print语句打印出将当前操作符应用在给定参数上所得的运算

结果。

我们前面介绍过的模块都列在表13.5中

表13.5



与类相关的模块



模块

UserList

UserDict

UserString



说明

提供一个列表对象的封装类 提供一个字典对象的封装类

![img](07Python38c3160b-1935.jpg)



提供一个字符串对象的封装类；它又包括一个MutableString子类，如果有需 要，可以提供有关功能

types定义所有Python对象的类型在标准Python解释器中的名字    山

operator标准操作符的函数接口    —

a.新出现于Python 1.6版本

在Python FAQ中，有许多与类和面向对象编程有关的问题。它对Python类库以及语言参考手 册都是很好的补充材料。关于新风格的类，请参考PEPs252和253和Python2.2以后的相关文档。

### 13.18 练习

13-1. 程序设计。请列举一些面向对象编程与传统旧的程序设计形式相比的先进之处。

13-2. 函数和方法的比较。函数和方法之间的区别是什么？

示例13.11 金额转换程序 (moneyfmt.py)

字符串格式类用来对浮点数值进行"打包"，使这个数值显示为带有正确符号的金额。

1    #!/usr/bin/env python

2

3    class MoneyFmt（object）:

4    def __init__（self， value=0.0）: # constructor #构造器



![img](07Python38c3160b-1937.jpg)



5    self.value = float(value)

6

7    def update(self, value=None): # allow updates #允许修改

8    ###

9    ### (a) complete this function

10    ###

11

12    def __repr__(self): # display as a float #显示为浮点数

13    return 'self.value'

14

15    def __str__(self): # formatted display    #格式化显示

16    val = ''

17

18 ###

19    ### (b) complete this function... do NOT

20    ### forget about negative numbers!!

21    ###

22

![img](07Python38c3160b-1938.jpg)



23    return val

![img](07Python38c3160b-1939.jpg)



24

25    def __nonzero__(self): # boolean test

26    ###

27    ### (c) find and fix the bug

28    ###

29

30 return int(self.value)

You will find the code skeleton for moneyfmt.py presented as Example 13.11. You will find a fully documented (yet incomplete) version of moneyfmt.py on the Web site. If we were to import the completed class within the interpreter, execution should behave similar to the following:

\>>> import moneyfmt

\>>>

\>>> cash = moneyfmt.MoneyFmt(123.45)

\>>> cash

123.45

\>>> print cash

$123.45

\>>>

![img](07Python38c3160b-1940.jpg)



![img](07Python38c3160b-1941.jpg)



\>>> cash.update(100000.4567)

\>>> cash

100000.4567

\>>> print cash

$100,000.46

\>>>

\>>> cash.update(-0.3)

\>>> cash -0.3

\>>> print cash

-$0.30

\>>> repr(cash)

'-0.3'

\>>> 'cash'

'-0.3'

\>>> str(cash)

'-$0.30'

13-3. 对类进行定制。写一个类，用来将浮点数值转换为金额。在本练习里，我们使用美国

![img](07Python38c3160b-1942.jpg)



货币，但读者也可以自选任意货币。

基本任务：编写一个dollarizeO函数，它以一个浮点数值作为输入，返回一个字符串形式的 金额数。比如说：

dollarize(1234567.8901) ==> ‘$1,234,567.89.

dollarizeO返回的金额数里应该允许有逗号(比如1,000,000)，和美元的货币符号。如果有负 号，它必须出现在美元符号的左边。完成这项工作后，你就可以把它转换成一个有用的类，名为 MoneyFmt。

MoneyFmt类里只有一个数据值(即，金额)，和五个方法(你可以随意编写其他方法)。_init_() 构造器对数据进行初始化，updateO方法把数据值替换成一个新值，__nonzero__0是布尔型的，当 数据值非零时返回True，_repr_()方法以浮点数的形式返回金额；而_8灶_()方法采用和 dollarizeO—样的字符格式显示该值。

(a)    编写updateO方法，以实现数据值的修改功能。

(b)    以你已经编写的dollarizeO的代码为基础，编写_str_()方法的代码

(c)    纠正__nonzero__()方法中的错误，这个错误认为所有小于1的数值，例如，50美分($0.50)， 返回假值(False)。

(d)    附加题: 允许用户通过一个可选参数指定是把负数数值显示在一对尖括号里还是显示一个 负号。默认参数是使用标准的负号。

13-4. 用户注册。建立一个用户数据库(包括登录名、密码和上次登录时间戳)类(参考练习7-5 和9-12)，来管理一个系统，该系统要求用户在登录后才能访问某些资源。这个数据库类对用户进行 管理，并在实例化操作时加载之前保存的用户信息，提供访问函数来添加或更新数据库的信息。在



数据修改后，数据库会在垃圾回收时将新信息保存到磁盘。(参见__del__()).

13-5. 几何.创建一个由有序数值对(x，y)组成的Point类，它代表某个点的X坐标和Y坐 标。X坐标和Y坐标在实例化时被传递给构造器，如果没有给出它们的值，则默认为坐标的原点。

13-6. 几何. 创建一个直线/直线段类。除主要的数据属性：一对坐标值(参见上一个练习)外， 它还具有长度和斜线属性。你需要覆盖__repr__()方法(如果需要的话，还有__str__()方法)，使得 代表那条直线(或直线段)的字符串表示形式是由一对元组构成的元组，即，((x1, y1)，(x2, y2)).

总结：

__repr__    将直线的两个端点(始点和止点)显示成一对元组

length    返回直线段的长度-不要使用〃len"，因为这样使人误解它是整数。

slope    返回此直线段的斜率(或在适当的时候返回None)

13-7. 数据类。提供一个time模块的接口，允许用户按照自己给定时间的格式，比如： “MM/DD/YY，” “MM/DD/YYYY，” “DD/MM/YY，” “DD/MM/ YYYY，” “Mon DD， YYYY，” 或是标准 的Unix日期格式：“Day Mon DD，HH:醐:SS YYYY”来查看日期。你的类应该维护一个日期值，并 用给定的时间创建一个实例。如果没有给出时间值，程序执行时会默认采用当前的系统时间。还包

括另外一些方法：

update() 按给定时间或是默认的当前系统时间修改数据值 display() 以代表时间格式的字符串做参数，并按照给定时间的格式显示:

'MDY' ==> MM/DD/YY

'MDYY' ==> MM/DD/YYYY

'DMY' ==> DD/MM/YY

'DMYY' ==> DD/MM/YYYY

'MODYY' ==> Mon DD， YYYY

如果没有提供任何时间格式，默认使用系统时间或ctimeO的格式。附加题：把这个类和练习

6-15结合起来。

13-8. 堆栈类。一个堆栈(Stack)是一种具有后进先出(last-in-first-out，LIFO)特性的数 据结构。我们可以把它想象成一个餐盘架。最先放上去的盘子将是最后一个取下来的，而最后一个 放上去的盘子是最先被取下来的。你的类中应该有push()方法(向堆栈中压入一个数据项)和pop() 方法(从堆栈中移出一个数据项)。还有一个叫isemptyO的布尔方法，如果堆栈是空的，返回布尔值 1,否则返回0; —个名叫peek()的方法，取出堆栈顶部的数据项，但并不移除它。

注意，如果你使用一个列表来实现堆栈，那么pop()方法从Python1.5.2版本起已经存在了。那 就在你编写的新类里，加上一段代码检查pop()方法是否已经存在。如果经检查pop()方法存在，就

调用这个内建的方法；否则就执行你自己编写的popO方法。你很可能要用到列表对象；如果用到它

时，不需要担心实现列表的功能(例如，切片)。只要确保你写的堆栈类能够正确实现上面的两项功

能就可以了。你可以用列表对象的子类或自己写个类似列表的对象，请参考示例6.2.



13-9.    队列类。一个队列(queue)是一种具有先进先出(first-in-first-out，FIFO)特性的数

据结构。一个队列就像是一行队伍，数据从前端被移除，从后端被加入。这个类必须支持下面几种

方法:

enqueue() 在列表的尾部加入一个新的元素

dequeue() 在列表的头部取出一个元素，返回它并且把它从列表中删除

请参见上面的练习和示例6. 3 .

13-10. 堆栈和队列。编写一个类，定义一个能够同时具有堆栈(FIFO)和队列(LIFO)操作行为 的数据结构。这个类和Perl语言中数组相像。需要实现四个方法：

![img](07Python38c3160b-1947.jpg)



shift() 返回并删除列表中的第一个元素，类似于前面的dequeueO函数。 unshift() 在列表的头部"压入"一个新元素 push() 在列表的尾部加上一个新元素，类似于前面的enqueueO和push()方法。 pop()    返回并删除列表中的最后一个元素，与前面的pop()方法完全一样。

![img](07Python38c3160b-1948.jpg)



请参见练习13-8和13-9.

13-11. 电子商务。

你需要为一家B2C (商业到消费者)零售商编写一个基础的电子商务引擎。你需要写一个针对顾客 的类User, —个对应存货清单的类Item,还有一个对应购物车的类叫Cart.货物放到购物车里，顾 客可以有多个购物车。同时购物车里可以有多个货物，包括多个同样的货物。

13-12 聊天室. 你对目前的聊天室程序感到非常失望，并决心要自己写一个，创建一家新的

因特网公司，获得风险投资，把广告集成到你的聊天室程序中，争取在6个月的时间里让收入翻五

倍，股票上市，然后退休。但是，如果你没有一个非常酷的聊天软件，这一切都不会发生。

你需要三个类：一个Message类，它包含一个消息字符串以及诸如广播、单方收件人等其他信 息，一个User类，包含了进入你聊天室的某个人的所有信息。为了从风险投资者那里拿到启动资金， 你加了一个Room类，它体现了一个更加复杂的聊天系统，用户可以在聊天时创建单独的“聊天屋” 并邀请其他人加入。附加题: 请为用户开发一个图形化用户界面应用程序。

13-13. 股票投资组合类.你的数据库中记录了每个公司的名字，股票代号，购买日期，购买 价格和持股数量。需要编写的方法包括：添加新代号(新买的股票)、删除代号(所有卖出股票)，根 据当前价格(及日期)计算出的YTD或年回报率。请参见练习7-6。



13-14. DOS.为DOS机器编写一个UNIX操作界面的shell。你向用户提供一个命令行，使得 用户可以在那里输入Unix命令，你可以对这些命令进行解释，并返回相应的输出，例如：“ls”命 令调用“dir”来显示一个目录中的文件列表，“more”调用同名命令(分页显示一个文件)，“cat”调 用 “type,” “cp” 调用 “copy,” “mv” 调用 “ren，” “rm” 调用 “del,” 等.

13-15. 授权。示例13.8的执行结果表明我们的类CapOpen能成功完成数据的写入操作。在 我们的最后评论中，提到可以使用CapOpenO或open()来读取文件中的文本。为什么呢？这两者使

用起来有什么差异吗？

13-16. 授权和函数编程。

(a)    请为示例13.8中的CapOpen类编写一个writelinesO方法。这个新函数将可以一次读入 多行文本，然后将文本数据转换成大写的形式，它与writeO方法的区别和通常意思上的writelinesO 与writeO方法之间的区别相似。注意：编写完这个方法后，writelinesO将不再由文件对象〃代理〃。

(b)    在writelinesO方法中添加一个参数，用这个参数来指明是否需要为每行文本加上一个 换行符。此参数的默认值是False，表示不加换行符。

13-17. 数值类型子类化。在示例13.3中所看到的moneyfmt.py脚本基础上修改它，使得它 可以扩展Python的浮点类型。请确保它支持所有操作，而且是不可变的。

13-18. 序列类型子类化。模仿前面练习13-4中的用户注册类的解决方案，编写一个子类。 要求允许用户修改密码，但密码的有效期限是12个月，过期后不能重复使用。附加题：支持“相 似密码”检测的功能(任何算法皆可)，不允许用户使用与之前12个月期间所使用的密码相似的任何 密码。

13-19.    映射类型子类化。假设在13.11.3节中字典的子类，若将keys()方法重写为：

def keys(self): return sorted(self.keys())

(a) What happens when keys() is called for a method?

(a)    当方法keys()被调用，结果如何？

(b)    Why is this, and what makes our original solution work?

(b) 为什么会有这样的结果？如何使我们的原解决方案顺利工作？

13-20. 类的定制。改进脚本time60.py，见13.13.2节，示例13.3.

(a)    允许“空”实例化: 如果小时和分钟的值没有给出，默认为零小时、零分钟。

(b)    用零占位组成两位数的表示形式，因为当前的时间格式不符合要求。如下面的示例，wed 应该输出为“12:05.”

\>>> wed = Time60(12, 5)

\>>> wed

12:5

(c)除了用hours (hr)和minutes (min)进行初始化外，还支持以下时间输入格式：

•    一个由小时和分钟组成的元组(10，30)

•    一个由小时和分钟组成的字典({'hr': 10，'min': 30})

•    一个代表小时和分钟的字符串(〃10:30〃)

附加题: 允许不恰当的时间字符串表示形式，如 “12:5”.

(d) 我们是否需要实现__radd__()方法? 为什么? 如果不必实现此方法，那我们什么时候可

以或应该覆盖它?

(e)    __repr__()函数的实现是有缺陷而且被误导的。我们只是重载了此函数，这样我们可以省 去使用print语句的麻烦，使它在解释器中很好的显示出来。但是，这个违背了一个原则:对于可估 值的Python表达式，repr()总是应该给出一个(有效的)字符串表示形式。12:05本身不是一个合法 的Python表达式，但Time60(’12:05’)是合法的。请实现它。

(f)    添加六十进制(基数是60)的运算功能。下面示例中的输出应该是19:15，而不是18:75:

\>>> thu = Time60(10， 30)

\>>> fri = Time60(8， 45)

\>>> thu + fri

18:75

13-21.装饰符和函数调用语法。第13.16.4节末尾，我们使用过一个装饰函数符把x转化成一 个属性对象，但由于装饰符是Python2.4才有的新功能，我们给出了另一个适用于旧版本的语法：

X = property (**x()).

执行这个赋值语句时到底发生了什么呢？为什么它和使用装饰符语句是等价的?
