---
title: 05 对序列使用加和乘
toc: true
date: 2018-07-11 15:00:15
---

### 2.5 对序列使用+和*

Python 程序员会默认序列是支持 + 和 * 操作的。通常 + 号两侧的序列由相同类型的数据 所构成，在拼接的过程中，两个被操作的序列都不会被修改， Python 会新建一个包含同样 类型数据的序列来作为拼接的结果。

如果想要把一个序列复制几份然后再拼接起来，更快捷的做法是把这个序列乘以一个整

数。同样，这个操作会产生一个新序列：

\>>> l = [1, 2, 3]

\>>> l * 5

[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3] >>> 5 * 'abcd'

'abcdabcdabcdabcdabcd'

+ 和 * 都遵循这个规律，不修改原有的操作对象，而是构建一个全新的序列。

如果在a * n这个语句中，序列a里的元素是对其他可变对象的引用的话，

你就需要格外注意了，因为这个式子的结果可能会出乎意料。比如，你想用

my_list = [[]] * 3 来初始化一个由列表组成的列表，但是你得到的列表里包含

的 3 个元素其实是 3 个引用，而且这 3 个引用指向的都是同一个列表。这可能不是你 想要的效果。

下面来看看如何用 * 来初始化一个由列表组成的列表。

建立由列表组成的列表

有时我们会需要初始化一个嵌套着几个列表的列表，譬如一个列表可能需要用来存放不同 的学生名单，或者是一个井字游戏板 3 上的一行方块。想要达成这些目的，最好的选择是 使用列表推导，见示例 2-12。

3又称过三关，是一种在3x3的方块矩阵上进行的游戏。一译者注

示例 2-12 一个包含 3 个列表的列表，嵌套的 3 个列表各自有 3 个元素来代表井字 游戏的一行方块

| >>>  | board = [['_'] * 3 for i | in range(3)]  | O     |      |
| ---- | ------------------------ | ------------- | ----- | ---- |
| >>>  | board                    |               |       |      |
| [['  | ', '_', '_'], ['_', '_', | '_'], ['_', ' | _', ' | _']] |
| >>>  | board[1][2] = 'X' ©      |               |       |      |
| >>>  | board                    |               |       |      |
| [['  | ', '', ''], ['', '',     | 'X'], ['', '  | ', '  | ']]  |

O 建立一个包含 3 个列表的列表，被包含的 3 个列表各自有 3 个元素。打印出这个嵌套

列表。

#### ©把第1行第2列的元素标记为X，再打印出这个列表。

示例 2-13 展示了另一个方法，这个方法看上去是个诱人的捷径，但实际上它是错的。

示例 2-13 含有 3 个指向同一对象的引用的列表是毫无用处的

| >>>  | weird  | board = [[' | '] * 3] *  | 3 O        |           |
| ---- | ------ | ----------- | ---------- | ---------- | --------- |
| >>>  | weird  | board       |            |            |           |
| [['  | ', '_' | , '_'], ['_ | , '_', '_' | ], ['_', ' | _', '_']] |
| >>>  | weird  | board[1][2] | = 'O' ©    |            |           |
| >>>  | weird  | board       |            |            |           |
| [['  | ', '   | , 'O'], ['  | , '', 'O'  | ], ['', '  | ', 'O']]  |

#### O外面的列表其实包含3个指向同一个列表的引用。当我们不做修改的时候，看起来都 还好。

© 一旦我们试图标记第 1 行第 2 列的元素，就立马暴露了列表内的 3 个引用指向同一个 对象的事实。

示例 2-13 犯的错误本质上跟下面的代码犯的错误一样：

row=['_'] * 3 board = [] for i in range(3): board.append(row) O

#### O 追加同一个行对象( row) 3 次到游戏板( board)。

相反，示例 2-12 中的方法等同于这样做：

| >>>  | board = []                          |      |         |       |      |
| ---- | ----------------------------------- | ---- | ------- | ----- | ---- |
| >>>  | for i in range(3):                  |      |         |       |      |
|      | row=['_'] * 3 # O board.append(row) |      |         |       |      |
| >>>  | board                               |      |         |       |      |
| [['  | ', '_', '_'], ['_', '_', '          | _'], | ['_', ' | _', ' | _']] |
| >>>  | board[2][0] = 'X'                   |      |         |       |      |
| >>>  | board # ©                           |      |         |       |      |
| [['  | ', '', ''], ['', '', '              | '],  | ['X', ' | ', '  | ']]  |

#### O每次迭代中都新建了一个列表，作为新的一行(row)追加到游戏板(board)。

#### © 正如我们所期待的，只有第 2 行的元素被修改。

#### 如果你觉得这一节里所说的问题及其对应的解决方法都有点云里雾里，没关

系。第 8 章里我们会详细说明引用和可变对象背后的原理和陷阱。

我们一直在说 + 和 *，但是别忘了我们还有 += 和 *=。随着目标序列的可变性的变化，这

个两个运算符的结果也大相径庭。下一节就来详细讨论。
