---
title: 06 序列的增量赋值
toc: true
date: 2018-07-11 15:00:15
---


### 2.6 序列的增量赋值

增量赋值运算符 += 和 *= 的表现取决于它们的第一个操作对象。简单起见，我们把讨论 集中在增量加法(+=)上，但是这些概念对 *= 和其他增量运算符来说都是一样的。

+= 背后的特殊方法是 __iadd__ (用于“就地加法”)。但是如果一个类没有实现这个方 法的话， Python 会退一步调用 __add__ 。考虑下面这个简单的表达式：

\>>> a += b

如果 a 实现了 __iadd__ 方法，就会调用这个方法。同时对可变序列(例如

list、bytearray 和 array.array)来说，a 会就地改动，就像调用了 a.extend(b)

一样。但是如果 a 没有实现 __iadd__ 的话， a += b 这个表达式的效果就变得跟 a = a + b 一样了：首先计算a + b，得到一个新的对象，然后赋值给a。也就是说，在这个表 达式中，变量名会不会被关联到新的对象，完全取决于这个类型有没有实现 __iadd__ 这 个方法。

总体来讲，可变序列一般都实现了 __iadd__ 方法，因此 += 是就地加法。而不可变序列 根本就不支持这个操作，对这个方法的实现也就无从谈起。

上面所说的这些关于 += 的概念也适用于 *=，不同的是，后者相对应的是 __imul__。关 于 __iadd__ 和 __imul__，第 13 章中会再次提到。

接下来有个小例子，展示的是 *= 在可变和不可变序列上的作用：

| >>> l = [1, 2, 3]  |
| ------------------ |
| >>> id(l)          |
| 4311953800 O       |
| >>> l *= 2         |
| >>> l              |
| [1, 2, 3, 1, 2, 3] |
| >>> id(l)          |
| 4311953800    &    |
| >>> t = (1, 2, 3)  |
| >>> id(t)          |
| 4312681568    ©    |
| >>> t *= 2         |
| >>> id(t)          |
| 4301348296    ©    |

❶ 刚开始时列表的 ID。

❷ 运用增量乘法后，列表的 ID 没变，新元素追加到列表上。 ❸ 元组最开始的 ID。

❹ 运用增量乘法后，新的元组被创建。

对不可变序列进行重复拼接操作的话，效率会很低，因为每次都有一个新对象，而解释器

需要把原来对象中的元素先复制到新的对象里，然后再追加新的元素。 4

|4str是一个例外，因为对字符串做+=实在是太普遍了，所以CPython对它做了优化。为str初始化内存的时候，程 序会为它留出额外的可扩展空间，因此进行増量操作的时候，并不会涉及复制原有字符串到新位置这类操作。

我们已经认识了 += 的一般用法，下面来看一个有意思的边界情况。这个例子可以说是突 出展示了“不可变性”对于元组来说到底意味着什么。

一个关于+=的谜题

读完下面的代码，然后回答这个问题：示例 2-14 中的两个表达式到底会产生什么结果？ 5回答之前不要用控制台去运行这两个式子。

| 5感谢Leonardo Rochael在2013年的Python巴西会议上提到这个谜题。

示例 2-14 一个谜题

\>>> t = (1, 2, [30, 40])

\>>> t[2] += [50, 60]

到底会发生下面 4 种情况中的哪一种？

a.    t 变成 (1, 2, [30, 40, 50, 60])。

b.    因为 tuple 不支持对它的元素赋值，所以会抛出 TypeError 异常。

c.    以上两个都不是。

d.    a 和 b 都是对的。

我刚看到这个问题的时候，异常确定地选择了 b，但其实答案是d，也就是说a和b都是

对的！示例 2-15 是运行这段代码得到的结果，用的 Python 版本是 3.4，但是在 2.7 中结果 也一样。 [1](#bookmark12)

#### Python Tutor （<http://www.pythontutor.com>）是一个对Python运行原理进行可视化分析的工

具。图 2-3 里是两张截图，分别代表示例 2-15 中 t 的初始和最终状态。

■ 1 t = (1, 2, [30, 40])

2 t[2] += [50. 60]

Edit code

[<<first ] [ < tack-| Step 2 of 2 [ Forwaid» j【Last

line that has just executed

next line to execute

t = (1, 2， [30， 40])

2 t[2] += [SO, 60】—

Edit code

[<<nr«t ] [ <Back j Program terminated f ward >

TypeError: 'tuple' object does not support item assignment

line that has just executed next line to execute

![img](08414584Python-13.jpg)



![img](08414584Python-14.jpg)



图 2-3：元组赋值之谜的初始和最终状态（图表由 Python Tutor 网站生成） 下面来看看示例 2-16 中 Python 为表达式 s[a] += b 生成的字节码，可能这个现象背后的 原因会变得清晰起来。

#### 示例 2-16 s[a] = b 背后的字节码

| >>> dis.dis('s[a] += b') |         |      |
| ------------------------ | ------- | ---- |
| 1    0 LOAD_NAME         | 0(s)    |      |
| 3 LOAD_NAME              | 1(a)    |      |
| 6 DUP_TOP_TWO            |         |      |
| 7 BINARY_SUBSCR          |         | O    |
| 8 LOAD_NAME              | 2(b)    |      |
| 11 INPLACE_ADD           |         | ©    |
| 12 ROT_THREE             |         |      |
| 13 STORE_SUBSCR          |         | O    |
| 14 LOAD_CONST            | 0(None) |      |
| 17 RETURN VALUE          |         |      |

#### O将s[a]的值存入TOS （Top Of Stack，栈的顶端）。

©计算TOS += b。这一步能够完成，是因为TOS指向的是一个可变对象（也就是示例 2-15 里的列表）。

#### O s[a] = TOS赋值。这一步失败，是因为s是不可变的元组（示例2-15中的元组 t）。

这其实是个非常罕见的边界情况，在 15 年的 Python 生涯中，我还没见过谁在这个地方吃

过亏。

至此我得到了 3 个教训。

•不要把可变对象放在元组里面。

.增量赋值不是一个原子操作。我们刚才也看到了，它虽然抛出了异常，但还是完成了 操作。

•查看Python的字节码并不难，而且它对我们了解代码背后的运行机制很有帮助。

在见证了 + 和 * 的微妙之处后，我们把话题转移到序列类型的另一个重要部分上：排

序。
