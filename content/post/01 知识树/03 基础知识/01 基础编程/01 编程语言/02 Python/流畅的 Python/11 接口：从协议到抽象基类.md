---
title: 11 接口：从协议到抽象基类
toc: true
date: 2018-06-26 21:37:45
---
## 第 11 章 接口：从协议到抽象基类

抽象类表示接口。 1

——Bjarne Stroustrup C++ 之父

| ^Bjarne Stroustrup, The Design and Evolution of C++ (Addison-Wesley, 1994), p. 278.

本章讨论的话题是接口：从鸭子类型的代表特征动态协议，到使接口更明确、能验证实

现是否符合规定的抽象基类(Abstract Base Class， ABC)。

如果用过Java、C#或类似的语言，你会觉得鸭子类型的非正式协议很新奇。但是对长时 间使用 Python 或 Ruby 的程序员来说，这是接口的“常规”方式，新知识是抽象基类的严格

规定和类型检查。 Python 语言诞生 15 年后， Python 2.6 才引入抽象基类。

本章先说明 Python 社区以往对接口的不严谨理解：部分实现接口通常被认为是可接受

的。我们将通过几个示例强调鸭子类型的动态本性，从而澄清这一点。

接着，我邀请 Alex Martelli 写了一篇短文，对抽象基类做了介绍，还为 Python 编程的一 个新趋势下了定义。本章余下的内容专门讲解抽象基类。首先，本章说明抽象基类的常见

用途：实现接口时作为超类使用。然后，说明抽象基类如何检查具体子类是否符合接口定

义，以及如何使用注册机制声明一个类实现了某个接口，而不进行子类化操作。最后，说

明如何让抽象基类自动“识别”任何符合接口的类——不进行子类化或注册。

我们将实现一个新抽象基类，看看它的运作方式。但是，我和 Alex Martelli 都不建议你自 己编写抽象基类，因为很容易过度设计。

抽象基类与描述符和元类一样，是用于构建框架的工具。因此，只有少数

Python 开发者编写的抽象基类不会对用户施加不必要的限制，让他们做无用功。

下面我们从 Python 风格的角度探讨接口。

### 11.1    Python文化中的接口和协议

引入抽象基类之前， Python 就已经非常成功了，即便现在也很少有代码使用抽象基类。第 1 章就已经讨论了鸭子类型和协议。在 10+3 节，我们把协议定义为非正式的接口，是让 Python 这种动态类型语言实现多态的方式。

接口在动态类型语言中是怎么运作的呢？首先，基本的事实是， Python 语言没有 interface 关键字，而且除了抽象基类，每个类都有接口：类实现或继承的公开属性

（方法或数据属性），包括特殊方法，如 __getitem__ 或 __add__。

按照定义，受保护的属性和私有属性不在接口中：即便“受保护的”属性也只是采用命名约 定实现的（单个前导下划线）；私有属性可以轻松地访问（参见 9+7 节），原因也是如 此。不要违背这些约定。

另一方面，不要觉得把公开数据属性放入对象的接口中不妥，因为如果需要，总能实现读 值方法和设值方法，把数据属性变成特性，使用 obj.attr 句法的客户代码不会受到影

响。 Vector2d 类就是这么做的，示例 11-1 是 Vector2d 类的第一版， x 和 y 是公开属 性。

示例 11-1 vector2d_v0+py： x 和 y 是公开数据属性（代码与示例 9-2 相同）

| class Vector2d: typecode =                 | ’d’                           |
| ------------------------------------------ | ----------------------------- |
| def __init_                                | _(self, x, y):                |
| self.x                                     | = float(x)                    |
| self.y                                     | = float(y)                    |
| def __iter_                                | _(self):                      |
| return                                     | (i for i in (self.x, self.y)) |
| # 下面是其他方法（这个代码清单将其省略了） |                               |

在示例 9-7 中，我们把 x 和 y 变成了只读特性（见示例 11-2）。这是一项重大重构，但是 Vector2d 的接口基本没变：用户仍能读取 my_vector.x 和 my_vector.y。

示例11-2 vector2d_v3+py：使用特性实现x和y （完整的代码清单参见示例9-9）

class Vector2d: typecode = ’d’

def __init__(self, x, y): self.__x = float(x) self.__y = float(y)

@property def x(self):

return self.__x

@property

def y(self):

return self.__y

def __iter__(self):

return (i for i in (self.x, self.y))

\# 下面是其他方法(这个代码清单将其省略了)

关于接口，这里有个实用的补充定义：对象公开方法的子集，让对象在系统中扮演特定的 角色。 Python 文档中的“文件类对象”或“可迭代对象”就是这个意思，这种说法指的不是特 定的类。接口是实现特定角色的方法集合，这样理解正是 Smalltalk 程序员所说的协议， 其他动态语言社区都借鉴了这个术语。协议与继承没有关系。一个类可能会实现多个接 口，从而让实例扮演多个角色。

协议是接口，但不是正式的(只由文档和约定定义)，因此协议不能像正式接口那样施加 限制(本章后面会说明抽象基类对接口一致性的强制)。一个类可能只实现部分接口，这 是允许的。有时，某些 API 只要求“文件类对象”返回字节序列的 .read() 方法。在特定 的上下文中可能需要其他文件操作方法，也可能不需要。

写作本书时， Python 3 中 memoryview 的文档 ([https://docs.python.org/3/library/stdtypes.html#typememoryview](https://docs.python.org/3/library/stdtypes.html%23typememoryview))说，它能处理“支持缓冲协

议的对象”，不过缓冲协议的文档是针对 C API 的。 bytearray 的构造方法

([https://docs.python.org/3/library/functions.html#bytearray](https://docs.python.org/3/library/functions.html%23bytearray))接受“一个符合缓冲接口 的对

象”。如今，文档正在改变用词，使用“字节序列类对象”这样更加友好的表述。 2 我指出

这一点是为了强调，对Python程序员来说，“X类对象”“X协议”和“X接口”都是一个意 思。

2其实，Issue 16518:“add buffer protocol to glossary” (<http://bugs.python.org/issue16518>)做的就是这种修改，把很多“支持缓 冲协议/接口 /API的对象”改成了“字节序列类对象”；“Other mentions of the buffer protocol”( <http://bugs.python.org/issue22581>)也是如此。

序列协议是 Python 最基础的协议之一。即便对象只实现了那个协议最基本的一部分，解

释器也会负责任地处理，如下一节所示。

### 11.2 Python喜欢序列

Python 数据模型的哲学是尽量支持基本协议。对序列来说，即便是最简单的实现， Python 也会力求做到最好。

图 11-1 展示了定义为抽象基类的 Sequence 正式接口。

图 11-1：Sequence 抽象基类和 collections.abc 中相关抽象类的 UML 类图，箭头 由子类指向超类，以斜体显示的是抽象方法

现在，看看示例11-3中的Foo类。它没有继承abc.Sequence，而且只实现了序列协议

的一个方法： __getitem__ （没有实现 __len__ 方法）。

示例 11-3 定义 __getitem__ 方法，只实现序列协议的一部分，这样足够访问元 素、迭代和使用 in 运算符了

\>>> class Foo:

... def __getitem__(self, pos):

... return range(0, 30, 10)[pos]

\>>> f = Foo()

\>>> f[1]

10

\>>> for i in f: print(i)

0

10

20

\>>> 20 in f True

\>>> 15 in f False

虽然没有 __iter__ 方法，但是 Foo 实例是可迭代的对象，因为发现有 __getitem__ 方 法时， Python 会调用它，传入从 0 开始的整数索引，尝试迭代对象（这是一种后备机 制）。尽管没有实现 __contains__ 方法，但是 Python 足够智能，能迭代 Foo 实例，因 此也能使用 in 运算符： Python 会做全面检查，看看有没有指定的元素。

综上，鉴于序列协议的重要性，如果没有 __iter__ 和 __contains__ 方法， Python 会调 用 __getitem__ 方法，设法让迭代和 in 运算符可用。

第1章定义的FrenchDeck类也没有继承abc.Sequence，但是实现了序列协议的两个方 法： __getitem__ 和 __len__。如示例 11-4 所示。

示例 11-4 实现序列协议的 FrenchDeck 类（代码与示例 1-1 相同）

import collections

Card = collections.namedtuple('Card', ['rank', 'suit']) class FrenchDeck:

ranks = [str(n) for n in range(2, 11)] + list('JQKA') suits = 'spades diamonds clubs hearts'.split() def __init__(self):

self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks]

def __len__(self):

return len(self._cards)

def __getitem__(self, position): return self._cards[position]

第 1 章那些示例之所以能用，大部分是由于 Python 会特殊对待看起来像是序列的对象。 Python 中的迭代是鸭子类型的一种极端形式：为了迭代对象，解释器会尝试调用两个不同 的方法。

下面再分析一个示例，着重强调协议的动态本性。

### 11.3 使用猴子补丁在运行时实现协议

示例 11-4 中的 FrenchDeck 类有个重大缺陷：无法洗牌。几年前，第一次编写 FrenchDeck 示例时，我实现了 shuffle 方法。后来，我对 Python 风格有了深刻理解， 我发现如果 FrenchDeck 实例的行为像序列，那么它就不需要 shuffle 方法，因为已经 有 random.shuffle 函数可用，文档中说它的作用是“就地打乱序列

x”（ [https://docs+python+org/3/library/random+html#random+shuffle](https://docs.python.org/3/library/random.html%23random.shuffle)）。

如果遵守既定协议，很有可能增加利用现有的标准库和第三方代码的可能性，

这得益于鸭子类型。

标准库中的 random.shuffle 函数用法如下：

\>>> from random import shuffle >>> l = list(range(10))

\>>> shuffle(l)

\>>> l

[5, 2, 9, 7, 8, 3, 1, 4, 0, 6]

然而，如果尝试打乱 FrenchDeck 实例，会出现异常，如示例 11-5 所示。 示例 11-5 random.shuffle 函数不能打乱 FrenchDeck 实例

\>>> from random import shuffle >>> from frenchdeck import FrenchDeck >>> deck = FrenchDeck()

\>>> shuffle(deck)

Traceback (most recent call last):

File "<stdin>", line 1, in <module>

File ".../python3.3/random.py", line 265, in shuffle x[i], x[j] = x[j], x[i]

TypeError: 'FrenchDeck' object does not support item assignment

错误消息相当明确， “'FrenchDeck' object does not support item

assignment”（'FrenchDeck' 对象不支持为元素赋值）。这个问题的原因是， shuffle 函 数要调换集合中元素的位置，而 FrenchDeck 只实现了不可变的序列协议。可变的序列

还必须提供 __setitem__ 方法。

Python 是动态语言，因此我们可以在运行时修正这个问题，甚至还可以在交互式控制台

中，修正方法如示例 11-6 所示。

示例11-6为FrenchDeck打猴子补丁，把它变成可变的，让random.shuffle函

数能处理（接续示例 11-5）

❶ 定义一个函数，它的参数为 deck、 position 和 card。

❷ 把那个函数赋值给 FrenchDeck 类的 __setitem__ 属性。

❸ 现在可以打乱 deck 了，因为 FrenchDeck 实现了可变序列协议所需的方法。

特殊方法 __setitem__ 的签名在 Python 语言参考手册的“3.3.6. Emulating container types”( [https://docs.python.org/3/reference/datamodel.html#emulating-container-types ](https://docs.python.org/3/reference/datamodel.html%23emulating-container-types))中定

义。语言参考中使用的参数是self、key和value，而这里使用的是deck、position 和card。这么做是为了告诉你，每个Python方法说到底都是普通函数，把第一个参数命 名为 self 只是一种约定。在控制台会话中使用那几个参数没问题，不过在 Python 源码文 件中最好按照文档那样使用 self、 key 和 value。

这里的关键是， set_card 函数要知道 deck 对象有一个名为 _cards 的属性，而且 _cards 的值必须是可变序列。然后，我们把 set_card 函数赋值给特殊方法 __setitem__，从而把它依附到 FrenchDeck 类上。这种技术叫猴子补丁：在运行时修

改类或模块，而不改动源码。猴子补丁很强大，但是打补丁的代码与要打补丁的程序耦合

十分紧密，而且往往要处理隐藏和没有文档的部分。

除了举例说明猴子补丁之外，示例11-6还强调了协议是动态的：random.shuffle函数 不关心参数的类型，只要那个对象实现了部分可变序列协议即可。即便对象一开始没有所

需的方法也没关系，后来再提供也行。

目前，本章讨论的主题是“鸭子类型”：对象的类型无关紧要，只要实现了特定的协议即

可。

前面给出的抽象基类图表是为了展示协议与抽象基类的文档中所说的接口之间的关系，但

是目前为止还没有真正继承抽象基类。

在接下来的几节中，我们将直接使用抽象基类，而不只将其当作文档。

### 11.4 Alex Martelli 的水禽

介绍完 Python 常规的协议风格接口后，下面讨论抽象基类。不过在分析示例和细节之

前，我们要看 Alex Martelli 写的一篇短文。这篇短文说明了 Python 为什么引入抽象基 类。

非常感谢Alex Martelli。本书引用最多的就是他说的话，后来他变成了本书的

技术编辑之一。他的见解已经非常宝贵了，现在又愿意撰写这篇短文。 Python 社区有

他的存在真是幸运。接下来交给你了， Alex ！

水禽和抽象基类

Alex Martelli 撰

维基百科([http://en.wikipedia.org/wiki/Duck_typing#History](http://en.wikipedia.org/wiki/Duck_typing%23History))说是我协助传播了“鸭子

类型”这种言简意赅的说法(即忽略对象的真正类型，转而关注对象有没有实现所需

的方法、签名和语义)。

对 Python 来说，这基本上是指避免使用 isinstance 检查对象的类型(更别提

type(foo) is bar 这种更糟的检查方式了，这样做没有任何好处，甚至禁止最简 单的继承方式)。

总的来说，鸭子类型在很多情况下十分有用；但是在其他情况下，随着发展，通常

有更好的方式。事情是这样的+ + + + + +

近代，属和种(包括但不限于水禽所属的鸭科)基本上是根据表型系统学

(phenetics)分类的。表征学关注的是形态和举止的相似性+ + + + + +主要是表型系统学特 征。因此使用“鸭子类型”比喻是贴切的。

然而，平行进化往往会导致不相关的种产生相似的特征，形态和举止方面都是如此，

但是生态位的相似性是偶然的，不同的种仍属不同的生态位。编程语言中也有这

种“偶然的相似性”，比如说下述经典的面向对象编程示例：

class Artist:

def draw(self): ...

class Gunslinger:

def draw(self): ...

class Lottery:

def draw(self): ...

显然，只因为 x 和 y 两个对象刚好都有一个名为 draw 的方法，而且调用时不用传入

参数，即x.draw（）和y.draw（），远远不能确保二者可以相互调用，或者具有相同

的抽象。也就是说，从这样的调用中不能推导出语义相似性。相反，我们需要一位渊

博的程序员主动把这种等价维持在一定层次上。

生物（和其他学科）遇到的这个问题，迫切需要（从很多方面来说，是催生）表征学

之外的分类方式解决，即支序系统学（cladistics）。这种分类学主要根据从共同祖

先那里继承的特征分类，而不是单独进化的特征。（近些年， DNA 测序变得便宜又

快，这使支序学的实用地位变得更高。）

例如，草雁（以前认为与其他鹅类比较相似）和麻鸭（以前认为与其他鸭类比较相

似）现在被分到 Tadornidae 亚科（表明二者的相似性比鸭科中其他动物高，因为它们

的共同祖先比较接近）。此外， DNA 分析表明，白翅木鸭与美洲家鸭（属于麻鸭） 不是很像，至少没有形态和举止看起来那么像，因此把木鸭单独分成了一属，完全不

在 Tadornidae 亚科中。

知道这些有什么用呢？视情况而定！比如，逮到一只水禽后，决定如何烹制才最美味 时，显著的特征（不是全部，例如一身羽毛并不重要）主要是口感和风味（过时的表 征学），这比支序学重要得多。但在其他方面，如对不同病原体的抗性（圈养水禽还 是放养）， DNA 接近性的作用就大多了……

因此，参照水禽的分类学演化，我建议在鸭子类型的基础上增加白鹅类型（goose typing）。

白鹅类型指，只要cls是抽象基类，即cls的元类是abc.ABCMeta，就可以使用 isinstance（obj, cls）。

collections.abc中有很多有用的抽象类（Python标准库的numbers模块中还有一

些）。 3

与具体类相比，抽象基类有很多理论上的优点（例如，参阅Scott Meyer写的《More Effective C++： 35 个改善编程与设计的有效方法（中文版）》的“条款 33：将非尾端 类设计为抽象类”，英文版见

<http://ptgmedia.pearsoncmg.com/images/020163371x/items/item33.html>） ， Python 的抽象

基类还有一个重要的实用优势：可以使用 register 类方法在终端用户的代码中把某

个类“声明”为一个抽象基类的“虚拟”子类（为此，被注册的类必须满足抽象基类对方

法名称和签名的要求，最重要的是要满足底层语义契约；但是，开发那个类时不用了

解抽象基类，更不用继承抽象基类）。这大大地打破了严格的强耦合，与面向对象编

程人员掌握的知识有很大出入，因此使用继承时要小心。

有时，为了让抽象基类识别子类，甚至不用注册。

其实，抽象基类的本质就是几个特殊方法。例如：

True

可以看出，无需注册， abc.Sized 也能把 Struggle 识别为自己的子类，只要实现

了特殊方法 __len__ 即可（要使用正确的句法和语义实现，前者要求没有参数，后 者要求返回一个非负整数，指明对象的长度；如果不使用规定的句法和语义实现特殊 方法，如 __len__，会导致非常严重的问题）。

最后我想说的是：如果实现的类体现了 numbers、collections.abc 或其他框架中 抽象基类的概念，要么继承相应的抽象基类（必要时），要么把类注册到相应的抽象 基类中。开始开发程序时，不要使用提供注册功能的库或框架，要自己动手注册；如 果必须检查参数的类型（这是最常见的），例如检查是不是“序列”，那就这样做：

isinstance(the_arg, collections.abc.Sequence)

此外，不要在生产代码中定义抽象基类（或元类）++++++如果你很想这样做，我打赌

可能是因为你想“找茬”，刚拿到新工具的人都有大干一场的冲动。如果你能避开这些

深奥的概念，你（以及未来的代码维护者）的生活将更愉快，因为代码会变得简洁明

了。再会！

3当然，你还可以自己定义抽象基类，但是我不建议高级 Python 程序员之外的人这么做；同样，我也不建议你自己定 义元类++我说的“高级 Python 程序员”是指对 Python 语言的一招一式都了如指掌，即便对这类人来说，抽象基类和元 类也不是常用工具。如此“深层次的元编程”，如果可以这么讲的话，适合框架的作者使用，这样便于众多不同的开发

团队独立扩展框架 真正需要这么做的“高级Python程序员”不超过1°%。 Alex Martelli

除了提出“白鹅类型”之外， Alex 还指出，继承抽象基类很简单，只需要实现所需的方 法，这样也能明确表明开发者的意图。这一意图还能通过注册虚拟子类来实现。

此外，使用 isinstance 和 issubclass 测试抽象基类更为人接受。过去，这两个函数用 来测试鸭子类型，但用于抽象基类会更灵活。毕竟，如果某个组件没有继承抽象基类，事

后还可以注册，让显式类型检查通过。

然而，即便是抽象基类，也不能滥用 isinstance 检查，用得多了可能导致代码异味，

即表明面向对象设计得不好。在一连串 if/elif/elif 中使用 isinstance 做检查，然 后根据对象的类型执行不同的操作，通常是不好的做法；此时应该使用多态，即采用一

定的方式定义类，让解释器把调用分派给正确的方法，而不使用 if/elif/elif 块硬编

码分派逻辑。

具体使用时，上述建议有一个常见的例外：有些Python API接受一个字符串或

字符串序列；如果只有一个字符串，可以把它放到列表中，从而简化处理。因为字符

串是序列类型，所以为了把它和4 其他不可变序列区分开，最简单的方式是使用 isinstance（x, str） 检查。[1](#bookmark10)

bytearray 类型。

另一方面，如果必须强制执行 API 契约，通常可以使用 isinstance 检查抽象基类。 “老

兄，如果你想调用我，必须实现这个”，正如本书技术审校 Lennart Regebro 所说的。这对

采用插入式架构的系统来说特别有用。在框架之外，鸭子类型通常比类型检查更简单，也

更灵活。

例如，本书有几个示例要使用序列，把它当成列表处理。我没有检查参数的类型是不是 list，而是直接接受参数，立即使用它构建一个列表。这样，我就可以接受任何可迭代

对象；如果参数不是可迭代对象，调用立即失败，并且提供非常清晰的错误消息。本章后 面示例 11-13 中的代码就是这么做的。当然，如果序列太长或者需要就地修改序列而导致 无法复制参数，就不能采用这种方式；此时，使用 isinstance(x,

abc.MutableSequence) 更好。如果可以接受任何可迭代对象，也可以调用 iter(x) 函 数获得一个迭代器，详情参见 14.1.1 节。

模仿

collections.namedtuple ([https://docs.python.org/3/library/collections.html#collections.nam](https://docs.python.org/3/library/collections.html%23collections.namedtuple) 处理field_names参数的方式也是一例：field_names的值可以是单个字符串，以空格

或逗号分隔标识符，也可以是一个标识符序列。此时可能想使用isinstance，但我会使

用鸭子类型，如示例 11-7 所示。 5

| 5这段代码摘自示例21-2。

示例 11-7 使用鸭子类型处理单个字符串或由字符串组成的可迭代对象

| try: Ofield_names = field_names.replace(',', '               | ■).split() © |
| ------------------------------------------------------------ | ------------ |
| except AttributeError: © pass Qfield_names = tuple(field_names)❺ |              |

❶假设是单个字符串(EAFP风格，即卩“取得原谅比获得许可容易”)。

❷ 把逗号替换成空格，然后拆分成名称列表。

❸ 抱歉， field_names 看起来不像是字符串++ 没有 .replace 方法，或者返回值不能 使用 .split 方法拆分。

❹ 假设已经是由名称组成的可迭代对象了。

❺ 为了确保的确是可迭代对象，也为了保存一份副本，使用所得值创建一个元组。

在那篇短文的最后， Alex 多次强调，要抑制住创建抽象基类的冲动。滥用抽象基类会造 成灾难性后果，表明语言太注重表面形式，这对以实用和务实著称的 Python 可不是好 事。在审阅本书的过程中， Alex 写道：

抽象基类是用于封装框架引入的一般性概念和抽象的，例如“一个序列”和“一个确切 的数”。（读者）基本上不需要自己编写新的抽象基类，只要正确使用现有的抽象基

类，就能获得 99.9% 的好处，而不用冒着设计不当导致的巨大风险。

下面通过实例讲解白鹅类型。

### 11.5 定义抽象基类的子类

我们将遵循 Martelli 的建议，先利用现有的抽象基类

(collections.MutableSequence)，然后再斗胆自己定义。在示例11-8中，我们明 确把 FrenchDeck2 声明为 collections.MutableSequence 的子类。

示例 11-8 frenchdeck2.py： FrenchDeck2， collections.MutableSequence 的子

类

import collections

Card = collections.namedtuple('Card', ['rank', 'suit'])

class FrenchDeck2(collections.MutableSequence):

ranks = [str(n) for n in range(2, 11)] + list('JQKA') suits = 'spades diamonds clubs hearts'.split() def __init__(self):

self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks]

def __len__(self):

return len(self._cards)

def __getitem__(self, position): return self._cards[position]

def __setitem__(self, position, value): # O self._cards[position] = value

def _delitem_(self, position): # © del self._cards[position]

def insert(self, position, value): # © self._cards.insert(position, value)

❶ 为了支持洗牌，只需实现 __setitem__ 方法。

❷ 但是继承 MutableSequence 的类必须实现 __delitem__ 方法，这是

MutableSequence 类的一个抽象方法。

❸ 此外，还要实现 insert 方法，这是 MutableSequence 类的第三个抽象方法。

导入时(加载并编译 frenchdeck2.py 模块时)， Python 不会检查抽象方法的实现，在运行

时实例化 FrenchDeck2 类时才会真正检查。因此，如果没有正确实现某个抽象方法， Python 会抛出 TypeError 异常，并把错误消息设为"Can't instantiate abstract class FrenchDeck2 with abstract methods __delitem__, insert"。正是这个原因，即 便 FrenchDeck2 类不需要 __delitem__ 和 insert 提供的行为，也要实现，因为 MutableSequence 抽象基类需要它们。

如图 11-2 所示， Sequence 和 MutableSequence 抽象基类的方法不全是抽象的。

图 11-2： MutableSequence 抽象基类和 collections.abc 中它的超类的 UML 类图 （箭头由子类指向祖先；以斜体显示的名称是抽象类和抽象方法）

FrenchDeck2 从 Sequence 继承了几个拿来即用的具体方

法： __contains__、__iter__、__reversed__、index 和 count。 FrenchDeck2 从 MutableSequence 继承了 append、extend、pop、remove 和__iadd__。

在 collections.abc 中，每个抽象基类的具体方法都是作为类的公开接口实现的，因此

不用知道实例的内部接口。

要想实现子类，我们可以覆盖从抽象基类中继承的方法，以更高效的方式重新 实现。例如， __contains__ 方法会全面扫描序列，可是，如果你定义的序列按顺序 保存元素，那就可以重新定义 __contains__ 方法，使用 bisect 函数做二分查找

（参见 2.8 节），从而提升搜索速度。

为了充分使用抽象基类，我们要知道有哪些抽象基类可用。接下来介绍集合抽象基类。

### 11.6标准库中的抽象基类

从 Python 2.6 开始，标准库提供了抽象基类。大多数抽象基类在 collections.abc 模块

中定义，不过其他地方也有。例如，numbers和io包中有一些抽象基类。但 是， collections.abc 中的抽象基类最常用。我们来看看这个模块中有哪些抽象基类。

11.6.1 collections.abc模块中的抽象基类

标准库中有两个名为abc的模块，这里说的是collections.abc。为了减少

加载时间， Python 3.4 在 collections 包之外实现这个模块(在 Lib/_collections_abc.py

中，<https://hg.python.org/cpython/file/3.4/Lib/_collections_abc.py>)，因此要与 collections分开导入。另一个abc模块就是abc (即

Lib/abc.py， <https://hg.python.org/cpython/file/3.4/Lib/abc.py>) ，这里定义的是 abc.ABC 类。每个抽象基类都依赖这个类，但是不用导入它，除非定义新抽象基类。

Python 3.4 在 collections.abc 模块中定义了 16 个抽象基类，简要的 UML 类图(没有 属性名称)如图 11-3 所示。 collections.abc 的官方文档中有个不错的表格

([https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes](https://docs.python.org/3/library/collections.abc.html%23collections-abstract-base-classes)) ，对

各个抽象基类做了总结，说明了相互之间的关系，以及各个基类提供的抽象方法和具体方

法(称为“混入方法”)。图 11-3 中有很多多重继承。我们将在第 12 章着重说明多重继 承，讨论抽象基类时通常不用考虑多重继承。 6

Java认为多重继承有危害，因此没有提供支持，但是提供了接口： Java的接口可以扩展多个接口，而且Java的类可 以实现多个接口。

图 11-3： collections.abc 模块中各个抽象基类的 UML 类图 下面详述图 11-3 中那一群基类。

Iterable、Container 和 Sized

各个集合应该继承这三个抽象基类，或者至少实现兼容的协议。 Iterable 通过 __iter__ 方法支持迭代， Container 通过 __contains__ 方法支持 in 运算符， Sized 通过 __len__ 方法支持 len() 函数。

Sequence、Mapping 和 Set

这三个是主要的不可变集合类型，而且各自都有可变的子类。 MutableSequence 的 详细类图见图 11-2；MutableMapping 和 MutableSet 的类图在第 3 章中(见图 3-1 和图

3-2)。

MappingView

在 Python 3 中，映射方法 .items()、.keys() 和 .values() 返回的对象分别是 ItemsView、KeysView 和 ValuesView 的实例。前两个类还从 Set 类继承了丰富的接 口，包含 3.8.3 节所述的全部运算符。

Callable 和 Hashable

这两个抽象基类与集合没有太大的关系，只不过因为 collections.abc 是标准库中 定义抽象基类的第一个模块，而它们又太重要了，因此才把它们放到 collections.abc 模块中。我从未见过 Callable 或 Hashable 的子类。这两个抽象基类的主要作用是为内 置函数 isinstance 提供支持，以一种安全的方式判断对象能不能调用或散列。 7

7若想检查是否能调用，可以使用内置的 callable() 函数；但是没有类似的 hashable() 函数，因此测试对象是否可

散列，最好使用 isinstance(my_obj, Hashable)。

Iterator

注意它是 Iterable 的子类。我们将在第 14 章详细讨论。

继collections.abc之后，标准库中最有用的抽象基类包是numbers。下面就来介绍。

11.6.2 抽象基类的数字塔

numbers 包([https://docs+pyhon+org/3/library/numbers+html](https://docs.python.org/3/library/numbers.html))定义的是“数字塔”(即各个抽 象基类的层次结构是线性的)，其中 Number 是位于最顶端的超类，随后是 Complex 子 类，依次往下，最底端是 Integral 类：

•    Number

•    Complex

•    Real

•    Rational

•    Integral

因此，如果想检查一个数是不是整数，可以使用 isinstance(x,

numbers.Integral)，这样代码就能接受int、bool (int的子类)，或者外部库使用 numbers 抽象基类注册的其他类型。为了满足检查的需要，你或者你的 API 的用户始终 可以把兼容的类型注册为 numbers.Integral 的虚拟子类。

与之类似，如果一个值可能是浮点数类型，可以使用 isinstance(x, numbers.Real) 检查。这样代码就能接受bool、int、float、fractions .Fraction，或者外部库(如

NumPy，它做了相应的注册)提供的非复数类型。

decimal.Decimal没有注册为numbers. Real的虚拟子类，这有点奇怪。 没注册的原因是，如果你的程序需要 Decimal 的精度，要防止与其他低精度数字类 型混淆，尤其是浮点数。

了解一些现有的抽象基类之后，我们将从零开始实现一个抽象基类，然后实际使用，以此

实践白鹅类型。这么做的目的不是鼓励每个人都立即开始定义抽象基类，而是教你怎么阅

读标准库和其他包中的抽象基类源码。

### 11.7定义并使用一个抽象基类

为了证明有必要定义抽象基类，我们要在框架中找到使用它的场景。想象一下这个场景：

你要在网站或移动应用中显示随机广告，但是在整个广告清单轮转一遍之前，不重复显示

广告。假设我们在构建一个广告管理框架，名为ADAM。它的职责之一是，支持用户提供

随机挑选的无重复类。 8 为了让 ADAM 的用户明确理解“随机挑选的无重复”组件是什么意

思，我们将定义一个抽象基类。

8客户可能要审查随机发生器，或者代理想作弊......谁知道呢！

受到“栈”和“队列”(以物体的排放方式说明抽象接口)启发，我将使用现实世界中的物品

命名这个抽象基类：宾果机和彩票机是随机从有限的集合中挑选物品的机器，选出的物品

没有重复，直到选完为止。

我们把这个抽象基类命名为Tombola，这是宾果机和打乱数字的滚动容器的意大利名。9 9牛津英语词典对tombola的定义是“像对号游戏(lotto)那样的彩票(lottery) ”。

Tombola 抽象基类有四个方法，其中两个是抽象方法。

•    .load(...):把元素放入容器。

•    .pick()：从容器中随机拿出一个元素，返回选中的元素。

另外两个是具体方法。

•    .loaded():如果容器中至少有一个元素，返回True。

•    .inspect():返回一个有序元组，由容器中的现有元素构成，不会修改容器的内容

(内部的顺序不保留)。

图 11-4 展示了 Tombola 抽象基类和三个具体实现。

图 11-4：一个抽象基类和三个子类的 UML 类图。根据 UML 的约定， Tombola 抽象基 类和它的抽象方法使用斜体。虚线箭头用于表示接口实现，这里它表示 TomboList 是 Tombola 的虚拟子类，因为 TomboList 是注册的，本章后面会说明这一点 [2](#bookmark19)

| [2](#bookmark19)«registered» 和《virtual subclass»不是标准的UML词汇。我们使用二者表示Python类之间的关系。

Tombola 抽象基类的定义如示例 11-9 所示。

示例 11-9 tombola.py：Tombola 是抽象基类，有两个抽象方法和两个具体方法

"""返回一个有序元组，由当前元素构成

items = []

while True: © try:

items.append(self.pick()) except LookupError:

break

self.load(items) O

return tuple(sorted(items))

我选择使用 LookupError 异常的原因是，在 Python 的异常层次关系中，它与 IndexError 和 KeyError 有关，这两个是具体实现 Tombola 所用的数据结构最有可能抛 出的异常。据此，实现代码可能会抛出 LookupError、 IndexError 或 KeyError 异常。

异常的部分层次结构如示例1211-10 所示（完整的层次结构参见 Python 标准库文档中的“5+4+ Exception hi erarchy” 一节。12 ）

| 12见 [https://docs+python+org/dev/library/exceptions+html#exception-hierarchy](https://docs.python.org/dev/library/exceptions.html%23exception-hierarchy)。-编者注

示例 11-10 异常类的部分层次结构

BaseException —SystemExit —KeyboardInterrupt —GeneratorExit

1— Exception

—StopIteration —ArithmeticError

I— FloatingPointError I— OverflowError I— ZeroDivisionError —AssertionError



—AttributeError —BufferError

—EOFError —ImportError —LookupError O

I— IndexError I— KeyError © —MemoryError



... etc.

#### ❶ 我们在 Tombola.inspect 方法中处理的是 LookupError 异常。

❷ IndexError 是 LookupError 的子类，尝试从序列中获取索引超过最后位置的元素时

抛出。

❸ 使用不存在的键从映射中获取元素时，抛出 KeyError 异常。

我们自己定义的 Tombola 抽象基类完成了。为了一睹抽象基类对接口所做的检查，下面 我们尝试使用一个有缺陷的实现来糊弄Tombola，如示例11-11所示。

示例 11-11 不符合 Tombola 要求的子类无法蒙混过关

❶ 把 Fake 声明为 Tombola 的子类。

❷ 创建了 Fake 类，目前没有错误。

❸尝试实例化Fake时抛出了 TypeError。错误消息十分明确：Python认为Fake是抽象 类，因为它没有实现 load 方法，这是 Tombola 抽象基类声明的抽象方法之一。

我们的第一个抽象基类定义好了，而且还用它实际验证了一个类。稍后我们将定义 Tombola 抽象基类的子类，在此之前必须说明抽象基类的一些编程规则。

11.7.1 抽象基类句法详解

声明抽象基类最简单的方式是继承 abc.ABC 或其他抽象基类。

然而，abc.ABC是Python 3.4新增的类，因此如果你使用的是旧版Python，那么无法继承 现有的抽象基类。此时，必须在 class 语句中使用 metaclass= 关键字，把值设为 abc.ABCMeta （不是abc.ABC）。在示例11-9中，可以写成：

class Tombola(metaclass=abc.ABCMeta):

\# ...

metaclass= 关键字参数是 Python 3 引入的。在 Python 2 中必须使用 __metaclass__ 类

属性：

class Tombola(object): # 这是 Python 2!!! __metaclass__ = abc.ABCMeta

\# ...

元类将在第 21 章讲解。现在，我们暂且把元类理解为一种特殊的类，同样也把抽象基类

理解为一种特殊的类。例如， “常规的”类不会检查子类，因此这是抽象基类的特殊行为。

除了 @abstractmethod 之外， abc 模块还定义了

@abstractclassmethod、@abstractstaticmethod 和 @abstractproperty 三个装饰

器。然而，后三个装饰器从 Python 3.3 起废弃了，因为装饰器可以在 @abstractmethod 上堆叠，那三个就显得多余了。例如，声明抽象类方法的推荐方式是：

| class MyABC(abc.ABC):@classmethod@abc.abstractmethoddef an_abstract_classmethod(cls, . | ..): |
| ------------------------------------------------------------ | ---- |
| pass                                                         |      |

#### 在函数上堆叠装饰器的顺序通常很重要， @abstractmethod 的文档就特别指出: 与其他方法描述符一起使用时， abstractmethod() 应该放在最里层， ..13

也就是说，在 @abstractmethod 和 def 语句之间不能有其他装饰器。

I 13出自abc模块文档中的@abc. abstractmethod词条

([https://docs.python.org/dev/library/abc.html#abc.abstractmethod](https://docs.python.org/dev/library/abc.html%23abc.abstractmethod))。

#### 说明抽象基类的句法之后，我们要通过实现几个功能完善的具体子代来使用 Tombola。

11.7.2定义Tombola抽象基类的子类

定义好 Tombola 抽象基类之后，我们要开发两个具体子类，满足 Tombola 规定的接口。 这两个子类的类图如图 11-4 所示，图中还有将在下一节讨论的虚拟子类。

示例 11-12 中的 BingoCage 类是在示例 5-8 的基础上修改的，使用了更好的随机发生

器。BingoCage实现了所需的抽象方法load和pick，从Tombola中继承了 loaded方

法，覆盖了 inspect 方法，还增加了 __call__ 方法。

示例 11-12 bingo.py: BingoCage 是 Tombola 的具体子类

import random

from tombola import Tombola

class BingoCage(Tombola): O

def __init__(self, items):

self._randomizer = random.SystemRandom() © self._items = []

self.load(items) ©

def load(self, items):

self._items.extend(items) self._randomizer.shuffle(self._items) o

def pick(self):❺ try:

return self._items.pop() except IndexError:

raise LookupError('pick from empty BingoCage')

def __call__(self): © self.pick()

#### ❶ 明确指定 BingoCage 类扩展 Tombola 类。

❷ 假设我们将在线上游戏中使用这个。 random.SystemRandom 使用 os.urandom(...) 函数实现random API。根据os模块的文档

([http://docs.python.org/3/library/os.html#os.urandom](http://docs.python.org/3/library/os.html%23os.urandom)) ， os.urandom(...) 函数生成“适合

用于加密”的随机字节序列。

❸ 委托 .load(...) 方法实现初始加载。

❹ 没有使用 random.shuffle() 函数，而是使用 SystemRandom 实例的 .shuffle() 方 法。

❺ pick 方法的实现方式与示例 5-8 一样。

❻ __call__ 也跟示例 5-8 中的一样。它没必要满足 Tombola 接口，添加额外的方法没 有问题。

BingoCage 从 Tombola 中继承了耗时的 loaded 方法和笨拙的 inspect 方法。这两个方 法都可以覆盖，变成示例 11-13 中速度更快的一行代码。这里想表达的观点是：我们可以 偷懒，直接从抽象基类中继承不是那么理想的具体方法。从 Tombola 中继承的方法没有 BingoCage 自己定义的那么快，不过只要 Tombola 的子类正确实现 pick 和 load 方法，

就能提供正确的结果。

示例 11-13 是 Tombola 接口的另一种实现，虽然与之前不同，但完全有

效。 LotteryBlower 打乱“数字球”后没有取出最后一个，而是取出一个随机位置上的

球。

示例 11-13 lotto.py： LotteryBlower 是 Tombola 的具体子类，覆盖了继承的 inspect 和 loaded 方法

import random

from tombola import Tombola class LotteryBlower(Tombola):

def __init__(self, iterable):

self._balls = list(iterable) O

def load(self, iterable):

self._balls.extend(iterable)

def pick(self): try:

position = random.randrange(len(self._balls)) © except ValueError:

raise LookupError('pick from empty LotteryBlower') return self._balls.pop(position) ©

def loaded(self): ©

return bool(self._balls) return tuple(sorted(self._balls))

❶ 初始化方法接受任何可迭代对象：把参数构建成列表。

❷ 如果范围为空， random.randrange（...）函数抛出 ValueError，为了兼容 Tombola，我们捕获它，抛出LookupError。

❸ 否则，从 self._balls 中取出随机选中的元素。

❹ 覆盖 loaded 方法，避免调用 inspect 方法（示例 11-9 中的 Tombola.loaded 方法是 这么做的）。我们可以直接处理 self._balls 而不必构建整个有序元组，从而提升速 度。

❺ 使用一行代码覆盖 inspect 方法。

示例 11-13 中有个习惯做法值得指出：在 __init__ 方法中， self._balls 保存的是 list（iterable），而不是iterable的引用（即没有直接把iterable赋值给 self._balls）。前面说过，14这样做使得LotteryBlower更灵活，因为iterable参 数可以是任何可迭代的类型。把元素存入列表中还确保能取出元素。就算 iterable 参数 始终传入列表， list（iterable） 会创建参数的副本，这依然是好的做法，因为我们要从 中删除元素，而客户可能不希望自己提供的列表被修改。 15

14我在Martelli写的“水禽和抽象基类”短文之后以此为例说明鸭子类型。

15+4+2节专门讨论了这种防止混淆别名的问题。

接下来要讲白鹅类型的重要动态特性了：使用 register 方法声明虚拟子类。

11.7.3 Tombola的虚拟子类

白鹅类型的一个基本特性（也是值得用水禽来命名的原因）：即便不继承，也有办法把一 个类注册为抽象基类的虚拟子类。这样做时，我们保证注册的类忠实地实现了抽象基类 定义的接口，而 Python 会相信我们，从而不做检查。如果我们说谎了，那么常规的运行 时异常会把我们捕获。

注册虚拟子类的方式是在抽象基类上调用 register 方法。这么做之后，注册的类会变成 抽象基类的虚拟子类，而且 issubclass 和 isinstance 等函数都能识别，但是注册的类 不会从抽象基类中继承任何方法或属性。

虚拟子类不会继承注册的抽象基类，而且任何时候都不会检查它是否符合抽 象基类的接口，即便在实例化时也不会检查。为了避免运行时错误，虚拟子类要实现 所需的全部方法。

register 方法通常作为普通的函数调用（参见 11+9 节），不过也可以作为装饰器使用。

在示例 11-14 中，我们使用装饰器句法实现了 TomboList 类，这是 Tombola 的一个虚拟 子类，如图 11-5 所示。

图 11-5：TomboList 的 UML 类图，它是 list 的真实子类和 Tombola 的虚拟子类 TomboList 能像它宣称的那样使用， doctest 能证明这一点，详情参见 11.8 节。

示例 11-14 tombolist.py：TomboList 是 Tombola 的虚拟子类

from random import randrange

from tombola import Tombola

@Tombola.register # O

class TomboList(list): # ©

def pick(self): if self: # ©

position = randrange(len(self)) return self.pop(position) # o

else:

load = list.extend # ©

def loaded(self):

return bool(self) # ©

def inspect(self):

return tuple(sorted(self))

\# Tombola.register(TomboList) # ©

Tombolist.__mro__中没有Tombola，因此Tombolist没有从Tombola中继承任何方

法。

我编写了几个类，实现了相同的接口，现在我需要一种编写 doctest 的方式来涵盖不同的 实现。下一节说明如何利用常规类和抽象基类的 API 编写 doctest。

[1](#footnote1)

可惜，在Python 3.4中没有能把字符串和元组或其他不可变序列区分开的抽象基类，因此必须测试str。在Python 2 中， basestr 类型可以协助这样的测试。 basestr 不是抽象基类，但它是 str 和 unicode 的超类；然而， Python 3 把 basestr 去掉了。奇怪的是， Python 3 中有个 collections.abc.ByteString 类型，但是它只能检测 bytes 和

[2](#footnote2)

import abc

class Tombola(abc.ABC): O

@abc.abstractmethod

def load(self, iterable): ©

"""从可迭代对象中添加元素。 """

@abc.abstractmethod def pick(self): ©

"""随机删除元素，然后将其返回。

如果实例为空，这个方法应该抛出'LookupError'

def loaded(self): ©

"""如果至少有一个元素，返回'True'，否则返回'False' return bool(self.inspect())❺

### 11.8    Tombola子类的测试方法

#### 我编写的 Tombola 示例测试脚本用到两个类属性，用它们内省类的继承关系。

#### __subclasses__()

#### 这个方法返回类的直接子类列表，不含虚拟子类。

#### _abc_registry

只有抽象基类有这个数据属性，其值是一个 WeakSet 对象，即抽象类注册的虚拟子 类的弱引用。

为了测试 Tombola 的所有子类，我编写的脚本迭代 Tombola.__subclasses__() 和 Tombola._abc_registry 得到的列表，然后把各个类赋值给在 doctest 中使用的 ConcreteTombola。

#### 这个测试脚本成功运行时输出的结果如下：

| $ python3 tombola_runner.py |      |        |      |        |      |
| --------------------------- | ---- | ------ | ---- | ------ | ---- |
| BingoCage                   | 24   | tests, | 0    | failed | - OK |
| LotteryBlower               | 24   | tests, | 0    | failed | - OK |
| TumblingDrum                | 24   | tests, | 0    | failed | - OK |
| TomboList                   | 24   | tests, | 0    | failed | - OK |

#### 测试脚本的代码在示例 11-15 中， doctest 在示例 11-16 中。

示例 11-15 tombola_runner+py：Tombola 子类的测试运行程序

import doctest

from tombola import Tombola

\# 要测试的模块

import bingo, lotto, tombolist, drum O

TEST_FILE = 'tombola_tests.rst'

TEST_MSG = '{0:16} {1.attempted:2} tests, {1.failed:2} failed - {2}' def main(argv):

verbose = '-v' in argv

real_subclasses = Tombola.__subclasses__()    ©

virtual_subclasses = list(Tombola._abc_registry) ©

for cls in real_subclasses + virtual_subclasses: o test(cls, verbose)

res = doctest.testfile(

TEST_FILE,

globs={'ConcreteTombola': cls},❺ verbose=verbose,

optionflags=doctest.REPORT_ONLY_FIRST_FAILURE)

tag = 'FAIL' if res.failed else 'OK' print(TEST_MSG.format(cls.__name__, res, tag)) ©

if __name__ == '__main__': import sys main(sys.argv)

#### ❶ 导入包含 Tombola 真实子类和虚拟子类的模块，用于测试。

❷ __subclasses__() 返回的列表是内存中存在的直接子代。即便源码中用不到想测试 的模块，也要将其导入，因为要把那些类载入内存。

❸ 把 _abc_registry(WeakSet 对象)转换成列表，这样方能与 __subclasses__() 的结果拼接起来。

❹ 迭代找到的各个子类，分别传给 test 函数。

❺ 把 cls 参数(要测试的类)绑定到全局命名空间里的 ConcreteTombola 名称上，供 doctest 使用。

❻ 输出测试结果，包含类的名称、尝试运行的测试数量、失败的测试数量，以及 'OK' 或 'FAIL' 标记。

doctest 文件如示例 11-16 所示。

示例 11-16 tombola_tests.rst：Tombola 子类的 doctest

Tombola tests

Every concrete subclass of Tombola should pass these tests.

Create and load instance from iterable::

\>>> balls = list(range(3))

\>>> globe = ConcreteTombola(balls) >>> globe.loaded()

True

\>>> globe.inspect()

(0, 1, 2)

Pick and collect balls::

\>>> picks = []

\>>> picks.append(globe.pick()) >>> picks.append(globe.pick()) >>> picks.append(globe.pick())

Check state and results::

\>>> globe.loaded()

False

\>>> sorted(picks) == balls True

Reload::

\>>> globe.load(balls)

\>>> globe.loaded()

True

\>>> picks = [globe.pick() for i in balls] >>> globe.loaded()

False

Check that 'LookupError' (or a subclass) is the exception thrown when the device is empty::

\>>> globe = ConcreteTombola([])

\>>> try:

... globe.pick()

... except LookupError as exc:

... print('OK')

OK

Load and pick 100 balls to verify that they all come out::

\>>> balls = list(range(100))

\>>> globe = ConcreteTombola(balls)

\>>> picks = []

\>>> while globe.inspect():

... picks.append(globe.pick())

\>>> len(picks) == len(balls)

True

\>>> set(picks) == set(balls)

True

Check that the order has changed and is not simply reversed:: >>> picks != balls True

\>>> picks[::-1] != balls True

Note: the previous 2 tests have a *very* small chance of failing even if the implementation is OK. The probability of the 100 balls coming out, by chance, in the order they were inspect is 1/100!, or approximately 1.07e-158. It's much easier to win the Lotto or to become a billionaire working as a programmer.

THE END

我们对 Tombola 抽象基类的分析到此结束。下一节说明 Python 如何使用抽象基类的 register 函数。

### 11.9 Python 使用 register 的方式

示例 11-14 把 Tombola.register 当作类装饰器使用。在 Python 3.3 之前的版本中不能这

样使用register,必须在定义类之后像普通函数那样调用，如示例11-14中最后那行注

释所述。

虽然现在可以把 register 当作装饰器使用了，但更常见的做法还是把它当作函数使用， 用于注册其他地方定义的类。例如，在 collections.abc 模块的源码中

(<https://hg.python.org/cpython/file/3.4/Lib/_collections_abc.py>)，是这样把内置类型

tuple、str、range 和 memoryview 注册为 Sequence 的虚拟子类的：

Sequence.register(tuple)

Sequence.register(str)

Sequence.register(range)

Sequence.register(memoryview)

其他几个内置类型在 _collections_abc.py 文件 ([http s://hg. python. org/ cpython/ file/3 +4/Lib/_collections_abc.py](https://hg.python.org/cpython/file/3.4/Lib/_collections_abc.py))中注册为抽象基类的虚拟子

类。这些类型在导入模块时注册，这样做是可以的，因为必须导入才能使用抽象基类：能 访问 MutableMapping 才能编写 isinstance(my_dict, MutableMapping)。 结束本章之前，还要解释一下 Alex Martelli 在“水禽和抽象基类”中施展的魔法。

### 11.10 鹅的行为有可能像鸭子

Alex 在他写的“水禽和抽象基类”一文中指出，即便不注册，抽象基类也能把一个类识别 为虚拟子类。下面是他举的例子，我添加了一些代码，使用 issubclass 做测试：

| >>> class Struggle:...    def __len__(self): return 23       |                 |
| ------------------------------------------------------------ | --------------- |
| >>> from collections import abc >>> isinstance(Struggle(), abc.Sized)True>>> issubclass(Struggle, abc.Sized)True |                 |
| 经issubclass函数确认（isinstance函数也会得出相同的结论），abc.Sized 的子类，这是因为 abc.Sized 实现了一个特殊的类方法， __subclasshook__。参见示例 11-17。 | Struggle 是名为 |
| 示例 11-17 Sized 类的源码，摘自 Lib/_collections_abc+py(Python 3+4， [https://hg+python+org/cpython/file/3+4/Lib/_collections_abc+py#l 127](https://hg.python.org/cpython/file/3.4/Lib/_collections_abc.py%23l127)) |                 |
| class Sized(metaclass=ABCMeta):                              |                 |
| __slots__ = ()                                               |                 |
| @abstractmethod def __len__(self): return 0                  |                 |
| @classmethoddef __subclasshook__(cls, C): if cls is Sized:if any("_len_" in B. _dict_ for B in C. _mro_): # O return True # © return NotImplemented # © |                 |

❶ 对 C.__mro__ （即 C 及其超类）中所列的类来说，如果类的 __dict__ 属性中有名为

__len__ 的属性……

❷......返回True,表明C是Sized的虚拟子类。

❸否则，返回NotImplemented,让子类检查。

如果你对子类检查的细节感兴趣，可以阅读 Lib/abc.py 文件中

ABCMeta.__subclasscheck__ 方法的源码 [https://hg+python+org/cpython/file/3+4/Lib/abc+py#1194](https://hg.python.org/cpython/file/3.4/Lib/abc.py%23l194)）。提醒：源码中有很多 if 语句和

两个递归调用。

__subclasshook__ 在白鹅类型中添加了一些鸭子类型的踪迹。我们可以使用抽象基类

定义正式接口，可以始终使用 isinstance 检查，也可以完全使用不相关的类，只要实现

特定的方法即可（或者做些事情让 __subclasshook__ 信服）。当然，只有提供 __subclasshook__ 方法的抽象基类才能这么做。

在自己定义的抽象基类中要不要实现 __subclasshook__ 方法呢？可能不需要。我在

Python 源码中只见到 Sized 这一个抽象基类实现了 __subclasshook__ 方法，而 Sized

只声明了一个特殊方法，因此只用检查这么一个特殊方法。鉴于 __len__ 方法的“特殊 性”，我们基本可以确定它能做到该做的事。但是对其他特殊方法和基本的抽象基类来 说，很难这么肯定。例如，虽然映射实现了 __len__、__getitem__ 和 __iter__，但 是不应该把它们视作 Sequence 的子类型，因为不能使用整数偏移值获取元素，也不能保 证元素的顺序。当然， OrderedDict 除外，它保留了插入元素的顺序，但是不支持通过 偏移获取元素。

在你我自己编写的抽象基类中实现 __subclasshook__ 方法，可靠性很低。我可不相信

随便一个实现或继承了 load、pick、inspect和loaded的类（如Spam）的行为一定像 Tombola。程序员最好让Spam继承Tombola，至少也要注册 （Tombola.register（Spam）），从而确保这一点。当然，自己实现的 __subclasshook__ 方法还可以检查方法签名和其他特性，但我觉得不值得这么做。

### 11.11 本章小结

本章首先介绍了非正式接口（称为协议）的高度动态本性，然后讲解了抽象基类的静态接 口声明，最后指出了抽象基类的动态特性：虚拟子类，以及使用 __subclasshook__ 方 法动态识别子类。

我们首先回顾了 Python 社区对接口的惯常理解。在 Python 的历史中常常出现接口的身

影，但它是非正式的，类似于Smalltalk的协议，而且在官方文档中，“foo协议”“foo接 口”和“foo类对象”这三种措辞是同一个意思。协议风格的接口与继承完全没有关系，实现 同一个协议的各个类是相互独立的。在鸭子类型中，接口就是这样的。

通过示例 11-3，我们发现 Python 对序列协议的支持十分深入。如果一个类实现了

__getitem__ 方法，此外什么也没做，那么 Python 会设法迭代它，而且 in 运算符也随 之可以使用。随后，我们继续编写第 1 章中的 FrenchDeck 示例，还动态添加了一个方 法，从而让它支持洗牌。这里用到的是猴子补丁，突出了协议的动态本性。我们再一次见

识到，部分实现协议也是有用的：添加可变序列协议中的 __setitem__ 方法之后，立即

就能使用标准库中的 random.shuffle 函数。了解现有的协议能让我们充分利用 Python 丰富的标准库。

接下来， Alex Martelli 介绍了“白鹅类型”这个术语， 18 以此描述一种新的 Python 编程风

格。借助“白鹅类型”，可以使用抽象基类明确声明接口，而且类可以子类化抽象基类或使

用抽象基类注册（无需在继承关系中确立静态的强链接），宣称它实现了某个接口。

18“白鹅类型”这种说法是Alex发明的，这是它第一次出现在书中。

FrenchDeck2 示例清楚地展示了显式继承抽象基类的优缺点。继承

abc.MutableSequence 后，必须实现 insert 和 __delitem__ 方法，而我们并不需要 这两个方法。不过，即便是 Python 新手，只要查看 FrenchDeck2 类的源码，就能看出它 是可变序列。此外，我们还得到一个额外好处，从 abc.MutableSequence 中继承了 11

个方法（其中五个间接继承自abc.Sequence），而且拿来即用。

全面介绍图 11-3 中 collections.abc 模块里的各个抽象基类后，我们自己动手从头开 始编写了一个抽象基类。PyMOTW.com （Python Module of the Week, <http://pymotw.com>）网 站的创建者 Doug Hellmann 道出了这么做的目的：

定义抽象基类之后，各个子类可以实现通用的API。如果有人不熟悉应用程序的运作 方式，却又想使用插件扩展，就可以利用这一功能+ + + + + +19

I[19](https://pymotw.com/2/abc/index.html%23why-use-abstract-base-classes)[PyMOTW 网站介绍 abc 模块的页面，“Why use Abstract Base Classes?”一节（https://pymotw+com/2/abc/index+html#why-](https://pymotw.com/2/abc/index.html%23why-use-abstract-base-classes)

use-abstract-base-classes）。

定义好Tombola抽象基类之后，我们创建了三个具体子类，两个继承Tombola，另一个 注册为虚拟子类——它们都能通过同一个测试组件。

本章结束之前，我们提到了几个内置类型是如何注册到 collections.abc 模块中的抽象

基类的。这样，虽然 memoryview 没有继承 abc.Sequence， isinstance(memoryview, abc. Sequence)的结果也是True。最后，我们探究了 __subclasshook__魔法。这个

方法的作用是让抽象基类识别没有注册为子类的类，你可以根据需要做简单的或者复杂的

测试——标准库的做法只是检查方法名称。

最后的最后，我要重申 Alex Martelli 的警告：不要自己定义抽象基类，除非你要构建允许 用户扩展的框架——然而大多数情况下并非如此。日常使用中，我们与抽象基类的联系应 该是创建现有抽象基类的子类，或者使用现有的抽象基类注册。此外，我们可能还会在

isinstance 检查中使用抽象基类，但这比继承或注册更少见。需要自己从头编写新抽象 基类的情况少之又少。

我使用Python 15年了，除了教学示例以外，我只在Pingo项目(<http://pingo.io>)中编写过 一个抽象类，即 Board 类(<https://github.com/garoa/pingo/blob/master/pingo/board.py>)。支

持单板机和控制器的驱动是 Board 的子类，共用相同的接口。就算我把 pingo.Board 打 造成抽象类，它也并没有继承 abc.ABC。 20 我本打算把 Board 定义为抽象基类，但是 Pingo 项目有更重要的事情要做。

20ython标准库也有这样做的，有些类虽然是抽象的，但是并没有显式地继承abc.ABC。

本章适合使用下面这段话结尾：

尽管抽象基类使得类型检查变得更容易了，但不应该在程序中过度使用它。 Python 的

核心在于它是一门动态语言，它带来了极大的灵活性。如果处处都强制实行类型约 束，那么会使代码变得更加复杂，而本不应该如此。我们应该拥抱 Python 的灵活 性。 21

——David Beazley 和 Brian Jones 《Python Cookbook (第3版)中文版》

21《Python Cookbook (第3版)中文版》第281页。

或者，像本书技术审校 Leonardo Rochael 所写的：“如果觉得自己想创建新的抽象基类，

先试着通过常规的鸭子类型来解决问题。 ”

### 11.12 延伸阅读

Beazley与Jones的《Python Cookbook (第3版)中文版》有一节(8.12)定义了一个抽象

基类。这本书在 Python 3+4 之前撰写，因此他们没有使用现在推荐的句法，即通过继承

abc.ABC 声明抽象基类，而是使用 metaclass 关键字。除了这个小细节之外，那个秘笈

很好地涵盖了抽象基类的主要功能，而且最后还给出了宝贵的意见，即前一节末尾引用的

那段话。

Doug Hellmann写的《Python标准库》一书中有一章是关于abc模块的。Doug创建的 PyMOTW (Python Module of the Week)网站中也有那一章

([http://pymotw+com/2/abc/index+html](http://pymotw.com/2/abc/index.html))。这本书和 PyMOTW 网站都针对 Python 2，因此如

果你使用 Python 3 的话，必须做些调整。 22 记住，在 Python 3+4 中，唯一推荐使用的抽象 基类方法装饰器是@abstractmethod，其他装饰器已经废弃了。本章小结中引用的关于 抽象基类的另一句话出自 Doug 的网站和这本书。

| 22PyMOTW网站现在己经是面向Python3 了。——编者注

使用抽象基类时，经常会遇到多重继承，而且是不可避免的，因为基本的集合抽象基类

(Sequence、Mapping和Set)都扩展多个抽象基类(如图11-3所示)。第12章接着 讨论这个话题，那是重要的一章。

“PEP 3119—Introducing Abstract Base Classes” ([https://www+python+org/dev/peps/pep-3119](https://www.python.org/dev/peps/pep-3119))

讲解了抽象基类的基本原理， “PEP 3141—A Type Hierarchy for

Numbers” ([https://www+python+org/dev/peps/pep-3141/](https://www.python.org/dev/peps/pep-3141/))提出了 numbers 模块

([https://docs+python+org/3/library/numbers+html](https://docs.python.org/3/library/numbers.html))中的抽象基类。

Bill Venners 对 Guido van Rossum 的采访“Contracts in Python: A Conversation with Guido van Rossum, Part IV” ( [http://www+artima+com/intv/pycontract+html ](http://www.artima.com/intv/pycontract.html))讨论了动态类型的优缺点。

zope.interface 包([http://docs+zope+org/zope+interface/](http://docs.zope.org/zope.interface/))提供了一种声明接口的方式：检 查对象是否实现了接口，注册提供方，然后查询指定接口的提供方。一开始，这个包是 Zope 3 核心的一部分，不过它可以在 Zope 外部使用，而且已经有人这么做了。这个包为 大型Python项目(如Twisted、Pyramid和Plone)的组件式架构提供了灵活的基础。 Lennart Regebro 写的“A Python Component Architecture”一文

([https://regebro+wordpress+com/2007/11/16/a-python-component-architecture/](https://regebro.wordpress.com/2007/11/16/a-python-component-architecture/))对

zope. interface 包做了介绍，BaijuM 还写了一本相关的书-A Comprehensive Guide

to Zope Component Architecture ([http://muthukadan+net/docs/zca+html](http://muthukadan.net/docs/zca.html)) 。

杂谈

类型提示

2014 年， Python 世界最大的新闻应该是 Guido van Rossum 同意实现可选的静态类型

检查，这与检查程序Mypy ([http://www+mypy-lang.org](http://www.mypy-lang.org))的做法类似，即使用函数注解

实现。这一消息出自 8 月 15 日发表在 Python-ideas 邮件列表中的一个话题，题

[为](https://mail.python.org/pipermail/python-ideas/2014-August/028742.html)[“Optional static typing —the crossroads” （https://mail.python.org/pipermail/python-](https://mail.python.org/pipermail/python-ideas/2014-August/028742.html)ideas/2014-August/028742.html）。一个月后，“PEP 484—Type Hints”草案

（https://www.python.org/dev/peps/pep-0484/）发布了，发起人是 Guido。

这个功能的目的是让程序员在函数定义中使用注解声明参数和返回值的类型，但这是

可选的。关键在于“可选”二字。仅当你想得到注解的好处和限制时才需要添加注解，

而且可以在一些函数中添加，在另一些函数中不添加。

从表面上看，这与 Microsoft 对 TypeScript（JavaScript 的超集）采取的方式类似，不 过TypeScript做得更进一步：TypeScript添加了新的语言结构（如模块、类、显式接 口，等等），允许声明变量类型，而且最终编译成常规的JavaScript。目前来看， Python 的可选静态类型没这么大的雄心。

为了理解这个提案的动机，不能忽略 Guido 在 2014 年 8 月 15 日发送的那封重要邮件 中的这段话：

我还得做个假设：这个功能主要供 lint 程序、 IDE 和文档生成工具使用。这些工 具有个共同点：即使类型检查失败了，程序仍能运行。此外，程序中添加的类型 不能降低性能（也不能提升性能 :-））。

因此，这一举动并不像乍一看那么激进。 “PEP 484—Type

Hints” （https://www.python.org/dev/peps/pep-0484/）提到了“PEP 482—Literature Overview for Type Hints” （https://www.python.org/dev/peps/pep-0482/） ，后者概述了第 三方 Python 工具和其他语言实现类型提示的方式。

不管激进不激进，类型提示都将到来：支持 PEP 484 的 typing 模块好像已经纳入 Python 3.5。 23 根据这个提案的表述和实现方式，可以肯定的是，现有代码不会因为 缺少类型提示（或相关的附加物）而无法运行。

最后， PEP 484 明确指出：

还要强调一点， Python 依旧是一门动态类型语言，作者从未打算强制要求使用类 型提示，甚至不会把它变成约定。

Python 是弱类型语言吗

由于缺少统一的术语，讨论语言类型方面的话题时有时会让人不明其意。有些人（例

如扩展阅读中提到的 Bill Venners 对 Guido 的访谈）说 Python 是弱类型语言，把 Python 与 JavaScript 和 PHP 归为一类。讨论类型时，最好考虑两条不同的坐标线。 强类型和弱类型

如果一门语言很少隐式转换类型，说明它是强类型语言；如果经常这么做，说明

它是弱类型语言。 Java、 C++ 和 Python 是强类型语言。 PHP、 JavaScript 和 Perl 是弱 类型语言。

静态类型和动态类型

在编译时检查类型的语言是静态类型语言，在运行时检查类型的语言是动态类型

语言。静态类型需要声明类型（有些现代语言使用类型推导避免部分类型声明）。

Fortran 和 Lisp 是最早的两门语言，现在仍在使用，它们分别是静态类型语言和动态 类型语言。

强类型能及早发现缺陷。

下面几例体现了弱类型的不足：24

//这些是JavaScript代码（在Node.js v0.10.33中做了测试）

'' == '0' // false

0 == ''    //    true

0 == '0'    //    true

'' < 0    //    false

'' < '0'    //    true

因为 Python 不会自动在字符串和数字之间强制转换，所以在 Python 3 中，上述 == 表 达式的结果都是False （保留了 ==的意思），而 < 比较会抛出TypeError。

静态类型使得一些工具（编译器和IDE）便于分析代码、找出错误和提供其他服务 （优化、重构，等等）。动态类型便于代码重用，代码行数更少，而且能让接口自然

成为协议而不提早实行。

综上， Python 是动态强类型语言。 “PEP 484—Type

Hints” （https://www.python.org/dev/peps/pep-0484/）无法改变这一点，但是 API 作者

能够添加可选的类型注解，执行某种静态类型检查。

猴子补丁

猴子补丁的名声不太好。如果滥用，会导致系统难以理解和维护。补丁通常与目标紧

密耦合，因此很脆弱。另一个问题是，打了猴子补丁的两个库可能相互牵绊，因为第

二个库可能撤销了第一个库的补丁。

不过猴子补丁也有它的作用，例如可以在运行时让类实现协议。适配器设计模式通过

实现全新的类解决这种问题。

为 Python 打猴子补丁不难，但是有些局限。与 Ruby 和 JavaScript 不同， Python 不允 许为内置类型打猴子补丁。其实我觉得这是优点，因为这样可以确保 str 对象的方

法始终是那些。这一局限能减少外部库打的补丁有冲突的概率。

Java、 Go 和 Ruby 的接口

从 C++ 2.0（1989 年发布）起，这门语言开始使用抽象类指定接口。 Java 的设计者选 择不支持类的多重继承，这排除了使用抽象类作为接口规范的可能性，因为一个类通 常会实现多个接口。但是， Java 的设计者添加了 interface 这个语言结构，而且允 许一个类实现多个接口——这是一种多重继承。以更为明确的方式定义接口是 Java 的一大贡献。在 Java 8 中，接口可以提供方法实现，这叫默认方法

（<https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html>） 。有了这个功

能， Java 的接口与 C++ 和 Python 中的抽象类更像了。

Go 语言采用的方式完全不同。首先， Go 不支持继承。我们可以定义接口，但是无需 （其实也不能）明确地指出某个类型实现了某个接口。编译器能自动判断。因此，考

虑到接口在编译时检查，但是真正重要的是实现了什么类型， Go 语言可以说是具

有“静态鸭子类型”。

与 Python 相比，对 Go 来说就好像每个抽象基类都实现了 __subclasshook__ 方

法，它会检查函数的名称和签名，而我们自己从不需要继承或注册抽象基类。如果想

让Python更像Go,可以对所有函数参数做类型检查。Python提供了部分基础设施 （参见 5+9 节）。 Guido 说过，他不介意使用注解做类型检查，至少在辅助工具中可

以这么做。详情参阅第 5 章的“杂谈”。

Ruby 程序员是鸭子类型的坚定拥护者，而且 Ruby 没有声明接口或抽象类的正式方 式，只能像 Python 2+6 之前的版本那样做，即在方法的定义体中抛出 NotImplementedError，以此表明方法是抽象的，用户必须在子类中实现。

不过， 2014 年 9 月， Ruby 之父松本行弘在日本举办的 Ruby Kaigi （最重要的 Ruby 大

会之一，每年举办）中做了一场主题演讲，他透露说， Ruby 未来可能会支持静态类

型。目前我还没看到相关报道，但是根据Godfrey Chan的博客文章“Ruby Kaigi 2014: Day 2” （[http://brewhouse+io/blog/2014/09/19/ruby-kaigi-2014-day-2](http://brewhouse.io/blog/2014/09/19/ruby-kaigi-2014-day-2)） ，松本行弘关注的 似乎是函数注解。他甚至还提到了 Python 的函数注解。

在没有抽象基类向类型系统添加结构，以及不丧失灵活性的情况下，我不知道函数注 解有什么用。因此， Ruby 未来可能还会支持正式接口。

我相信， Python 的抽象基类在 register 函数和 __subclasshook__ 方法的协助下

能把正式接口带入这门语言，而且不失去动态类型的优势。

或许，鹅正在赶超鸭子。

接口中的隐喻和习惯用法

隐喻能打破壁垒，让人更易于理解。使用“栈”和“队列”描述基本的数据类型就有这样 的功效：这两个词清楚地道出了添加或删除元素的方式。另一方面， Alan Cooper 在

《交互设计精髓（第 4 版）》中写道：

严格奉行隐喻设计毫无必要，却把界面死死地与物理世界的运行机制捆绑在一

起。

他说的是用户界面，但对 API 同样适用。不过 Cooper 同意，当“真正合适的”隐喻“正

中下怀”时，可以使用隐喻（他用的词是“正中下怀”，因为合适的隐喻可遇不可

求）。我觉得本章用宾果机作比喻是合适的，我相信自己。

我读过不少 UI 设计方面的书，《交互设计精髓》是最好的。我从 Cooper 的书中学到

的最宝贵的知识是，不把隐喻当作设计范式，而代之以“习惯用法的界面”。前面说

过，Cooper说的不是API，但是我越深入思考他的观点，越觉得可以将之运用到 Python 中。 Python 语言的基本协议就是 Cooper 所说的“习惯用法”。知道“序列”是什 么之后，可以把这些知识应用到不同的场合。这正是本书的主要目的：着重讲解这门 语言的基本惯用法，让你的代码简洁、高效且可读，把你打造成熟练的 Python 程序 员。

23现在，typing模块己经纳入Python 3.5。-编者注

| 24改编自 JavaScript: The Good Parts (Douglas Crockford 著)附录 B 第 109 页给出的示例。
