---
title: 03 基本语法
toc: true
date: 2018-06-27 07:24:36
---
### 基础语法

Python中常见的基本数据类型有数字、字符串、列表、字典、集合、元组等，常见语法 有条件、循环、函数、列表解析等。它们两者组合起来便构成了 Python程序的基本要素，可 以称之为基础语法。本章我们主要从语法层面阐述一些使用技巧和注意事项。

##### 建议19:有节制地使用from...import语句

Python提供了 3种方式来引人外部模块：import语句、from...import…及_import_函 数。其中较为常见的为前面两种，而_^1^(^_函数与import语句类似，不同点在于前者显 式地将模块的名称作为字符串传递并赋值给命名空间的变量。

在使用import的时候注意以下几点：

□ 一般情况下尽量优先使用import ae形式，如访问B时需要使用a.B的形式。

□有节制地使用from a import B形式，可以直接访问B。

□尽挝避免使用from a import*,因为这会污染命名空间，并且无法清晰地表示导人了 哪些对象。

为什么在使用import的时候要注意以上儿点呢？在回答这个问题之前先来简单了解一下 Python的import机制。Python在初始化运行环境的时候会预先加载一批内建模块到内存中， 这些模抉相关的信息被存放在sys.modules中。读者导人sys模块后在Python解释器中输人 sys.modules.items()便可显示所有预加载模块的相关信息。当加载一个模块的时候，解释器实 际上要完成以下动作：

㊀本节的a指的是模块名称，B则指代模块a中的一些类名或者变盘等

1 )在sys.modules中进行搜索看看该模块是否已经存在，如果存在，则将其导入到当前 局部命名空间，加载结束。

2)    如果在sys.modules中找不到对应模块的名称，则为需要导人的模块创建一个字典对 象，并将该对象信息插人sys.modules中。

3)    加载前确认是否需要对模块对应的文件进行编译，如果需要则先进行编译。

4)    执行动态加载，在当前模块的命名空间中执行编译后的字节码，并将其中所有的对 象放人模块对应的字典中。

我们以用户自定义的模块为例来看看sys.modules和当前局部命名空间发生的变化。在 Python的安装目录下创建一个简单的模块testmodule.py：

a = 1 b = 'a'

print "testing module import"

我们知道用户模块未加载之前，sys.modules中并不存在相关信息。那么进行import testmodule操作会发生什么情况呢？

»> dir ()

[1 _built ins_ •, • _doc_ •, 1_name_ •, • _package 19 1 sys •]

»> import testmodule testing module import

»> dir ()    ①import testmodule之后局部命名空间发生变化

[* _built ins_•, •_doc_•,    •_name_ •,    •_package_*, • sys •,    • testmodule •

]

\>» • testmodule • in sys .modules. keys ()

True

\>» id (testmodule)

35776304

\>>> id(sys.modules[•testmodule•])

35776304

\>» dir (testmodule)

[•_builtins_•, •_doc_•, •_file_•, •_name_•,    •_package_•, ’a’，•b* ]

\>» sys.modules [ •testmodule'】• _diet_. keys ()

[•a*, •b1 r _builtins_’_file_’，■_package_•, ■_name_1, ■_doc_•,】

从输出结果可以看出，对于用户定义的模块，import机制会创建一个新的module将其 加人当前的局部命名空间中，与此同时，sys.modules也加人了该模块的相关信息。但从它们 的id输出结果可以看出，本质上是引用同一个对象。同时会发现testmodule.py所在的目录 下多了一个.pyc的文件，该文件为解释器生成的模块相对应的字节码，从import之后的输出 “ testing module import”可以看出模块同时被执行，而a和b被写人testmodule所对应的字 典信息中。

需要注意的是，直接使用import和使用from a import B形式这两者之间存在一定的差 异，后者直接将B暴露于当前局部空间，而将a加载到sys.modules集合。

\>>> import sys

\>» dir ()

[• _built ins_ ■,    1 _doc_ ■,    1 _name_ •,    ’_package_1, • sys •]

\>» from testmodule import a testing module import

»> dir () 使用from......import......之后命名空间发生的变化

[•_builtins_’，    •_doc_19    •_name_•,    •_package_•,    1 a 1 r 1 sys 1 ]

»> sys .modules [ • testmodule 1 )

<module •testmodule * from •testmodule.pyc1>

\>>> id(sys.modules[1testmodule•】)

36562576

\>» id (a)

31697400

\>>> id(sys.modules[•a•])

Traceback (most recent call last):

File "<stdin〉M, line 1, in <module>

KeyError: •a*

了解完import机制，我们冉来看看对于from a import...无节制的使用会带来什么问题。

(1)命名空间的冲突

来看一个例子。假设有如下3个文件：a.py，b.py及importtest.py,其中a和b都定义了 add()函数，当在import test文件中同时采用from...import...的形式导人add的时候，import test中起作用的到底是哪一个函数呢？

文件a.py如下：

def add ():

print "add in module Aw 文件b.py如下： def add():

print "math in module B"

文件 importtest.py 如下：

from a import add from b import add

if _name_ == *_main_1 : math ()

从程序的输出“add in module B ”可以看出实际起作用的是最近导人的add()，它完全覆 盖了当前命名空间之前从a中导人的add()。在项目中，特别是大型项目中频繁地使用from a import ...的形式会增加命名空间冲突的概率从而导致出现无法预料的问题。因此需要有节制 地使用frOm...import语句。一般来说在非常明确不会造成命名冲突的前提下，以下几种情况 下町以考虑使用from...import语句：

###### 1 )当只需要导人部分属性或方法时。

2)    模块中的这些属性和方法访问频率较髙导致使用“模块名.名称”的形式进行访问过 于烦琐时。

3)    模块的文裆明确说明需要使用形式，导人的是一个包下面的子模块, 且使用from...import形式能够更为简单和便利时。如使用from io.drivers import zip要比使用 import io.drivers.zip 更方便。

(2)循环嵌套导入的问题

先来看下面的例子： cl.py:

from c2 import g def x():

Pass c2.py:

from cl import x def g ():

Pass

无论运行上面哪一个文件都会抛出ImportError异常。这是因为在执行cl.py的加载过 程中，需要创建新的模块对象cl然后执行cl.py所对应的字节码。此时遇到语句from c2 import g,而c2在sys.modules也不存在，故此时创建与c2对应的模块对象并执行c2.py所 对应的字节砰。当遇到c2中的语句from cl import x时，由于cl已经存在，于是便去其对应 的字典中査找g，但cl模块对象虽然创建但初始化的过程并未完成，因此其对应的字典中并 不存在g对象，此时便抛出ImportError: cannot import name g异常。而解决循环嵌套导人问 题的一个方法是直接使用import语句。读者可以自行验证。

##### 建议20:优先使用absolute import来导入模块

假设有如下文件结构，其中app/subl/string.py中定义了一个lower()方法，那么当在 modl.py中import string之后再使用string.lower()方法时，到底引用的是subl/string.py中的 lower()方法，还是Python标准库中string里面的lower()方法呢？

app/

_init_.py subl/

_init_.py modi.py string.py

sub2/

_init_.py mod2.py

从程序的输出会发现，它引用的是app/subl/string.py中的lower()方法。显然解释器

默认先从当前B录下搜索对应的模块，当搜到string.py的时候便停止搜索进行动态加载。 那么，如果要使用Python自带的string模块中的方法，该怎么实现呢？这就涉及absolute import 和 relative import 相关的话题了。

在Python2.4以前默认为隐式的relative import,局部范fM的模块将覆盖同名的全局范 围的模块。如果要使用标注库中同名的模块，你不得不去深人考察sys.modules—番，显然 这并不是一种非常友好的做法。Python2.5中后虽然默认的仍然是relative import，但它为 absolute import 提供了一种新的机制，在模块中使用 from _future_ import absolute import 语句进行说明后再进行导人。同时它还通过点号提供了一种显式进行relative import的方法，

表示当前目录，表示当前目录的上一层目录。例如想在modl.py中导人string.py， 可以使用from . import string,其中modi所在的包层次结构为app.subl.modl，表示app. subl ；如果想导入 sub2/mo2.py 可以使用 from ..sub2 import mod2,    代表的是 appo

但事情是不是就此结束了呢？远不止，使用显式relative import之后再运行程序一不小 心你就有可能遇到这种错误 “ ValueError: Attempted relative import in non-package”。这是什 么原因呢？这个问题产生的原因在于relative import使用模块的_name_属性来决定当前 模块在包层次结构中的位置，如果当前的模块名称中不包含任何包的信息，那么它将默认为 模块在包的顶层位置，而不管模块在文件系统中的实际位置。而在relative import的情形下， _name_会随着文件加载方式的不同而发生改变，上例中如在目录app/sub 1 /下运行Python modl.py，会发现模块的_name_为_main_，但如果在目录app/subl/下运行Python -m modl.py,会发现_name_变为modi。其中-m的作用是使得一个模块像脚本一样运行。而 无论以何种方式加载，当在包的内部运行脚本的时候，包相关的结构信息都会丢失，默认当 前脚本所在的位置为模块在包中的顶层位H，因此便会抛出异常。如果确实需要将模块当作 脚本一样运行，解决方法之一是在包的顶层目录中加入参数-m运行该脚本，上例中如果要 运行脚本modl.py可以在app所在的目录的位置输人Python -m app.subl.modl。另一个解决 这个问题的方法是利用Python2.6在模块中引人的_package_嵐性，设置_package_之 后，解释器会根据_package_和_name_的值来确定包的层次结构。上面的例子中如果 将modl.py修改为以下形式便不会出现在包结构内运行模块对应的脚本时出错的情况了。

if name == ” main •’ and package is None: import sys import os.path

sys .path [0] = os .path.abspath (•••/"/../••> print sys.path[0] import app.subl _package_ = str (•app.subl•) from . import string

相比于absolute import，relative import在实际应用中反馈的问题较多，因此推荐优先使 用absolute import。absolute import可读性和出现问题后的可跟踪性都更好。当项0的包层次

结构较为复杂的时候，显式relative import也是可以接受的，由于命名冲突的原因以及语义 模糊等原因，不推荐使用隐式的relative import,并且它在Python3中已经被移除。

##### 建议21: i+=1不等于++i

对于对Python语言的每个细节了解得不是那么清楚，而恰好又有其他语言背景的开发 人员，很有可能写出如下类似的代码：

i = 0

mylist =【1'2,3人5,6] while i < len(mylist):

print mylist[i]

十十i

运行这段代码会有什么问题？也许你会说：抛出语法错误。能说出这个答案的至少知 道Python中是不支持++i操作的。但输出果真如此吗？非也，这段程序不会抛出任何语法错 误，却会无限循环地输出1。原因是什么呢？因为Python解释器会将操作解释为+(+i)， 其中+表示正数符号。对于操作也是类似。

\>» +1 1

\>>> ++1 1

\>>>十十十+1 1

\>>> -2 -2

»> --2 #负负得正 2

\>>>-----2

-2

\>>>

因此你需要明白在Python中语法上是合法的，但并不是我们理解的通常意义上的自 增操作。

##### 建议22:使用with自动关闭资源

来做个简单的试验，观察一下发生的现象。在Python解释器中输人下面两行代码，会 有什么情况发生呢？

\>>> f = open(1 test.txt1,    •w*)

\>>> f.write("test")

答案是：在解释器所在的目录下生成了一个文件test.txt,并且在里面写人了字符串test, 对吗？事实真相是：的确生成了一个文件，但其内容为空，并没有写人任何字符串。这个一 个简单得不能再简单的问题，相信不用多说你已经知道症结所在了。

对文件操作完成后应该立即关闭它们，这是一个常识。我们都知道需要这么做，在很 多编程语言中都会强调这个问题，因为打开的文件不仅会占用系统资源，而且可能影响其他 程序或者进程的操作，甚至会导致用户期望与实际操作结果不一致。但实际应用中真相往往 是：即使我们心中记得这个原则，但仍然可能会忘记关闭它。为什么？因为编程人员会把更 多的精力和注意力放在对具体文件内容的操作和处理上；或者设计的正常流程是处理完毕关 闭文件，但结果程序执行过程中发生了异常导致关闭文件的代码没有被执行到。也许你会 说，还有try..finally块。对！这是一种比较古老的方法，但Python提供了一种更为简单的解 决方案：with语句。with语句的语法为：

with表达式 [as目标】：

代码块

With语句支持嵌套，支持多个with子句，它们两者可以相互转换。“with exprl as el , cxpr2 as e2"与下面的嵌套形式等价：

with exprl as el:

with expr2 as e2:

With语句的使用非常简单，本节开头的例子改用with语句能够保证当写操作执行完毕 后自动关闭文件。

\>» with open (• test • txt ■, *w 丨)as f:

•    "    f.write("test”)

•    參 參

With语句可以在代码块执行完毕后还原进人该代码块时的现场。包含有with语句的代 码块的执行过程如下：

1)计算表达式的值，返回一个上下文管理器对象。

2 )加载上下文管理器对象的方法以备后用。

3)    调用上下文管理器对象的_enter_()方法。

4)    如果with语句中设置了目标对象，则将_enter_()方法的返回值赋值给目标对象。

5 )执行with中的代码块。

6)    如果步骤5中代码正常结束，调用上下文管理器对象的_exit_()方法，其返回值直 接忽略。

7)    如果步骤5中代码执行过程中发生异常，调用上下文管理器对象的_exit_()方法， 并将异常类型、值及traceback信息作为参数传递给_exit_()方法。如果_exit_()返回值为 false,则异常会被重新抛出；如果其返回值为true,异常被挂起，程序继续执行。

在文件处理时使用with的好处在于无论程序以何种方式跳出with块，总能保证文件被 正确关闭。实际上它不仅仅针对文件处理，针对其他情景同样可以实现运行时环境的清理 与还原，如多线程编程中的锁对象的管理。with的神奇实际得益于一个称为上下文管理器 (context manager)的东西，它用来创建一个运行时的环境。上下文管理器是这样一个对象： 它定义程序运行时需要建立的上下文，处理程序的进人和退出，实现了上下文管理协议，即 在对象中定义_61^1_()和__6*^_()方法。其中：

□    _enter_():进人运行时的上下文，返回运行时上下文相关的对象，with语句中会将 这个返回值绑定到目标对象。如上面的例子中会将文件对象本身返回并绑定到目标f。

□    _exit_(exccption_typc,exception_value,traceback):退出运行时的上下文，定义在块 执行(或终止)之后上下文管理器应该做什么。它可以处理异常、清理现场或者处理 with块中语句执行完成之后需要处理的动作。

实际上任何实现了上下文协议的对象都可以称为一个上下文管理器，文件也是实现了这 个协议的上下文管理器，它们都能够与with语句兼容。文件对象的 性如下：

»> f._enter_

<built-in method _enter_ of file object at 0x029F0700>

»> f._exit_

<built-in method _exit_ of file object at 0x029F0700>

###### 用户也可以定义自己的上下文管理器来控制程序的运行，只需要实现上下文协议便能够 和with语句一起使用。

\>>> class MyContextManager(object):

..    def _enter_(self"♦实现_enter_方法

..    print "entering " .

..    def exit_(self,exceptiontype, exception_valuez traceback):

..    print "leaving"."

..    if exception一type is None:

..    print "no exceptions!"

..    return False

..    elif exception_type is    ValueError:

"    print "value    error!!!"

..    return True

.•    else:

• .    print "other    error"

..    return True

»> with MyContextManager (): .• .    print ^Testing. . .,f

•••    raise(ValueError)

entering...

Testing... leaving... value error!!!

\>»

\>» with MyContextManager (): print "Testing •••,f

參 •會

entering...

Testing... leaving... no exceptions!

\>»

因为上下文管理器主要作用于资源共享，因此在实际应用中_enter()_和_exit()_方 法基本用于资源分配以及释放相关的工作，如打开/关闭文件、异常处理、断开流的连接、 锁分配等。为了更好地辅助上下文管理，Python还提供了 contextlib模块，该模块是通过 Generator实现的，contextlib中的contextmanager作为装饰器来提供一种针对函数级别的上 下文管理机制，可以直接作用于函数/对象而不用去关心_enter()_和_exit()_方法的具 体实现。关于 contextlib 更多内容读者可以参考网页 <http://docs.python.Org/2/library/contextlib>. htmlo

##### 建议23:使用else子句简化循环(异常处理)

有其他编程语言经验的程序员接触到Python时，对于它无所不在的else往往感到非常 惊讶。在Python中，不仅分支语句有else子句，而且循环语句也有，甚至连异常处理也有。 首先来看看循环语句中的else,看看它们的语法。

while_stmt ::= "while” expression • suite Iwelsen w• suite]

for_stmt = "for" target list "in" expression_list • suite ["else" ”：" suite]

从语法定义中可以看到如果没有[”elW suite]这一块，Python的循环语句跟大多数语 言并无二致。要谈else子句，必须先从Python从其他语言中借鉴的语义相同的break语句说 起，因为else子句提供了隐含的对循环是否由break语句引发循环结束的判断。先来看一个 没有应用else子句的例子：

def print_prime(n):

for i in xrange(2, n):

found = True

for j in xrange(2, i):

if i % j == 0:

found = False break

if found:

print *%d is a prime number1%i

这是一个査找素数的简单实现，可以看到我们借助了一个标志量found来判断是循环结 朿是不是由break语句引起的。如果对else善加利用，代码可以简洁得多。来看下面的具体 实现：

def print一prime2(n):

for i in xrange(2/ n):

for j in xrange(2, i): if i % j == 0:

break

else:

print *%d is a prime number * %i

当循环“自然”终结(循环条件为假)时else从句会被执行一次，而当循环是由break 语句中断时，else子句就不被执行。与for语句相似，while语句中的else子句的语意是一样 的：else块在循环正常结束和循环条件不成立时被执行。

与C/C++等较为“老土”的语言相比，else子句使程序员的生产力和代码的可读性都得 到了提髙，所以建议大家多使用else，让程序变得更加Pythonic。

在Python的异常处理中，也提供了 else子句语法，这颗“语法糖”的意义跟循环语 句中的else是相似的：try块没有抛出任何异常时，执行else块。按惯例先看一下如下语 法定义：

try—stmt tryl stmt



![img](12 1699d828cfe301 3984Python0b8f84912afaae-40.jpg)



tryl一stmt

(••except，1

["else”

["finally11



try2 stmt



![img](12 1699d828cfe301 3984Python0b8f84912afaae-42.jpg)



.•finally.'



I try2一stmt suite

[expression •• suite]

":"suite] suite

• suite



[(Hasn



target] ]    suite) +



###### 从tryl stmt的定义中可以看到，Python的异常处理中有一种try-except-eise-finally形式。 下面的例子是把数据写人文件中。

def save(db# obj): try:

\#    save attrl

db.execute (1 a sql stmt1, obj.attrl)

\#    save attr2

db.execute(* another sql stmt'9 obj.attr2) except DBError:

db.rollback () else:

db.commit()

###### 如果没有else子句，就像前文中关于循环的例子一样，需要引人一个标志变ft。

def save(dbz obj):

some_error_occurred = False try:

\#    save attrl

db.execute('a sql stmt', obj.attrl)

\#    save attr2

db.execute(1 another sql stmt1, obj.attr2) except DBError:

db.rollback()

some_error_occurred = True if not some_error_occurreci:

db.commit()

这样代码就变得复杂了。在Python中还有不少语法都是致力于让程序员可以编写更加 简明、更接近自然语言语义的代码，比如in和with语句(将在其他章中讲述相关用法)，这 也证明充分地学习手册中的Language Reference非常有必要。

##### 建议24:遵循异常处理的几点基本原则

现实世界是不完美的，意外和异常会在不经意间发生，从而使我们的生活不得不暂时 偏离正常轨道，软件世界也是如此。或因为外部原因，或因为内部原因，程序会在某些条件 下产生异常或者错误。为了提髙系统的健壮性和用户的友好性，需要一定的机制来处理这种 情况。跟其他很多编程语言一样，Python也提供了异常处理机制。Python中常用的异常处 理语法是try、except、else、finally,它们可以有多种组合，如try-except (—个或多个)，try -cxccpt-clsc； try -finally 以及 try -except-else-finally 等。语法形式如 F:

try:

〈statements〉 except <namel>:

〈statements〉 except (name2, name3):

<statements>

except <name4> as <data>: 〈statements〉

except:

〈statements〉

else:

<statements>

finally:

<statements>



\# Run this main action first

\#当try中发生namel的异常时处理

\#当try中发生name2或name3中的某一个异常的时候处理

\#当try中发生name4的异常时处理，并获取对应实例

\#其他异常发生时处理

\#没有异常发生时执行

\#不管有没有异常发生都会执行

最为全面的组合try -except-else-finally异常处理的流程如图3-1所示。

try代码块

阁3-1异常处理的流程阁

异常处理通常需要遵循以下几点基本原则：

1）    注意异常的粒度，不推荐在try中放人过多的代码。异常的粒度是人为划分的，在 处理异常的时候最好保持异常粒度的一致性和合理性，同时要避免在try中放人过多的代 码，即避免异常粒度过大。在try中放人过多的代码带来的问题是如果程序中抛出异常，将 会较难定位，给debug和修复带来不便，因此应尽量只在可能抛出异常的语句块前面放人 try语句。

2）    谨慎使用单独的except语句处理所有异常，最好能定位具体的异常。同样也不推荐 使用 except Exception 或者 except StandardError 来捕获异常。

在try后面单独使用except语句可以捕获所有的异常，从表面上看这似乎是个不错的做 法，但实际上会带来什么问题呢？来看以下简单的例子：

import sys try:

print a b -0

print a/b except:

sys.exit(MZeroDivisionError:Can not division zero"}

程序运行以打印“ ZeroDivisionError : Can not division zero”结束，这会让我们以为是 发生了除数为零的错误，但实际情况是因为a在使用前并没有定义，程序引发了 NameEiror。 而由于单独的except语句的使用，真实的错误往往被掩盖。对上述代码修改如下：

import sys try:

print a b =0

print a/b

except ZeroDivisionError:

sys.exit("ZeroDivisionError:Can not division zero")

运行程序输出NameError异常如下：

Traceback (most recent call last):

File "test.py", line 3, in <module>

print a

NameError: name *a1 is not defined

单独使用except会捕获包括SystemExit，Keyboardlnterrupt等在内的各种异常，从而掩 盖程序真正发生异常的原因，给debug造成一定的迷惑性。因此需要谨慎使用，最好能在

except语句中定位具体的异常。如果在某些情况 下不得不使用单独的except语句，最好能够使用 raise语句将异常抛出向上层传递。

3)注意异常捕获的顺序，在合适的层次 处理异常。Python中内建异常以类的形式出现， Python2.5后异常被迁移到新式类上，启用了一个 新的所有异常之母的BaseException类，内建异常 有一定的继承结构，如UnicodeDecodeError继承自 UnicodeError,而其继承链结构为 UnicodeDecodeError -->UnicodcError —>ValueError -->Exception 一〉BaseException，如图 3-2 所示。

用户也可以继承自内建异常构建自己的异常 类，从而在内建类的继承结构上进一步延伸。在 这种情况下异常捕获的顺序显得非常重要。为了

![img](12 1699d828cfe301 3984Python0b8f84912afaae-45.jpg)



更精确地定位错误发生的原因，推荐的方法是将继承结构中子类异常在前面的except语句 屮抛出，而父类异常在后面的except语句抛出。这样做的原因是当try块中有异常发生的时 候，解释器根据except声明的顺序进行匹配，在第一个匹配的地方便立即处理该异常。如 果将M•次较髙的异常类在前面进行捕获，往往不能精确地定位异常发生的具体位置。如下例 中 Value Error 声明在前而 UnicodeDecodeError 在后，当抛出 UnicodeDecodeError 异常的吋 候，由于它是ValueError的子类，在ValueError处便直接被捕获了，打印出消息“ ValucError occured’，而真正的昇常UnicodeDecodeError却被悄然掩盖。

»> try:

...    raise UnicodeDecodeError (’’pdfdocencoding”，’’a", 2,-1, "not support decoding

• . . except ValueError: #Va丄ueError 为 UnicodeDecodeError 的父类，捕获异常时却在前面 ...    print "ValueError occured"

...except UnicodeDecodeError^ e:

...    print e

ValueError occured >>>

因此，异常捕获的顺序非常重要，同时异常应该在适当的位S被处理，一个原则就是如 果异常能够在被捕获的位置被处理，那么应该及时处现，不能处理也应该以合适的方式向上 层抛出。遇到异常不论好歹就向上层抛出是非常不明智的。向上层传递的时候需要警惕异常 被丢失的情况，可以使用不带参数的raise来传递。

try:

some_code() except:

revert_stuff() raise

4)使用更为友好的异常信息，遵守异常参数的规范。软件最终是为用户服务的，当异 常发生的时候，异常信息清晰友好与否直接关系到用户体验。通常来说有两类异常阅读者: 使用软件的人和开发软件的人，即用户和开发者。对于用户来说关注更多的是业务。先来看 一段异常信息：

Traceback (most recent call last):

File ntest.py", line 4, in 〈module〉

print ItemPriceTable【•a•]

KeyError:    1 a 1

如果将这段信息给一个没有软件编程背景的人看，他肯定会觉得如渎天书一般，对于用 户这并不是一种较为友好的做法，在面对用户的时候异常信息应该以较为清晰和明确的方式 显示出来。如下例中当査找一个不在列表的水果价格的时候给出相关的提示信息会比直接抛 出KeyError信息要友好得多。

import sys

import traceback

ItemPriceTable = { "apple" : • 3 • 5 •, "orange” ： • 4 •, "cheery••: "20", "mango" : "8" } def getprice(itemname):

try:

price = ItemPriceTable[itemname] return price

except KeyError:

print "%s can not find in the price table, you should input another kind of fruit. % sys.exc value #显示异常相关的提示信息

while 1:

itemname = raw一input ("Enter the fruit name to get the price or press x to exit: ”) if itemname == wx":

break

price = getprice(itemname) if price !«= None:

print n%s1s price is $%s/kg" % (itemname, price)

此外，如果内建异常类不能满足需求，用户可以在继承内建异常的基础上针对特定的业 务逻辑定义自己的异常类。但无论是内建异常类，还是用户定义的异常类，在传递异常参数 的时候都需要遵守异常参数规范。

##### ;议25:避免finally中可能发生的陷阱

无论try语句中是否有异常抛出，finally语句总会被执行。由于这个特性，finally语句经 常被用来做一些清理工作，如打开一个文件，抛出异常后在finally语句中对文件句柄进行关 闭等。

但使用finally时，也要特别小心一些陷阱。先来看以下例子：

def FinallyTest():

print 1 i am starting------1

while True:

try:

print "I am running"

raise IndexError (Mrn) # 拋出异 IndexError 异常 except Nam©Error,e:

print 1NameError happended %s1r e break

finally:

print •finally executed* break #finally语句中有break语句

FinallyTest ()

###### 上述程序输出结果为：

i am starting

I am running finally executed

上面的例子中try代码块抛出了 IndexError异常，但在except块却没有对应的异常声明。 按常理该异常会向上层抛出，可是程序输出却没有提示任何异常发生，IndexError异常被丢 失。这是什么原因呢？当try块中发生异常的吋候，如果在except语句中找不到对应的异常 处理，异常将会被临时保存起来，当finally执行完毕的时候，临时保存的异常将会再次被抛 出，但如果finally语句中产生了新的异常或者执行了 retuni或者break语句，那么临时保存 的异常将会被丢失，从而导致异常屏蔽。这是finally使用时需要小心的第一个陷阱。再来看 另外一个例子：

def ReturnTest(a): try:

if a <=0:

raise ValueError (f,data can not be negative") else:

return a

except ValueError as e: print e

finally:

print("The End!n) return -1

print ReturnTest(0) print ReturnTest(2)

思考一下这里程序RetumTest(O)和RetumTest(2)的返回值是什么？答案是：-1，-1。对 于第一个调用RetumTcst(O)在抛出ValueError异常后直接执行finally语句返回值为-1，这 点比较容易理解；那么对于第二个调用ReturnTeSt(2)为什么也返回-1呢？这是因为a>0, 会执行else分支，但由于存在finally语句，在执行else语句的return a语句之前会先执行 finally中的语句，此时由于finally语句中有return-1,程序直接返回了，所以永远不会返回 a对应的值2。此为使用finally语句需要注意的第二个陷阱。在实际应用程序开发过程屮， 并不推荐在finally中使用return语句进行返冋，这种处理方式不仅会带来误解而且可能会引 起非常严重的错误。

##### 建议26:深入理解None,正确判断对象是否为空

在学习Python的过程中，可能曾经有人写过以下代码用来判断变量a是否为空：

if a is not None:    析value is not empty

Do something

else:    #value is empty

Do some other thing

那么这样写有什么问题呢？先来了解一下Python中哪些形式的数据为空。Python中以 下数据会当做空来处理：

□常最None。

□常量 False。

□任何形式的数值类型零，如0、0L、0.0、Oj。

□空的序列，如"、()、［］。

□空的字典，如»。

□当用户定义的类中定义了 nonzero()方法和len()方法，并且该方法返回整数0或者布 尔值False的时候。

其中常量None的特殊性体现在它既不是0、False,也不是空字符串，它就是 一个空值对象。其数据类型为NoneType,遵循单例模式，是唯一的，因而不能创建 None对象。所有赋值为None的变量都相等，并且None与任何其他非None的对象 比较结果都为False。

〉>〉id(None)

505555980

\>>> None == 0

False

\>>> None -- False

False

»> None == •”’

False

\>>> a = None

\>>> id(a)

505555980

»> b = None

»> a m b

True

»> listl =[】

»> if listl is not None:

...    print "list is : M rlistl

••• else:

••.    print "list is empty"

• • •

list is:[]



\#None不为0

林None也不是False

參None更不是空字符串

\#任何賦值为None的对象都相同

①    判新list是否为空

②    输出结果表示上面的逻辑认为list不为空

上面的例子中对列表是否为空的判断显然不符合我们的要求，因为除非a被赋值为 None,否则else中的语句永远不会被执行。正确的形式如下：

if listl lvalue is not empty    ③判新listl是否为空的正确方式

Do something

else:    lvalue is empty

Do some other thing

标注③执行过程中会调用内部方法_nOnzerO_()来判断变量listl是否为空并返回其结 果。下面介绍一下_nOnzerO_()方法：该内部方法用于对自身对象进行空值测试，返回0/1

或True/False。如果一个对象没有定义该方法，Python将获取_len_()方法调用的结果来进 行判断。返回值为0则表示为空。如果一个类中既没有定义_len_O方法也没有 定义_nOnzerO_0方法，该类的实例用if判断的结果都为True。

class A:

def _nonzero_(self) :    # 类中实现了 _nonzero_ 方法

print1 testing A. nonzero_() 1 return True

def _len_(self):

print "get length•’ return False

if A (>:#该语句执行的时候会自动调用_nonzero_ ()方法 print 1 not empty*

else:

print ”empty•’

###### 程序输出如下：

testing A.nonzero_() not empty

##### ;议27:连接字符串应优先使用join而不是+

字符串处理在大多数编程程序语言中都不可避免，字符串的连接也是在编程过程中经常 需要面对的问题。Python中的字符串与其他一些程序语言如C++、Java有一些不同，它为不 可变对象，一旦创建便不能改变，它的这个特性直接影响到Python中字符串连接的效率。我 们首先来看常见的两种字符串连接方法。

###### 1 )使用操作符+连接字符串的方法如下：

\>» strl,str2,str3 = 1 testing 1/ 1 string 1r 1 concatenation >» strl + str2 + str3 • testing string concatenation •

\>>>

###### 2)使用join方法连接字符串的方法如下：

\>» strl, str2, str3 = f testing ’"string f, •concatenation >>> 1 *.join([strl,str2,str3])

• testing string concatenation ■

\>»

###### 思考这么一个问题：上述两种字符串连接的方法除了使用形式上的不同还有其他区别 吗？性能上会不会有所差异呢？来看下面这个测试例子：

import timeit #生成测试所偌要的字符数组

strlist=(l,it is a long value string will not keep in memory" for n m range (100000｝】

\#100000为字符串连接的数目，下面对应的濟试数据，每次帑要修改 def join_test():

return • 1 .join (strlist)    #使用join方法连接strlist中的元素并返回字符串

def plustest():

result = 1 *

for i,v in enumerate(strlist):

results results v    #使用+进行字符串连接

return result if _name_ == 1_main_•:

jointimer - timeit • Timer (••join_test ()", nfrom _main import join_test")

print jointimer.timeit(number = 100)

plustimer = timeit.Timer(”plus_test()n,"from _main_ import plus_test") print plustimer.timeit(number = 100)

给上面的程序传入一组测试参数(测试参数为3，10, 100, 1000. 10000, 100000 ；分 别表示每一次测试所要连接的字符串的数量)，程序用于测试join_test()和plusjesto这两个 方法在字符串连接规模改变时所消耗时间的变化。测试结果记录如表3-1所示。

表3-1 join test()和plus test()连接字符串所耗时间记录

| 连接的字符串数量 | joinjest运行时间   | plus test运行时间 |
| ---------------- | ------------------ | ----------------- |
| 3                | 0.0000389002415462 | 0.000132909158616 |
| 10               | 0.000126425785025  | 0.000602548533116 |
| 100              | 0.00033997190268   | 0.00357801180055  |
| 1000             | 0.00274368266155   | 0.030371768798    |
| 10000            | 0.0343671477735    | 0.379505083573    |
| 100000           | 0.441415223204     | 187.267786021     |

###### 表3-1可以用图3-3所示的X-Y图表示，其中X轴表示所要连接的字符串的数量，Y轴 表示消耗的时间。

cods ill



u



40000

35000

30000

25000

20000

15000

10000

-♦- join test + plustest

3

10

100

1000

10000 100000

String Size



图3-3 joinjest()和plusjest()耗时比较阁(运行时间扩大10000倍)

从分析测试结果图表我们不难发现：分别使用join()方法和使用+操作符来连接字符串， join()方法的效率要高于+操作符，特别是字符串规模较大的时候，join()方法的优势更为明 显(如连接数为100000的时候，两者耗时相差上百倍)。造成这种差别的原因在哪里呢？我 们来探W•—下。当用操作符+连接字符串的时候，由于字符串是不可变对象，其T作原理实 际上是这样的：如果要连接如下字符串：S1+S2+S34-.......+SN，执行一次+操作便会在内存

中申请一块新的内存空间，并将上一次操

![img](12 1699d828cfe301 3984Python0b8f84912afaae-48.jpg)



作的结果和本次操作的右操作数复制到新 申请的内存空间，即当执行S1+S2的时候 会申请一块内存，并将SI、S2复制到该内 存屮，依次类推，如图34所示。因此，在 N个字符串连接的过程中，会产生N-1个 中间结果，每产生一个中问结果都需要申 请和复制一次内存，总共需要申请N-1次

内存，从而严重影响7执行效率。N越大，    图操作符+连接字符串示意图

对内存的申请和复制的次数越多，+操作符的效率就越低。因此，整个字符连接的过程中， 相当于S1被复制N-1次，S2被复制N-2次....SN复制1次(并不完全等同于S1复制N-1 次，W为后续复制都是对中间结果的复制)，所以字符串的连接时间复杂度近似为0(111)。

而当用join()方法连接字符串的吋候，会首先计算需要申请的总的内存空间，然后一次 性申请所需内存并将字符序列中的每一个元素复制到内存中去，所以join操作的时间复杂度 为0⑻。

因此，字符串的连接，特别是大规模字符串的处理，应该尽量优先使用join而不是+。

##### 建议28:格式化字符串时尽量使用.format方式而不是％

Python中内置的％操作符和.format方式都可用于格式化字符串。先来看看这两种具体 格式化方法的基本语法形式和常见用法。

%操作符根据转换说明符所规定的格式返回一串格式化后的字符串，转换说明符的基本 形式为：％ ［转换标记］［宽度［.精确度］］转换类型。其中常见的转换标记和转换类型分别如 表3-2和表3-3所示。如果未指定宽度，则默认输出为字符串本身的宽度。

表3-2格式化字符串转换标记

| 转换标记  | 解    释                                              |
| --------- | ----------------------------------------------------- |
| -         | 表示左对齐                                            |
| 十        | 在正数之前加t +                                       |
| (a space) | 表示正数之前保留空格                                  |
| 林        | 在八进制数前面显示零C09,在十六进制前面显示’Ox•或者'0X |
| 0         | 表示转换值若位数不够则用0填充而非默认的空格           |

表3-3格式化字符串转换类型

| 转换类型 | 解    释                                                     |
| -------- | ------------------------------------------------------------ |
| C        | 转换为单个字符，对十数字将转换该值所对应的ASCII码            |
| S        | 转换为字符串.对于非字符串对象，将默认调用str()函数进行转换   |
| r        | 用repr()函数进行字符串转换                                   |
| id       | 转换为带符号的十进制数                                       |
| u        | 转换为不带符号的十进制数                                     |
| o        | 转换为不带符号的八逬制                                       |
| xX       | 转换为不带符号的十六进制                                     |
| eE       | 表示为科学计数法表不的浮点数                                 |
| fF       | 转成浮点数(小数部分自然截断)                                 |
| gG       | 如果指数大于>4或者小于楮度值则和e相同，其他悄况与f相同；如果指数大于-4或者 小于精度值则和E相同，其他悄况与F相同 |

###### %操作符格式化字符串时有如下儿种常见用法：

###### 1）    直接格式化字符或者数值。

\>» print ”your score is %06.1 fn % 9.5 your score is 0009.5

\>>>

###### 2）    以元组的形式格式化。

\>» import math

\>» itemname = • circumference *

»> radius = 3

\>>> print "the %s of a circle with radius %f is %0.3f " %《itemname,radius,math•p i*radius*2）

the circumference of a circle with radius 3.000000 is 18.850

###### 3)以字典的形式格式化。

\>» itemdict = {1itemname1:1 circumference 1r1 radius 1:3,1 value 1:math.pi*radius*2}

\>» print "the %(itemname)s of a circle with radius %(radius)f is %(value)0.3f

’• % itemdict

the circumference of a circle with radius 3.000000 is 18.850

\>»

.format方式格式化字符串的基本语法为：［［填充符］对齐方式］［符号］［#］［0］［宽度］［，】 ［.精确度］［转换类型］。其中填充符可以是除了 “{”和“广符号之外的任意符号，对齐 方式和符号分别如表3-4和表3-5所示。转换类型跟％操作符的转换类型类似，可以参见 表 3-3。

| 表3-4 .format方式格式化字符串的对齐方式 |                                                              |
| --------------------------------------- | ------------------------------------------------------------ |
| 对齐方式                                | 解    释                                                     |
| <                                       | 表示左对齐.是大多数对象为默认的对齐方式                      |
| >                                       | 表示右对齐，数值默认的对齐方式                               |
| =                                       | 仅对数值类型有效，如果有符号的话，在符号后数值前进行填充，如-000029 |
| A                                       | 居中对齐，用空格进行填充                                     |

| 表3-5 .format方式格式化字符串符号列表 |                                          |
| ------------------------------------- | ---------------------------------------- |
| 符号                                  | 解    释                                 |
| 十                                    | 正数前加+,负数前加-                      |
| —                                     | 正数前不加符号，负数前加为数值的默认形式 |
| 空格                                  | 正数前加空格，负数前加-                  |

###### .format方法几种常见的用法如下: 1）使用位置符号。

»> 11 The number {0:,} in hex is: {0:#x},the number {1} in oct is {1: #o}w. format ( 4746,45)

• The number 4,746 in hex is: 0xl28ar the number 45 in oct is 0o551

\>>>

\#其中{0}表示format方法中对应的第一个参数，{1}表示format方法对应的第二个参教.依次递推

###### 2)使用名称。

»> print "the max number is {max},the min number is {min},the average number is {average: 0 • 3f} •’. format (max=18 9, min=12 • 6, average=23.5)

the max number is 189/the min number is 12.6/the average number is 23.500

###### 3 )通过属性。

\>» class Customer (object):

def



.•    def

• ♦

(self=self)



init_(self,name,gender,phone): self.name = name self.gender - gender self.phone = phone

str_(self):

return * Customer({self•name){self.gender},{self.phone" ••format

\#通过str()函数返回格式化的结果

»> str (Customer ("Lisa", "Female", n67889")) 1 Customer(Lisa,Female, 67889) •

\>>>

###### 4)格式化元组的具体项。

\>>> point = (1,3)

»> •X:{0[0]};Y:{0[l】H .format (point)

'X: 1; Y: 3 '

\>>>

###### 在了解了两种字符串格式的基本用法之后我们再回到本节开头提出的问题：为什么要尽 量使用format方式而不是％操作符来格式化字符串。

理由一：format方式在使用上较％操作符更为灵活。使用format方式时，参数的顺序 与格式化的顺序不必完全相同。如：

\>» "The number {1} in hex is: {l:#x},the number {0} in oct is {0: #o}n. format (474

6,45)

rThe number 45 in hex is: 0x2d,the number 4746 in oct is 0oll2121

上例中格式化的顺序为{1}，{0}，其对应的参数申明的顺序却相反，{1}与45对应， 而用％方法需要使用字典形式才能达到同样的目的。

理由二：format方式可以方便地作为参数传递。

\>>> weather^[("Monday1’，"rain"), ("Tuesday","sunny”)，("Wednesday","sunny">, ("Thurs dayM，rain") , ("Friday", "cloudy”)】

\>» formatter = MWeather of 1 { 0 [0) } 1 is •{ 0 [ 1 ]}"•. format

\>>> for item in map (formatter, weather) : # format 方法作为第一个参数传递给 map 函数

...    print item

• • •

Weather of ’Monday* is 1 rain1

Weather of 1 Tuesday1 is •sunny1

Weather of 1 Wednesday* is •sunny*

Weather of •Thursday* is * rain1

Weather of 1 Friday* is •cloudy1

»>

理由三：％最终会被.format方式所代替。这个理由可以认为是最直接的原因，根据 Python 的官力•文矜([http://docs.python.Org/2/library/stdtypes.html#string-formatting](http://docs.python.Org/2/library/stdtypes.html%23string-formatting)), .format() 方法最终会取代％，在Python3.0中.format方法是推荐使用的方法，而之所以仍然保留％ 操作符是为了保持向后兼容。

理由四：％方法在某些特殊情况下使用时需要特别小心。

\>> itemname = (’’mouse", "mobilephone", "cup")

\>>> print Hitemlist are %s" % (itemname)    # 使用％ 方法格式化元组

Traceback (most recent call last):

File "<stdin>", line 1, in <module>

TypeError: not all arguments converted during string formatting

\>>>

\>>> print "itemlist are %s" % (itemname,)    禅注意后面的符号，

itemlist are ("mouse•, fmobilephone1,    * cup•)

林使用format方法直接格式化不会拋出异常



\>>> print "itemlist are {}H.format(itemname) itemlist are (•mouse1, •mobilephone•,    1 cup')

»>

上述例子中本意是把itemname看做一个整体来进行格式化，但直接使用时却抛出 TypeError,对于％直接格式化字符的这种形式，如果字符本身为元组，则需要使用在％使 用(itemname,)这种形式才能避免错误，注意逗号。

##### 建议29:区别对待可变对象和不可变对象

Python中一切皆对象，每一个对象都有一个唯一的标示符(id())、类型(type())以及值。 对象根据其值能否修改分为可变对象和不可变对象，其中数字、字符串、元组属于不可变对 象，字典以及列表、字节数组属于可变对象。而“菜鸟”常常会试图修改字符串中某个字符。 看下面这个例子：

teststr = WI am a pytlon string" teststr[ print teststr

###### 字符串为不可变对象，任何对字符串中某个字符的修改都会抛出异常。修改字符串中某 个字符可以采用如下方式：

\>>> teststr = "I am a pytlon string"

\>>> import array

\>» a ■ array. array (• c \ teststr)

»> a[10] = ,h,

»> a

array (* c * r * I am a Python string1)

»> a.tostringO

11 am a Python string*

###### 再来看下面一段程序：

class Student(object):

def _init_ (self, name, course=⑴：

self.name=name self.course=course

def addcourse(self,coursename):

self.course.append(coursename)

def printcourse (self):

for item in self.course:

print item

stuA=Student("Wang yi")

stuA.addcourse {’’English")

stuA. addcourse (’’Math")

print stuA. name +."s course: M stuA.printcourse ()

print n-----------------------•.

stuB=Student("Li sanw)

stuB.addcourse("Chinese"> stuB.addcourse (•• Physics") print stuB.name 十*"s course:" stuB.printcourse ()

###### 上述代码清单描述的是两个不同的学生选择不同课程的场景。这个程序宥什么问题吗? 通过运行程序得到如下输出结果：

Wang yi1s course:

English

Math

Li san1s course:

English

Math

Chinese

Physics

你会诧异地发现Li san同学所选的多了 English和Math两门课程。这是怎么回事呢？ 通过査看id(stuA.course)和id(stuB.course),我们发现这两个值是一样的，也就是说在内存中 指的是同一块地址，但stuA和stuB本身却是两个不同的对象。在实例化这两个对象的时候, 这两个对象被分配了不同的内存空间，并且调用init()函数进行初始化。但由于init()函数的 第二个参数是个默认参数，默认参数在函数被调用的时候仅仅被评估一次，以后都会使用第 一次评估的结果，因此实际上对象空间里面course所指向的是list的地址，每次操作的实际 上是list所指向的具体列表。这是我们在将可变对象作为函数默认参数的时候要特别警惕的 问题，对可变对象的更改会直接影响原对象。要解决上述例子中的问题，最好的方法是传人 None作为默认参数，在创建对象的时候动态生成列表。具体代码如下：

def _init_ (self, name, course=NoneH self.name=name if course is None:course=[] self.course=course

###### 对于可变对象，还有一个问题是®要注意的。我们通过以下例子来说明：

»> listl=[y, "c1 ]

\>» list2 - listl >» listl .append (1 d 1)

\>» listl

[*a1#    , 9 c9,    •d1]

»> list2    ①list2也会发生变化

l，a\    •<!•]

»> list3 = listl[:]    ②切片操作相当于浅拷贝

\>» list3 . remove (1 a 1)

\>» list3 [•b\ 'c', 'd»]

\>» listl

[•a\    •b*.    •d1)

»> list2

[*a* f •b., fc.' •d*]

»> id(list3) ③重新指向一坱内存

14075304

»> id (listl)

13418864

»> id(list2)

13418864

上面的例子中对listl的切片操作实际会重新生成一个对象，因为切片操作相当于浅拷 贝，因此对list3的操作并不会改变listl和list2本身。我们再来看以下不可变对象的简单 例子：

a=l a+*2 print a

![img](12 1699d828cfe301 3984Python0b8f84912afaae-49.jpg)



我们会发现此时a的值变为3,这是理所当然的，可是仔细一想a是属于数值类型，是 不可变对象，怎么会发生改变呢？实际上Python中变景a存放 的是数值1在内存中的地址，数值1本身才是不可变对象。在 上面的过程中所改变的是a所指向的对象的地址，数值1并没 有发生改变，当执行a+=2的时候重新分配了一块内存地址存 放结果，并将a的引用改为该内存地址，而对象1所在的内存 空间会最终被垃圾回收器回收。上述分析的图示如图3-5所示。

通过id()函数分析也可以证实上述变化过程。    图3-5 a在内存中的变化示意图

\>>> a=l >>> id(a) 12184696 »> id(l) 12184696

\>>> a+薫2 »> a 3

»> id (a) 12184672 »> id(3) 12184672



①id(a)和icHl)的值并不相等



②id(a)的馆发生改变



③id(a)和id(3)的值相同



id()函数分析也可以证实上述变化过程，对于不可变对象来说，当我们对其进行相关操 作的时候，Python实际上仍然保持原来的值而是重新创建一个新的对象，所以字符串对象不 允许以索引的方式进行赋值，当有两个对象同时指向一个字符串对象的时候，对其中一个对 象的操作并不会影响另一个对象。

»> strl



••hello world•’



\>» str2 = strl >» strl = strl [: -5] >» strl

•hello •

\>» str2

1 hello world1 >»

##### 建议30:[]、()和{}: 一致的容器初始化形式

列表是一个很有用的数据结构，它在Python中属于可变对象，列表中的元素没有限制， 可以重复可以嵌套，操作上支持对单个元素的读取和修改，还支持分片、排序、插入、删除 等。由于其灵活性，在实际应用中经常会看到它的身影。下面的程序遍历列表中的每个元 索，并根据要求(去掉单词所包含的空格后首字母是否为大写)生成一个新的list。

words = [* Are’， • abandon * r * Passion 1r1 Business 19 1 fruit 19 •quit•J

size = len(words)

newlist =[]

for i in range(size):

if words[i].strip().istitle (): newlist.append(words[i])

print newlist

那么，这段程序有什么问题吗？就程序本身来说并没有什么明显的问题，但有更好的实 现方式。这就是列表解析(list comprehension)所涉及的内容了。先来了解一下列表解析的基 本知识点。

列表解析的语法为：[expr for iter item in iterable if cond expr]。它迭代 iterable 中的每一 个元素，当条件满足的时候便根据表达式expr计算的内容生成一个元素并放人新的列表屮， 依次类推，并最终返冋整个列表。在语法上，它等价于下面代码段：

Newlist =[]

for iter_item in iterable: if cond_expr:

Newlist.append(expr)

其中条件表达式不是必需的，如果没有条件表达式，就直接将expr中计算出的元索加入 List中。列表解析的使用非常灵活。

1)支持多重嵌套。如果需要生成一个二维列表可以使用列表解析嵌套的方式。示例 如下：

»> nested list ® [[•Hello、* World1 ] / [•Goodbye1, •World’]]

»> nested_list = [(s.upper() for s in xs] for xs in nested_list]

»> print nested_list

[[•HELLO \    •WORLD•b [•GOODBYE•,    •WORLD•】】

\>>>

2 )支持多重迭代。下面的例子中a、b分别对应两个列表中的元索，[(a,b) for a in [•a’，T，l，2] for b in [T,3,4/b’] if a != b]表示:列表[，a.，T，l，2]和[T，3,4，’b’]依次求笛卡儿积之后 并去棹元素值相等的元组之后所剰下的元组的集合。

»> [ (a,b) for a in [•a,/,l\l,2】 for b in [ • 1 •, 3,4, ■ b •】if a ! = bj

(Ca\    •l1), Ca\    3) ,    Ca\    4), (fa\ 9b9)f Cl\ 3), Cl\ 4), Cl\    9b9), (lf

•1.),    (1, 3), (1,    4),    (1,    (2, T), (2, 3), <2, 4),    <2, 9b9)]

\>»

3)列表解析语法中的表达式可以是简单表达式，也可以是复杂表达式，其至是函数。

\>>> def f(v):

…    if v%2    == 0:

...    v = v**2

...    else:

...    v = v+1

...    return    v

參 參 參

»> [f (v) for v inif v>0J # 表达式可以是函数

(4, 4f 16]

\>>> [v**2 if v%2 ==0 else v+1 for v in [2,3,4，-l】 if v>0】# 也可以是普通计算 [4, 4, 16]

\>>>

4)列表解析语法中的iterable可以是任意可迭代对象。下面的例子中把文件句柄当做一 个可迭代对象，可轻易读出文件内容。

fh = open (M test, txt ,fr,f)

result = [i for i in fh if ”abc" in i] ♦文件句柄可以当做可迭代对象 print result

了解完列表解析的基本知识之后，本节开头的例子你应该知道怎么使用更为简洁了。那 么，为什么要推荐在需要生成列表的时候使用列表解析呢？

1)    使用列表解析更为直观清晰，代码更为简洁。本节开头的例子改用列表解析，直接 可将代码行数减少为2行，这在大型复杂应用程序中尤为重要，因为这意味着潜在的缺陷较 小，同时代码清晰直观，更容易阅读和理解，可维护性更强。

2)    列表解析的效率更髙。本节开头的例子用两种不同方法实现后进行测试，测试结果 表明列表解析在时间上有一定的优势，这主要是因为普通循环生成List的时候一般需要多次 调用appendO函数，增加了额外的时间开销。需要说明的是对于大数据处理，列表解析并不 是一个最佳选择，过多的内存消耗可能会导致MemoryError0

除了列表可以使用列表解析的语法之外，其他几种内a的数据结构也支持，比如元组 (tuple)的初始化语法是(expr for iter item in iterable if cond expr),而集合(set)的初始化 语法是｛expr for iteritem in iterable if condexpr｝，甚至字典(diet)也有类似的语法｛cxprl, expr2 for iter item in iterable if cond expr｝。它们的使用类似列表解析，但需要注意，因为元

组也适用赋值语句的装箱和拆箱机制，所以需要注意(I )与(1,)是不同的：前者为数字1, 后者才代表元组(注意1后面的

»> type ((D)

<type * int*>

»> type ( (1/ ))

<type •tuple1>

\>»

此外，当函数接受一个可迭代对象参数吋，可以使用元组的简写方式。

\>>> def foo(a):

... for i in a:

"•    print i

• • •

»> foo([l, 2, 3])

1

2

3

\>>> foo(i for i in range (3) if i % 2 == 0)

0

2

##### 建议31:记住函数传参既不是传值也不是传引用

###### Python中的函数参数到底是传值还是传引用呢？这是许多人在学习过程中会纠结的一个 问题，很多论坛也有这样的讨论。总结来说基本有3个观点：传引用；传值；可变对象传引 用，不可变对象传值。这3个观点到底哪个正确呢？我们逐一讨论。

1)传引用。先来看一个非常简单的例子(请不要因为例子太简单而不以为然，小故事往 往蕴含大道理，它照样能说明问题)。

###### 示例一•:

»> def inc (n):

... print id(n)

... n = n+1

... print id(n)

• • •

\>>> n =3

\>>> id(n)

34450040

\>» inc (n)

34450040    #修改之前的n的id值

34450028    #修改之后的n的id值

\>» print n

3

»>

按照传引用的概念，上面的例子期望的输出应该是4,并且inc()函数里面执行操作 n=n+l的前后n的id值应该是不变的。可是事实是不是这样的呢？非也，从输出结果来看n 的值还是不变，但id(n)的值在函数体前后却不一致。显然，传引用这个说法是不恰当的。

###### 2)    传值3来看一个示例。

示例二：

»> def change_list (orginator_list):

... print "orginator list is:orginator_list

...    new^list = orginator一list

•••    new^list.append(nI am    new")

...    print "new list is:”，    new^list

•    "    return new^list

###### 參 參 ♦

»>

»> orginator list = (• a 1 r 1 b1 r f c 1 ]

»> new list = change_list (orginator^list) orginator list is:    fb1 r 1 c 1J

new list is: [ *a 1 r    1 c1 r 11 am new* J

\>» print new_list

[•a.,    'b.,    fI am new* ]

\>» print orginator一list

[*a 1 r •b\    1 c1 r • I am new.】

»>

传值通俗来讲就是这个意思：你在内存中有一个位置，我也有一个位置，我把我的值 复制给你，以后你做什么就跟我没关系了，我是我，你是你，咱俩井水不犯河水3可是上面 的程序输出根本就不是这么一回事，显然changeJistO函数没有遵守约定，调用该函数之后 orginator list也发生了改变，这明显侵犯了 orginatorjist的权利。这么看来传值这个说法也 不合适。

###### 3)    可变对象传引用，不可变对象传值。这个说法最靠谱，很多人也是这么理解的，但 这个说法到底是否准确呢？再来看一个示例。

示例三：

\>» def change_me (org_list):

...    print id(org_list)

...    new^list = org_list

...    print id(new_list,

...    if len(new_list)>5:

•    ••    new一list =【*a •, ’b,,*c•J

...    for i,e in enumerate(new_list):

...    if isinstance<e,list):

...    new_list [i】=••***"    #将元素为list类型的咎换为***

•••    print new list

.•.    print id(newlist)

\>>>

传入参数orgjist为列表，属于可变对象，按照可变对象传引用的理解，newjist和org_ list指向同一块内存，因此两者的id值输出一致，任何对newjist所执行的内容的操作会直 接反应到orgjist,也就是说修改newjist会导致orgjist的直接修改，对吧？来看测试例子。

»> testl = [1, [.a.,1,3], >>> change me(testl) 35260216

35260216

[1, •****, ,***.,6】 35260216 >>> print testl [1/ •***., •***•/ 6]

\>>> test2-[1,2,3,4,5,6,(1]] >>> change^me(test2) 35260136



[2r1],6]

\#testl的元素个数小于5



\#testl中所有list类型的元素铈替换为了 ***



\#testl中元素的个数大于5



35260136

(fa\ fb\ fcM

35250664 #new_list 的 id 值发生 了改变

\>» print test2    #test2并没有发生改变

(1, 2, 3,    5, 6, [1]】

\>»



对于testl、newJist和orgjist的表现和我们理解的传引用确实一致，最后testl被修改 为[1，•***•，•***•，6],但对于输人test2、new list和orgjist的id输出在进行列表相关的操作 前是一致的，但操作之后new list的id值却变为35250664,整个test2在调用函数change_ me()后却没有发生任何改变，可是按照传引用的理解期望输出应该是[’aYb’/c*]，似乎可变对 象传引用这个说法也不恰当。

那么Python函数中参数传递的机制到底是怎么样的？要明白这个概念，首先要理解： Python中的赋值与我们所理解的C/C++等语言中的赋值的意思并不一样。如果有如下语句：

a =5, b = a, b«7 ;

我们分别来看一下在C/C-H-以及Python中是如何赋值的。

如阁3-6所示，C/C++中当执行b=a的时候，在内存中申请一块内存并将a的值复制到 该内存中；当执行b=7之后是将b对应的值从5修改为7。

b=7导致b的值从5修改到7

图3-6 C/C++赋值时内存的变化



但在Python中赋值并不是复制，b=a操作使得b与a引用同一个对象。而b=7则是将b 指向对象7,如图3-7所示。

图3-7 Python中赋值语句对应的内存变化

我们通过以下示例来验证上面所述的过程：

\>>> a - 5

»> id (a)

34450016

〉>> b = a

»> id(b)    #b-a之后b的id()值和a —样

34450016

〉>〉b = 7

»> id(b)    #b=7之后b指向对象7，id()值发生改变

34449992

»> id (a)

34450016

从输出可以看出，b=a赋值后b的id()输出和a—样，但b=7操作后b指向另外一块空 间。可以简单理解为，b=a传递的是对象的引用，其过程类似于贴“标签”，5和7是实实在 在的内存空间，执行a=5相当于申请一块内存空间代表对象5并在上面贴上标签a,这样a 和5便绑定在一起了。而b=a相当于对标签a创建了一个别名，因此它们实际都指向5。但 b=7操作之后标签b重新贴到7所代表的对象上去了，而此时5仅有标签a。

理解了上述背景，再回头来看看前面的例子就很好理解了。对于示例一，n=n+l,由于 n为数字，是不可变对象，ii+l会重新申请一块内存，其值为n+1,并在函数体中创建局部 变量n指向它。当调用完函数inC(n)之后，函数体中的局部变量在函数外不并不可见，此吋 的n代表函数体外的命名空间所对应的n,值还是3。而在示例三中，当orgjist的长度大于 5的时候，new list = ['a'/b'/c*]操作重新创建了一块内存并将new list指向它。当传人参数为 test2=[l,2,3,4,5,6,[l]]的时候，函数的执行并没有改变该列表的值。

因此，对于Python函数参数是传值还是传引用这个问题的答案是：都不是。正确的叫法 应该是传对象(call by object)或者说传对象的引用(call-by-object-reference)。函数参数在传 递的过程中将整个对象传人，对可变对象的修改在函数外部以及内部都可见，调用者和被调 用者之间共享这个对象，而对于不可变对象，由于并不能真正被修改，因此，修改往往是通 过生成一个新对象然后赋值来实现的。

##### I议32:警惕默认参数潜在的问题

###### 默认参数可以给函数的使用带来很大的灵活性，当函数调用没有指定与形参对应的实参 时就会自动使用默认参数。

\>>> def appendtest (newitemr lista = []):    # 默认参教为空列表

•••    print id(lista)

...    lista.append(newitem)

print id (lista)

...    return lista

\>>> appendtest (’a1,[1,2]]}

39644216

39644216

[•b\ 2, 4,【lf 2],    •a1]

\>>>

现在请读者思考这么一个问题：如果第二个参数采取默认参数，连续调用两次 appendtest(l)、appendtestfa’)，函数的返回值是多少？期望的结果应该是[1]和[’a’】，对吧？ 可是实际情况却输出了 [1]和[l/a'Jo那么这是什么原因呢？

def在Python中是一个可执行的语句，当解释器执行def的时候，默认参数也会被计算， 并存在函数的.func defaults属性中。由于Python中兩数参数传递的是对象，可变对象在调 用者和被调用者之间共享，因此当首次调用appendtestd)的时候，[]变为[1],而再次调用的 时候由于默认参数不会重新计算，在[1]的基础上便变为了 [l/a1]。我们可以通过査看函数的 func_defaults来确认这一点。

»> appendtest (1)

39022960

39022960

[1】

»> appendtest. f unc_defaults    #第一次调用后默认参数变为[1】

(⑴，)

»> appendtest (• a •)

39022960

39022960

[1， 'a']

»> appendtest. f unc_defaults    #经过第二次调用变为[1，’ a’ ]

(【1, .a.】，)

\>»

\>>> appendtest. f unc一defaults [0] [: J =[]    林可以直接修改 func_defaults 風性

\>» appendtest. func_defaults

((Jr)

###### 如果不想让默认参数所指向的对象在所有的函数调用中被共享，而是在函数调用的过程 中动态生成，可以在定义的时候使用None对象作为占位符。因此本节开头的例子应该修正 为如下形式：

»> def appendtest (newitem, lista « None) :# JK认参数改为 None ...    if lista is None:

.• .    lista = [J

•    • •    lista.append(newitern)

...    return lista

最后以一个问题结束本节：假设report()函数需要传人当前系统的时间并做一些处理, 下面两种参数传递方式哪种正确呢？读者应该知道答案了！

»> import time

\>» def report (when = time. time ()):

•••    pdSS

•    蠢 •

\>>> def report(when = time.time):

... pass

##### 建议33:慎用变长参数

Python支持可变长度的参数列表，可以通过在函数定义的时候使用*args和**kwargS这 两个特殊语法来实现(args和kwargs可以替换成任意你喜欢的变量名)。先来看两个可变长 参数使用的例子。

1)    使用*args来实现可变参数列表：*args用于接受一个包装为元组形式的参数列表来 传递非关键字参数，参数个数可以任意，如下例所示。

def SumFun(*args): result = 0 for x in args[0:】：

result 十=x return result

print SumFun<2,4) print SumFun(1,2,3,4,5) print SumFun()

2)    使用**kwargs接受字典形式的关键字参数列表，其中字典的键值对分别表示不可变 参数的参数名和值。如下例中apple表示参数名，而fruit为其对应的value,可以是一个或者 多个键值对。

def category_table(**kwargs):

for name, value in kwargs.items():

print 1{0} is a kind of {1)1.format(namer value) category_table(apple = 'fruit1, carrot = 1vegetable•9 Python = •programming language1) category_table(BMW = fCar•)

如果一个函数中同时定义了普通参数、默认参数，以及上述两种形式的可变参数，那么 使用情况又是怎样的呢？来看一个简单的问题。

def set_axis (xr y, xlabel="x”，ylabel = Myf,/ *args, **kwargs): pass

对于上面的函数下面几种调用方式哪些是不正确的呢？

set axis (2,3, "testl", "test2"，test3"f myJcwarg=Mtest3H)    ①

set axis (2,3, my kwarg=”test3")

set axis (2,3, "test 1", my_kwarg=’’test3")    ②

set axis ("testl"/ •’test2M, xlabel="new_x",ylabel = "new_y”，my_kwarg="test3"}

set axis (2,"testl", "test2M,ylabel = "new_y", my kwarg=”test3")

答案是：上面的所有调用方式都是合法的！实际上在4种不同形式的参数同时存在的情 况下，会首先满足普通参数，然后是默认参数、如果剩余的参数个数能够覆盖所有的默认参 数，则默认参数会使用传递时候的值，如标注①处的函数在调用的时候xlabel和ylabel的值 分别为“testl”和“test2”；如果剩余参数个数不够，则尽最大可能满足默认参数的值，标 注②中xlabel值为“testl”，而ylabel则使用默认参数y。除此之外其余的参数除了键值对以 外所有的参数都将作为args的可变参数，kwargs则与键值对对应。那么，为什么要慎用可变 长度参数呢？原因如下：

1)    使用过于灵活。上面的示例set_axiS()随随便便就能写出好几种不同形式的调用方 式。在混合普通参数或者默认参数的情况下，变长参数意味着这个函数的签名不够清晰，存 在多种调用方式。如果调用者需要花费过多的时间来研究你的方法该如何调用，显然这并不 是一种值得提倡的方式，即使你认为它很炫，很髙端大气上档次，但在团队合作开发的项目 中，千万不要有这种想法，团队开发不是你的个人竞技场，代码编写从某种程度上说也是一 种沟通，清晰准确是一个很重要的指标。另外变长参数可能会破坏程序的健壮性。

2)    如果一个函数的参数列表很长，虽然可以通过使用来简化函数 的定义，但通常这意味着这个函数可以有更好的实现方式，应该被重构。前面的例子中 SumFun(*args)如果改为def Sum(seq),在函数凋用之前将需要传递的参数保存在一个序列 中，如seq = (l，2,3,4,5,6,7),再将序列seq作为参数传入Sum中也是一个不错的选择。同样 如果使用**kwargs的目的仅仅是为了传入一个字典，这将是一个非常糟糕的选择。

3)    可变长参数适合在下列情况下使用(不仅限于以下场景)：

□为函数添加一个装饰器。

»> def mydecorator (fun):

...    def new <*args# **kwargs):

...    # ...

• ..    return fun(*args,**kwargs)

••.    return new

»>

###### □如果参数的数目不确定，可以考虑使用变长参数。如配置文件testxfg内容如下:

[Defaults] name = test version = 1.0 platform = windows

###### fUnC(**kwargs)用T读取一些配置文件中的值并进行全局变量初始化。

from ConfigParser import ConfigParser

conf = ConfigParser ()

conf.read(•test.cfg•)

conf^dict = diet(conf.items(•Defaults 1))

def func (**kwargs):

kwargs.update(conf diet) global name

name - kwargs.get(1 name•) global version

version = kwargs.get(•version•) global platform

platform = kwargs.get(•platform*)

###### □用来实现函数的多态或者在继承情况下子类需要调用父类的某些方法的时候。

\>» class A (object):

..• def somefun(self,pl,p2):

...    pass

\>» class B (A):

.•• def myfun(self,p3,*args,**kwargs):

...    super(3,self).somefun(*args,**kwargs)

\>»

##### ;议34:深入理解str()和rep「()的区别

###### 函数str()和repr()都可以将Python中的对象转换为字符串，它们的使用以及输出都非 常相似，以至于很多人认为这两者之间并没有区别，但事实是不是这样呢？先来看对于不同 类型的输人，这两个函数的输出有何异同，如表3-6所示。

表3-6 str()和repr()函数在不同悄况下输出比较

| 输入        | str()     | repr()     |
| ----------- | --------- | ---------- |
| a= 1        | T         | •1.        |
| a = 0.1     | •o.r      | •o.r       |
| a ="abc”    | •abc*     | H,abc,M    |
| a = (1,2,3) | •(1,2,3)' | •(1,2, 3). |

(续)

| 输入               | str()                           | repr()                          |
| ------------------ | ------------------------------- | ------------------------------- |
| class A(object):   | •’〈class • main .A’>"          | "<class • main .A’>"            |
| pass               |                                 |                                 |
| a = A()            | •<main.A object at 0x0228C6B0>* | •<main.A object at 0x0228C6B0>, |
| deff():pass        | •〈function f at 0x02284830〉’  | •<function fat 0x02284830〉*    |
| a=                 | ••{•a.: 1厂                     | ••{•a.: 1}W                     |
| a = 2/3.0 ①        | •0.6666666666671                | *0.6666666666666666-            |
| a = [l，2,3]       | •(1,2, 3]*                      | 11,2, 3]*                       |
| a = Decimal(1.25)② | •1.25*                          | ,fDecimalC1.25•广               |
| a = date.todayO ③  | •2013-07-20*                    | ,datetime.date(2013> 7, 20)'    |
| a = H\r\nR    ④    |                                 | Wf\\r\\nm                       |

从表3-6看出，reprO和str()对于大多数数据类型的输出基本一致，因此混淆也就不难 理解了。但它们也存在不一致的情况。那么，这两者之间到底有什么区别呢？总结来说有以 下几点：

1)    两者之间的目标不同：str()主要面向用户，其目的是可读性，返回形式为用户友好 性和可读性都较强的字符串类型；而repr()面向的是Python解释器，或者说开发人员，其目 的是准确性，其返回值表示Python解释器内部的含义，常作为编程人员debug用途。

###### 2)    在解释器中直接输入a时默认调用repr()函数，而print a则调用str()函数。

###### 3)    repr()的返回值一般可以用eval()函数来还原对象，通常来说有如下等式。

obj == eval(repr(obj ))

但需要提醒的是，这个等式不是所有情况下都成立，如用户重新实现的repr()方法如下。

»> s=." 1 n

\>>> str(s)

\>>> repr(s)

\ t

\>>> eval(repr (s)) == s True

\>>> eval(str(s))

• *

\>>> eval(str(s)) == s False »>

4)这两个方法分别调用内建的_5打_()和_1"印^_()方法，一般来说在类中都应该定 义方法，m_str_()方法则为可选，当可读性比准确性更为重要的时候应该考虑 定义_str_O方法。如果类中没有定义_str_()方法，则默认会使用_repr_()方法的结

###### 果来返回对象的字符串表示形式。用户实现_repr_()方法的时候最好保证其返回值可以用 cval()方法使对象重新还原。

##### 建议35:分清staticmethod和classmethod的适用场景

###### Python中的静态方法(staticmethod)和类方法(classmethod)都依赖于装饰器 (decorator)来实现。其中静态方法的用法如下：

class C(object):

@staticmethod

def f(argl, arg2r ...):

###### 而类方法的用法如下：

class C (object):

^classmethod

def f (clsF argl, arg2,

静态方法和类方法都可以通过类名.方法名(如c.f())或者实例.方法名(c().f())的形 式来访问。其中静态方法没有常规方法的特殊行为，如绑定、非绑定、隐式参数等规则，而 类方法的调用使用类本身作为其隐含参数，但调用本身并不需要显示提供该参数。

class A(object):

def instance_method(self,x):

print Mcalling instance method instance一method(%s,%s)"%(self,x)

^classmethod

def class_method(cis,x):

print "calling class_method (%S/ %s) (cis，x)

^staticmethod

def static_method(x):

print "calling static_method (%s) f,%x

a = A()

a.instance一method("test")

\#    输出 calling instance method instance一method(<_main_.A object at OxOOD66B50>, test) a.class_method("test">

\#    输出 calling class_method (<class 1_main_. A 1 >r test)

a . static一method ("test■•)

\#    檢出 calling static method (test)

###### 上面的例子是类方法和静态方法的简单应用，从程序的输出可以看出虽然类方法在调用 的时候没有显式声明Cis,但实际上类本身是作为隐含参数传人的。

在了解完静态方法和类方法的基本知识之后再来研究这样一个问题：为什么需要静态方 法和类方法，它们和普通的实例方法之间存在什么区别？我们通过对具体问题的研究来回答 这些问题。假设有水果类Fruit,它用属性total表示总量，Fruit中已经有方法set()来没置总 量，print_total()方法来打印水果数ft。类Apple和类Orange继承自Fruit。我们需要分别跟 踪不同类型的水果的总M。有好几种方法可以实现这个功能。

方法一：利用普通的实例方法来实现。

在Apple和Orange类中分别定义类变fi total,然后再覆盖基类的set()和print_total()方 法，但这会导致代码冗余，因为本质上这些方法所实现的功能相同(读者可以自行完成)。

方法二：使用类方法实现，具体实现代码清单如下。

class Fruit(object): total - 0 @classmethod def print_total(cis):

print cis.total #print id(Fruit•total)

\#print id (cis.total)

@classmethod

def set (cis, value):

\#print "calling class_method (%s, %s) (cis, value) cis.total = value    •

class Apple(Fruit): pass

class Orange(Fruit):

Pass

appl - Apple() appl.set(200) app2 - Apple() orgl - Orange() orgl.set(300) org2 - Orange()

appl.print_total() loutput 200 orgl.print_total()    #output 300

###### 删除上面代码中的注释语句后运行程序会得到以下结果：

calling class_method(〈class •—main_.Apple *>r 200) calling class_method(<class 1_main_.Orange 1>9 300)

200

12184820------>Fruit类的类变蛩

12186364----->动态生成的Apple类的类变里

300

12184820------>Fruit 类的类变:S

13810996 -----〉动态生成的Orange类的类变:&

简单分析可知，针对不同种类的水果对象调用set()方法的时候隐形传人的参数为该对象 所对应的类，在调用set()的过程中动态生成了对应的类的类变量。这就是classmethod的妙 处。请读者自行思考：此处将类方法改为静态方法是否可行呢？

我们再来看一个必须使用类方法而不是静态方法的例子：假设对于每一个Fruit类我们 提供3个实例属性：area表示区域代码，category表示种类代码，batch表示批次号。现需要 一个方法能够将以area-category-batch形式表示的字符串形式的输人转化为对应的属性并以 对象返回。

假设Fruit中有如下初始化方法，并且有静态方法Init_Product()能够满足上面所提的 要求。

def _init_(self# area=WM/ category:"", batch:""):

self.area = area

self.category = category

self.batch = batch

©staticmethod

def Init_Product(product^info):

area, category, batch = map(intr product_info.split(1- 1)) fruit = Fruit(area, category, batch)

return fruit

###### 我们首先来看看使用静态方法所带来的问题。

appl = Apple (2,5,10)

orgl = Orange.Init_Product("3-3-9")

print "appl is instance of Apple:w+str(isinstance(applz Apple)) print "orgl is instance of Orange:M+str(isinstance(orgl, Orange))

运行程序我们会发现isinstance(orgl, Orange)的值为False。这不奇怪，因为静态方法实 际相当于一个定义在类里面的函数，Init_Product返冋的实际是Fruit的对象，所以它不会是 Orange的实例。lnit_PnxkiCt()的功能类似于工厂方法，能够根据不同的类型返回对应的类的 实例，因此使用静态方法并不能获得期望的结果，类方法才是正确的解决方案。可以针对代 码做出如下修改：

@classmethod

def Init Product(clsrproduct_info):

area, category, batch = map(intr product_info.split(•-•)) fruit ■ cis(area, category, batch)

return fruit

###### 也许读者会问：既然这样，静态方法到底有什么用呢？什么情况下可以使用静态方法? 继续上面的例子，假没我们还需要一个方法来验证输人的合法性，方法的具体实现如下：

def is_input_valid(product_info):

area, category, batch = map(intr product_info.split(•-•)) try:

assert 0 <= area <= 10 assert 0 <■ category <■ 15 assert 0 <= batch <= 99

except AssertionError: return False

return True

那么应该将其声明为静态方法还是类方法呢？答案是两者都可，甚至将其作为一个定义 在类的外部的函数都是可以的。但仔细分析该方法会发现它既不跟特定的实例相关也不跟特 定的类相关，因此将其定义为静态方法是个不错的选择，这样代码能够一目了然。也许你会 问：为什么不将该方法定义成外部函数呢？这是因为静态方法定义在类中，较之外部函数, 能够更加有效地将代码组织起来，从而使相关代码的垂直距离更近，提髙代码的可维护性。 当然，如果有一组独立的方法，将其定义在一个模块中，通过模块来访问这些方法也是一个 不错的选择。
