---
title: 算法：二进制中1的个数
toc: true
date: 2018-06-25 16:28:20
---

# ORIGINAL




[CodingInterviews](https://github.com/gatieme/CodingInterviews)







# TODO






  * **对于源码补码等还是不清楚，之前弄的大概清楚了些，又忘记了，还是要总结下的。**


  * **看来STL还是要好好总结下的，比如这个bitset就很厉害。而Bootstrap由于与python的一些结合，也是要好好总结下的。**






# 题目




## **题目描述**


输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。


## **样例输入**


3 4 5 -1


## **样例输出**


1 2 3 2

**样例输出为什么是这样的？**






# 问题解答




## 直接看看每一位是不是 1


我们可以通过移位的方法，挨个判断其每一位：


    #include <iostream>
    #include <cmath>

    using namespace std;


    class Solution {
    public:
    	int NumberOf1(int n) {
    		int count = 0;
    		while (n) {
    			if (n & 1 == 1) {
    				count++;
    			}
    			n >>= 1;
    		}
    		return count;
    	}
    };

    int main() {
    	cout << sizeof(long) << endl;

    	Solution solu;
    	cout << solu.NumberOf1(1) << endl;
    	cout << solu.NumberOf1(2) << endl;
    	cout << solu.NumberOf1(8) << endl;
    	cout << solu.NumberOf1(INT_MAX) << endl;

    	//为什么这两个没有？
    	cout << solu.NumberOf1(-8) << endl;
    	cout << solu.NumberOf1(INT_MIN) << endl;
    	cout << solu.NumberOf1(-2147483648) << endl;
    	return 0;
    }


输出：


    4
    1
    1
    1
    31


可见，负数的三个值都没有输出。为什么呢？

这要从逻辑右移与算术右移说起，我们先看一下逻辑右移与算数右移的区别：




  * 逻辑左移=算数左移，右边统一添0


  * 逻辑右移，左边统一添0


  * 算数右移，左边添加的数和符号有关


那么，我们上面的代码问题出在哪里呢？

因为c++中，对于上面的有符号数 int，>> 这个符号代表的就是算数右移，而对于无符号数 unsigned int ，>> 就是逻辑右移。（见 [C++ 左移<< 右移>>](http://106.15.37.116/2018/05/15/cpp-shift/) ）

也就是说，对于一个有符号位的8位二进制数 11001101，>> 之后，就变成 11100110 。

因此，如果我们输入的是负数，那么右移之后，首位还是1，这样我们判断 n & 1 == 1 就会一直循环下去，即死循环了。**看到这里，我突然想起之前一直不知道无限循环和死循环有什么区别，因此查了下：根据目的区分，死循环是不符合目的无限循环 。无限循环中除了死循环还有有意义和价值的无限循环，比如操作系统。**

OK，既然上面的程序不能处理负数的情况，那么怎么办呢？


## 为了避免负数移位的死循环，我们可以移动那个测试位


为了负数时候避免死循环，我们可以**不右移数字n，转而去移动测试位**

那么思考我们的循环结束条件，flag一直左移（乘以2），当超出表示标识范围的时候，我们就可以终止了，但是这样子的话，最高位的符号位没有测试，因此要单独测试，同时由于会溢出，我们的flag需要用long来标识
<table >

<tr >
类型
范围
</tr>

<tbody >
<tr >

<td >unsigned int
</td>

<td align="center" >0～4294967295
</td>
</tr>
<tr >

<td >int
</td>

<td align="center" >2147483648～2147483647
</td>
</tr>
<tr >

<td >unsigned long
</td>

<td align="center" >0～4294967295
</td>
</tr>
<tr >

<td >long
</td>

<td align="center" >2147483648～2147483647
</td>
</tr>
<tr >

<td >long long
</td>

<td align="center" >最大值：9223372036854775807
</td>
</tr>
<tr >

<td >long long
</td>

<td align="center" >最小值：-9223372036854775808
</td>
</tr>
<tr >

<td >unsigned long long
</td>

<td align="center" >最大值：1844674407370955161
</td>
</tr>
<tr >

<td >__int64
</td>

<td align="center" >最大值：9223372036854775807
</td>
</tr>
<tr >

<td >__int64
</td>

<td align="center" >最小值：-9223372036854775808
</td>
</tr>
<tr >

<td >unsigned __int64
</td>

<td align="center" >最大值：18446744073709551615
</td>
</tr>
</tbody>
</table>
代码如下：


    #include <iostream>
    #include <cmath>

    using namespace std;


    class Solution {
    public:
    	int NumberOf1(int n) {
    		int count = 0;
    		int i = 0;
    		unsigned long flag = 1;

    		while (flag <= INT_MAX) {
    			cout << n << " & " << flag << " == "
    				<< (n & flag) << endl;
    			if ((n & flag) != 0) {
    				count++;
    			}
    			flag <<= 1;
    		}
    		//  由于循环终结，我们使用的是flag <= INT_MAX
    		//  因此前面的循环只会执行31次
    		//  最后测试符号位
    		if ((n & flag) != 0) {
    			count++;
    		}
    		return count;
    	}

    };

    int main() {
    	cout << sizeof(long) << endl;

    	Solution solu;
    	cout << solu.NumberOf1(1) << endl;
    	cout << solu.NumberOf1(INT_MAX) << endl;

    	cout << solu.NumberOf1(-8) << endl;
    	cout << solu.NumberOf1(INT_MIN) << endl;
    	return 0;
    }


输出：


    4
    1 & 1 == 1
    1 & 2 == 0
    1 & 4 == 0
    1 & 8 == 0
    1 & 16 == 0
    1 & 32 == 0
    1 & 64 == 0
    1 & 128 == 0
    1 & 256 == 0
    1 & 512 == 0
    1 & 1024 == 0
    1 & 2048 == 0
    1 & 4096 == 0
    1 & 8192 == 0
    1 & 16384 == 0
    1 & 32768 == 0
    1 & 65536 == 0
    1 & 131072 == 0
    1 & 262144 == 0
    1 & 524288 == 0
    1 & 1048576 == 0
    1 & 2097152 == 0
    1 & 4194304 == 0
    1 & 8388608 == 0
    1 & 16777216 == 0
    1 & 33554432 == 0
    1 & 67108864 == 0
    1 & 134217728 == 0
    1 & 268435456 == 0
    1 & 536870912 == 0
    1 & 1073741824 == 0
    1
    2147483647 & 1 == 1
    2147483647 & 2 == 2
    2147483647 & 4 == 4
    2147483647 & 8 == 8
    2147483647 & 16 == 16
    2147483647 & 32 == 32
    2147483647 & 64 == 64
    2147483647 & 128 == 128
    2147483647 & 256 == 256
    2147483647 & 512 == 512
    2147483647 & 1024 == 1024
    2147483647 & 2048 == 2048
    2147483647 & 4096 == 4096
    2147483647 & 8192 == 8192
    2147483647 & 16384 == 16384
    2147483647 & 32768 == 32768
    2147483647 & 65536 == 65536
    2147483647 & 131072 == 131072
    2147483647 & 262144 == 262144
    2147483647 & 524288 == 524288
    2147483647 & 1048576 == 1048576
    2147483647 & 2097152 == 2097152
    2147483647 & 4194304 == 4194304
    2147483647 & 8388608 == 8388608
    2147483647 & 16777216 == 16777216
    2147483647 & 33554432 == 33554432
    2147483647 & 67108864 == 67108864
    2147483647 & 134217728 == 134217728
    2147483647 & 268435456 == 268435456
    2147483647 & 536870912 == 536870912
    2147483647 & 1073741824 == 1073741824
    31
    -8 & 1 == 0
    -8 & 2 == 0
    -8 & 4 == 0
    -8 & 8 == 8
    -8 & 16 == 16
    -8 & 32 == 32
    -8 & 64 == 64
    -8 & 128 == 128
    -8 & 256 == 256
    -8 & 512 == 512
    -8 & 1024 == 1024
    -8 & 2048 == 2048
    -8 & 4096 == 4096
    -8 & 8192 == 8192
    -8 & 16384 == 16384
    -8 & 32768 == 32768
    -8 & 65536 == 65536
    -8 & 131072 == 131072
    -8 & 262144 == 262144
    -8 & 524288 == 524288
    -8 & 1048576 == 1048576
    -8 & 2097152 == 2097152
    -8 & 4194304 == 4194304
    -8 & 8388608 == 8388608
    -8 & 16777216 == 16777216
    -8 & 33554432 == 33554432
    -8 & 67108864 == 67108864
    -8 & 134217728 == 134217728
    -8 & 268435456 == 268435456
    -8 & 536870912 == 536870912
    -8 & 1073741824 == 1073741824
    29
    -2147483648 & 1 == 0
    -2147483648 & 2 == 0
    -2147483648 & 4 == 0
    -2147483648 & 8 == 0
    -2147483648 & 16 == 0
    -2147483648 & 32 == 0
    -2147483648 & 64 == 0
    -2147483648 & 128 == 0
    -2147483648 & 256 == 0
    -2147483648 & 512 == 0
    -2147483648 & 1024 == 0
    -2147483648 & 2048 == 0
    -2147483648 & 4096 == 0
    -2147483648 & 8192 == 0
    -2147483648 & 16384 == 0
    -2147483648 & 32768 == 0
    -2147483648 & 65536 == 0
    -2147483648 & 131072 == 0
    -2147483648 & 262144 == 0
    -2147483648 & 524288 == 0
    -2147483648 & 1048576 == 0
    -2147483648 & 2097152 == 0
    -2147483648 & 4194304 == 0
    -2147483648 & 8388608 == 0
    -2147483648 & 16777216 == 0
    -2147483648 & 33554432 == 0
    -2147483648 & 67108864 == 0
    -2147483648 & 134217728 == 0
    -2147483648 & 268435456 == 0
    -2147483648 & 536870912 == 0
    -2147483648 & 1073741824 == 0
    1


**嗯，真是不错的方法，再理解下。**


## 把上面的 long 换成 int


OK，我们继续考虑，有没有什么能够精简我们的循环条件呢？ 考虑这点，如果数据发生溢出的话，会被截断，截断以后是多少呢，0 代码如下

代码如下：


    #include <iostream>
    #include <cmath>

    using namespace std;
    class Solution {
    public:
    	int NumberOf1(int n) {
    		int count = 0;
    		int i = 0;
    		unsigned int flag = 1;

    		while (flag != 0) {
    			cout << n << " & " << flag << " == " << (n & flag) << endl;
    			if ((n & flag) != 0) {
    				count++;
    			}
    			flag <<= 1;
    		}
    		cout << n << " & " << flag << " == " << (n & flag) << endl;
    		return count;
    	}
    };
    int main() {
    	cout << sizeof(long) << endl;

    	Solution solu;
    	cout << solu.NumberOf1(1) << endl;
    	cout << solu.NumberOf1(INT_MAX) << endl;

    	cout << solu.NumberOf1(-8) << endl;
    	cout << solu.NumberOf1(INT_MIN) << endl;
    	return 0;
    }


输出：


    4
    1 & 1 == 1
    1 & 2 == 0
    1 & 4 == 0
    1 & 8 == 0
    1 & 16 == 0
    1 & 32 == 0
    1 & 64 == 0
    1 & 128 == 0
    1 & 256 == 0
    1 & 512 == 0
    1 & 1024 == 0
    1 & 2048 == 0
    1 & 4096 == 0
    1 & 8192 == 0
    1 & 16384 == 0
    1 & 32768 == 0
    1 & 65536 == 0
    1 & 131072 == 0
    1 & 262144 == 0
    1 & 524288 == 0
    1 & 1048576 == 0
    1 & 2097152 == 0
    1 & 4194304 == 0
    1 & 8388608 == 0
    1 & 16777216 == 0
    1 & 33554432 == 0
    1 & 67108864 == 0
    1 & 134217728 == 0
    1 & 268435456 == 0
    1 & 536870912 == 0
    1 & 1073741824 == 0
    1 & 2147483648 == 0
    1 & 0 == 0
    1
    2147483647 & 1 == 1
    2147483647 & 2 == 2
    2147483647 & 4 == 4
    2147483647 & 8 == 8
    2147483647 & 16 == 16
    2147483647 & 32 == 32
    2147483647 & 64 == 64
    2147483647 & 128 == 128
    2147483647 & 256 == 256
    2147483647 & 512 == 512
    2147483647 & 1024 == 1024
    2147483647 & 2048 == 2048
    2147483647 & 4096 == 4096
    2147483647 & 8192 == 8192
    2147483647 & 16384 == 16384
    2147483647 & 32768 == 32768
    2147483647 & 65536 == 65536
    2147483647 & 131072 == 131072
    2147483647 & 262144 == 262144
    2147483647 & 524288 == 524288
    2147483647 & 1048576 == 1048576
    2147483647 & 2097152 == 2097152
    2147483647 & 4194304 == 4194304
    2147483647 & 8388608 == 8388608
    2147483647 & 16777216 == 16777216
    2147483647 & 33554432 == 33554432
    2147483647 & 67108864 == 67108864
    2147483647 & 134217728 == 134217728
    2147483647 & 268435456 == 268435456
    2147483647 & 536870912 == 536870912
    2147483647 & 1073741824 == 1073741824
    2147483647 & 2147483648 == 0
    2147483647 & 0 == 0
    31
    -8 & 1 == 0
    -8 & 2 == 0
    -8 & 4 == 0
    -8 & 8 == 8
    -8 & 16 == 16
    -8 & 32 == 32
    -8 & 64 == 64
    -8 & 128 == 128
    -8 & 256 == 256
    -8 & 512 == 512
    -8 & 1024 == 1024
    -8 & 2048 == 2048
    -8 & 4096 == 4096
    -8 & 8192 == 8192
    -8 & 16384 == 16384
    -8 & 32768 == 32768
    -8 & 65536 == 65536
    -8 & 131072 == 131072
    -8 & 262144 == 262144
    -8 & 524288 == 524288
    -8 & 1048576 == 1048576
    -8 & 2097152 == 2097152
    -8 & 4194304 == 4194304
    -8 & 8388608 == 8388608
    -8 & 16777216 == 16777216
    -8 & 33554432 == 33554432
    -8 & 67108864 == 67108864
    -8 & 134217728 == 134217728
    -8 & 268435456 == 268435456
    -8 & 536870912 == 536870912
    -8 & 1073741824 == 1073741824
    -8 & 2147483648 == 2147483648
    -8 & 0 == 0
    29
    -2147483648 & 1 == 0
    -2147483648 & 2 == 0
    -2147483648 & 4 == 0
    -2147483648 & 8 == 0
    -2147483648 & 16 == 0
    -2147483648 & 32 == 0
    -2147483648 & 64 == 0
    -2147483648 & 128 == 0
    -2147483648 & 256 == 0
    -2147483648 & 512 == 0
    -2147483648 & 1024 == 0
    -2147483648 & 2048 == 0
    -2147483648 & 4096 == 0
    -2147483648 & 8192 == 0
    -2147483648 & 16384 == 0
    -2147483648 & 32768 == 0
    -2147483648 & 65536 == 0
    -2147483648 & 131072 == 0
    -2147483648 & 262144 == 0
    -2147483648 & 524288 == 0
    -2147483648 & 1048576 == 0
    -2147483648 & 2097152 == 0
    -2147483648 & 4194304 == 0
    -2147483648 & 8388608 == 0
    -2147483648 & 16777216 == 0
    -2147483648 & 33554432 == 0
    -2147483648 & 67108864 == 0
    -2147483648 & 134217728 == 0
    -2147483648 & 268435456 == 0
    -2147483648 & 536870912 == 0
    -2147483648 & 1073741824 == 0
    -2147483648 & 2147483648 == 2147483648
    -2147483648 & 0 == 0
    1


这种方法循环的次数正好是是整数二进制数的位数，比如int就是32位循环32次。

那么有没有一种方法，整数中有几个1就循环几次呢？


## 整数中有几个1就循环几次  lowbit优化


**为什么叫 lowbit 优化 这个名字呢？**

我们分析 n 以 n-1两个数的差别，




  * 如果 n!=0，那么其二进制位中至少有一个1


  * 如果 n 的最低位是1（奇数），那么 n-1 正好把这个最低位的 1 变成 0，其他位不变


  * 如果 n 的最低位是0（偶数），那么假设其右起第一个 1 位于 m 位，即 m 位后面全是0，那么 n-1的第 m 位由1变成0，而第m位后面的所有0均变成1，m位之前的所有位保持不变。


因此通过分析发现：

**把一个整数n减去1，再和原来的整数做与运算，会把该整数最右边一个 1 变成 0，那么该整数有多少个1，就会进行多少次与运算。厉害了**

OK，这样，不断循环，循环的次数，就等于二进制中1的个数：


    #include <iostream>
    #include <cmath>

    using namespace std;

    class Solution {
    public:
    	int NumberOf1(int n) {
    		int count = 0;
    		while (n) {
    			count++;
    			n = n & (n - 1);
    		}
    		return count;
    	}
    };


    int main() {
    	cout << sizeof(long) << endl;
    	Solution solu;
    	cout << solu.NumberOf1(1) << endl;
    	cout << solu.NumberOf1(2) << endl;
    	cout << solu.NumberOf1(INT_MIN) << endl;
    	cout << solu.NumberOf1(-2147483648) << endl;
    	return 0;
    }


输出：


    4
    1
    1
    1
    1


OK，到这里，基本上是最厉害的方法了。


## STL 里的 bitset


实际上STL里面有 bitset 这个类型，可以用来方便地管理一系列的 bit 位而不用程序员自己来写代码。而bitset除了可以访问指定下标的bit位以外，还可以把它们作为一个整数来进行某些统计：


    #include <iostream>
    #include <cmath>
    #include <bitset>

    using namespace std;

    class Solution {
    public:
    	int NumberOf1(int n) {
    		bitset<32> bit(n);
    		return bit.count();
    	}
    };


    int main() {
    	cout << sizeof(long) << endl;
    	Solution solu;
    	cout << solu.NumberOf1(1) << endl;
    	cout << solu.NumberOf1(2) << endl;
    	cout << solu.NumberOf1(INT_MIN) << endl;
    	cout << solu.NumberOf1(-2147483648) << endl;
    	return 0;
    }


输出：


    4
    1
    1
    1
    1


**没想到，看来STL还是要好好总结下的。而Bootstrap由于与python的一些结合，也是要好好总结下的。**





* * *





# COMMENT
