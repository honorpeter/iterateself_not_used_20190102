---
title: 10 数学概念与方法
toc: true
date: 2018-06-27 08:59:39
---
10章 数学概念与方法

学习目标

E熟练掌握扩展欧几里德算法和它的时间复杂度 叵熟练掌握用筛法构造素数表，了解素数定理 E学会求二元线性不定方程的整数解

E熟练掌握模运算规则、快速幂取模算法和模线性方程的解法 E熟悉杨辉三角、二项式定理和组合数的基本性质 E学会推导约数个数公式和欧拉函数公式 E熟练掌握可重集全排列的编码和解码算法

E理解样本空间、事件和概率，学会用组合计数的方法计算离散概率 叵理解条件概率的概念和计算方法 叵理解连续概率和数学期望的概念和计算方法 E熟悉常见计数序列，如Fibonacci数列、Catalan数列等 E熟悉建立递推关系的基本方法、常见错误和实现技巧

没有数学就没有算法；没有好的数学基础，也很难在算法上有所成就。本章介绍算法竞

赛中涉及的常见数学概念和方法，包括数论、排列组合、递推关系和离散概率等。

###### 10.1 数论初步

数论被“数学王子”高斯誉为整个数学王国的皇后。在算法竞赛中，数论常常以各种面貌

出现，但万变不离其宗，大部分数论题目并不涉及多少特殊的知识，但对数学思维和能力要

求较高。本节介绍几个最为常用的算法，并通过例题展示一些常用的思维方式。

10.1.1 欧几里德算法和唯一分解定理

除法表达式。给出一个这样的除法表达式：；/;/;厂../;，其中；是正整数。除法

表达式应当按照从左到右的顺序求和，例如，表达式1/2/1/2的值为1/4。但可以在表达式中

嵌入括号以改变计算顺序，例如，表达式(1/2)/(1/2)的值为1。

输入；，    ；，    ...，Xk ,判断是否可以通过添加括号，使表达式的值为整

数。 K<10000， Xi<109。

分析】

表达式的值一定可以写成的形式：^是其中一些七的乘积，而5是其他数的乘积。不 难发现，X2必须放在分母位置，那其他数呢？

幸运的是，其他数都可以在分子位置：

E=XJ(X,iX,/^X^



林'…A



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-193.jpg)



接下来的问题就变成了：判断冗是否为整数。

第1种方法是利用前面介绍的高精度运算：k次乘法加一次除法。显然，这个方法是正确

的，但却比较麻烦。

第2种方法是利用唯一分解定理，把X2写成若干素数相乘的形式：

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-194.jpg)



然后依次判断每个的约数。这次不用高精度乘法了，只需把所 有^中巧的指数加起来。如果结果比％小，说明还会有巧约不掉，因此冗不是整数。这种方法 在第5章中已经用过，这里不再赘述。

第3种方法是直接约分：每次约掉^和為的最大公约数gcd(A, A2)，则当且仅当约分结束 后；=1时冗为整数，程序如下：

int judge(int* X) {

X[2] /= gcd(X[2], X[1]);

for(int i = 3; i <= k; i++) X[2] /= gcd(X[i], X[2]); return X[2] == 1;

}

整个算法的时间效率取决于这里的gcd算法。尽管依次试除也能得到正确的结果，但还 有一个简单、高效，而且相当优美的算法——辗转相除法。它也许是最广为人知的数论算 法。

辗转相除法的关键在于如下恒等式：gcd(A^) = gcd(6, mod幻。它和边界条件gcd(^, 0)=^一起构成了下面的程序：

int gcd(int a, int b) { return b == 0 ? a : gcd(b, a%b);

这个算法称为欧几里德算法(Euclid algorithm )。既然是递归，那么免不了问一句：会 栈溢出吗？答案是不会。可以证明，gcd函数的递归层数不超过4.785lg^    +    1.6723，其

中#=max{^6}。值得一提的是，让gcd递归层数最多的是gcdCF^&j，其中&是后文要介绍 的 Fibonacci 数。

利用gcd还可以求出两个整数和的最小公倍数lcm(^力)。这个结论很容易由唯一分解定 理得到。设

a = Px' P疒…P，

b = p'f' p/2 …p/r

则

gcd(a,Z?)=乃吨〜广⑽…夕，，/；} lcm(6Z，Z0 = prn^Ml} p^{e2,f2} .. . p^{er,fr}

由此不难验证gcd(^力)*lcm(^力)=^*办。不过即使有了公式也不要大意。如果把lcm写成a * b/gcd(a,b)，可能会因此丢掉不少分数——a*b可能会溢出！正确的写法是先除后乘，即 a/gcd(a,b) * b。这样一来，只要题面上保证最终结果在int范围之内，这个函数就不会出错。 但前一份代码却不是这样：即使最终答案在int范围之内，也有可能中间过程越界。注意这样 的细节，毕竟算法竞赛不是数学竞赛。

10.1.2 Eratosthenes 筛法

无平方因子的数。给出正整数《和讲，区间[«，    m]内的“无平方因子”的数有多少个？整

数^无平方因子，当且仅当不存在A>1，使彳得是女2的倍数。1$必m^1012，m-«<107。

【分析】

对于这样的限制，直接枚举判断会超时：需要判断107个整数，而每个整数还需要花费

一定的时间判断是否没有平方因子。怎么办呢？在介绍具体算法之前，需要学会用 Eratosthenes筛法构造1的素数表。

筛法的思想特别简单：对于不超过《的每个非负整数^，删除2A 3A 4p，...，当处理完所 有数之后，还没有被删除的就是素数。如果用vis[i]表示/已经被删除，筛法的代码可以写 成：

memset(vis, 0, sizeof(vis));

for(int i = 2; i <= n; i++) for(int j = i*2; j <= n; j+=i) vis[j] = 1;

尽管可以继续改进，但这份代码已经相当高效了。为什么呢？给定外层循环变量/，内 层循环的次数是- , i这样，循环的总次数小于    。这个结论来

源于欧拉在1734年得到的结果：-丁-丁——-=kn.,.,其中欧拉常数产0.577218。这 样低的时间复杂度允许在很短的时间内得到106以内的所有素数。

下面来改进这份代码。首先，在“对于不超过n的每个非负整数中^可以限定为素数 ——只需在第二重循环前加一个判断if(!vis[i])即可。另外，内层循环也不必从/*2开始——它 已经在/=2时被筛掉了。改进后的代码如下：

int m = sqrt(n+0.5);

memset(vis, 0, sizeof(vis));

for(int i = 2; i <= m; i++) if(!vis[i]) for(int j = i*i; j <= n; j+=i) vis[j] = 1;

这里有一个有意思的问题：给定的n , c的值是多少呢？换句话说，不超过n的正整数 中，有多少个是素数呢？

素数定理：「I .」

lnx

其中，我表示不超过的素数的个数。上述定理的直观含义是：它和x/lnx比较接近—— 对于算法入门来说，这已足够。表10-1给出了一些值来加深读者的印象。

表10-1 素数定理的直观验证

| N     | 102  | 103  | 104  | 105  | 106   | 107    | 108     |
| ----- | ---- | ---- | ---- | ---- | ----- | ------ | ------- |
| 酬    | 25   | 168  | 1229 | 9592 | 78498 | 664579 | 5761455 |
| n/lnn | 22   | 145  | 1086 | 8686 | 72382 | 620421 | 5428681 |

最后回到原题：如何求出区间内无平方因子的数？方法和筛素数是类似的：对于不超过: 的所有素数^ ,筛掉区间[n, m]内的所有倍数。

10.1.3 扩展欧几里德算法

直线上的点。求直线ox+^y+c=0上有多少个整点(x,y)满足妖^，勾，yeLy^ys]。

【分析】

在解决这个问题之前，首先学习扩展欧几里德算法——找出一对整数(x，y),使得似+吵= gcd(^，^)。注意，这里的和y不一定是正数，也可能是负数或者0。例如，gcd(6,15)=3 , 6*3-

15*1=3，其中^=3，尸-1。这个方程还有其他解，如^=-2，y=1。 下面是扩展欧几里德算法的程序：

void gcd(int a, int b, int& d, int& x, int& y) {

if(!b){ d = a; x = 1; y = 0; }

else{ gcd(b, a%b, d, y, x); y -= x*(a/b); }

}

用数学归纳法并不难证明算法的正确性，此处略去。注意在递归调用时，和y的顺序变 了，而边界也是不难得出的：gcd(^,0)=1*^-0*0=^。这样，唯一需要记忆的是y-=x*(W)，哪 怕暂时不懂得其中的原因也不要紧。

上面求出了ax+^y=gcd(“力)的一组解(^乃)，那么其他解呢？任取另外一组解(x2,y2)，

则^+咖二^+批(它们都等于gcd(a》))，变形得^^2)=办加-乃)。假设gcd(^》)=g，方程 左右两边同时除以[g](#bookmark9)[m](#bookmark9)，得“'(^-^2)=^' (y2-y1)，其中“'=“/g，b'=blg。注意，此时和b互素， 因此^-^一定是b的整数倍。设它为妫'，计算得y2-y1=^'。注意，上面的推导过程并没有用 到“似+by的右边是什么”，因此得出如下结论。

提示10-1 :设a, b, c为任意整数。若方程3乂+匕丫=〔的一组整数解为(x0,y0)，则它的任 意整数解都可以写成(x0+kb', y0-ka')，其中a'=a/gcd(a,b)，b'=b/gcd(a,b)，k取任意整数。

有了这个结论，移项得似+by=-c，然后求出一组解即可。例如：

例1 : 6^+15y=9。根据欧几里德算法，已经得到了6x(-2)+15x1=3，两边同时乘以3得6x(-6)+15^3=9，即_x=-6，y=3时6_x+15y=9。

例2 : 6^+15=8，两边除以3得2针5=8/3。左边是整数，右边不是整数，显然无解。综合 起来，有下面的结论。

提示10-2 :设a, b, c为任意整数，g=gcd(a,b)，方程ax+by=g的一组解是(x0,y0)，则 当c是g的倍数时ax+by=c的一组解是(x0c/g, y0c/g);当c不是g的倍数时无整数解。

这样，即完整地解决了本问题。顺便说一句，本题的名称为什么叫“直线上的点”呢？这 是因为在平面坐标系下，ox+^y+c=0是一条直线的方程。

10.1.4 同余与模算术

你需要花多少时间做下面这道题目呢？

123456789*987654321=( )

A．121932631112635266

B．121932631112635267

C．121932631112635268

D．121932631112635269

既然是选择题，不必费力把答案完整地计算出来——4个选项的个位数都不相同，因此

只需要计算出答案的最后一位即可。不难得出，它等于1*9=9。把刚才的解题过程抽象出来

就是下面的式子：

123456789*987654321 mod10=((123456789 mod10)*(987654321 mod10)) mod10

其中mod 表示除以的余数，C语言表达式是a °% ^。在本章中，一定是正整数，尽 管办＜ 0时表达式a °% b也是合法的(但b=0时会出现除零错)。

不难得到下面的公式：

(ei + b) mod n = ((a mod /?) + (/; mod /?)) mod/?

( a - b) mod n =    — (Z)mod/?) + n) mod n

abniod n = (amod n)(b mod n)mod/?

注意在减法中，由于mod n可能小于b mod n ,需要在结果加上n ,而在乘法中，需要注 意a mod n和b mod n相乘是否会溢出。例如，当n=109时，ab mod n—定在int范围内，但a mod n和b mod n的乘积可能会超过int。需要用long long保存中间结果，例如：

int mul_mod(int a, int b, int n) {

return (int)((long long)a * b % n);

}

当然，如果《本身超过int但又在long long范围内，上述方法就不适用了。在这种情况下，

建议初学者使用高精度乘法——尽管有办法可以避免，但技巧性很强，不推荐初学者学习。

大整数取模。输入正整数《和讲，输出《 mod m的值。«<10100，m<109。

【分析】

首先，把大整数写成“自左向右”的形式： 1234=((1*10+2)*10+3)*10+4，然后用前面的公 式，每步取模，例如：

| scanf(" | %s%d", n, &m);  |                      |            |
| ------- | --------------- | -------------------- | ---------- |
| int len | = strlen(n);    |                      |            |
| int ans | = 0;            |                      |            |
| for(int | i = 0; i < len; | i++)                 |            |
| ans     | = (int)(((long  | long)ans*10 + n[i] - | '0') % m); |
| printf( | "%d\n",ans);    |                      |            |

当然，也可以把ans声明成long long类型的，然后在输出时临时转换为int，但要注意乘法 溢出的问题。

幕取模。输入正整数“、《和讲，输出mod m的值。久《，m<109。

【分析】

很容易写出下面的代码：

int pow_mod(int a, int n, int m) { int ans = 1;

for(int i = 0; i < n; i++) ans = (int)((long long)ans * n % m);

这个函数的时间复杂度为0(«)，当《很大时速度很不理想。有没有办法算得更快呢？可

以利用分治法：

int pow_mod(int a, int n, int m) { if(n == 0) return 1; int x = pow_mod(a, n/2, m); long long ans = (long long)x * x % m; if (n%2 == 1) ans = ans * a % m; return (int)ans;

}

例如， “29=(“14)2*“，而“14=(“7)2， “7=(“3)2*“， “3=“2*“，一共只做了7次乘法。不知读者

有没有发现，上述递归方式和二分查找很类似——每次规模近似减小一半。因此，时间复杂 度为O(log«)，比0(«)好了很多。

模线性方程组。输入正整数b, «，解方程似三b(mod «)。“, b, «<109。

【分析】

本题中出现了一个新记号：同余。辰b(mod «)的含义是““和b关于模《同余”，即“ mod « = b mod n。 不难得出，^=b(mod «)的充要条件是：“-6是《的整数倍。

提示10-3 : aEb(mod n)的含义是“a和b除以n的余数相同〃，其充要条件是“a-b是n的整 数倍”。

这样，原来的方程就可以理解成：似功是《的正整数倍。设这个“倍数”为y，则似-b=吵， 移项得fla-«y=b，这恰好就是10.1.3节介绍的不定方程(“，《，b是已知量，和y是未知数)！ 接下来的步骤不再介绍。唯一需要说明的是，如果^是方程的解，满feEy( mo d «)的其他整 数y也是方程的解。因此，当谈到同余方程的一个解时，其实指的是一个同余等价类。

尽管算法已无须继续讨论，有一个特殊情况需要引起读者重视。b=1时，似三1(mod«)的 解称为“关于模《的逆( inverse) ，它类似于实数运算中“倒数”的概念。什么时候“的逆存在 呢？根据上面的讨论，方程ox-«y=1要有解。这样，1必须是gcd(a，《)的倍数，因此“和《必须互 素(即gcd(^，《)=1 )。在满足这个条件的前提下，ox=1(mod «)只有唯一解。注意，同余方程 的解是指一个等价类。

提示10-4 :方程axEl(mod n)的解称为a关于模n的逆。当gcd(a,n)=1时，该方程有唯 一解；否则，该方程无解。

10.1.5 应用举例

例题 10-1 巨大的斐波那契数！( Colossal Fibonacci Numbers!, UVa11582 )

输入两个非负整数仏办和正整数《 ( 0<a，b<264，1<«<1000 )，你的任务是计算/(ab)除 以《的余数。其中/(0)=/(1)=1，且对于所有非负整数/，f(i+2)=f(i+1)+f(i)。

【分析】

所有计算都是对《取模的，不妨设F(i)=f：i) mod «。不难发现，当二元组(F(i), F(i+1))出现 重复时，整个序列就开始重复。例如，《=3，序列F(i)的前10项为1，1，2,0,2,2，1，0，1，1，第9、10 项和前两项完全一样。根据递推公式，第11项会等于第3项，第12项等于第4项……

多久会出现重复呢？因为余数最多《种，所以最多《2项就会出现重复。设周期为M，则 只需计算出汽0)〜汽《2)，然后算出汽ab)等于其中的哪一项即可。

例题 10-2 不爽的裁判(Disgruntled Judge, NWERC 2008, UVa12169 )

有个裁判出的题太难，总是没人做，所以他很不爽。有一次他终于忍不住了，心 想： “反正我的题没人做，我干嘛要费那么多心思出题？不如就输入一个随机数，输出一个

随机数吧。 ”

于是他找了3个整数^、a和b，然后按照递推公式x^axw+b) mod 10001计算出了一个长 度为27的数列，其中7是测试数据的组数。然后，他把7和卩x3，…，x2F-i写到输入文件中，x2, x4，…，x27写到了输出文件中。

你的任务就是解决这个疯狂的题目：输入7,    x3，…，x27-1，输出x2, x4，…，x2T。输入保

证7<100，且输入的所有x值为0〜10000的整数。如果有多种可能的输出，任意输出一个即 可。

如果知道了a ,就可以计算出_x2 ,进而根据■Xg^ax^+b) mod 10001算出b。有了a和b ,

就可以在0(7)时间内计算出整个序列了。如果在计算过程中发现和输入矛盾，则这个a是非 法的。由于a是0〜10000的整数(因为递推公式对10001取模)，即使枚举所有的a ,时间效

率也足够高。

例题 10-3 选择与除法(Choose and Divide, UVa10375 )

已知C(m，n)    = m!/(n!(m-n)!),输入整数几    r,    (p>q , r>s , p，q，r，s^10000 ),计

算C(p，q)/C(r，s)。输出保证不超过108 ,保留5位小数。

【分析】

本题正是唯一分解定理的用武之地。组合数C(m，n)的性质将在10.2.1节中介绍，本题只 需要用到它的定义。

首先，求出10000以内的所有素数primes ,然后用数组e表示当前结果的唯一分解式中各 个素数的指数。例如，e={1，0，2，0，0，0，...}表示21*52=50。主程序如下：

while(cin >> p >> q >> r >> s) { memset(e, 0, sizeof(e)); add_factorial(p, 1); add_factorial(q, -1); add_factorial(p-q, -1); add_factorial(r, -1); add_factorial(s, 1); add_factorial(r-s, 1); double ans = 1;

for(int i = 0; i < primes.size(); i++) ans *= pow(primes[i], e[i]);

printf("%.5lf\n", ans);

}

其中add_factorial(n，d)表示把结果乘以(n!)d ,它的实现如下：

//乘以或除以n. d=0表示乘，d=-1表示除

void add_integer(int n, int d) { for(int i = 0; i < primes.size(); i++) {

while(n % primes[i] == 0) { n /= primes[i]; e[i] += d;

}

if(n == 1) break; // 提前终止循环，节约时间

}

}

void add_factorial(int n, int d) { for(int i = 1; i <= n; i++)

add_integer(i, d);

}

例题10-4最小公倍数的最小和(Minimum Sum LCM, UVa10791 )

输入整数《 ( 1<n<231 )，求至少两个正整数，使得它们的最小公倍数为n，且这些整数 的和最小。输出最小的和。

【分析】

本题再次用到了唯一分解定理。设唯一分解式"二“/1^/2..，不难发现每个“广作为一个 单独的整数时最优。

如果就这样匆匆编写程序，可能会掉入陷阱。本题有好几个特殊情况要处理：n=1时答 案为1+1=2 ; n只有一种因子时需要加个1，还要注意n=231-1时不要溢出。

例题 10-5 GCD等于 XOR ( GCD XOR, ACM/ICPC Dhaka 2013, UVa12716 )

输入整数打(1<n<30000000 )，有多少对整数(“，b)满足：1<b<a<n，且gcd(a，b)=“ XOR b。例如n=7时，有4对：(3,2)，(5,4)，(6,4)，(7,6)。

本题看上去很难找到简洁的数学公式，因为gcd和xor看上去似乎毫不相干。不过xor的好 处是：a xor b = c，则a xor c = b，所以可以枚举a和c，然后算出6=0! xor c，最后验证一下是 否有gcd（a，b）=c。时间复杂度如何？因为c是a的约数，所以和素数筛法类似，时间复杂度 为《/1+«/2+...+«/«=0（«log^）。再加上gcd的时间复杂度为0（log«），所以总的时间复杂度 为 O（n（logn）2）。

我们还可以做得更好。上述程序写出来之后，可以打印一些满足gcd（a，b）=a xor b=c的三 元组（a，b，c），然后很容易发现一个现象 ： c=a-b。

证明如下：不难发现a-b^a xor b，且a-b^c。假设存在c使得a-b>c，则c<a-b^a xor b， 与c=a xor b矛盾。

有了这个结论，还是沿用上述算法，枚举a和c，计算b=a-c，则gcd（a，b）=gcd（a，a-c）=c， 因此只需验证是否有c = a xor b，时间复杂度降为了0（«log«）。

###### 10.2 计数与概率基础

排列与组合是最基本的计数技巧。本节介绍一些基本的相关知识和方法，供读者参考 加法原理。做一件事情有n个办法，第/个办法有p/种方案，则一共^i+p^u+PM种方

案。

乘法原理。做一件事情有n个步骤，第/个步骤有p^方案，则一共有p1p2...pn种方案。

乘法原理是加法原理的特殊情况（按照第一步骤进行分类），二者都可用于递推。注意

应用加法原理的关键是分类：各类别之间必须没有重复、没有遗漏。如果有重复，可以使用

容斥原理。

容斥原理。假设班里有10个学生喜欢数学， 15个学生喜欢语文， 21个学生喜欢编程，

一共有多少个学生呢？是10+15+21=46个吗？不是的，因为有些学生可能同时喜欢数学和语

文，或者语文和编程，甚至还可能有三者都喜欢的。为了叙述方便，将喜欢语文、数学、编

程的学生集合分别用或5, C表示，则学生总数等于|^U5UC|。刚才已经说了，如果把这3个集 合的元素个数凶、网、|C|直接加起来，会有一些元素重复统计了，因此需要扣掉4门5|、

|mC|、|Cn^|，但这样一来，又有一小部分多扣了，需要加回来：i^amCi。这样，就得到了 一个公式：

|AU5UC|=|A|+|5|+|C|-|An5|-|5nC|-|CnA|+|An5nC|

一般地，对于任意多个集合，都可以列出这样一个等式，其中左边是所有集合的并的元

素个数，右边是这些集合的“各种搭配”。每个“搭配”都是若干个集合的交集，且每一项前面

的正负号取决于集合的个数——奇数个集合为正，偶数个集合为负。

有重复元素的全排列。有&个元素，其中第/个元素有^个，求全排列个数。

【分析】

令所有nz之和为n，再设答案为X。首先做全排列，然后把所有元素编号，其中第s种元素

编号为1 ~ns （例如，有3个a，两个b，先排列成aabba，然后可以编号为ap^^a］）。这样

做以后，由于编号后所有元素均不相同，方案总数为n的全排列数n!。根据乘法原理，得到 了一个方程 :n1!n2!n3!...nkX!=n!， 移项即可。

可重复选择的组合。有n个不同元素，每个元素可以选多次，一共选&个元素，有多少 种方法？例如，n=3，A=2时有6种:(1,1)，(1,2)，(1,3)，(2,2)，(2,3)，(3,3)。

【分析】

设第/个元素选'个，问题转化为求方程^+x2+...+_xn4的非负整数解的个数。令yz=xz+1，

则答案Sy1+y2+...+yn=^+n的正整数解的个数。想象有奸1个数字“1”排成一排，则问题等价

于：把这些“1”分成n个部分，有多少种方法？这相当于在奸n-1个“候选分隔线”中选n-1个， 即 C(k+n-1，n-1 )=C(n+k- 1，k)。

10.2.1 杨辉三角与二项式定理

组合数(.在组合数学中占有重要地位。与组合数相关的最重要的两个内容是杨辉三角和

n

二项式定理。如图10-1所示就是一个杨辉三角

13 3 1 14 6 4 1 1 5 10 W 5 1 1 6 15 20 15 6 1

图10-1 杨辉三角

另一方面，把(a+b)n展开，将得到一个关于的多项式：

(a + /))[’= 1

(a + b)x =a + b

(a + b )2 =a2 + 2ab + h2

(a + bY =a:' + 3a~b + 3a b:' +b:'

(a + hf =a + 4a b + 6a2b" + 4ab^ + //

系数正好和杨辉三角一致。一般地，有二项式定理：

Jt=O

这不难理解：^+6)"是《个括号连乘，每个括号里任选一项乘起来都会对最后的结果有一

个贡献。如果选了&个a，就一定会选《-&个b，最后的项自然就是aw-^b^。而从《个“里选女个 (同时也相当于《个6里选个)有{:种方法，这也是组合数的定义。

给定《，如何求出(a+b)"中所有项的系数呢？ 一个方法是用递推，根据杨辉三角中不难发 现的规律，可以写出如下程序：

memset(C, 0, sizeof(C));

for(int i = 0; i <= n; i++) {

C[i][0] = 1;

for(int j = 1; j <= i; j++) C[i][j] = C[i-1][j-1] + C[i-1][j];

}

但遗憾的是，这个算法的时间复杂度是0("2)——尽管只用了杨辉三角的第"行的"+1个 元素，却把全部"行的0("2)个元素都计算了 一遍。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-195.jpg)



另一个方法是利用等式，    ，从O开始从左到右递推，例如：

C[0] = 1;

for(int i = 1;



n; i++) C[i] = C[i-1]*(n-i+1)/i;

注意，应该先乘后除，因为C[i-1]/i可能不是整数。但这样一来增加了溢出的可能 性 ——即使最后结果在int或long long范围之内，乘法也可能溢出。如果担心这样的情况出现， 可以先约分，不过一般来说是不必要的。

尽管等式,_ "    -的“实际意义”不是很明显，却很容易用组合数公式< -

"    a "    "    A!(/7-A-)!

证明，读者不妨一试。

例题 10-6 无关的元素(Irrelevant Elements, ACM/ICPC NEERC 2004, UVa1635 )

对于给定的n个数ah a2，…，an，依次求出相邻两数之和，将得到一个新数列。重复上述

操作，最后结果将变成一个数。问这个数除以m的余数与哪些数无关？例如n=3，m=2时，第 一次求和得到a^a2，a2+a3，再求和得到ai+2a2+a3，它除以2的余数和“2无关。

1<n<105，2<m<109。

【分析】

显然最后的求和式是aha2，…，an的线性组合。设“2的系数为/(/)，则和式除以m的余数 与口,无关，当且仅当/(/)是i的倍数。不妨看一个简单的例子：

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-196.jpg)



<7j + 2<72 + a3 cix + 3<72 + 3“3 + “4 + 4队 + 6<73 + 4c/4 + a5

看到最后的结果，你想到了什么？没错， “1 4 6 4 1”正是杨辉三角的第5行！不难证明， 在一般情况下，最后az的系数是这样，问题就变成了C r _中有哪些是m的 倍数。

还记得二项式展开的方法吗？理论上，利用此方法可以递推出所有e -，但它们太大了， 必须用高精度才能存得下。但此问题中所关心的只是“哪些是m的倍数”，受到数论部分中的 启发，只需要依次计算m的唯一分解式中各个素因子在(_中的指数即可完成判断。这些指数 仍然可以用，    递推，并且不会涉及高精度。有的读者可能会尝试直接递推每个

系数除以m的余数，但遗憾的是，递推式中有除法，而模m意义下的逆并不一定存在。

10.2.2 数论中的计数问题

约数的个数。给出正整数n的唯一分解式/, & /, ...＜，求n的正约数的个数。

【分析】

不难看出，n的任意正约数也只能包含'A，巧，等素因子，而不能有新的素因子出现。对 于n的某个素因子A，它在所求约数中的指数可以是0，1, 2,…，a^az+1种情况，而且不同的素 因子之间相互独立。根据乘法原理，n的正约数个数为：

k

XI + 1) = (^1 + 1)(^2 + I)…(叫 + 1)

/=]

小于《且与《互素的整数个数。给出正整数n的唯一分解式-    ，求1, 2, 3,

…，n中与n互素的数的个数。

【分析】

用容斥原理。首先从总数n中分别减去是A， p2，…，pk的倍数的个数(对于素数p来

说，“与p互素”和“不是p的倍数”等价)，即    ，然后加上“同时是两个素因子

P' P2 Pk

的倍数”的个数    ，再减去“同时是3个素因子的倍数”——写成一个“学术

P'Pl P'P3 Pk-xPk

味比较浓”的公式就是：

P⑻

Pi

StP2 >'

■，pU

这里引入的新记号列"）就是题目中所求的结果，称为欧拉函数。强烈建议初学者花一些 时间理解这个公式。对于（A，巧，…，&｝的任意子集^，“不与其中任何一个互素”的元素个数 是^。不过这一项的前面是加号还是减号呢？这取决于中的元素个数——奇数个就是“减

P^s

号”，偶数个就是“加号”。

公式已得出，可计算起来很不方便。如果直接根据公式，需要计算多达2&项的代数和， 甚至可能比“暴力枚举（依次判断1〜"中每个数是否与"互素）”还要慢。

下一步并不显然。上述公式可以变形成如下的形式：

（p、n、二 w（l--（I--）*，，（1--）

Pi Pk

从而只需要0（幻的计算时间，在刚才的基础上大大提高了效率。为什么这个式子和上一 个等价呢？直接考虑新公式的“展开方式”即可。展开式的每一项是从每个括号各选一个（选 1或者-丄），全部乘起来以后再乘以"得到。这不正是最初的推导过程吗？

Pi

如果没有给出唯一分解式，需要用试除法依次判断^内的所有素数是否是"的因子。这 样，则需要先生成▲内的素数表。但其实并不用这么麻烦：只需要每次找到一个素因子之后 把它“除干净”，即可保证找到的因子都是素数（想一想，为什么）。

int euler_phi(int n) { int m = (int)sqrt(n+0.5); int ans = n;

for(int i = 2; i <= m; i++) if(n % i == 0) { ans = ans / i * (i-1); while(n % i == 0) n /= i;

}

if(n > 1) ans = ans / n * (n-1); return ans;

}

1〜《中所有数的欧拉phi函数值。并不需要依次计算。可以用与筛法求素数非常类似的 方法，在O（nloglogn）时间内计算完毕，例如（原理请读者体会）：

| void phi_ | table(int | n,   | int* phi) {         |
| --------- | --------- | ---- | ------------------- |
| for(int   | i = 2; i  | <=   | n; i++) phi[i] = 0; |
| phi[1]    | = 1;      |      |                     |
| for(int   | i = 2; i  | <=   | n; i++) if(!phi[i]) |

for(int j = i; j <= n; j += i) {

if(!phi[j]) phi[j] = j; phi[j] = phi[j] / i * (i-1);

例题 10-7 交表(Send a Table, UVa10820 )

有一道比赛题目，输入两个整数x、y （ 1<x，y<n ），输出某个函数/（x，y）。有位选手想交 表（即事先计算出所有的Xx，y），写在源代码里），但是表太大了，源代码超过了比赛的限 制，需要精简。

好在那道题目有一个性质，使得很容易根据/（x，y）算出Xx*k，    y*k）（其中k是任意正整

数），这样有一些/（x，y）就不需要存在表里了。

输入n （ n<50000 ），你的任务是统计最简的表里有多少个元素。例如，n=2时有3个： （1，1）， （1，2）， （2，1）。

【分析】

本题的本质是：输入n，有多少个二元组（x，y）满足：1<x，y<n，且x和y互素。不难发现除 了（1,1）之外，其他二元组（x，y）中的x和y都不相等。设满足x<y的二元组有Xn）个，那么答案就 是 2f（n）+1。

对照欧拉函数的定义，可以得至!j/(n)=phi(2)+phi(3)+...+phi(n)，时间复杂度

为 O(nloglogn)。

10.2.3 编码与解码

两个a、一个和一个c组成的所有串可以按照字典序编号为： aabc(1)、 aacb(2)、 abac(3)、 . 、 cbaa(12)

任给一个字符串，能否方便地求出它的编号呢？例如，输入aca^，则应输出5。

下面直接求解一般情况的问题(并不限定字母的种类和个数)。设输入串为^，记硪5)

为S的各个排列中，字典序比5小的串的个数，则可以用递推法求解硪5)，如图10-2所示。

其中边上的字母表示“下一个字母”，/(>)表示多重集^的全排列个数。例如，根据第一个 字母，可以把字典序小于ca^a的字符串分为3种：以a开头的，以开头的，以c开头的，分别 对应成ca^a)的3棵子树。以a开头的所有串的字典序都小于ca^a，所以剩下的字符可以任意排 列，个数为Xc^a);同理，以开头的所有串的字典序也都小于ca^a，个数为Xcaa);以c开头 的串字典序不一定小于ca^a，关键要看后3个字符，因此这部分的个数为硪a^a)，还需要继续 往下分。

至于/函数的求解，大部分组合数学书籍中均有介绍：设字符一共有k类，个数分别为nh n2，…，nk，则这个多重集的全排列个数为

不难算出，，,=11';二--二:，其他/值分别为/(c办a)=6，/(b)=1，故d(caba)=/(cba)+ /(caa)+/(b)=3+6+1=10。既然“比它小”的个数是10，序号自然就是11 了。

“给物体一个编号”称为编码，同理也有“解码”，即根据序号构造出这个物体。这个过程

和刚才的很接近：依次确定各个位置上的字母即可。例如，要求出序号为8(因此有7个比它

小)的字符串，推理过程如图10-3所示。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-198.jpg)



d(ba)



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-199.jpg)



f(b) d(a)



图10-3 字符串解码的递推过程



图10-2 字符串编码的递推过程



例题 10-8 密码(Password, ACM/ICPC Daejon 2010, UVa1262 )

给两个6行5列的字母矩阵，找出满足如下条件的“密码”：密码中的每个字母在两个矩阵 的对应列中均出现。例如，左数第2个字母必须在两个矩阵中的左数第2列中均出现。例如， 图10-4中，COMPU和DPMAG都满足条件。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-201.jpg)



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-202.jpg)



字典序最小的5个满足条件的密码分别是：ABGAG、ABGAS、ABGAU、ABGPG和 ABGPS。给定k( 1<k<7777 )，你的任务是找出字典序第k小的密码。如果不存在，输出

NO。

【分析】

本题是一个经典的解码问题。首先把不可能出现在答案中的字母排除。例如在上面的例 子中，第1个字母只能是｛A，C，D，W｝，第2个字母只能是｛B，O，P｝，第3个字母只能是 ｛G，M，O，X｝，第4个字母只能是｛A，P｝，第5个字母只能是｛G，S，U｝。

不管第1个字母是多少，后4个字母都有3*4*2*3=72种可能，因此当k<72时，第1个字母 是A，当72<k<144时第1个字母是C，如此等等。再用同样的方法确定第2，3，4，5个字母即 可。

由于k<7777，本题还有一个取巧的方法：直接按照字典序从小到大的顺序递归一个一个 的枚举。虽然代码比递推法要长，但是由于思维难度小，往往能在更短的时间内写完、写 对。

10.2.4 离散概率初步

关于概率有一套很深的理论，不过很多和概率相关的问题并不需要特别的知识，熟悉排

列组合就够了。

第1个例子是：连续抛3次硬币，恰好有两次正面的概率是多少？用H和T来表示正面和 背面(取自英文单词head和tail )，则一共有8种可能的情况：HHH、HHT、HTH、HTT、

THH、THT、TTH、TTT。根据我们对硬币的认识，这8种情况出现的可能性相同，概率各为 1/8。用概率论的专业术语说，这里的｛HHH、HHT、HTH、HTT、THH、THT、TTH、TTT｝ 称为样本空间(Sample Space )。所求的是“恰好有两次正面”这个事件(Event)的概率。借 助于集合的记号，这个事件可以表示为｛HHT，HTH，THH｝，其概率为3/8。

提示10-5 :如果样本空间由有限个等概率的简单事件组成，事件E的概率可以用组合计

数的方法得到：/    。

第2个例子是：如果一间屋子里有23个人，那么“至少有两个人的生日相同”的概率超过

50%。为了简单起见，假定已知每个人的生日都不是2月29日。

尽管看上去复杂了许多，其实这个例子和抛硬币是类似的。每个人的生日是365天中等 概率随机选择的，因此样本空间大小冏=36523。接下来需要计算“至少有两个人生日相同”的 情况有多少种。这个数目不太好直接统计，所以统计“任何两个人的生日都不相同”的数目， 然后用总数减去它即可。公式不难得到：

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-203.jpg)



不管是/，还是36523都无法储存在mt或者lo



ng long中，但概率是实数，并且此处并不需



要太高的精度，所以可以直接计算，例如：

double P(int n, int m) {

double ans = 1.0; for(int i = 0; i < m; return ans;

}

double birthday(int n, double ans = P(n, m); for(int i = 0; i < m; return 1 - ans;



i++) ans *= (n-i);



int m) {



i++) ans /= n;



函数birthday(365,23)的返回值为0.5073，即50.73°%。别高兴得太早，我们来算一算 birthday(365,365)。直观上，365个人中几乎肯定会有两个人的生日相同，因此 birthday(365,365)应该返回一个很接近1的值。可结果呢？很不幸，返回值为-1.#INF0000 连double都溢出了。

解决方案是边乘边除，而不是连着乘m次，然后再连着除m次。例如：

double birthday(int n, int m) { double ans = 1.0;

for(int i = 0; i < m; i++) ans *= (double)(n-i) / n;

本例说明：正如数论和组合计数中要注意mt和long long溢出一样，在概率计算中要注意 double溢出。顺便说一句，这个“改进版”程序其实有个直接的概率意义：

n n n    n

其中，乓表示“第/个人的生日不和前面的人重复”这个事件。上面的公式用到了这样一个

结论：如果有n个相互独立的事件，则它们同时发生的概率是每个事件单独发生的概率的乘

积，像计数中的乘法原理一样。看上去很直观吧？但严格的定义需要用到“条件概率”的知

识。

条件概率。在概率计算中，条件概率扮演了重要的作用。公式如下：

P(A|B) = P(AB) | P(B)

这里，P(4B)是指，在事件5发生的前提下，事件乂发生的概率，而P(45)是指两个事 彳件4和5同时发生的概率。前面所说的两个事件M独立就是指P(45)=PG4)PCB)。

条件概率中还有一个重要的公式，即贝叶斯公式： P(A|5)=P(5|A) * P(A)/P(5)

全概率公式。计算概率的一种常用方法是：样本空间5分成若干个不相交的部分51， 52， …，Bn，则尸(4)=P(摩 1)*尸(51) + P(4|52)*P(52)+…+P(4|5n)*P(5n)。

公式看上去复杂，但其实思路很简单。例如，参加比赛，得一等奖、二等奖、三等奖和 优胜奖的概率分别为0.1、 0.2、 0.3和0.4，这4种情况下，你会被妈妈表扬的概率分别为1.0、 0.8、 0.5、 0.1，则你被妈妈表扬的总概率为0.1*1.0+0.2*0.8+0.3*0.5+0.4*0.1=0.45。使用全概 率公式的关键是“划分样本空间”，只有把所有可能情况不重复、不遗漏地进行分类，并算出 每个分类下事件发生的概率，才能得出该事件发生的总概率。

例题 10-9 决斗(Headshot, ACM/ICPC NEERC 2009, UVa1636 )

首先在手枪里随机装一些子弹，然后抠了一枪，发现没有子弹。你希望下一枪也没有子 弹，是应该直接再抠一枪(输出SHOOT )呢，还是随机转一下再抠(输出ROTATE )？如果

两种策略下没有子弹的概率相等，输出EQUAL。

手枪里的子弹可以看成一个环形序列，开枪一次以后对准下一个位置。例如，子弹序列 为0011时，第一次开枪前一定在位置1或2（因为第一枪没有子弹），因此开枪之后位于位置 2或3。如果此时开枪，有一半的概率没有子弹。序列长度为2〜100。

【分析】

直接抠一枪没子弹的概率是一个条件概率，等于子串00的个数除以00和01总数（也就是

0的个数）。转一下再抠没子弹的概率等于0的比率。

设子串00的个数为^，0的个数为^，则两个概率分别是和^n。问题就是比较⑽和办2。 前者大就是SHOOT，后者大就是ROTATE。

例题 10-10 奶牛和轿车(Cows and Cars, UVa10491 )

有这么一个电视节目：你的面前有3个门，其中两扇门里是奶牛，另外一扇门里则藏着

奖品——一辆豪华小轿车。在你选择一扇门之后，门并不会立即打开。这时，主持人会给你

个提示，具体方法是打开其中一扇有奶牛的门（不会打开你已经选择的那个门，即使里面是

牛）。接下来你有两种可能的决策：保持先前的选择，或者换成另外一扇未开的门。当然，

你最终选择打开的那扇门后面的东西就归你了。

在这个例子里面，你能得到轿车的概率是2/3（难以置信吧！），方法是总是改变自己 的选择。 2/3这个数是这样得到的：如果选择了两个牛之一，你肯定能换到车前面的门，因 为主持人已经让你看了另外一个牛；而如果你开始选择的就是车，就会换成剩下的牛并且输 掉奖品。由于你的最初选择是任意的，因此选错的概率是2/3。也正是这2/3的情况让你能换 到那辆车（另外1/3的情况你会从车切换到牛）。

现在把问题推广一下，假设有头牛，M两车（门的总数为^+^ ），在最终选择前主持人 会替你打开c个有牛的门（1<^<10000，1<^<10000，0<c<^），输出“总是换门”的策略下，赢 得车的概率。

【分析】

使用全概率公式。打开c个牛门后，还剩^-c头牛，未开的门总数是好卜c，其中有好卜c-1个门可以换（称为“可选门”），换到门的概率就是“可选门”的总数除以“可选门中车门的个

数”。

情况1: 一开始选了牛(概率^ / (好幻)，则可选门中车门有个。这种情况的总概率

为 a/(a+b) * b/(a+b-c-1)。

情况2 :—开始选了车(概率为W (a+b))，则可选门中车门只有b-1个，概率为b/(a+b) * (b-1)/(a+b-c-1)。

加起来得(ab+b(b-1)) / ((a+b)(a+b-c-1))。

例题 10-11 条件概率(Probability|Given, UVa11181 )

有《个人准备去超市逛，其中第/个人买东西的概率是Pz。逛完以后你得知有r个人买了东

西。根据这一信息，请计算每个人实际买了东西的概率。输入《 ( 1分$20 )和〃(0<r<n )， 输出每个人实际买了东西的概率。

【分析】

“r个人买了东西”这个事件叫冗，“第/个人买东西”这个事件为馬，则要求的是条件概 率P(EE)。根据条件概率公式，P(EE) = P(EE) / P(E)。

P(E)依然可以用全概率公式。例如，n=4，r=2，有6种可能：1100, 1010, 1001, 0110, 0101, 0011，其中1100的概率为Pi*P2*(1-P3)*(1-P4)，其他类似，设置4幻表示第女个人是否买 东西(1表示买，0表示不买)，则可以用递归的方法枚举恰好有r个4幻=1的情况。

如何计算P(EE)呢？方法一样，只是枚举的时候要保证第4i]=1。不难发现，其实可以

用一次枚举就计算出所有的值。用tot表示上述概率之和，sum[i]表示4i]=1的概率之和，则答 案为 P(Ei)/P(E)=sum[i]/tot。

例题 10-12 纸牌游戏(Double Patience, NEERC 2005, UVa1637 )

36张牌分成9堆，每堆4张牌。每次可以拿走某两堆顶部的牌，但需要点数相同。如果有 多种拿法则等概率的随机拿。例如，9堆顶部的牌分别为KS, KH, KD, 9H, 8S, 8D, 7C, 7D, 6H，则有5种拿法(KS,KH), (KS,KD), (KH,KD), (8S,8D), (7C,7D)，每种拿法的概率均为 1/5。 如果最后拿完所有牌则游戏成功。按顺序给出每堆牌的4张牌，求成功概率。

分析】

用9元组表示当前状态，即每堆牌剩的张数，状态总数为59=1953125。设d[/]表示状 态/对应的成功概率，则根据全概率公式，d[/]为后继状态的成功概率的平均值，按照动态规 划的写法计算即可。

###### 10.3 其他数学专题

10.3.1 递推

汉诺塔问题。假设有A、B、C 3个轴，有n个直径各不相同、从小到大依次编号为1, 2, 3，...，n的圆盘按照上小下大的顺序叠放在A轴上。现要求将这n个圆盘移至B轴上并仍按同样 顺序叠放，但圆盘移动时必须遵循下列规则：

□每次只能移动一个圆盘，它必须位于某个轴的顶部。

□圆盘可以插在A、B、C中的任一轴上。

□任何时刻都不能将一个较大的圆盘压在较小的圆盘之上。

【分析】

这个问题看上去很容易，但当n稍大一点时，手工移动就开始变得困难起来。下面直接 给出递归解法：首先，把前n-1个圆盘放到C轴；接下来把n号圆盘放到B轴；最后，再把前n-1个盘子放到B轴，如图10-5所示。

图10-5 根据递归解法建立汉诺塔的递推关系

图10-4中还给出了n个圆盘所需步数Xn)的递推式：f(n)=2/(n-1)+1。如果把f(n)的值从小 到大列出来，即1,3,7,15,31,63,127,255...，你会发现其实有一个简单的表达式：f>)=2n-1。

用数学归纳法不难证明：f(1)=1满足等式。假设n=k满足等式，即f(k)=2k-1，则n=k+1

时，fk+1)=2f；k)+1=2(2k-1)+1=2k+1-2+1=2k+1-1。因此n=k+1 也满足等式。由数学归纳法可 知，n取任意正整数均成立。

如果还不熟悉数学归纳法，其实从上面的证明过程已经能看出来其基本原理——其实它 正是一种递归证明。只要边界处理好(f(1)=1满足)，递归时缩小规模(用k来证明k+1 )， 然后在“相信递归”(假设n=k成立)的前提下证明即可。

提示10-6：数学归纳法是一种利用递归的思想证明的方法。如果要讨论的对象具有某 种递归性质(如正整数)，可以考虑用数学归纳法。

Fibonacci数列。先来考虑一个简单的问题：楼梯有n个台阶，上楼可以一步上一阶，也 可以一步上两阶。一共有多少种上楼的方法？

这是一道计数问题。在没有思路时，不妨试着找规律。n=5时，一共有8种方法：

5=1+1+1+1+1

5=2+1+1+1

5=1+2+1+1

5=1+1+2+1

5=1+1+1+2

5=2+2+1

5=2+1+2

5=1+2+2

其中有5种方法第1步走了1阶(灰色)， 3种方法第1步走了2阶。没有其他可能了。假 设An)为n个台阶的走法总数，把n个台阶的走法分成两类。

第1类：第1步走1阶。剩下还有n-1阶要走，有?(n-1)种方法。

第2类：第1步走2阶。剩下还有n-2阶要走，有Xn-2)种方法。

这样，就得到了递推式：/(n)=/(n-1)+/(n-2)。不要忘记边界情况：f(1)=1，f(2)=2。当 然，也可以认为边界是f(0)=/(1)=1。把f(n)的前几项列出：1, 1,2, 3, 5, 8，...。

再例如，把雌雄各一的一对新兔子放入养殖场中。每只雌兔从第2个月开始每月产雌雄

各一的一对新兔子。试问第n个月后养殖场中共有多少对兔子？

还是先找找规律。

第1个月：一对新兔子h。用小写字母表示新兔子。

第2个月：还是一对新兔子，不过已经长大，具备生育能力了，用大写字母表示。

第3个月：尺1生了一对新兔子r2，—共两对。

第4个月：尺1又生一对r3，—共3对。另外，^长大了，变成R2。

第5个月：R^R2各生一对，记为『4和^，共5对。此外，r3长成R3。

第6个月：Rp R,R3各生一对，记为r6~r8，共8对，同时r4到r5长大。

把这些数排列起来：1, 1, 2, 3, 5, 8,...，和刚才的一模一样！事实上，可以直接推导出递 推关系/(n)=/(n-1)+/(n-2):第n个月的兔子由两部分组成，一部分是上个月就有的老兔子，一 部分是上个月出生的新兔子。前一部分等于八n-1)，后一部分等于八n-2)(第n-1个月时具有生 育能力的兔子数就等于第n-2个月的兔子总数)。根据加法原理，/(n)=/(n-1)+/(n-2)。

提示10-7 :满足FfF^l，Fn=Fn-1+Fn-2的数列称为Fibonacci数列，它的前若干项是1, 1, 2, 3, 5, 8, 13, 21, 34, 55,…。

再例如，有2行n列的长方形方格，要求用n个1*2的骨牌铺满。有多少种铺法？

考虑最左边一列的铺法。如果用一个骨牌直接覆盖，则剩下的2*(n-1)方格有/(n-1)种铺 法；如果是用两个横向骨牌覆盖，则剩下的2*(n-2)方格有>-2)种方法，如图10-6所示。不 难发现：第一列没有其他铺法，因此/>)=>-1)+>-2)。边界/(0)=1,/(1)=1，恰好是Fibonacci 数列。

这就是多数课本上讲解这道题目的方法，无须多说，因为重点并不在此。笔者曾想到过 另一个解法，与各位读者分享：设第i列是纵向骨牌，则左边i-1列和右边n-i列各有/(/-1)

和/(n-i)种铺法。根据乘法原理，一共有/(i-1)/(n-i)种铺法。然后把i=1,2,3，...，n的情形全部加 起来，根据加法原理，有：

/(n)=/(0)/(n-1) + /(1)/(n-2)+.+/(n-1)/(0)

这个递推式对不对呢？聪明的读者也许已经看出，这个解法存在两个问题：

(1 )有遗漏。只考虑了第1,2,3，...，n列是纵向骨牌的情形，但实际上可能所有的骨牌都 是横向的。当且仅当n为偶数时，恰好有一种这样的方案。

(2)有重复。根据“第/列有骨牌”对所有方案进行了分类，但其实这些方案是有重叠 的。例如，第1列和第2列完全可以同时有骨牌。这些方案在递推式中被重复计算了。

既然如此，这个思路是不是走入死胡同了呢？不是的！只要把刚才的推理变得严密起 来，同样可以得到一个正确的递推式：根据从左到右第一条纵向骨牌的列编号分类。如果不 存在，当且仅当n为偶数时有一种方案；当第一条纵向骨牌的列编号为/时，意味着左边/-1列 必须全部是横向骨牌——当/为奇数时恰好有一个方案。而右边n-/列则可以用任意铺法，

共An々)种。换句话说：

n为偶数时，»=>-1)+>-3)+>-5)…+f(1)+1 (最后加上的就是“没有纵向骨牌”的情 形)。

n为奇数时，f(n)=f(n-1)+/(n-3)+/(n-5)... +f(2)+f(0)。

边界是f(0)=f(1)=1。我们已经知道，问题的答案应该是Fibonacci数列，自然会对这个复 杂的递推式产生怀疑：它真的是正确的吗？

带着这个疑问，笔者写了一个程序。结果出乎意料：居然和Fibonacci数列一样！事实 上，它确实是Fibonacci数列。Fibonacci数列拥有很多有趣的性质，有兴趣的读者可以在网上 搜索更多相关资料。不管怎样，这个“旧题新解”至少说明了两点：

( 1)一个数列可能有多个看上去完全不同的递推式。

( 2)即使是漏洞百出的解法也有可能通过“打补丁”的方式修改正确。

Catalan数。给一个凸n边形，用n-3条不相交的对角线把它分成n-2个三角形，求不同的 方法数目。例如，n=5时，有5种剖分方法，如图10-7所示。

分析】

设答案为fn)。按照某种顺序给凸多边形的各个顶点编号为^，72，…，匕。既然分成的是 三角形，边在最终的剖分中一定恰好属于某个三角形，所以可以根据k进行分 类。不难看出，三角形的左边是一个k边形，右边是一个n-k+1边形(如图10-8 ( a )所 示)。根据乘法原理，包含三角形的方案数为f(k)/(n-k+1);根据加法原理有：

f(n)=f(2)f(n-1) + f(3)f(n-2) +…+ f(n-1)f(2)

边界是f(2)=/(3)=1。不难算出从f(3)开始的前几项/值依次为：1、2、5、14、42、132、 429、 1430、 4862、 16796。

提示10-8 ：在建立递推式时，经常会用到乘法原理，其核心是分步计数。如果可以把 计数分成独立的两个步骤，则总数量等于两步计数之乘积。

另一种思路是考虑匕连出的对角线。对角线把凸n边形分成两部分，一部分是k边 形，另一部分是n-k+2边形(如图10-8 ( b )所示)。根据乘法原理，包含对角线的凸多 边形有/(kf(n-k+2)个。根据对称性，考虑从F2、F3、…、匕出发的对角线也会有同样的结 果，因此一共有nf(3)/(n-1)+/(4)/(n-2)+...+>-1)/(3))个部分。

A边形

n~k+1边形



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-208.jpg)



但这并不是正确答案，因为同—个剖分被重复计算了多次！不过这次不必去消除重复 了，因为这些重复很有规律：每个方案恰好被计算了2n-6次——有n-3条对角线，而考虑每 条对角线的每个端点时均计算了一次。这样，得到了/(n)的第2个递推式：

/(n) = (/(3)(n-1)+/(4)/(n-2)+…+/(n-1)/(3)>n/(2n-6)

它和第一个递推式有几分相似，但又不同。把n+1代入第1个递推式后得到：

/(n+1)=/(2)/(n) + /(3)/(n-1) + /(4)/(n-2) +…+ /(n-1)/(3) + /(n)/(2)

灰色部分是相同的！根据第2个递推式，它等于/(n)*(2n-6)/n，把它和/(2)=1—起代入上 式得：

,("+ 1卜/⑻ + /(") • (2" -6) / " + j(n) =    6,⑻

n

这个递推式和前两个相比就简单多了。这个数列称为Catalan数，也是常见的计数数列。

例题 10-13 危险的组合(Critical Mass, UVa580 )

有一些装有铀(用U表示)和铅(用L表示)的盒子，数量均足够多。要求把n ( n<30) 个盒子放成一行，但至少有3个U放在一起，有多少种放法？例如，n=4, 5, 30时答案分别为3, 8和974791728。

【分析】

设答案为/(n)。既然有3个U放在一起，可以根据这3个U的位置分类——对，根据前面的 经验，要根据“最左边的3个U”的位置分类。假定是i、i+1和i+2这3个盒子，则前i-1个盒子不 能有3个U放在一起的情况。设n个盒子“没有3个U放在一起”的方案数为g(n)=2n-/(n)，则前i-1

个盒子的方案有g(i-1)种。后面的n-i-2个盒子可以随便选择，有2n-i-2种。根据乘法原理和加

法原理，、.，-乙，乂 。

1=1

遗憾的是，这个推理是有瑕疵的。即使前i-1个盒子内部不出现3个U，仍然可能和i、i+1 和i+2组成3个U。正确的方法是强制让第i-1个盒子(如果存在)放L，则前i-2个盒子内部不

能出现连续的3个U。因此；    「，边界

/-2

是f(0)=f(1)=f(2)=0。g(0)=1，g(1)=2，g(2)=4。注意上式中的2n-3对应于/=1 的情况。

例题 10-14 比赛名次(Race, UVa12034 )

A、B两人赛马，最终名次有3种可能：并列第一；A第一B第二；B第一A第二。输 入n ( 1<n<1000 )，求n人赛马时最终名次的可能性的个数除以10056的余数。

【分析】

设答案为f(n)。假设第一名有/个人，有C(n，/)种可能性，接下来有f>/)种可能性，因此 答案为 ZC(n，/f(n-/)。

例题 10-15 杆子的排列(Pole Arrangement, ACM/ICPC Daejeon 2012, UVa1638 )

有高为1, 2, 3,…，n的杆子各一根排成一行。从左边能看到/根，从右边能看到r根，求有 多少种可能。例如，图10-9中的两种情况都满足Z=1，r=2 ( 1</，r<n<20 )。

图10-9 杆子的排列

【分析】

设亦，M)表示让高度为卜/根杆子排成一行，从左边能看到/根，从右边能看到&根的方 案数。为了方便起见，假定&2。如何进行递推呢？首先尝试按照从小到大的顺序按照各个 杆子。假设已经安排完高度为1〜/-1的杆子，那么高度为/的杆子可能会挡住很多其他杆子， 看上去很难写出递推式。

那么换一个思路：按照从大到小的顺序安排各个杆子。假设已经安排完高度为2〜/的杆 子，那么高度为1的杆子不管放哪里都不会挡住任何一根杆子。有如下3种情况。

情况1 ：插到最左边，则从左边能看到它，从右边看不见（因为^2 ）。

情况2：如果插到最右边，则从右边能看到它，从左边看不见。

情况3 （有/-2个插入位置）：插到中间，则不管从左边还是右边都看不见它。

在第一种情况下，高度为2〜/的那些杆子必须满足：从左边能看到/-1根，从右边能看 到k根，因为只有这样，加上高度为1的杆子之后才是“从左边能看到/根，从右边能看 到k根”。虽然状态成/J，k）表示的是“让高度为卜/的杆子……”，而现在需要把高度为2〜/+1 的杆子排成一行，但是不难发现：其实杆子的具体高度不会影响到结果，只要有/根高度各 不相同的杆子，从左从右看分别能看到/根和k根，方案数就是硪/，/，k）。换句话说，情况1对应 的方案数是硪/-1J-1，k）。类似地，情况2对应的方案数是硪/-1J，k-1），而情况3对应的方案数 是成/-1J，k）*（/-2）。这样，就得到了如下递推式：

d（i，j，k） = d（i-1，j-1，k） + d（i-1，j，k-1） + d（i-1，j，k）*（i-2）

10.3.2 数学期望

数学期望。简单地说，随机变量X的数学期望£¥就是所有可能值按照概率加权的和。例 如，一个随机变量有1/2的概率等于1， 1/3的概率等于2， 1/6的概率等于3，则这个随机变量 的数学期望为1*1/2+2*1/3+3*1/6=5/3。在非正式场合中，可以说这个随机变量“在平均情况 下”等于5/3。在解决和数学期望相关的题目时，可以先考虑直接使用数学期望的定义求解： 计算出所有可能取值，以及对应的概率，最后求加权和，如果遇到困难，则可以考虑使用下 面两个工具：

期望的线性性质。有限个随机变量之和的数学期望等于每个随机变量的数学期望之 和。例如，对于两个随机变量x和y，所x+r）=£A+ey。

全期望公式。类似全概率公式，把所有情况不重复、不遗漏地分成若干类，每类计算

数学期望，然后把这些数学期望按照每类的概率加权求和。

例题 10-16 过河(Crossing Rivers, ACM/ICPC Wuhan 2009, UVa12230 )

你住在村庄A，每天需要过很多条河到另一个村庄B上班。B在A的右边，所有的河都在 中间。幸运的是，每条河上都有匀速移动的自动船，因此每当到达一条河的左岸时，只需等 船过来，载着你过河，然后在右岸下船。你很瘦，因此上船之后船速不变。

日复一日，年复一年，你问自己：从A到B，平均情况下需要多长时间？假设在出门时

所有船的位置都是均匀随机分布。如果位置不是在河的端点处，则朝向也是均匀随机。在陆

地上行走的速度为1。

输入A和B之间河的个数n、长度D ( 0<n<10，1<D<1000 )，以及每条河的左端点坐标离 A的距离^，长度Z和移动速度v ( 0<p<D，0<L<D，1<v<100 )，输出A到B时间的数学期望。 输入保证每条河都在A和B之间，并且相互不会重叠。

【分析】

用数学期望的线性。过每条河的时间为L/v到3L/v的均勻分布，因此期望过河时间为 2L/v。把所有2L/v加起来，再加上D-sum(L)即可。

例题 10-17 糖果(Candy, ACM/ICPC Chengdu 2012, UVa1639 )

有两个盒子各有打(n<2*105 )个糖，每天随机选一个(概率分别为p，1-p )，然后吃一 颗糖。直到有一天，打开盒子一看，没糖了！输入n, p，求此时另一个盒子里糖的个数的数 学期望。

【分析】

根据期望的定义，不妨设最后打开第1个盒子，此时第2个盒子有/颗，则这之前打开 过n+(n-/)次盒子，其中有n次取的是盒子1，其余n-/次取的盒子2，概率为C(2n-/，    n)pn+1

(1-p)n-/。注意p的指数是n+1，因为除了前面打开过n次盒子1之外，最后又打开了一次。

这个概率表达式在数学上是正确的，但是用计算机计算时需要小心：n可能高达20万，

因此C(2n-/，n)可能非常大，而，*1和(1-p)n-/却非常接近0。如果分别计算这3项再乘起来，会 损失很多精度。一种处理方式是利用对数，设v1(/) = ln(C(2n-/，n)) + (n+1)ln(p) + (n-/)ln(1-p)，则“最后打开第1个盒子”对应的数学期望为ev1(/)。

同理，当最后打开的是第2个盒子，对数为v2(/) = ln(C(2n-/， n)) + (n+1)ln(1-p) + (n-i)ln(p)，概率为ev2(/)。根据数学期望的定义，最终答案为sum{/(ev1(/)+ev2(/))}。

例题 10-18 优惠券(Coupons, UVa10288 )

大街上到处在卖彩票，一元钱一张。购买撕开它上面的锡箔，你会看到一个漂亮的图 案。图案有n种，如果你收集到所有n ( n<33 )种彩票，就可以得大奖。请问，在平均情况 下，需要买多少张彩票才能得到大奖呢？如n=5时答案为137/12。

【分析】

已有k个图案，令5=^，拿一个新的需要Z次的概率：st-1(1-s);因此平均需要的次数为(1-s) (1 + 2s + 3s2 + 4s3 + …)=(1-s)^，而s^ = s + 2s2 + 3s3 + ... = ^-(1+s+s2+…)，移项得

(1-s)£=1+s+s2+...=1/(1-s) = n/(n-k)

换句话说，已有k个图案：平均拿n/(n-k)次就可多搜集一个，所以总次数为：

n(1/n+1/(n-1)+1/(n-2)+. +1/2+1/1)

10.3.3 连续概率

连续概率。简单地说，随机变量X的数学期望£¥就是所有可能值按照概率加权的和。例 如，一个随机变量有1/2的概率等于1， 1/3的概率等于2， 1/6的概率等于3，则比变量随机。

例题 10-19 概率(Probability, UVa11346 )

在[-¥]*[-¥]区域内随机取一个点P，求以(0，0)和P为对角线的长方形面积大于S的概率 (a，b>0，5>0 )。例如a=10，b=5，S=20，答案为23.35%。

【分析】

根据对称性，只需要考虑[0，a]*[0，b]区域取点即可。面积大于S，即吵>S。吵=5是一条双 曲线，所求概率就是[0，a]*[0，b]中处于双曲线上面的部分。为了方便，还是求曲线下面的面 积，然后用总面积来减，如图10-10所示。

图10-10 双曲线所围面积

设双曲线和区域［0,列*［0力］左边的交点P是(5/h幻，因此积分就是：

查得1AS的原函数是ln⑶，因此积分部分就是ln⑷-ln(5^)= ln⑽/5)。设面积为m，则答案

为 (m - s - s *ln(m/s)) / m。

注意这样做有个前提，就是双曲线和所求区域相交。如果5〉冰，则概率应为0 ;而如 果太接近0，概率应直接返回1，否则计算ln(m/5)时可能会出错。

例题 10-20 你想当2n元富翁吗？( So you want to be a 2n-aire?, UVa10900 )

在一个电视娱乐节目中，你一开始有1元钱。主持人会问你n个问题，每次你听到问题后 有两个选择：—是放弃回答该问题，退出游戏，拿走奖金；二是回答问题。如果回答正确， 奖金加倍；如果回答错误，游戏结束，你一分钱也拿不到。如果正确地回答完所有n个问 题，你将拿走所有的2n元钱，成为2"元富翁。

当然，回答问题是有风险的。每次听到问题后，你可以立刻估计出答对的概率。由于主 持人会随机问问题，你可以认为每个问题的答对概率在Z和1之间均勻分布。输入整数n和实 数t（ 1<n<30，0<t<1 ），你的任务是求出在最优策略下，拿走的奖金金额的期望值。这里的 最优策略是指让奖金的期望值尽量大。

【分析】

假设你刚开始游戏，如果直接放弃，奖金为1；如果回答，期望奖金是多少呢？不仅和 第1题的答对概率相关，而且和答后面的题的情况相关。即：

选择“回答第1题”后的期望奖金 = p * 答对1题后的最大期望奖金

注意，上式中“答对1题后的最大期望奖金”和这次的无关，这提示我们用递推的思想， 用叫i]表示“答对i题后的最大期望奖金”，再加上“不回答”时的情况，可以得到：若第1题答对 概率为^，期望奖金的最大值=max{20, p*d[1]}

这里故意写成20，强调这是“答对0题后放弃”所得到的最终奖金。

上述分析可以推广到一般情况，但是要注意一点：到目前为止，一直假定p是已知的，

而p实际上并不固定，而是在t〜1内均勻分布。根据连续概率的定义，d[i]在概念上等于

max{2z^ p*d[i+1]}在p=t~ 1上的积分。不要害怕“积分”二字，因为虽然在概念上这是一个积 分，但是落实到具体的解法上，仍然只需要基础知识。

因为有max函数的存在，需要分两种情况讨论，即p*d[i+1]<2^p*d[i+1]^2俩种情况。

令p0=max{t, 2Vd[i+1]}（加了一个max是因为根据题目，p^t），则：

□ p<p0时，p*d[i+1]<2z，因此“不回答”比较好，期望奖金等于2Z。

p改0时，“回答”比较好，期望奖金等于d[i]乘以p的平均值（d[i]作为常数被“提出

来” 了)，即(1+^0)/2 * 叫z+1]。

在第一种情况中，，p的实际范围是似0)，因此概率为W=b0-t)/(1-t)。根据全期望公 式， d[i] = 2i * p1 + (1+p0)/2 * d[i+1] * (1-p1)。

边界是破n] =2n，逆向递推出破0]就是本题的答案。

例题 10-21 多边形(Polygon, UVa11971 )

有一根长度为n的木条，随机选k个位置把它们切成k+1段小木条。求这些小木条能组成 一个多边形的概率。

【分析】

不难发现本题的答案与n无关。在一条直线上切似乎难以处理，可以把直线接成一个 圆，多切一下，即在圆上随机选k+1个点，把圆周切成k+1段。根据对称性，两个问题的答案 相同。

新问题就要容易处理得多了： “组不成多边形”的概率就是其中一个小木条至少跨越了半 个圆周的概率。设这个最长的小木条从点/开始逆时针跨越了至少半个圆周，则其他所有点 都在这半个圆周之外，如图10-11所示的灰色部分。

图10-11 木条逆时针跨越所成形状

除了点i之外其他每个点位于灰色部分的概率均为1/2，因此总概率为1/2\点i的取法 有奸1种，因此“组不成多边形”的概率为（奸1）/2\能组成多边形的概率为1-（奸1）/2\

###### 10.4 竞赛题目选讲

例题 10-22 统计问题(The Counting Problem, ACM/ICPC Shanghai 2004, UVa1640 )

给出整数“、办，统计“和办(包含“和办)之间的整数中，数字0，1,2,3,4,5,6,7,8,9分别出现 了多少次。1<^，^<108。注意，有可能大于办。

【分析】

解决这类题目的第一步一般都是：令/x«)表示01-1中数字出现的次数，则所求的就 是fd(b+1)-fd(a)。例如，要统计0〜234中4的个数，可以分成几个区间，如表10-2所示。

表10-2 0~ 234所划区间

| 范围      | 模板集                      |
| --------- | --------------------------- |
| 0〜9      | *                           |
| 10 〜99   | **                          |
| 100〜199  | 1**                         |
| 200 〜229 | 20*， 21*， 22*             |
| 230〜234  | 230， 231， 232， 233， 234 |

表10-2中的“模板”指的是一些整数的集合，其中字符“*”表示“任意字符”。例如， 1**表 示以1开头的任意3位数。因为后两个数字完全任意，所以“个位和十位”中每个数字出现的次 数是均等的。换句话说，在模板1**所对应的100个整数的200个“个位和十位”数字中，0〜9 各有20个。而这些数的百位总是1，因此得到：模板1**对应的100个整数包含数字0，2〜9各 20个，数字1有120个。

这样，只需把0~«分成若干个区间，算出每个区间中各个模板所对应的整数包含每个数 字各多少次，就能解决原问题了，细节留给读者思考。

例题10-23 多少块土地( How Many Pieces of Land?, UVa10213)

有一块椭圆形的地。在边界上选《 ( 0<n<231 )个点并两两连接得到n(n-1)/2条线段。它们 最多能把地分成多少个部分？如图10-12所示，n=6时最多能分成31份。

图10-12 n=6时所划分的土地

【分析】

本题需要用到欧拉公式：在平面图中，V-E+F=2，其中V是顶点数，E是边数，F是面 数。因此，只需要计算V和E即可(注意还要减去外面的“无限面”)。

不管是顶点还是边，计算时都要枚举一条从固定点出发(所以最后要乘以n )的对角 线，它的左边有/个点，右边有n-2-/个点。左右点的连线在这条对角线上形成i(n-2-/)个交 点，得到/(n-2-/)+1条线段。每个交点被重复计算了4次，每条线段被重复计算了2次。

本题还有一个有趣之处：n=1〜n=6时答案分别为1、2、4、8、16、31。如果根据前5 项“找规律”得到“公式”2n-1，即就错了。

例题 10-24 ASCII面积(ASCII Area, NEERC 2011, UVa1641 )

在一个铲w ( 2<力，w<100 )的字符矩阵里用“”、“\”和“/”画出一个多边形，计算面积。 如图10-13所示，面积为8。

图 10-13 ASCII 面积

【分析】

这是一道和几何相关的题目，不过不需要高深的几何知识。每个格子要么全白，要么全

黑，要么半白半黑，只要能准确地判断出来即可。字符“\”和“/”都是半白半黑，问题在

于“.”到底是全白还是全黑。

解决方法是从上到下从左到右处理，沿途统计“/”和“\”。当这两个字符出现偶数次时说

明接下来的格子在多边形外；奇数次则说明接下来的格子在多边形内。

例题10-25 约瑟夫的数论问题( Joseph's Problem, NEERC 2005, UVa1363)

输入正整数n和女(1<n，k<109 )，计算k mod

?=i

【分析】

被除数固定，除数逐次加1，直观上余数也应该有规律。假设k/i的整数部分等于p，则k mod i = k-i*p。因为k/(i+1)和k/i差别不大，如果k/(i+1)的整数部分也等于p，则k mod (i+1) = k-(i+1)*p = k-i*p -p = k mod i -p。换句话说，如果对于某一个区间i, i+1, i+2,…,j，k除以它们 的商的整数部分都相同，则k除以它们的余数会是一个等差数列。

这样，可以在枚举i时把它所在的等差数列之和累加到答案中。这需要计算满足[k/j]=

[w]=/»的最大/。

□当^=0时这样的J不存在，所以等差序列一直延续到序列的最后。

□当/»〉0时/为满足的•改的最大/，即j<k/p。除了首项之外的项数j-/<(k-/*p)/p =抑。

例题 10-26 帮帮Tomisu ( Help Mr. Tomisu, UVa11440 )

给定正整数#和似，统计2和M之间有多少个整数满足：的所有素因子都大

于M( 2<N<107，1<M<N，N-M<105 )。输出答案除以 100000007的余数。例

如，N=100，M=10时答案为 43274465。

【分析】

因为M<N，所以N!是M!的整数倍。“所有素因子都大于M”等价于和M!互素。另外，根据 最大公约数的性质，对于k〉M!，k与M!互素当且仅当k    mod M!与M!互素。这样，只需要求

出“不超过M!且与M!互素的正整数个数”，再乘以N!/M!即可。这样，问题的关键就是求出 phi(M!)。因为有多组数据，考虑用递推的方法求出所有的phifac(n)=phi(n!)。由phi函数的公 式：

###### 炉⑷=/7(1-丄)(1_丄)…(I -丄)

Pl Pl    Pk

如果n不是素数，那么n!和(n-1)!的素因子集合完全相同，因此phifac(n)=phifac(n-1)*n ; 如果n是素数，那么还会多一项(1-1/n)，即(n-1)/n，约分得phifac(n)=phifac(n-1)*(n-1)。

核心代码如下(请读者注意其中的细节，如rn=1的情况)：

int main() { int n, m;

sieve(10000000); //筛法求素数

phifac [1] = phifac [2] = 1; //请读者思考，为什么phifac[1]等于1而不是0 for (int i = 3; i <= 10000000; i + +)    //递推 phifac[i]=phi(i!)%MOD

phifac [i] = (long long) phifac [i-1]    * (vis [i]    ? i : i-1)    % MOD; //vis[i]为真^> i 不

int ans = phifac[m];

for(int i = m+1; i <= n; i++) ans = (long long)ans * i % MOD; printf("%d\n", (ans-1+MOD)%MOD); //注意这里要减1，因为题目从2开始统计

}

return 0;

}

例题 10-27 树林里的树(Trees in a Wood, UVa10214 )

在满足（^<2000，b<2000000 ）的网格中，除了原点之外的整点（即坐标 均为整数的点）各种着一棵树。树的半径可以忽略不计，但是可以相互遮挡。求从原点能看 到多少棵树。设这个值为尺，要求输出尺从，其中#为网格中树的总数。如图10-14所示，只 有黑色的树可见。

【分析】

显然4个坐标轴上各只能看见一棵树，所以可以只数第一象限（即x〉0，y〉0 ），答案乘 以4后加4。第一象限的所有人y都是正整数，能看到（x，y），当且仅当gcd（x，y）=1。

由于范围比较小，b范围比较大，一列一列统计比较快。第列能看到的树的个数等于 0<y<b的数中满足gcd（^，y）=1的y的个数。可以分区间计算。

□    1<y<x :有phi（v）个，这是欧拉函数的定义。

□    .x+1<y<2.x :也有phi（x）个，因为 gcdCx+/，_x）=gcdCx，/）。

□    2_x+1<y<3_x ：也有phi（x）个，因为 gcd（2_x+/，x）=gcdCx，/）。

□ kx+1<y<b :直接统计，需要□&）时间。

换句话说，每次需要计算phi⑻和进行0⑻次直接判断，计算phi⑻需要0（'2）时间，而 直接判断只需要0（1）时间。再加上枚举的所有种可能，总时间为C^2）。

例题10-28 (问题抽象)高速公路( Highway, ACM/ICPC CERC 2006, UVa1393)

有一个n行讲列（1<n，rn<300 ）的点阵，问：一共有多少条非水平非竖直的直线至少穿过 其中两个点？如图10-15所示，n=2，rn=4时答案为12，n=rn=3时答案为14。

图10-14 树林里的树



图10-15n行m列点阵



【分析】

不难发现两个方向是对称的，所以只统计“\”型的，然后乘以2。方法是枚举直线的包围 盒大小^*&，然后计算出包围盒可以放的位置。首先，当gcd(^力)〉1时肯定重复了，如图10-16(a)所示，大包围盒^*办满足gcd(^)〉1，在它的对角线和的对角线是同一条直线

(其中 a'=a/gcd(a,b)， b'=b/gcd(a,b))。

其次，如果放置位置不够靠左，也不够靠上，则它和它“左上方”的包围盒也重复了，如 图10-16 ( b )所示。

(a)    (b)

图 10-16 gcd(a,b)>1 时示意图



假定左上角坐标为(0,0)，则对于左上角在(^y)的包围盒，其“左上方”的包围盒的左上角 为(i^y-办)。这个“左上角”合法的条件是论0且y-^0。

包围盒本身不出界的条件是^+^<m-1 ,y+^<n-1，一共有(m-^)(n-6)个，而“左上方”有包围 盒的情况，即“<^<讲皆1且办<>^-办-1，有c = max(0, m-2a) * max(0, n-2幻种放法。相减得 到：^*办的包围盒有(rn-^)(n-办)-c种放法。

另外要注意应预处理保存所有gcd，而不是边枚举边算，否则会超时。

例题 10-29 魔法GCD （ Magical GCD, ACM/ICPC CERC 2013, UVa1642 ）

输入一个n ( n<100000 )个元素的正整数序列    …    ，，求一个连续子序

列，使得该序列中所有元素的最大公约数与序列长度的乘积最大。例如，5个元素的序列30，

60，20，20，20的最优解为｛60，20，20，20｝，乘积为gcd(60，20，20，20)*4=80。

【分析】

本题看上去和第8章介绍的一些“传统算法题”很像，所以可试着沿用这样一个常见的框 架：从左到右枚举序列的右边界/，然后快速求出左边界/<•，使得MGCD(/J)最大，其中

定义为_ h1    。

如何快速求出i呢？好像那些“传统方法”(单调队列等)都用不上，因为gcd函数并没有 很多“好用”的代数性质。怎么办？还是从数论的角度入手吧。考虑序列5, 8, 6, 2, 6, 8，当j=5 时需要比较i=1, 2, 3, 4, 5时的MGCD(ij)，如表10-3所示。

表 10-3 j=5时比较的 MGCD(i,j)

| i    | gcd表达式          | gcd值 | 序列长度 |
| ---- | ------------------ | ----- | -------- |
| 1    | gcd(5，8，6，2，6) | 1     | 5        |
| 2    | gcd（8，6，2，6）  | 2     | 4        |
| 3    | gcd（6，2，6）     | 2     | 3        |
| 4    | gcd（2，6）        | 2     | 2        |
| 5    | gcd（6）           | 6     | 1        |

从下往上看，gcd表达式里每次多一个元素，有时gcd不变，有时会变小，而且每次变小 时一定是变成了它的某个约数(想一想，为什么)。换句话说，不同的gcd值最多只有 log2/种！当gcd值相同时，序列长度越大越好，所以可以把表10-3简化成表10-4中的形式。

表10-4 简化表10-3

| gcd值 | 1    | 2    | 6    |
| ----- | ---- | ---- | ---- |
|       |      |      |      |

因为表里只有log2/个元素，所以可以依次比较每一个i对应的MGCD(ij)，时间复杂度为

O(logj-)。下面考虑/从5变成6时，这个表会发生怎样的变化。首先，上述所有gcd值都要再 和“6=8取gcd，即表 10-4中第一行的 1, 2, 6分别变成gcd(1,8)=1，gcd(2,8)=2，gcd(6,8)=2。然后

要加入i=6的序列，gcd值为8。由于相同的gcd值只需要保留i的最小值，所以i=5被删除，最 终得到如表10-5所示结果。

表10-5 i=5被删除后的结果

| gcd值 | 1    | 2    | 6    |
| ----- | ---- | ---- | ---- |
| i     | 1    | 2    | 8    |

上述过程需要删除gcd相同的重复元素，但因为元素个数只有O(logj)个，即使用二重循 环比较，时间效率也是很高的，每次修改表10-5的时间复杂度为O((log/)2)，总时间复杂度 为O(n(logn)2)。但因为很难构造出每次表里都有接近log2/个元素的数据，实际运行时间和时 间复杂度为O(nlogn)的算法相当。



###### 10.5 训练参考

数学题目的特点是：思维难度往往远大于编程难度。尽管如此，也有一些程序实现细节

不容忽视，例如，整数溢出和精度误差。本章的例题很多，不过多数题目的难度不大，重点

在于帮助读者巩固相关的知识点。建议读者先学会所有不加星号的例题，然后逐步弄懂有星

号的例题。本章例题列表如表10-6所示。

表10-6 例题列表

| 类别       | 题号     | 题目名称（英文）           | 备注         |
| ---------- | -------- | -------------------------- | ------------ |
| 例题10-1   | UVa11582 | Colossal FibonacciNumbers! | 模算术       |
| 例题10-2   | UVa12169 | Disgruntled Judge          | 模算术       |
| 例题10-3   | UVa10375 | Choose and Divide          | 唯一分解定理 |
| 例题10-4   | UVa10791 | Minimum Sum LCM            | 唯一分解定理 |
| 例题10-5   | UVa12716 | GCD XOR                    | 数论         |
| 例题10-6   | UVa1635  | Irrelevant Elements        | 组合数       |
| 例题10-7   | UVa10820 | Send a Table               | 欧拉phi函数  |
| 例题10-8   | UVa1262  | Password                   | 编码解码问题 |
| 例题10-9   | UVa1636  | Headshot                   | 离散概率     |
| 例题10-10  | UVa10491 | Cows and Cars              | 离散概率     |
| 例题10-11  | UVa11181 | Probability\|Given         | 离散条件概率 |
| 例题10-12  | UVa1637  | Double Patience            | 离散概率     |
| 例题10-13  | UVa580   | Critical Mass              | 递推         |
| 例题10-14  | UVa12034 | Race                       | 递推         |
| *例题10-15 | UVa1638  | Pole Arrangement           | 递推         |
|            |          |                            |              |

| 例题10-16  | UVa12230 | Crossing Rivers              | 数学期望           |
| ---------- | -------- | ---------------------------- | ------------------ |
| 例题10-17  | UVa1639  | Candy                        | 数学期望           |
| 例题10-18  | UVa10288 | Coupons                      | 数学期望           |
| *例题10-19 | UVa11346 | Probability                  | 连续概率           |
| *例题10-20 | UVa10900 | So you want to be a 2n-aire? | 连续概率，数学期望 |
| *例题10-21 | UVa11971 | Polygon                      | 连续概率           |
| 例题10-22  | UVa1640  | The Counting Problem         | 数位统计           |
| 例题10-23  | UVa10213 | How Many Pieces of Land?     | 欧拉公式、计数     |
| 例题10-24  | UVa1641  | ASCII Area                   | 多边形面积         |
| 例题10-25  | UVa1363  | Joseph's Problem             | 数论，数列求和     |
| *例题10-26 | UVa11440 | Help Mr. Tomisu              | 欧拉phi函数        |
| 例题10-27  | UVa10214 | Trees in a Wood              | 欧拉phi函数        |
| 例题10-28  | UVa1393  | Highway                      | 分类统计           |
| 例题10-29  | UVa1642  | Magical GCD                  | 综合题             |

本章的习题是本书中数量最多的，不过多数习题的难度不大，主要目的是巩固知识。因

为大多数题目的描述比较简单，建议读者阅读所有题目，并选择感兴趣的题目思考。

习题10-1 砌砖( Add Bricks in the Wall, UVa11040) 45块石头按照如图10-17所示的方式排列，每块石头上有一个整数。

255

10

o

!

3

5

2

rz

j:

I

1

1

1

图10-17 45块石头排列方式

除了最后一行外，每个石头上的整数等于支撑它的两个石头上的整数之和。目前只有奇

数行的左数奇数个位置上的数已知，你的任务是求出其余所有整数。输入保证有唯一解。

习题10-2 勤劳的蜜蜂( Bee Breeding, ACM/ICPC World Finals 1999, UVa808)

如图10-18所示，输入两个格子的编号a和^ （久衫10000 ），求最短距离。例如，19和30 的距离为5（一条最短路是19-7-6-5-15-30）。

习题10-3 角度和正方形( Angles and Squares, ACM/ICPC Beijing 2005, UVa1643)

如图10-19所示，第一象限里有一个角，把n （ n<10）个给定边长的正方形摆在这个角里 （角度任意），使得阴影部分面积尽量大。

」—\」一—\」一\ 厂'    /54\    /

/55 \    /    \

/    \_/5D\_/3D\_/32\_/5^\    /

\_/47\    /    /5&\

/.t\ /a5\    e\    /

'■■■    .<4\    / T-..    .-=G\ m.

/~\    /44\    /妇\    /7T\    _/

\_/70\^/43 \_^/2a \    /3?\    /62\

/    \    /42\    /4D\    /S3\    /

\」一\」研」ZT\」讯」一\ /    \」\_/S7\ 咕\」\_J

\」\」\    /6S\__/    \」\

图 10-18 勤劳的蜜蜂问题示意图



图 10-19 角度和正方形问题示意图



习题10-4 素数间隔( Prime Gap, ACM/ICPC Japan 2007, UVa1644)

输入一个整数n，求它后一个素数和前一个素数的差值。输入是素数时输出0。n不超过 1299709 (第 100000个素数)。例如，n=27时输出29-23=6。

习题10-5 不同素数之和( Sum of Different Primes, ACM/ICPC Yokohama 2006, UVa1213)

选择尺个质数，使它们的和等于#。给出A和尺(K1120，K<14 )，问有多少种满足条件 的方案？例如，n=24，A=2时有3种方案:5+19=7+17=11+13=24。注意，1不是素数，因 此n=A=1时答案为0。

习题10-6 连续素数之和( Sum of Consecutive Prime Numbe rs , ACM/ICPC Japan 2005, UVa1210)

输入整数打(2<n<10000 )，有多少种方案可以把n写成若干个连续素数之和？例如，41 可由3种方案： 2+3+5+7+11+13， 11+13+17和41写成。

习题10-7 几乎是素数( Almost Prime Numbe rs , UVa10539)

输入两个正整数£、U(L<U<1012)，统计区间［L，U］的整数中有多少个数满足：它本身 不是素数，但只有一个素因子。例如，4、27都满足条件。

习题 10-8 完全P次方数(Perfect Pth Powers, UVa10622 )

对于整数x ,如果存在整数使得x=^ ,则说x是一个完全次方数。输入整数《 ,求出最 大的整数^ ,使得《是完全次方数。《的绝对值不小于2 ,且《在32位带符号整数范围内。例

如， n=17， p=1；n=1073741824， p=30；n=25， p=2。

习题10-9 约数( Divisors, UVa294)

输入两个整数I、1<L<U<109 , U-L<10000 ),统计区间［L,U］的整数中哪一个的正约 数最多。如果有多个，输出最小值。

习题10-10 统计有根树( Count, Chengdu 2012, UVa1645)

输入《 ( ^<1000 ),统计有多少个《结点的有根树，使得每个深度中所有结点的子结点数 相同。例如，《=4时有3棵，如图10-20所示；《=7时有10棵。输出数目除以109+7的余数。

图10-20 n=4时的有根树

习题10-11 圈图的匹配( Edge Case, ACM/ICPC NWERC 2012, UVa1646)

n ( 3<n<10000 )个结点组成一个圈，求匹配(即没有公共点的边集)的个数。例 如，n=4时有7个，如图 10-21 所示，n=100时有792070839848372253127个。

(a)    (b) M2 (c) M3    (d) A/4    (e) A/5    (f) M6 (g) M-,

图10-21 n=4时匹配的个数

习题10-12 汉堡( Burger, UVa557)

有n个牛肉堡和n个鸡肉堡给2n个孩子吃。每个孩子在吃之前都要抛硬币，正面吃牛肉 煲，反面吃鸡肉煲。如果剩下的所有汉堡都一样，则不用抛硬币。求最后两个孩子吃到相同 汉堡的概率。

习题10-13 H(n)( H(n), UVa11526)

输入n (在32位带符号整数范围内)，计算下面C++函数的返回值：

long long H(int n){ long long res = 0;

for( int i = 1; i <= n; i=i+1 ){ res = (res + n/i);

}

return res;

}

例如，n=5、10时答案分别为10和27。

习题10-14 标准 差( Standard Deviation, UVa10886)

下面是一个随机数发生器。输入seed的初始值，你的任务是求出它得到的前n个随机数 标准差，保留小数点后5位( 1<n<10000000， 0<seed<264)。

unsigned long long seed;

long double gen()

{

static const long double Z = ( long double )1.0 / (1LL<<32); seed >>= 16;

seed *= seed; return seed * Z;

}

习题10-15 零和一( Zeros and Ones, ACM/ICPC Dhaka 2004, UVa12063)

给出n、女(n<64 , K100 ),有多少个打位(无前导0 )二进制数的1和0—样多，且值 为女的倍数？

习题10-16 计算机变换( Comput e r Transformations, ACM/ICPC SEERC 2005, UVa1647)

初始串为—个1，每—步会将每个0改成10，每个1改成01，因此1会依次变成01, 1001, 01101001,...输入n(n<1000 )，统计n步之后得到的串中，“00”这样的连续两个0出现了多少 次。

习题 10-17 H-半素数(Semi-prime H-numbers, UVa11105 )

所有形如4n+1 ( n为非负整数)的数叫H数。定义1是唯一的单位H数，H素数是指本身不 是1 ,且不能写成两个不是1的H数的乘积。H-半素数是指能写成两个H素数的乘积的H数(这 两个数可以相同也可以不同)。例如，25是H-半素数，但125不是。

输入一个H数力(^<1000001 ),输出1〜力之间有多少个H-半素数。

习题10-18 —个研究课题( A Research Problem, UVa10837)

输入正整数rn ( m<108 ),求最小的正整数n ,使得q(n)=rn。输入保证n小于200000000。

习题10-19 蹦极( Bungee Jumping, UVa10868)

James Bond为了摆脱敌人的追击，逃到了一座桥前。桥上正好有一条蹦极绳，于是他打 算把它拴到腿上，纵身跳下桥，落地后切断绳子，继续逃生。已知绳子的正常长度 为l , Bond的体重为w ,桥的高度为5 ,你的任务是替James Bond判断能否用这种方法逃生。

当从桥上跳下后，绳子綳紧前Bond将做自由落体运动(重力按9.81w计)，而綳紧后绳 子会有向上的拉力，大小为PA1 ,其中Al为绳子当前长度和正常长度之差。当且仅当Bond可

以到达地面，且落地速度不超过10米/秒时，才认为他安全着落。

输入每组数据包含4个非负整数屯l, s, w（ s<200 ）。对于每组数据，如果可以安全着 地，输出“James Bond survices.”，如果到不了地面，输出“Stuck in the air.”，如果到达地面速 度太快，输出“Killed by the impact.”

习题10-20 商业中心( Business Center, NEERC 2009, UVa1648)

商业中心是一幢无限高的大楼。在一楼有m座电梯，每座电梯只有两个键：上、下。对 于第/座电梯，每按一次“上”会往上走层楼，每按一次“下”会往下走或层楼。你的任务是从

一楼开始选一个电梯，恰好按n次按钮，到达一个尽量低（一楼除外）的楼层。中途不能换 乘电梯。1^n^1000000，1<m<2000，1<w/?^z<1000。

习题10-21 二项式系数( Binomial coefficients, ACM/ICPC NWERC 2011, UVa1649)

输入m （ 2<m<1015 ），求所有的（n，^）使得C（n,女）=m。输出按照n升序排列，当n相同时女按 升序排列。

习题10-22 飞机环球( Planes Around the World, UVa10640)

有一种飞机，加满油能环游地球圈。如果要使得一架飞机能够环游地球一圈，那么 必须要使用其他若干架同种飞机，在某处为它空中加油。

假设“=1，6 = 2，5架飞机可以环游。

首先3架飞机一起从A走到C，飞机3给另外两架加满油，然后开始返程。当飞机1和2到 达D的同时飞机3回到A。然后飞机2给飞机1加满油，回到A点。

接下来，飞机4和5逆时针出发，其中飞机4在F处等待，飞机5在E处等待，直到飞机1到 达E。然后飞机5给飞机1加油，使得二者都能恰好飞到F。然后飞机4给飞机1和飞机5加油， 三者都恰好飞回A，如图10-22所示。

图 10-22 飞机环球问题示意图

假设：

□只有飞机1环游地球。

□有A架飞机和飞机1同时出发，同向飞行，称为正向飞机。每艘正向飞机都在某个位置 处为其他飞机加油，然后折返。

□有B架飞机于不同时间反向出发，称为反向飞机。每架反向飞机会停在一个地方等待飞 机1（及其他同行飞机）。等到之后为其他飞机加油，然后折返。

□除了飞机1之外的其他飞机恰好为其他飞机加一次油，使得每个其他飞机得到相同多的 油量。

输入仏^ ,输出最少需要时用多少架飞机才能完成环游地球。例如^ = 1 , ^ = 2时需要5 架。无解输出-1。

习题 10-23 Hendrie序列(Hendrie Sequence, UVa10479 )

Hendrie序列是一个自描述序列，定义如下：

□ H（1）=0。

□如果把H中的每个整数x变成x个0后面跟着x+1 ,则得到的序列仍然是H （只是少了第一 个元素）。

因此，H序列的前几项为：0，1，0，2,1，0，0，3，0，2,1,1，0，0，0，4,1，0，0，3，0，……输入正整 数权（n<263 ）,求H（n）。

习题10-24 幂之和( Sum of Powers, UVa766)

对于正整数^，可以定义&次方和：

可以把它写成下面的形式。当似取最小可能的正整数时，所有系数％都是确定的。

输入女(0<A<20)，输出1人卜冬…例如，A=2，输出6, 2, 3, 1，0。

习题10-25 因子( Factors, ACM/ICPC World Finals 2013, UVa1575)

算术基本定理：每一个大于1的正整数都有唯一的方式写成若干个素数的乘积。不过如

果允许把这些素数重排，就有多种表示方式：

10 = 2 * 5 = 5 * 2, 20 = 2 * 2 * 5 = 2 * 5 * 2 = 5 * 2 * 2

令A幻为正整数&的写法个数，如f(10)=2，f(20)=3。对于正整数n，可以证明一定有整 数女使得/(^)=n。你的任务是求出最小的^。n<263。

习题10-26 方形花园( Square Garden, UVa12520)

在Z*£ ( £<106 )网格里涂色n ( n<L2 )个格子，要求涂色格子的轮廓线周长尽量大。例 如，图10-22中为L=3，n=8的两组解，图10-23 ( a )的周长为16，图10-23 (办)的周长为12。

(a)

图10-23 L=3



(b)

n=8的两组解



习题10-27 互联( Interconnect, ACM/ICPC NEERC 2006, UVa1390)

输入n个点rn条边的无向图G ( n<30，rn^1000 )。每次随机加一条非自环的边(w，v)(加 完后可以出现重边)。添加每条边的概率是相等的，求使G连通的期望操作次数。

习题10-28 数字串( Number String, ACM/ICPC Changchun 2011, UVa1650)

每个排列都可以算出一个特征，即从第二个数开始每个数和前面一个数相比是增加(I)还 是减少(D)。例如，｛3,1,2,7,4,6,5｝的特征是DIIDID。输入一个长度为n-1 ( 2<n<1001 )的字符 串(包含字符/，    D和？)，统计1〜n有多少个排列的特征和它匹配(其中?表示I和D都符

合)。输出答案除以1000000007的余数。

习题10-29 名次表的变化( Fantasy Cricket, UVa11982)

如图10-24所示为一个足球比赛的名次表，给出了每个队伍相对上一轮的排名变化。例

如：

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-229.jpg)



这代表队伍A的名次提高了，B降低了，C提高了，D降低了。用U表示排名上升，D表示 降低，E表示不变，则上表可以用UDUD表示。经过计算可知，上一轮的名次表有两种可 能：BADC和BDAC (假定本轮和上一轮的名次都没有并列)。

输入这样一个UDE组成的序列(长度不超过1000 ),求上一轮名次有多少种可能。输出 答案除以109+7的余数。

习题10-30 守卫( Guard, ACM/ICPC Dhaka 2011, UVa12371)

在n*n棋盘上放2n个守卫，使得每行每列均恰好有两个守卫，且一个格子里最多只有一 个守卫。如图10-25所示是两种方法，其中图10-25 ( a )的守卫形成一个大圈，图10-25 ( b ) 中形成两个小圈。

(a)

图10-25



两种守卫方法



输入n、k ( 2<n<105 , 1<k<rnin(n，50)),输出恰好包含k个圈的方案总数。例 如，n=2 , k=1答案为1 ; n=3 , k=1 ,答案为6 ; n=4 , k=1 ,答案为72 ; n=4 , k=2 ,答案为 18 。

习题 10-31 守卫II ( Guards II, ACM/ICPC Dhaka 2012, UVa12590 )

在n行rn列的棋盘里放k个车，使得边界格子都被攻击到。输出方案总数除以109+7的余 数。n，m，k<100。输入最多包含20000组数据。

习题10-32 汉诺塔( Hanoi Towers, ACM/ICPC NEERC 2007, UVa1414)

Hanoi塔问题有一种构造解法：把6种移动(ABAQB^BQC^CB )排序后选择第一个能 用的操作，前提是不能连续移动同一个盘子。给出n ( n<30 )和6种移动的顺序，求解Hanoi 问题的步数。最终所有盘子可以都在B也可以都在C。例如，对于n=2，排序为AB, BA, CA, BC, CB, AC，—共需要5步。

习题10-33 二元运算( Binary Operation, ACM/ICPC NEERC 2010, UVa1651)

给定正整数a<6，你的任务是计萬/®(a+l)®(“+2)® — ®(Z?-l) op 的值，其中的 计算方法是这样的：首先，如果和的位数不同，位数较少的一个前面补0 ;然后逐位执行 ©操作。例如，当©表示“加起来模10”时，    :.的计算方法如下：

操作符是左结合的，因此.    从左到右计算即可。

输入©的运算表(一个10*10矩阵，表示0©0, 0©1,…，9©9的结果，其中0©0保证为0 ) 和a, b ( 0<a<办<1018 )的值，输出所求结果。

习题 10-34 记住 密码( Password Remembering, ACM/ICPC Dhaka 2009, UVa12212)

输入正整数A 5 ( A<B<264 )，求有多少个整数n满足：n在A和B之间(即A<n<B )，

且n翻转之后也在A和B之间。1203翻转以后为3021，1050翻转以后是501。

习题 10-35 Fibonacci单词(Fibonacci Word, ACM/ICPC World Finals 2012, UVa1282 )

0    if /7 = 0

F{n) — < 1    if a? = 1

F(w -1) + F(/7 - 2) if

输入非空01串^nn ( 0<n<100 )，求在F(n)中出现几次。夕的长度不超过100000。

习题 10-36 Fibonacci进制(Fibonacci System, ACM/ICPC NEERC 2008, UVa1652 ) 每个正整数都可以写成\彳厂-彳i…-U|/'i，其中an=1，^就是第Z•个Fibonacci数

，然后用.■.    作为#的Fibonacci进制表示。规定不能出现两个连续的1。例

如，卜 7的Fibonacci进制表示分别为：1, 10，100，101, 1000，1001, 1010。

把所有自然数的Fibonacci进制表示拼起来，会得到一个长长的串 110100101100010011010…。输入n n ( n<1015 )，统计前n位有多少个 1。

习题10-37 倍数问题( Yet Another Multiple Problem, Chengdu 2012, UVa1653)

输入一个整数n ( 1<n<10000 )和rn个十进制数字，找n的最小倍数，其十进制表示中不 含这m个数字中的任何一个。

提示：需要建一张图，结点i代表除以n的余数等于i。巧妙地利用第6章学过的BFS树可 以简洁地解决这个问题。

习题10-38 正多边形( Regular Polygon, UVa10824)

给出圆周上的n(n<2000 )个点，选出其中的若干个组成一个正多形，有多少种方法？ 输出每行包含两个整数和F，表示有F种选法得到正边形。各行应按从小到大排序。

习题10-39 圆周上的三角形( Circum Triangle, UVa11186)

在一个圆周上有打(n<500 )个点。不难证明，其中任意3个点都不共线，因此都可以组 成一个三角形。求这些三角形的面积之和。

习题10-40    实验法计算概率( Probability Through Experiments, ACM/ICPC Hatyai

2012, UVa12535)

输入圆的半径和圆上n ( n<20000 )个点的极角，任选3点能组成多少个锐角三角形？ 习题10-41 整数序列( A Sequence of Numbers, ACM/ICPC Chengdu 2007, UVa1406)

输入n个整数，执行2个操作(n<105，2<200000 )。有两种操作：

□    ADD d :把所有数加上一个定值d。

□    QUERY i :统计有多少个数的二进制表示法中第i位上是1，并输出。

习题10-42 网格中的三角形( Triangles in the Grid, UVa12508)

一个n行m列的网格有n+1条横线和m+1条竖线。任选3个点，可以组成很多三角形。其中 有多少个三角形的面积位于闭区间W］内？ 1^n，m^200 , 0^AHnm。

习题10-43 整数对( Pair of Integers, ACM/ICPC NEERC 2001, UVa1654)

考虑一个不含前导0的正整数把它去掉一个数字以后得到另外一个数y。输入+!的

值#（ 1<^<109）,输出所有可能的等式1+!=#。例如，#=34有两个解：31+3=34 ; 27+7=34。

习题10-44 选整数( K-Multiple Free Set, UVa11246)

给定正整数k ,从1〜n的整数中选出尽量多的整数，使得没有一个整数是另一个整数 的k倍。例如，n=10 , k=2 ,最多可以选6个：1,3,4,5,7,9。1<n<109 , 2<k<100。

习题10-45 带符号二进制( Power Signs, UVa11166)

每个整数都可以写成二进制。现将二进制变一下：每个数位上可以是0和1，还可以是-

1。例如， 13可以写成（1，0，0，-1，-1）=24-21-20。在这种进位制下，正整数的表示方法不唯一， 例如， 7可以写成（1，1，1）或者（1，0，0，-1）。你的任务是找一种非0数字最少的表示法。

输入每组数据第一行为用二进制表示的正整数n（n<25000 ），保证不含前导0。对于每组 数据，输出非0数字最小的表示法（ 0表示0， +表示1， -表示-1）。如果有多解，输出字典序 最小的。



习题10-46 抽奖( Honorary Tickets, UVa11895)

在一次抽奖活动中，有n （ 1<n<105 ）个抽奖箱，其中第/个箱子里有（ Zz〉0 ）个信封，

其中li个里面有奖。所有人依次抽奖（即自主选择一个抽奖箱，然后随机抽一个信封），每 次抽完后的空信封放回去。假设每个人都知道上述数据，并且足够聪明，求第k个人抽到奖 的概率（用最简分数表示，保证分子和分母都在32位带符号整数范围内）。注意，每个人抽 到奖之后只会默默地将它拿出，其他人并不会知道，因此不会改变既定的策略。

习题10-47 随机数( Randomness, UVa11429)

你有一个随机数发生器（R#G ）,可以得到1〜及（2<R<1000 ）之间的随机整数（每个 整数的概率均为1/R ）。现在你希望用它在#（ 2<#<1000 ）个事件中随机选择一个，使得事 件•的概率Pz等于给定的有理数az/bz （ 1^az<bf1000 ）。你的任务是设计一个RNG使用算法， 使得对RNG的调用次数的数学期望尽量小。可以多次使用这个RNG。

例如，当R=2，N=4，厂,厂：广尸，U时，则只需调用两次RNG，—共有4种可能的结 果，分别对应一个事件。

习题10-48 考试( Exam, ACM/ICPC Chengdu 2012, UVa1655)

设/⑻为满足ab|;v的（a,b）个数。输入n （ 1<n<10Z1 ），求f（ 1 ）+f（2）+…+f（n）。例如，/山1 （即（1，1），（1，2），（2，1），（1，3），（3，1），（1，6），（6，1），（2,3），（3,2）），因此n=6时输出25。

习题10-49 指数塔( Exponential Towers, ACM/ICPC NWERC 2013, UVa1656)

用“A”来表示指数运算，即aAb=ab，例如，256=2A2A3=4A2A2 （注意“A”是右结合的，即

2A2A3表示2^（2A3））。定义| \    - * -（卜这样的表达式为“高度为&的指数



八八，’八• • •、

塔”，其中女>1，且所有整数az〉1。输入一个高度为3的指数塔aAbAc （ 1<a,b,c<9585 ），统计有 多少个高度至少为3的指数塔的值等于aAbAc。注意，9585这个常数可以保证输出小于263。

习题10-50 排列( Permutation, UVa11303)

输入一个长度为m的序列，每个元素均为1〜n的正整数，并且不含相同元素。找出1 〜n的排列中有哪些排列包含输入子序列（不一定连续出现），求出字典序第刎、的。例如， 若输入子序列为1, 3, 2, n=4，则一共有4个排列：1,3,2,4 ; 1,3,4,2 ; 1,4,3,2 ; 4,1,3,2，它们的字 典序分别为第1， 2， 3， 4小。 1<n<250， 1<m<n。

习题10-51 游戏( Game, ACM/ICPC ACM/ICPC NEERC 2003, UVa1657)

有这样一^个游戏：裁判先公布一^个正整数打（2<n<200 ），然后在1〜n中选两个不同的整 数和y （ x<y ），把x+y告诉S先生，把x*y告诉P先生，然后依次循环S先生和P先生是否知道 这两个数是几（总是先问S先生）。例如：

裁判：n=10 （然后悄悄告诉S : ^+y=9, ;v*y=18 ）。

S先生：不知道^和y是多少。

P先生:不知道^和y是多少。

S先生:不知道^和y是多少。

P先生：不知道^和y是多少。

S先生：知道了。 x=3，y=6。

两人一共说了m次“不知道”后，下一个人算出了答案。已知S和P都非常聪明且精于心 算，你的任务是根据《和讲(0<m<100)计算出所有可能的(x，y)。

例如，n=10，m=4时有3个解:(2,5), (3,6), (3,10)。
