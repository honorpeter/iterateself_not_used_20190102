---
title: 20 数据库函数
toc: true
date: 2018-08-21 18:16:23
---
### 第20章

##### 20.1引言

20世纪80年代早期，UNIX系统被认为不适合运行多用户数据库系统（见Stonebraker［1981］ 和Weinberger［1982］）。早期的系统（如V7）,因为没有提供任何形式的IPC机制（除了半双工管 道），也没有提供任何形式的字节范围锁机制，所以确实不适合运行多用户数据库系统。但是， 这些碘陷中的大多数都已得到纠正。到20世纪了 80年代后期，UNIX系统已为运行可靠的、多 用户的数据库系统提供了一个适合的环境。自那时以束，很多商业公司都已提供这种数据库系统。

本章将开发一个简单的、多用户数据库的C函数库。调用此函数库提供的C语言函数，其他 程序可以获取和存储数锯库中的记录=（这类数据库通常被称为键-值存储。）这个C函数库只是 一个完整的数据库系统的一部分，我们并不开发其他部分（如査询语言等），关于其他部分可以 参阅专门介绍数据庳的教科书。我们感兴趣的是数据库函数库与UNIX的接口，以及这些接口与 前面各章节所涉及主题的关系（如14.3节的字节范围锁）。

##### 20-2历史

dbm（3）是一个在UNIX系统中很流行的数据库函数库，它由Ken Thompson开发，使用了动 态散列结构。最初，它与V7—起提供，并出现在所有BSD版本中，也包含在SVR4的BSD兼 容函数库中［AT&T 1990c］。BSD的开发者扩充了 dbm函数库，并将它称为ndbm。ndbm函数库 包括在BSD和SVR4中。ndbm函数是Single UNIX Specification的XSI扩展标准的一部分。

Seltzer和^糾［1991］中详细介绍了 dbm函数库使用的动态散列算法的历史，以及这个库的其 他实现方法，如dbm函数库的GNU版本gdbm。但是，这些实现的一个根本限制是它们都不支 持多个进程对数据库的并发更新。它们都没有提供并发控制（如记录锁机制）。

4.4BSD提供了一个新的库——db（3）,该库支持3种不同的访问模式：面向记录、散列和B 树。同样，db也没有提供并发授制（这一点在db（3）手册页的BUGS部分说得很清楚）。

j    Oracle （http://www.oracle.com）提供了几个版本的db函数库，它们支持并发访问、

j锁机制和事务。

大部分商用数据库函数库提供多进程同时更新数据库所需要的并发控制。这些系统一般都使 用14.3节中介绍的建议记录锁机制，但是，它们也常常实现自己的锁原语，以避免为获得一把无 竞争锁而需的系统调用开销。这些商用系统通常用B+树［Comer 1979］或某种动态散列技术，如线

性散列［Litwin 1980］或者可扩展的散列［Faginetal. 1979］来实现数据库。

图20-1列出了本书说明的4种操作系统常用的数据库函数库。注意在Linux上，gdbm库既

支持dbm函数库，又支持ndbm函数库。

| 函数库  | POSIX.l | FreeBSD 8.0 | Linux 3.2.0 | Mac OS X 10.6.8 | Solaris 10 |
| ------- | ------- | ----------- | ----------- | --------------- | ---------- |
| dbmndbm | XSI     |             | gdbmgdbm    |                 | •          |
| db      |         |             |             |                 |            |

图20-1多种平台支持的数据库函数库

###### 20.3函数库

本章开发的函数库类似于ndbm函数库，但增加了并发控制机制，从而允许多进程同时更新 同一数据库。本节将首先描述数据库函数库的C语言接口，下一节再讨论其实现。

当打开一个数据库时，通过返回值得到一个代表数据库的句柄（一个不透明指针）。将用此 ［7441句柄作为参数来调用其他数据库函数。

\#include "apue_db.h"

DBHANDLE db_open （const char * pathname, int oflag, ... /* int mode */）;

返回值：若成功，返回数据库句柄；若失败，返回NULL

void db close（DBHANDLE 側；

如果 db_open 成功返回，则将建立两个文件：patfmame.idx 和 pathname.dat，pathname.idx 是索引文件，pathname.daf是数据文件。参数作为传递给open （见3.3节）的第二个参数， 来指定这些文件的打开模式（只读、读/写或如果文件不存在则创建等）。如果需要建立新的数据 库，mo也将作为第三个参数传递给open （文件访问权限）。

当不再使用数据库时，调用disclose来关闭数据库。db_cloSe将关闭索引文件和数据文 件，并释放数据库使用过程中分配到的所有用于内部缓冲区的存储空间。

当向数据库中存入一条新的记录时，必须提供一个此记录的键，以及与此键相关联的数据。如 果此数据库存储的是人事信息，键可以是员工ID,数据可以是此员工的姓名、地址、电话号码以及 受聘日期等，实现要求每条记录的键必须是唯一的（例如，不会有两个员工记录有同样的员工ID）。

♦include "apue_db.hn

int db_store （DBHANDLE db, const char *key, const char ’data, int flag};

返回值：若成功，返回0;若出错•返回非0值（见下）

和^是由null字符终止的字符串。它们可以包含除了 null字符外的任何字符，如换行符。 /Zag参数只能是DBJCNSERT （插入一条新记录）、DB_REPLACE （替换一条已有的记录）或

DB_STORE （插入一条新记录或替換一条已有的记录，只要合适无论哪一种都可以）。这3个常数 定义在apue_db.h头文件中。如果使用DB_INSERT或DB_STORE，并且记录并不存在，则插 入一条新记录》如果使用DB_REPLACE或DB_STORE，并且该记录已经存在，则用新记录替换己 有记录。如果使用DB_REPLACE,而记录不存在，则将errno设置为ENOENT，返回值为-1，并 且不加入新记录。如果使用DB_INSERT,而记录已经存在，则不插入新记录，返回值为1。在这

里，返回1以区别于一般的出错返回（一 1）。

通过指定键蜘可以从数据库中获取一条记录。 ttinclude "apue_db.h"

char *db_fetch （DBHANDLE db, const char *key）；

返回值：若成功，返回指向数据的指针；若没有找到记录，返回NULL 如果找到了记录，返回指向通过吻存放的数据的指针。通过指定咏，也可以在数据库中删 除一条记录。

\#include "apue_db.h"

int db_delete （DBHANDLE db, const char *key） i

返回值：若成功，返回0:若没有找到记录，返回H

除了通过指定获取记录外，还可以逐条记录地访问数据库。为此，首先调用db_rewind 回滚到数据库的第一条记录，然后在每一次循环中调用db_nextrec，顺序地读每条记录。

\#include ’’apue_db.h"

void db_rewind（DBHANDLE db];

char *db_nextrec {DBHANDLE db, char *key）；

返回值，若成功，返回指向数据的指针：若到达数据库文件的尾端，返回NULL 如果是非空指针，db_nextreC将这个指针复制到存储区域开始的内存位置，然后返回 这个指针。

db_nextrec不保证其返回记录的顺序，只保证对数据库中的每一条记录只读取一次，如果 顺序存储3条键计别为A、B、C的记录，则无法确定db_nextrec将按什么顺序返回这3条记 录。它可能按B、A、C的顺序返回，也可能按其他顺序，实际的顺序由数据库的实现决定。

这7个函数提供了数据库函数库的接口。接下来介绍实现。

###### 20.4实现概述

访问数据库的函数库通常使用两个文件来存储信息：一个索引文件和一个数据文件=索引文 件包括实际的索引值（键）和一个指向数据文件中对应数据记录的指针。有许多技术可用来组织 索引文件以提髙按键査询的速度和效率，散列表和B+树是两种常用的技术。我们采用固定大小 的散列表来组织索引文件结构，并采用链表法解决散列冲突。在介绍db_Open时，曾提到将创 建两个文件：一个以.idx为后缀的索引文件和一个以.dat为后缀的数据文件。

我们将键和索引以null结尾的字符串形式存储，它们不能包含任意的二进制数据。有些数据库系统 用二《制形式存储数值数据（如用1个、2个或4个字节存储一个整数）以节省存储空间，这样一来使 函数复杂化，也使数据库文件在不同的平台间移植比较困难。例如，网络上有两个系统使用不同的二进 制格式存储整数，如果想要这两个系统都能够访问数据库，就必领解决不同存储格式的问题（今天不同 体系结构的系统在网络上共享文件己经很常见了）。按照字符串形式存储所有的记录，包括键和数据，能 使这一切变得简单。这确实需要使用更多的磁盘空间，但降低了获得可移植性需要付出的代价=    [746]

db_store要求对于每个键，只有一条对应的记录。有些数据库系统允许多条记录使用同样 的键，并提供方法访问与一个键相关的所有记录。另外，我们只有一个索引文件，这意味着每个

数据记录只能有一个键（我们不支持次键）。有些数据库允许一条记录拥有多个键，并且对每一 个键使用一个索引文件。当插入或删除一条记录时，要对所有的索引文件进行相应的修改。（一 个拥有多个索引的例子是员工库文件。可以将员工ID作为键，也可以将员工的社会保险号作为 键，由于员工的名字并不保证唯一，所以名字不能作为键。）

图20-2是数据库实现的基本结构。

r    触记录长度    I

图20-2索引文件和数据文件结构

索引文件由3部分组成：空闲链表指针、散列表和索引记录。图20-2中，所有指针字段中实 [7471际存储的是ASCII码数字形式的文件偏移量，

当给定一个键，要在数据库中寻我一条记录时，db_fetCh根据该键计算散列值，由此散列 值可确定一条散列链（链表指针字段可以为0,表示一条空的散列链）。沿着这条散列链，可以找 到所有具有这一散列值的索引记录。当遇到一个索引记录的键表指针字段为0时，表示到达了此 散列链的末尾。

下面来看一个实际的数据库文件。图20-3所示的程序建立了一个新的数据库，并且写入了 3 条记录。由于所有的字段都以ASCII字符的形式存储在数据库中，所以可以用任何标准的UNIX 系统工具来查看索引文件和数据文件：

$ 1» -1 db4.*

-rw-r—r~ 1 sar    28 Oct 19 21:33 db4 .dat

-rw-r--r-- 1 sar    72 Oct 19 21:33 db4.idx

$ cat db4.idx

0 53    35    0

0 lOAlpha:0:6 0 10beta:6:14

17 llgamma:20:8

3 oat db4.dat

da tai

Data for beta record3

为了使这个例子紧凑，将每个指针字段的大小设置为4个ASCII字符，将散列链的数量设置为3 条。由于每一个指针中记录的是一个文件偏移量，所以4个ASCII字符限制了一个索引文件或数 据文件的大小最多只能为10000字节。当在20.9节做性能测试时，将指针字段的大小设为6个字 符（这样文件大小可以达到1000000字节），将散列链数量设为100。

♦include "apue.h"

番include "apue_db.h"

finclude <fcntl.h> int

main(void)

{

DBHANDLE    db;

if ((db = db_open("db4", O_RDWR I O_CREAT | O_TRONC( FILE_MODE)J == NULL)

err_sys ("db_open error’’)；

if (db_store(db, "Alpha", "datai", DB_INSERT) != 0) err_quit ('*db_store error for alpha");

if (db_store{dh, "beta", "Data for beta", DB_INSERT) != 0) err_quit("db_store error for beta");

if (db_store{db, "gamma", *'record3H( DB一INSERT) != 0) err_quit("db_store error for gamma");

db_close(db); exit(0);

图20>3建立一个数据库并写入3条记录

索引文件的第一行为：

0 53 35    0

分别为空闲链表指针（0表示空闲链表为空）和3个散列链的指针：53、35和0。下一行：

0 lOfllpha:0:6

显示了一条索引记录的结构，第一个4字符字段（0）为链表指针，表示这一条记录是此散列链的 最后一条。下一个4字符字段（10）为idxlen （索引记录长度），表示此索引记录剩余部分的长度。 用两个read操作来读取一条索引记录：第一个read读取这两个固定长度的字段（链表指针和索 引记录长度），然后再根据索引记录长度来读取后面的不定长部分。剰下的3个字段为：键、数据记 录的偏移量和数据记录的长度。这3个字段用分隔符隔开，此处使用的分隔符是冒号。由于这3 个字段都是不定长的，所以需要一个专门的分隔符，而且这个分隔符不能出现在键中。最后用一个

\n （换行符）结束这一条索引记录。由于在索引记录长度字段中已经有了记录的长度，所以这个 換行符并不是必需的，加上换行符是为了把各条索引记录好开，这样就可以用标准的Ul^IX系统工 具（如cat和more）来查看索引文件。键字段是将记录写入数据库时指定的值。数据记录在数据 文件中的偏移量为0,长度为6。从数据文件中可看到数据记录确实从0开始，长度为6个字节。（与 索引文件一样，这里自动在每条数据记录的后面追加一个换行符，以便于使用UNIX系统工具。在 调用db_fetch时，此换行符不作为数据返回。）

如果在这个例子中跟踪3条散列链，可以看到第一条散列链上第一条记录的偏移量是53 （gamma）。这条链上下一条记录的偏移量为n （alpha）,并且是这条链上的最后一条记录。 第二条散列链上的第一条记录的偏移量是35 （beta）,且是此链上最后一条记录。第三条散列 链为空。

请注意，索引文件中键的顺序和数据文件中对应数据记录的顺序与图20-3程序中调用db_ store的顺序一样。由于在调用db_open时使用了 O_TRUNC标志，索引文件和数据文件都被截 断了，整个数据库相当于重新初始化。在这种情况下，db_StOre将新的索引记录和数据记录追 加到对应的文件末尾。后面将看到，db_stOre还可以重复使用这两个文件中已删除记录原来对 应的空间。

使用固定大小的散列表作为索引是一个妥协。当每个散列链都不太长时，这个方法能保证快 7481速地访问。我们的目的是能够快速地査找任一键，同时又不使用太复杂的数据结构（如B树或动 749态散列表），动态散列表的优点是能保证仅用两次磁盘存取就能找到数据记录（详见Litwin[1980] 或Fagin等P979]）。B树能够用（已排序的）键的顺序来遍历数据库（采用散列表的db_nextrec 函数就做不到这一点）。

20.5集中式或^集中式

当有多个进程访问同一数据库时，有两种方法可实现库函数。

（1）    集中式。由一个进程作为数据库管理者，所有的数据库访问工作由此进程完成。其他进 程通过IPC机制与此中心进程进行联系。

（2）    非集中式。每个库函数使用要求的并发控制（加锁），然后发起自己的I/O函数调用。

使用这两种技术的数据库系统都有。如果有适当的加锁例程，因为避免了使用IPC,那么非

[750]集中式方法一般要快一些。图20-4描绘了集中式方法的操作。

图中特意表示出IPC像绝大多数UNIX系统的消息传递一样需要经过操作系统内核（15.9节

中说明的共享存储不需要这种经过内核的复制），在集中方式下，中心控制进程将记录读出，然 后通过IPC机制将数据传递给请求进程＜■这是这种设计的不足之处。注意，集中式数据库管理进 程是唯一对数据库文件进行I/O操作的进程。

集中式的优点是能够根据需要来对操作模式进行调整。例如，可以通过中心进程给不同的进 程赋予不同的优先级，这会影响到中心进程对I/O操作的调度。而用非集中式方法则很难做到这 一点。在这种情况下，只能依赖于操作系统内核的磁盘I/O调度策略和加锁策略（例如，当3个 进程同时等待一个即将可用的锁时，我们无法确定哪个进程将得到这个锁）。

集中式方法的另一个优点是，恢复要比非集中式方法容易。在集中式方法中，所有状态信息 都集中存放在一处，所以如若杀死了数据库进程，只需在该处査看以炽别出需要解决的未完成事 务，然后将数据库恢复到一致状态。

用户进程    用户进程    用户进程

图2M集中式数据库访问



图20-5描绘了非集中式方法，本章的实现就是采用这种方法。

用户进程    用户进程



图20-5非集中式数据库访问    间

调用数据库库函腳I行I/O的用户进程是合作进程，它们使用字节狼围记录锁机制来实现并餓制，



##### 20.6并发

由于很多系统的实现都采用两个文件（一个索引文件和一个数裾文件）的方法，所以在此也 使用这种方法，这要求能够控制对两个文件的加锁。有很多方法可用牵对两个文件进行加锁。

\1.    粗粒度锁

最简单的加锁方法是将这两个文件中的一个作为整个数据库的锁.并要求调用者在对数据库 进行操作前必须获得这个锁。这种加锁方式称为粗粒度锁（coarse-grained locking）。例如，可以 认为一个进程对索引文件的0字节加了读锁后，才能读整个数据库：一个进程对索引文件的0字 节加了写锁后，就能写整个数据库。可以使用UNIX系统的字节范围锁机制来控制每次可以有多 个读进程，而只能有一个写进程（见图14"3）。db_fetch相db_nextrec函数要求具有读锁， 而db_delete、db_store和db_open则要求具有写锁。（db_open要求写锁的原因是如果要 创建新文件的话，要在索引文件前端建立空闲区链表以及散列链表。）

粗粒度锁的问题是它限制了并发。用粗粒度锁时，当一个进程向一条散列链中添加一条记录 时，其他进程无法访问另一条散列链上的记录。

\2.    细粒度锁

细粒度锁（fine-grainedlocking）的方法改进了粗粒度锁，提供了更髙的并发性。一个读进程 或写进程在操作一条记录前必须先获得此记录所在散列链的读锁或写锁。一条散列链允许同时有 多个读进程，但只能有一个写进程。其次，一个写进程在访问空闲区链表（如db_delete或 db_stOre）前，必须获得空闲区链表的写锁。最后，当db_store向索引文件或数据文件末尾 追加一条新记录时，必须获得对应文件相应区域的写锁。

期望细粒度锁能比粗粒度锁能提供更高的并发性，20.9节将给出一些实际的比较测试结 果。20.8节给出了细粒度锁实现的源代码，并讨论锁的实现细节（粗粒度锁是这个细粒度锁实 现的简化）

在源代码中，直接调用丁 read、readv、write和writev。没有使用标准I/O函数库。 [7521虽然使用标准I/O函数库也可以使用字节范围锁，但是需要非常复杂的缓冲管理。例如，标准I/O

缓冲区的数据在5分钟之前被另一个进程修改了，那么我们就不希望fgets返回的数据是10分 钟之前读入标准I/O缓冲区的数据。

以上对并发的讨论依据的是对数据库函数库的简单需求。商业系统一般有更多的需要。关于 并发更多的细节可以参见Data[2004]的第16章。

20.7构造函数库

数据库的函数库由两个文件构成，一个公用的C头文件以及一个C源文件=我们可以用下列 命令构造一个静态函数库。

gcc -I../include -Wall -c db.c ar rsv libapue_db.a db.o

因为我们在数据库函数库中使用，了一些我们自己的公共函数，所以希望与libapue_db.a相连接 的应用程序也需要与libapue.a相连接。

另一方面，如果想构建数据库函数库的动态共享库版本，可使用下列命令：

gcc -I../include -Wall -fPIC -c db.c

gcc -shared -W1,-soname,libapue_db.so.1 -o libapue_db.so.1 \

-L../lib -lapue -lc db.o

构建成的共享库libapue_db. so. 1需放置在动态连接程序/载入程序(dynamic linker/loader)能 够找到的一个公用目录中。还可以将共享库放置在一个私有目录中，修改LD_LIBRARY_PATH环境 变量，使动态连接程序/载入程序的搜索路径包含该私有目录。

在不同平台间，构建共享库的步廉会有所不同。这里说明的步棟是在带GNU C编译器的Linux i系统中进行的。

###### 20.8源代码

本节解释我们编写的数据库函数库源代码，先从头文件apUe_db.h开始。函数库源代码以 及调用此函数库的所有应用程序都包含这一头文件。

从此处开始，实例程序的编排方式在很多方面与前面的实例程序编排有所不同。首先，因为 源代码较长，为此加了行号，这使得通过行号联系相应的源代码进行讨论更加方便。其次，对源 代码的说明紧随相关源代码之后。

!    这种风格受到John Lions解释UNIX V6操作系统源代码的书［Lions 1977, 1996］的影响，这使

［得解释说明大量源代码更为简易。

注意，此处对空白行不编号。虽然某些工具(如pr(l))的正常操作与这些空白行是有关的，

但是我们对它们并无任何兴趣。    ［753］

| 1    | lifndef                  | _APUE_DB_H                                           |                   |
| ---- | ------------------------ | ---------------------------------------------------- | ----------------- |
| 2    | #define                  | _APUE_DB_H                                           |                   |
| 3    | typedef                  | void * DBHANDLE;                                     |                   |
| 4    | DBHANDLE                 | db_open(const char *, int, ...);                     |                   |
| 5    | void                     | db_close (DBHANDLE)，-                               |                   |
| 6    | char                     | *db_fetch(DBHANDLE, const char *);                   |                   |
| 7    | int                      | db_atore(DBHANDLE, const char *, const char *, int); |                   |
| 8    | int                      | db_delete(DBHANDLE, const char *};                   |                   |
| 9    | void                     | db_rewind{DBHANDLE);                                 |                   |
| 10   | char                     | *db_nextrec(DBHANDLE, char *);                       |                   |
| 11   | /*                       |                                                      |                   |
| 12   | * Flags                  | for db_store ().                                     |                   |
| 13   | */                       |                                                      |                   |
| 14   | 眷define                 | DB_INSERT    1    Z* insert new record               | only */           |
| 15   | #define                  | DB_REPLACE    2    /* replace existing record */     |                   |
| 16   | #define                  | DB_STORE    3    /* replace or insert                | */                |
| 17   | /*                       | i                                                    |                   |
| 18   | * Implementation limits. |                                                      |                   |
| 19   | */                       |                                                      |                   |
| 20   | #define                  | IDXLEN_MIN    6    " key, sep, start,                | sep, length, \n ‘ |
| 21   | #define                  | IDXLEN_MAX 1024    /* arbitrary */                   |                   |

| 22   | #define  | DATLEN_MIN    2 | /* data byte, newline */ |
| ---- | -------- | --------------- | ------------------------ |
| 23   | #define  | DATLEN_MAX 1024 | /* arbitrary */          |
| 24   | #endif ' | APUE DB H */    |                          |

[1—3] 使用符以保证只包括该头文件一次。DBHANDLE类型表示对数据库的 一个有效引用，用于隔离应用程序和数据库的实现细节。将此技术与标准I/O库向应 用程序提供FILE结构相比较，两者相似。

[4^10] 接着，声明了数据库函数库公有函数的原型。因为使用函数库的应用程序包括了此头 文件，所以这里不再声明函数库私有函数的原型。

[11-24]定义了可以传送给db_Store函数的合法标志。其后是实现的基本限制。如果希望 支持更大的数据库，可以更改这些限制。

最小索引记录长度由IDXLEN_MIN指定。这表示1字节键、1字节分隔符、1字节起 始偏移量，另一个1字节分隔符、1字节长度和终止换行符。（回忆图20-2中索引记

[7541    录的格式一条索引记录通常长于IDXLEN_MIN字节，这只是最小长度。

下一个文件是db.c,它是库函数的C源文件。为简化起见，将所有函数都放在一个文件中。

这样处理的优点是只要将私有函数声明为static,就可对外将它隐蔽起来。

| 1    | #include                                                 | "apue.h"                                                  |
| ---- | -------------------------------------------------------- | --------------------------------------------------------- |
| 2    | #include                                                 | "apue_db.h"                                               |
| 3    | #include                                                 | <fcntl.h>    /* open & db_open flags */                   |
| 4    | ^include                                                 | <stdarg.h>                                                |
| 5    | #include                                                 | <errno.h>                                                 |
| 6    | ♦include                                                 | <sys/uio.h> /* struct iovec */                            |
| 78   | /** Internal index file constants.                       |                                                           |
| 9    | * These                                                  | are used to construct records in the                      |
| 10   | ★ index                                                  | file and data file.                                       |
| 11   | */                                                       |                                                           |
| 12   | #define                                                  | IDXLEN_SZ    4    /* index record length (ASCII chars) */ |
| 13   | tdefine                                                  | SEP    1 : '    /* separator char in index record */      |
| 14   | #define                                                  | SPACE    ' '    /* space character */                     |
| 15   | #define                                                  | NEWLINE    '\n'    /* newline character */                |
| 16   | /*                                                       |                                                           |
| 17   | * The following definitions are for hash chains and free |                                                           |
| 18   | * list                                                   | chain in the index file.                                  |
| 19   | */                                                       |                                                           |
| 20   | #define                                                  | PTR_SZ    7    /* size of ptr field in hash chain */      |
| 21   | #define                                                  | PTR_MAX 999999    /* max file offset = 10**PTR_SZ - 1 */  |
| 22   | #define                                                  | NHASH_DEF    137    /* default hash table size */         |
| 23   | #define                                                  | FREE_OFF    0    /* free list offset in index file */     |
| 24   | #define                                                  | HASH_OFF PTR_SZ    /* hash table offset in index file */  |
| 25   | typedef                                                  | unsigned long DBHASH; /* hash values */                   |
| 26   | typedef                                                  | unsigned long COUNT;    Z* unsigned counter */            |

[1-6]    使用了一些私有函数库中的函数，所以程序中包括了 apue.h。当然，apue.h也包

括若干标准头文件，包括因为db_open函数使用由 <stdarg.h>S义的可变参数函数，所以程序中也包括了<stdarg.h>。

[7-26]索引记录的长度说明为IDXLEN_SZ。我们用某些字符（如冒号、换行符）作为数据 库中的分隔符。当删除一记录时，在其中全部填入空格符。

其中一些定义为常量的值也可定义为变量，只是会使实现复杂一些，例如，设定散列 表的大小为137记录项，也许更好的方法是让db.open的调用者根据预期的数据库 _大小通过参数来设定这个值，然后将该值存在索引文件的最前面。_画

| 2728   | /*★Library's private representation of the database. |                                                 |
| ------ | ---------------------------------------------------- | ----------------------------------------------- |
| 293031 | */typedef struct {int    idxfd;    /*                | fd for index file */                            |
| 32     | int    datfd;    /*                                  | fd for data file */                             |
| 33     | char *idxbuf;    /*                                  | malloc'ed buffer for index record */            |
| 34     | char *datbuf;    /*                                  | malloc'ed buffer for data record*/              |
| 35     | char *name;    /*                                    | name db was opened under */                     |
| 36     | off_t idxoff;    /*                                  | offset in index file of index record */         |
| 37     | /*                                                   | key is at (idxoff + PTR_SZ + IDXLEN_SZ} */      |
| 38     | size_t idxlen;    /*                                 | length of index record */                       |
| 39     | /*                                                   | excludes IDXLEN_SZ bytes at front of record */  |
| 40     | /*                                                   | includes newline at end of index record */      |
| 41     | off_t datoff;    /*                                  | offset in data file of data record */           |
| 42     | size_t datlen;    /*                                 | length of data record */                        |
| 43     | /*                                                   | includes newline at end */                      |
| 44     | off_t ptrval;    /*                                  | contents of chain ptr in index record */        |
| 45     | of f_t ptroff;    /*                                 | chain ptr offset pointing to this idx record */ |
| 46     | off_t chainoff;    /*                                | offset of hash chain for this index record */   |
| 47     | off_t hashoff;    /*                                 | offset in index file of hash table */           |
| 48     | DBHASH nhash;    /*                                  | current hash table size */                      |
| 49     | COUNT cnt.delok;                                     | /* delete OK "                                  |
| 50     | COUNT cnt_delerr;                                    | /* delete error */                              |
| 51     | COUNT cnt_fetchok;                                   | /* fetch OK */                                  |
| 52     | COUNT cnt_fetcherr;                                  | /* fetch error */                               |
| 53     | COUNT cnt_nextrec;                                   | /* nextrec */                                   |
| 54     | COUNT cnt_storl;                                     | /* store: DB_INSERT, no empty, appended */      |
| 55     | COUNT cnt_stor2;                                     | /* store: DB_INSERT, found empty, reused */     |
| 56     | COUNT cnt_stor3;                                     | /* store: DB_REPLACE, diff len, appended */     |
| 57     | COUNT cnt_3tor4;                                     | /* store: DB_REPLACE, same len, overwrote */    |
| 58     | COUNT cnt_storerr;                                   | /* store error */                               |
| 59     | } DB;                                                |                                                 |

[27-48] 在DB结构中记录一个打开数据库的所有信息。db_open函数返回DB结构的指针 DBHANDLE值。这个指针被用于其他所有函数，而该结构本身则不面向调用者，

因为在数据库中以ASCII形式存放指针和长度，所以将这些转换为数字值，并存放 在DB结构中。也存放散列表长度，虽然一般而言，这是定长的，但也有可能为加强 该函数库，允许调用者在创建数据库时指定该长度（见习题20.7）。

[49-59]    DB结构的最后10个字段对成功和不成功的操作进行计数。如果想要分析数据库的性能，

则可编写一个函数返回这些统计值。但目前我们仅保持这些计数器，并未编写此种函数。[756]

60 /*

61    ^Internal functions.

62    */

63



static DB



*_db_alloc(int);



| 64   | static void                                            | _db_dodelete (DB ”；                          |
| ---- | ------------------------------------------------------ | --------------------------------------------- |
| 65   | static int                                             | _db_find_and_lock£DB *, const char *, int);   |
| 66   | static int                                             | _db_findfree{DB *, int, int);                 |
| 67   | static void                                            | _db_free{DB *);                               |
| 68   | Static DBHASH                                          | _db_hash{DB *, const char *);                 |
| 69   | static char                                            | *_db_readdat(DB *);                           |
| 70   | static off_t                                           | _db_readidx(DB *, off_t);                     |
| 71   | static off_t                                           | _db_readptr<DB *, off_t);                     |
| 72   | static void                                            | _db_writedat(DB *, const char *, off_t, int), |
| 73   | static void                                            | _db_writeidx(DB *, const char *,    int,      |
| 74   | static void                                            | _db_writeptr(DB *,    off_t);                 |
| 75   | /*                                                     |                                               |
| 76   | *Open or create a database. Same arguments as open(2). |                                               |
| 77   | */                                                     |                                               |
| 78   | DBHANDLE                                               |                                               |
| 79   | db_open(const                                          | char *pathname, int oflag, ...}               |
| 80   |                                                        |                                               |
| 81   | DB                                                     | *db;                                          |
| 82   | int                                                    | len, mode;                                    |
| 83   | size_t                                                 | i；                                           |
| 84   | char                                                   | asciiptr[PTR_SZ + 1],                         |
| 85   |                                                        | hash[(NHASH_DEF + 1) * PTR_SZ + 2];           |
| 86   |                                                        | /* +2 for newline and null */                 |
| 87   | struct stat                                            | statbuff;                                     |
| 88   | /*                                                     |                                               |
| 89   | * Allocate                                             | a DB structure, and the buffers it needs.     |
| 90   | */                                                     |                                               |
| 91   | len = strlen (pathname)，-                             |                                               |
| 92   | if t{db = _db_alloc(len)) == NULL)                     |                                               |
| 93   | err dump("db open: db alloc error for DB");            |                                               |

[60-74]选择用北_开头来命名用户可调用（公有）的所有函数，用_此_开头来命名内部（私 有）函数。公有函数在函数库头文件apue_db.h中声明。内部函数声明为static, 所以只有同一文件中的其他函数才能调用它们（该文件包含函数库实现）。

[75-93] db.open函数的参数与Open（2）相同。如果调用者想要创建数据库文件，那么用可选 择的第三个参数指定文件权限。db_open函数打开索引文件和数据文件，在必要时初 始化索引文件。该函数调用_db_alloc来为DB结构分配空间，并初始化此结构。

| 94   | db->nhash = NHASH_DEF； /* hash table size */                |
| ---- | ------------------------------------------------------------ |
| 95   | db->haahoff = HASH_OFF;    /* offset in index file of hash table *, |
| 96   | strcpy(db->name, pathname);                                  |
| 97   | strcat(db->name, ".idx")；                                   |
| 98   | if (oflag & O_CREAT) {                                       |
| 99   | va_list ap;                                                  |
| 100  | va„start(ap, oflag);                                         |
| 101  | mode = va_arg(ap, int);                                      |
| 102  | va_end(ap);                                                  |
| 103  | /*                                                           |
| 104  | * Open index file and data file.                             |

105    */

106

db->idxfd = open<db->name, oflag, mode); strcpy(db->name + len, ".dat"); db->datfd = open{db->name, oflag, mode);

(else {



107

108 109

117

118

119

120



if (db->idxfd < 0 1| db->datfd < 0) { _db_free(db); return(NULL);

i




[94〜97]    继续初始化DB结构。调用者传入的路径名指定数据库文件名的前缀。追加后

缀.idx以构成数据库索引文件的名字-

[98-108]    如果调用者想要创建数据库文件，那么使中的可变参数®数以找

到可选的第三个参数。然后，使用open创建并打开索引文件和数据文件。注意，

数据文件的文件名以索引文件同样的前缀开始，但后缀为.dat。

[109-116]    如果调用者没有指定O_CREAT标志，那么正在打开已有的数据库文件。此时，只

用两个参数调用open。

[117〜120】    如果在打开或创建任一数据库文件时出错，则调用_db_free清除DB结构，然后

127    if (writew_lock(db->idxfd, 0, SEEK_SET, 0) < 0)

128    err_dump("db_open: writew_lock error");

129    if (fstat(db->idxfd, sstatbuff) < 0)

130    err_sys("db^open: fstat error");

131

132

133

134

135

136

137



if (statbuff.st_size == 0)    {

Z*

*    We have to build a list of (NHASH_DEF + 1) chain

\*    ptrs with a value of 0. The +1 is for the free

\*    list pointer that precedes the hash table.

*/

sprintf(asciiptr,    PTR SZ, 0);

[121-130]    如果正在建立数据库，则必须正确地加锁。考虑两个进程试图同时建立同一个数

据库的情况。第一个进程运行到调用fstat,并且在fstat返回后被内核阻塞。

这时第二个进程调用db_open,发现索引文件的长度为0,然后初始化空闲链表 和散列链表。第二个进程继续运行，向数据库中写入了一条记录。这时第二个进 程被阻塞，第一个进程在调用fstat后立刻继续运行，它发现索引文件的长度为 0（因为第一个进程调用fstat在前，然后第二个进程再初始化索引文件），所以 第一个进程重新初始化空闲链表和散列链表，第二个进程写入的记录就被抹去了。 避免发生这种情况的方法是进行加锁，为此可以使用14.3节中的readw_lock> writew_lock 和 un_lock 这 3 个宏。

[131〜137]    如果索引文件的长度是0,那么这是刚刚被创建的，所以需要初始化它所包含的

空闲列表指针和散列链指针。注意，使用格式字符串％*d将数据库指针从整型转 换为ASCII字符串。（在_db_writeidx和_db__writeptr中还将使用这种格式 字符串。）这一格式告诉sprintf取PTR_SZ参数，用它作为下一个参数的最小 字段宽度，在此例中，它是0 （此处，因为正在创建一数据库，所以将指针初始 化为0）。其作用是强迫创建的字符串至少包含PTR_SZ个字符（在左边用空格充 填）。和_db_writeptr中，将传送一十非0指针值，但是首 先将验证指针值不大于PTR_MAX,以保证写入数据库的指针字符串恰好为

[759]    PTR_SZ⑺个字符。

138

139

140

141

142

143

144

145

146

147

148

149

150

151



hash[0] = 0;

for (i = 0; i < NHASH_DEF + 1; i++) strcat(hash, asciiptr);

strcat(hash, M\n"); i = strlen(hash);

if (write(db->idxfd, hash, i) != i)

err_dump("db_open: index file init write error");

}

if (un_lock(db->idxfd, 0, SEEK_SET, 0) < 0) err_dump{"db_open: un_lock error")；

}

db_rewind(db)；

return(db);

166    * Allocate room for the name.

167    * +5 for ”.idx" or ".dat" plus null at end.

168    */

169    if ((db->name = malloc(namelen + 5)) == NOLL)

170    err dump<"db alloc: roalloc error for name");

[138〜151]    继续初始化新创建的数据库。构造散列表，将它写到索引文件中。然后，解锁索

引文件，重置数据库文件指针，返回DB结构指针作为句柄，以便调用者以后用于 其他数裾库函数。

[152-164]    db_open调用函数_此_3110(:为DB结构分配空间，包括一个索引缓冲区和一个

数据缓冲区。用calloc分配存储区来存放DB结构，并将该存储区各存储单元. 全部初始化为0。这产生了一个副作用，也就是将数据库文件描述符也设置为0,

为此需将它们重新设置为_1,表示它们至此还不是有效的。

[165〜170]    分配空间以存放数据库索引文件和数据文件的名字。如db.open中所说明的那

样，更改它们的名字后缀以便引用索引文件或数据文件、    [760]

171

172

173

174

175

176

177

178

179

180    }



Allocate an index buffer and a data buffer. +2 for newline and null at end.

if ({db->idxbuf = malloc(IDXLEN_MAX + 2)> == NULL)

err_dump ("_db_alloc: malloc error for index buffer");

if ({db->datbuf = malloc{DATLEN_MAX +2)} == NULL)

err_dump ("_db_alloc： malloc error for data buffer")；

return(db);

181 /*

182    * Relinquish access to the database.

189

190

191

192

193

194

195

196

197

198

199



\*    Free up a DB structure, and all the malloc'ed buffers it

\*    may point to. Also close the file descriptors if still open.

static void

_db_free(DB *db)

if (db->idxfd >= 0)

close(db->idxfd);

if (db->datfd >= 0)

close(db->datfd);

[171-180]    为索引文件和数据文件的缓冲区分配空间。索引缓冲区和数据缓冲区的大小在

apue_db.h中定义。可以通过让这些缓冲区按需要动态扩张来增强数据库函数 库。其方法可以是记录这两个缓冲区的大小，然后在需要更大的缓冲区时调用 realloco最后，返回指向己分配到的DB结构的指针》

[181〜188]    db.close函数只是一个包装，它将数据库句柄强制类型转换为DB结构的指针，

将它传送给_db_free函数，由该函数释放资源以及DB结构。

[189〜199]    db_open在打开索引文件和数据文件时如果发生错误，会调用_db_free函数释

放资源。应用程序在结束对数据库的使用后，disclose也会调ffl_db_free。如 果数据库索引文件的文件描述符有效，那么关闭该文件。对数据文件描述符也进 行同样处理。（回忆在_曲_£1110＜：中分配一个新的DB结构时，将每个文件描述符 都初始化为_1。如果不能打开两个数据库文件中的一个，相应文件描述符仍为_1,

闽    也就是无需关闭它。〉

| 200  | if (db->idxbuf    NULL)                                     |
| ---- | ----------------------------------------------------------- |
| 201  | free(db->idxbuf);                                           |
| 202  | if (db->datbuf != NULL}                                     |
| 203  | free(db->datbuf,;                                           |
| 204  | if (db->name != NULL)                                       |
| 205  | free(db->name)；                                            |
| 206  | free(dto);                                                  |
| 207  | »                                                           |
| 208  | Z*                                                          |
| 209  | * Fetch a record. Return a pointer to the null-terminated < |
| 210  | */                                                          |
| 211  | char *                                                      |
| 212  | db_fetch(DBHANDLE h, const char *key)                       |
| 213  |                                                             |
| 214  | DB    *db = h;                                              |
| 215  | char    *ptr;                                               |
| 216  | if (_db_find_and_lock (db, key, 0) < 0) {                   |
| 217  | ptr = NULL;    /* error, record not found */                |
| 218  | db->cnt_fetcherr++;                                         |
| 219  | } else {                                                    |
| 220  | ptr = _db_readdat (db);    /* return pointer to data */     |
| 221  | db->cnt_fetchok++;                                          |
| 222  | J                                                           |
| 223  | Z*                                                          |
| 224  | * Unlock the hash chain that _db_find_and_lock locked.      |
| 225  | */                                                          |
| 226  | if (un_lock(db->idxfd, db->chainoff, SEEK_SET, 1) < 0)      |
| 227  | err_dump("db_fetch: un_lock error")；                       |
| 228  | return (ptr);                                               |
| 229  | J                                                           |

[200-207] 接着，释放动态分配的缓冲区。可以安全地将一个空指针传递给free函数，这 样也就无需事先检查每个缓冲区指针的值，但是我们认为只释放已分配的対象是 一种较好的编程风格。（并非所有释放程序都像free那样容忍差错。）最后，释 放DB结构占用的存储区。

[208〜218]    函数db_fetch根据给定的键来读取一条记录。它调用_db_f ind_and_lock在

数据库中査找记录。若不能找到该记录，则将返回值（ptr）设置为NULL，将不 成功的记录搜索计数器值加1。因为从_db_find_and_lock返回时，数据库索

引文件是加锁的，所以先要解锁，然后再返回。

[219〜229]    如果找到了记录，调用_db_readdat读相应的数据记录，并将成功记录搜索计数

239    *    Calculate the    hash value    for    this    key,    then calculate    the

240    *    byte offset of corresponding    chain ptr    in hash table.

241    *    This is where    our search    starts.    First    we calculate the

242    *    offset in the    hash table    for    this    key.

250    if (writelock) {

251    if {writew_lock(db->idxfd, db->chainoff, SEEK_SET, 1) < 0)

252    err_dump("_db_find_and_lock: writew_lock error");

253    } else {

254    if (readw_lock(db->idxfd, db->chainoff, SEEK_SET, 1) < 0)

255    err_dump("_db_find_and_lock: readw_lock error");

261    offset = db readptr(db, db->ptroff);

[230-237] _db_find_and_lock函数在函数库内部用于按给定的键査找记录。在搜索记录 时，如果想在索引文件上加一把写锁，则将writelock参数设置为非0值。如 果将writelock参数设置为0,则在搜索记录时，在索引文件上加读锁。

[238—256] it_db_find_and_lock中准备遍历散列链-将键转换为散列值，用其计算在文 件中相应散列链的起始地址(chainoff)o在遍历散列链前，等待获得锁。注意，

只锁该散列链开始处的第1个字节。这种方式允许多个进程同时捜索不同的散列 链，因此增加了并发性。

[257-261]    调用_db_readptr读散列链中的第一个指针a如果该函数返回0,则该散列链为空。[?63]

262    while (offset != 0) {

263    nextoffset = _db_readidx(db, offset);

264

265

266

267

268

269

270

271

272

273



if (strcmp(db->idxbuf, key) == 0) break;    /* found a match */

db->ptroff = offset； /* offset of this (unequal) record ★/ offset = nextoffset; /* next one to compare */

\* offset == 0 on error (record not found)

return(offset == 0 ? -1 : 0>;

274    /*

275    * Calculate the hash value for a key.

276    */

277    static DBHASH

| 278  | _db_hash(DB | *db,  | const char | *key)       |
| ---- | ----------- | ----- | ---------- | ----------- |
| 279  |             |       |            |             |
| 280  | DBHASH      | hval  | =o；       |             |
| 281  | char        | c;    |            |             |
| 282  | int         | i;    |            |             |
| 283  | for (i =    | 1; (c | =*key++)   | != 0； i++) |



284    hval += c * i;    /* ascii char times its 1-based index */

285    return(hval % db->nhash);

286    }



[262-268]    while循环遍历散列链中的每一条索引记录，并比较键。调用函

读取每条索引记录。它将当前记录的键填入DB结构中的idxbuf字段。如果 _db_readidx返回0，则已到达散列链的最后一记录项。

[269-273]    如果在循环后，offset为0,说明已达到散列链末端而且没有找到匹配键，于是

返回一1。否则，找到了匹記记录（用break语句退出了循环），所以返回0表示成 功。此时，ptroff字段包含前一索引记录的地址，datoff包含数据记录的地址， datlen是数据记录的长度。当沿着散列链进行遍历时，必须始终保存当前索引记 录的前一条索引记录，其中有一个指针指向当前索引记录。这样做在删除一条记录 时很有用，因为必须修改当前索引记录的前一条记录的链指针以删除当前记录。

[274-286]    _db_hash根据给定的键计算散列值。它将键中的每一个ASCII字符乘以这个字

符在字符串中以1开始的索引号，将这些结果加起来，除以散列表记录项数，将 余数作为这个键的散列值。回忆散列表记录项数是137,它是一个素数，按

间    Knuth[1998],素数散列通常能提供良好的分布特性。

295    char    aaciiptr[PTR_SZ + 1];

296    if (lseek(db->idxfd, offset, SEEK_SET) == -1)

297    err_dump{"_db_readptr: lseek error to ptr field");

298    if (read(db->idxfd, asciiptr, PTR_SZ) != PTR_SZ)

299    err_dump{"_db_readptr: read error of ptr field");

300    asciiptr[PTR_SZ] = 0;    /[1](#bookmark19) [2](#bookmark20) null terminate [2](#bookmark20)/

301    return(atol(asciiptr))；

302    J

303    /[2](#bookmark20)

304    [2](#bookmark20)    Read the next index record. We start at the    specified offset

305    [2](#bookmark20)    in the index file. We read the index record    into db->idxbuf

306    [2](#bookmark20)    and replace the separators with null bytes.    If all is OK we

307    [2](#bookmark20)    set db->datoff and db->datlen to the offset    and length of the

308    [2](#bookmark20)    corresponding data record in the data file.

314    char    [2](#bookmark20)ptrl, [2](#bookmark20)ptr2;

315    char    asciiptr[PTR_SZ + 1], asciilen[XDXLEN_SZ + 1];

316    struct iovec iov[2];

[287〜302]    _db_readptr函数读取以下3种不同链表指针中的任意一种：(a)索引文件最开

始处指向空闲链表中第一个索引记录的指针，(b)散列表中指向散列链的第一条 索引记录的指针，(c)存放在每条索引记录开始处、指向下一条记录的指针(这 里的索引记录既可以处于一条散列链表中，也可以处于空闲链表中〉。返回前，将 指针从ASCII形式转换为长整型。此函数不进行任何加锁操作，所以其调用者应 事先做好必要的加锁。

[303〜316]    _dto_readidx函数用于从索引文件的指定偏移量处读取索引记录。如果成功，该

函数将返回链表中下一条记录的偏移量。该函数还填充DB结构的许多字段： idxoff包含索引文件中当前记录的偏移量，ptrval包含在散列链表中下一个索 引项的偏移量，idxlen包含当前索引记录的长度，idxbuf包含实际索引记录， datoff包含数据文件中该记录的偏移量，datlen包含该数据记录的长度。

328

329

330

331

332

333



334

335

336

337

338



if ((i = readv(db->idxfd, siovtO], 2)) != PTR_SZ + IDXLEN_SZ) { if (i == 0 && offset == 0)

return(-1);    Z* EOF for dh_nextrec */

err_dump{"_db_readidx: readv error of index record");

339    /*

340    * This is our return value; always >= 0.

341    */

342    asciiptr[PTR_SZ] = 0;    /* null terminate */

343    db->ptrval = toll (asciiptr); /* offset of next key in chain ★/

344    asciilen[IDXLEN_SZ] = 0;    /* null terminate */

345    if ((db->idxlen = atoi(asciilen)) < IDXLEN_MIN ||

346    db->idxlen > IDXLEN_MAX)

347    err dump("db readidx: invalid length");

[317-324]    按调用者提供的参数査找索引文件偏移量。在DB结构中记录该偏移量，为此即使

调用者想要在当前文件偏移量处读记录（设置offset为0）,仍需要调用lseek 以确定当前偏移量。因为在索引文件中，索引记录决不会存放在偏移量为0处， 所以可以放心地使用0表示“从当前偏移量处读

[325〜338]    调用readv读在索引记录开始处的两个定长字段：指向下一索引记录的链指针和

该索引记录余下部分的长度（余下部分是变长的）。

[339-347]    将下一记录的偏移量转换为整型，并存放到ptrval字段中（这将被用作此函数

的返回值），然后将索引记录的长度转换为整型，并存放到idxlen字段中。

371    if ({db->datoff = atol(ptrl)) < 0)

372    err_dump("_db_readidx: starting offset < 0");

373    if ((db->datlen = atol(ptr2)) <= 0 I I db->datlen > DATLEN_MAX)

374    err_dump {n_db_readidx: invalid length[3](#bookmark27));

375    return(db->ptrval);    /[4](#bookmark28) return offset of next key in chain [4](#bookmark28)/

376    }

[348-356]    将索引记录的变长部分读入DB结构中的idxbuf字段，该记录应以换行符结尾。

用null字符代替换行符。如果索引文件己遭破坏，那么调用err_dump函数终止 core文件。

[357-367]    将索引记录划分成3个字段：键、对应数据记录的偏移量和数据记录的长度。

strchr函数在给定字符串中找到第一个指定字符。这里，我们要寻找的是记录 中分隔字段的字符(SEP,此处定义为冒号)。

[368-376]    将数据记录偏移量和数据记录长度转换为整型，井将它们存放在DB结构中。然

后，返回在散列链中下一条记录的偏移量。注意，我们并不读数据记录，这由调[767] 用者自己完成。例如，在db_fetch中，S_db_find_and_lock按键找到索引 记录前是不读取数据记录的。

377

378

379

380

381

382

383

384

385

386

387

388

389

390

391

392



401

402

403

404

405

406

407 409



409    err_dump{"db_delete: un_lock error",;

410    return(rc);

411    }

[377-392] 在datoff和datlen己经被正确初始化后，_db_readdat函数将数据记录的 内容读入DB结构中的datbuf字段指向的缓冲区。

[393〜411]    db_delete函数用于删除与给定键匹配的一条记录。使用_db_f ind_and_lock

来判断在数据库中该记录是否存在。如果存在，则调用_db_dOdelete函数执行 删除该记录的操作。_db_find_and_lock的第三个参数控制对散列链是加读锁 还是写锁，此处，因为可能执行更改该链表的操作，所以要加一把写锁。 _db_find_and_lock返回时，这把锁仍旧存在，为此不管是否找到了所需的记

@    录，都需要解除这把锁=

| 412  | /*                                                         |
| ---- | ---------------------------------------------------------- |
| 413  | * Delete the current record specified by the DB structure. |
| 414  | * This function is called by db_delete and db_store, after |
| 415  | * the record has been located by _db_find_and_lock.        |
| 416  | */                                                         |
| 417  | static void                                                |
| 418  | _db_dodelete(DB *db)                                       |
| 419  | {                                                          |
| 420  | int    i;                                                  |
| 421  | char    *ptr;                                              |
| 422  | off„t    freeptr, saveptr;                                 |
| 423  | /*                                                         |
| 424  | * Set data buffer and key to all blanks.                   |
| 425  | */                                                         |
| 426  | for (ptr = db->datbuf, i = 0； i < db->datlen - 1; i++)    |
| 427  | *ptr++ = SPACE;                                            |
| 428  | *ptr = 0;    /* null terminate for _db_writedat */         |
| 429  | ptr = db~>idxbuf;                                          |
| 430  | while (*ptr)                                               |
| 431  | *ptr++ = SPACE;                                            |
| 4 32 | /*                                                         |
| 433  | * We have to lock the free list.                           |
| 434  | */                                                         |
| 435  | if (writew_lock(db->idxfd, FREE_0FF, SEEK_SET, 1) < 0)     |
| 436  | err_dump("_db_dode1ete: writew_lock error");               |
| 437  | /*                                                         |
| 438  | * Write the data record with all blanks.                   |
| 439  | */                                                         |
| 440  | db writedat(db, db->datbuf, db->datoff, SEEK SET);         |

[412-431] ^db_dodelete函数执行从数据库中删除一条记录的所有操作=(该函数也可以 由db_store调用。)此函数的大部分工作仅仅是更新空闲链表以及与键对应的散 列链。当一条记录被删除后，将其键和数据记录设为空。本章后面将提到的函数 db_nextrec要用到这一点。

[432-440] 调用writew.lock对空闲链表加写锁，这样能防止两个进程同时删除不同链表

上的记录时产生相互影响，因为要将被删除的记录添加到空闲链表中，这将改变 空闲链表指针，而一次只能有一个进程能这样做。

调用函数_db_writedat清空数据记录。这时_db_writedat并不对数据文件加 写锁，这是因为db_delete对这条记录的散列链已经加了写锁，这保证不会再 有其他进程能够读、写这条记录。

463    * Rewrite the chain ptr that pointed to this record being

464    *    deleted.    Recall that _db_find_and_lock    sets    db->ptroff to

465    *    point to    this chain ptr. We set    this chain    ptr to the

466    *    contents    of the deleted record's    chain    ptr,    saveptr.

467    */

468    _db_writeptr(db, db->ptroff, saveptr);

469    if (unblock (db->idxfd, FREE.OFF, SEEK.SET, 1) < 0)

470    err_dump ("_db_dodelete: un_lock error");

471    }

[441-461] 读空闲链表指针，接着修改索引记录。让这条记录的下一条记录指针指向空闲链 表的第一条记录(如果空闲链表为空，则这个新的链表指针置为0)。清除键之后 用正被删除索引记录的偏移量更新空闲链表指针，也就是使其指向当前删除的这 条记录。这意味着空闲链表的处理基于后进先出(虽然是以首次适应算法来删除 空闲链表项)，也就是说被删除的记录都被添加到空闲链表头部

没有为每个文件分别设置空闲链表。将一个删除的索引记录添加到空阐链表时，该 索引记录仍指向己删除的数据记录。当然还有更好的处理方法，但复杂性会增加。

[462-471]    修改散列链中前一条记录的指针，使其指向正删除记录之后的记录，这样就从散

列链中移除了要删除的记录。最后对空闲链表解锁。    [770]

472

473

474

475

476

477

478

479

480

481

482

483

484

485

486

487

488

489

490

491

492

493 4 94

495

496

497

498

499

500

501



\*    Write a data record. Called by _db_dodelete (to write

\*    the record with blanks) and db_store.

*/

static void

_db_writedat(DB *db, const char *data, off_t offset, int whence)

struct iovec    iov[2];

static char    newline = NEWLINE;

\*    If we're appending, we have to lock before doing the Iseek

\*    and write to make the two an atomic operation. If we' re

\*    overwriting an existing record, we don't have to lock.

*/

if {whence == SEEK_END) /* we■re appending, lock entire file */ if (writew_lock(db->datfd, 0, SEEK_SET, 0) < 0)

err_dump(°_db_writedat: writew_lock error");

if ({db->datoff = Iseek{db->datfd, offset, whence} } == -1) err^dump("_db_writedat： Iseek error")；

db->datlen = strlen(data) + 1; /* datlen includes newline */

iov[0].iov_base = (char *) data；

iov[0].iov_len = db->datlen - 1;

iov[1].iov_base = finewline;

iov[1].iov_len = 1;

if (writev(db->datfd, &iov[0], 2) != db->datlen)

err_dump{"_db_writedat： writev error of data record")；

if (whence == SEEK_END)

if (un_lock(db->datfd, 0, SEEK_SETZ 0) < 0)

err_dump("_db_writedat: un_lock error'*);

[472〜491]    调用函写一个数据记录。当删險一记录时，调用函数_db

_writedat清空数据记录：这时_db_writedat并不对数据文件加写锁，因为 db_delete对这条记录的散列链已经加了写锁，这保证不会再有其他进程能够 读、写这条记录。在本节稍后处说明db_store函数时，会遇到_db_writedat 函数追加写数据文件的情况，此时就必需对该文件加锁。

定位到要写数据记录的位置。要写的字节数是记录长度加1个字节，这1个字节 是表示记录终止的换行符。

[492-501] 设置iovec数组，调用writev写数据记录和换行符。不能想当然地认为调用者 缓冲医的尾端有空间可以追加换行符，所以应该将换行符写入另一个缓冲区，然 后再从该缓冲区写至数据记录。如果正在对文件追加一条记录，那么就释放早先 获得的锁。

502    /*

503    * Write an index record. _db_writedat is called before

504    * this function to set the datoff and datlen fields in the

505    * DB structure, which we need to write the index record.

513    int    len;

514    if ((db->ptrval = ptrval)    <    0    ||    ptrval    >    PTR_MAX)

515    err_quit (”_db_writeidx: invalid ptr: %d", ptrval};

516    sprintf (dt>->idxbuf, "%s%c%lld%c%ld\n", key, SEP,

517    (long long)db->datoff, SEP, (long)db->datlen);

518    len = strlen(db->idxbuf);

519    if (len < IDXLEN_MIN || len > IDXLEN_MAX)

520    err_dump("_db_writeidx: invalid length");

521    sprintf (asciiptrlen,    "%*lld%*d'1,    PTR_SZ, (long long)ptrval,

522    IDXLEN_SZ, len);

523    /*

524    * If wef re appending, we have to lock before doing the lseek

525    * and write to make the two an atomic operation. If wefre

526    * overwriting an existing record, we donf t have to lock.

527    */

528    if (whence == SEEK_END>    /* we're appending */

529    if (writew_lock(db->idxfd, ((db->nhash+l)*PTR_S2)+1,

530    SEEK_SET, 0) < 0)

531    err dump("db writeidx: writew lock error");

[502〜522]    调用_db_WriteidX函数写一条索引记录。在验证散列链中下一个指针有效后，

创建索引记录，并将它的后半部分存放到idxbuf中。需要索引记录这一部分的 长度以创建该记录的前半部分，而前半部分被存放到局部变量asciiptrlen中。 注意，使用强制类型转换使得sprintf语句的参数的长度与格式说明中相匹配， 这样做是因为off_t和Size_t数据类型的长度因平台不同而不同。32位系统也 能提供64位文件偏移量，所以不能假定off_t数据类型的长度。

[523-531]    一样，只有在追加新索引记录时这一函数才需要加锁。

_db_dodeiete调用此函数是为了重写一条已有的索引记录。在这种情况下，调 用者已经在散列链上加了写锁，所以不再需要加另外的锁。

| 532  | /*                |
| ---- | ----------------- |
| 533  | ★ Position the    |
| 534  | */                |
| 535  | if { (db->idxoff  |
| 536  | err_dump ("_c     |
| 537  | iov[0].iov_base   |
| 538  | iovtO].iov_len    |
| 539  | iov[l].iov_base   |
| 540  | iov[l].iov_len    |
| 541  | if (writev (db->: |
| 542  | err_dump ("_c     |



-1)



:asciiptrlen;

PTR_S2 + IDXLEN_SZ;

•- db->idxbuf; len;

ixfd, &iov[0] , 2) != _writeidx: writev er



PTR_SZ 十 IDXLEN_SZ + len) cor of index record");



543    if (whence == SEEK_END)

544    if (unblock(db->idxfd, ((db->nhash+l)*PTR_SZ)+1,

545    SEEK一SET, 0) < 0)

546    err_dump("_db_writeidx: un_lock error");

555    char asciiptr [PTR_SZ + 1];

556    if (ptrval < 0 I I ptrval > PTR_MAX)

557    err_quit{M_db_writeptr: invalid ptr: %d", ptrval);

558    sprintf(asciiptr,    PTR_SZ, {long long)ptrval);

559    if (lseek(db->idxfd, offset, SEEK_SET) == -1)

560    err_dump("_db_writeptr: lseek error to ptr field");

561    if (write(db->idxfd, asciiptr, PTR_SZ) != PTR_SZ)

562    err_dump("_db_writeptr: write error of ptr field");

563    }

[532〜547]    定位到开始写索引记录的位置，将该偏移量存入DB结构的idxoff字段。因为

在两个独立的缓冲区中构建索引记录，所以调用writev将它存放到索引文件中。 如果是追加写该文件，则释放在定位操作前获得的锁。从并发运行进程追加新记 录到数据库的角度思考问题，那么这把锁使定位操作和写操作成为原子操作。

[548-563]    _db_writeptr被用于将一散列链指针写至索引文件中。验证该指针在索引文件

的边界范围内，然后将它转换成Ascn字符串。按指定的偏移量在索引文件中定 位，然后将该指针Ascn字符串写入索引文件。

| 571  | DB       | *db = h;               |                |
| ---- | -------- | ---------------------- | -------------- |
| 572  | int      | rc, keylen, datlen;    |                |
| 573  | off_t    | ptrval;                |                |
| 574  | if (flag | != DB_INSERT && flag ! | =DB_REPLACE && |

579    keylen    = strlen(key);

580    datlen = strlen (data) + 1;    /* +1 for newline at end */

581    if (datlen < DATLEN_MIN || datlen > DATLEN_MAX)

582    err_dump("db_store: invalid data length");

583    "

584    *    _db_find_and_lock calculates which hash table this new record

585    *    goes into (db->chainoff), regardless of whether it already

586    *    exists or not. The following calls to _db_writeptr change the

587    *    hash table entry for this chain to point to the new record.

588    *    The new record is added to the front of the hash chain.

589    */

590    if (_db_find_and_lock(db, key, 1) < 0) { /* record not found */

591    if (flag == DB_REPLACE) {

592    rc = -1;

593    dto->cnt_storerr++;

594    errno = ENOENT;    /* error, record does not exist ♦/

595    goto doreturn;

596    }

[564〜582]    db_store函数的功能是将一条记录添加到数据库中。首先验证参数flag的值。

然后，检査数据记录长度是否有效。如果无效，则删除core文件并终止。作为一 个例子这样处理无可厚非，但如果构造正式应用的函数库，那么最好返回出错状 态而非终止，这样可以给应用程序一个恢复的机会。

[583〜596]    调用_db_find_and_lock以査看这个记录是否已经存在。如果记录并不存在且指定

的标志为DB_rNSERT或DB_STORE,或者记录存在且指定的标志为DB_REPLACE 或DB_STORE，那么这些都是允许的。替换一条已有的记录意味着键不变，而数 据记录很可能不同。注意，因为db_store很可能会改变散列链，所以调用 _db_f ind_and_lock的最后一个参数指明要对散列链加写锁。

[774]



621    _db_writedat(db,    data, db->datoff, SEEK_SET);

622    _db_writeidx(db,    key, db->idxoff, SEEK_SET,    ptrval);

623    _db_writeptr(db,    db->chainoff, db->idxoff)；

624    db->cnt_stor2++;

625    }

[597〜601]    在调用_db_find_and_lock后，代码分成4种情况。前两种情况中，没有找到

足够大的空闲记录，所以添加一条新纪录。读散列链上第一项的偏移量。

[602-614] 第1种情况：调用_db_findfree在空闲链表中捜索一条已删除的记录，它的键 长度和数据长度与参数keylen和datlen相同。如果没有找到对应大小的空闲 记录，这意味着要将这条新记录追加到索引文件和数据文件的末尾。调用 _writedat写数据部分，调用_db_writeidx写索引部分，调用_db_writeptr 将新记录添加到对成的散列链的头部。将执行此种情况的计数器(cnt^storl) 值加1，以便观察数据库的运行状况。

[615〜625]    第2种情况：_db_findfree找到对应大小的空记录，然后将这条空记录从

空闲链表中移除(稍后就会看的实现)，写入新的索引记录 和数据记录，然后，如同第1种情况一样，将新记录添加到对应的散列链的 头部。将执行此种情况的计数器(cnt_stor2)值加1，以便观察数据库的 运行状况。

| 626  | } else | {    /* record found */                              |
| ---- | ------ | ---------------------------------------------------- |
| 627  | if     | (flag == DB_INSERT) {                                |
| 628  |        | rc = 1;    Z* error, record already in db */         |
| 629  |        | db->cnt_storerr++;                                   |
| 630  |        | goto doreturn;                                       |
| 631  | }      |                                                      |
| 632  | /*     |                                                      |
| 633  | ★      | We are replacing an existing record. We know the new |
| 634  | *      | key equals the existing key, but we need to check if |
| 635  | ★      | the data records are the same size.                  |
| 636  | */     |                                                      |
| 637  | if     | (datlen != db->datlen) {                             |
| 638  |        | _db_dodelete(db); /* delete the existing record */   |
| 639  |        | /*                                                   |
| 640  |        | * Reread the chain ptr in the hash table             |
| 641  |        | * (it may change with the deletion).                 |
| 642  |        | */                                                   |
| 643  |        | ptrval = _db_readptr{db, db->chainoff);              |
| 644  |        | /*                                                   |
| 645  |        | * Append new index and data records to end of files. |
| 646  |        | */                                                   |
| 647  |        | _db_writedat{db, data, 0, SEEK_END);                 |
| 648  |        | _db_writeidx(db, key, 0, SEEK_END, ptrval);          |
| 649  |        | /*                                                   |
| 650  |        | * New record goes to the front of the hash chain.    |
| 651  |        | */                                                   |
| 652  |        | _db_writeptr(db, db->chainoff, db->idxoff);          |

653    db->cnt_stor3++;

654    } else {

[626〜631]    另两种情况是具有相同键的记录在数据库中已存在，如果不想替换该记录，则设

置表示一条记录已经存在的返回码，将存储出错计数的计数器cnt_StOrerr值 加1，然后跳转至函数末尾，在此处理公共返回逻辑，

[632〜654]    第3种情况：要替换一条已有记录，而新数据记录的长度与已有记录的长度不一

样。调用_db_dodelete删除已有记录，将该删除记录放在空闲链表头部，然后，

调用_db_writedat 和_db_writeidx将新记录追加到索引文件和数据文件的 末尾（也可以用其他方法，如可以再找一找是否有数据大小正好的已删除的记录 项）。最后调用_d^lWriteptr将新记录添加到对应的散列链的头部。DB结构中 的cnt_stor3计数器记录发生此种情况的次数。    闹

655

656

657

658

659

660 661 662

663

664

665

666

667

668

669

670

671

672

673

674

675

676



\* Same size data, just replace data record.

*/

_db_writedat(db, data, db->datoff, SEEK_SET)； db->cnt_stor4++;

}

}

rc = 0;    /* OK */

doreturn:    /* unlock hash chain locked by _db_find_and_lock *Z

if (un_lock{db->idx£d, db->chainoff, SEEK_SET, 1) < 0)

err_dump{"db_store: un_lock error"); return(rc);

J

/*

\*    Try to find a free index record and accompanying data record

\*    of the correct sizes. We're only called by db_store.

*/

static int

_db_findfree{DB *db, int keylen, int datlen)

{

685    saveoffset    = FREE_OFF;

686    offset    = db readptr(db,    saveoffset);

[655-661]    第4种情况：替换一条己有记录，而新数据记录的长度与己有记录的长度恰好一

样=这是最容易的情况，只需要重写数据记录即可，并将这种情况的计数器（cnt_

stor4)值加 1。

[662〜667]    在正常情况下，设置表示成功的返回码，然后进入公共返回逻辑。对散列链解锁

(这把锁是由调用_db_find_and_lock而加上的)，然后返回调用者。

[668-686] dbfindfree函数试图找到一个指定大小的空闲索引记录和相关联的数据记录。

需要对空闲链表加写锁以避免与其他使用空闲链表的进程互相影响。在对空闲链

固    表加写锁后，得到空闲链表的头指针地址。

687    while (offset != 0) {

688    nextoffset = _db_readidx(db, offset);

689    if (strlen(db->idxbuf) == keylen && db->datlen == datlen)

690    break;    /* found a match */

691    saveoffset = offset;

692    offset = nextoffset;

[687〜693]    _db__f indf ree中的while循环遍历空闲链表以搜寻一个能够匹配键长度和数、

[1](#footnote1)

317    /[2](#bookmark20)

318    [2](#bookmark20) Position index file and record the offset. db_nextrec

319    [2](#bookmark20) calls us with offset==0, meaning read from current offset.

320    [2](#bookmark20) We still need to call lseek to record the current offset.

321    [2](#bookmark20)/

322    if ((db->idxoff = lseek(db->idxfd, offset,

323    offset == 0 ? SEEK_COR : SEEK_SET)) == -1)

324    err_dump{"_db_readidx: lseek error")；

325    /[2](#bookmark20)

326    [2](#bookmark20) Read the ascii chain ptr and the ascii length at

327    [2](#bookmark20) the front of the index record. This tells us the

[2](#footnote2)

remaining size of the index record. V

iov[0]-iov_base = asciiptr;

iov[0].iov_len = PTR_SZ;

iov[l],iov_base = asciilen;

iov[l].iov_len = IDXLEN_SZ;

348    Z*

349    * Now read the actual index record. We read it into the key

350    * buffer that we malloced when we opened the database.

351    */

352    if {(i = read(db->idxfd, db->idxbuf, db->idxlen)) != db->idxlen)

353    err_dump{*'_db_readidx: read error of index record");

354    if (db->idxbuf[db->idxlen-l] != NEWLINE) /* sanity check */

355    err_dump{"_db_readidx: missing newline");

356    db->idxbuf[db->idxlen-l] = 0;    /* replace newline with null */

357    /*

358    * Find the separators in the index record.

359    */

360    if ((ptrl = strchr{db->idxbuf( SEP)} == NOLL)

361    err_dump (■’_db_readidx: missing first separator");

362    *ptrl++ = 0;    /* replace SEP with null */

363    if ((ptr2 = strchr(ptrl, SEP)) == NULL)

364    err_dump("_db_readidx： missing second separator");

365    *ptr2++ = 0;    /* replace SEP with null */

366    if {strchr(ptr2( SEP) != NULL)

367    err_dump ("_db_readidx: too many separators");

368    /*

369    * Get the starting offset and length of the data record.

370    */

\*    Read the current data record into the data buffer.

[3](#footnote3)

*/

static char [4](#bookmark28)

_db_readdat{DB [4](#bookmark28)db)

if <lseek(db->datfd, db->datoff, SEEK_SET) == -1) err_dump("_db_readdat: lseek error");

if (read(db->datfd, db->datbufz db->datlen) != db->datlen) err_dump([4](#bookmark28)'_db_readdat: read error");

if (db->datbuf[db->datlen-lj != NEWLINE) /[4](#bookmark28) sanity check [4](#bookmark28)/ err_dump("_db_readdat: missing newline");

db->datbuf[db->datlen-l] = 0; /[4](#bookmark28) replace newline with null [4](#bookmark28)/ return(db->datbuf};    /[4](#bookmark28) return pointer to data record [4](#bookmark28)/

393    /[4](#bookmark28)

394    [4](#bookmark28) Delete the specified record.

395    [4](#bookmark28)/

396    int

397    db_delete(DBHANDLE h, const char [4](#bookmark28)key)

398    {

399    DB    [4](#bookmark28)db = h;

400    int    rc = 0;    /[4](#bookmark28) assume record will be found [4](#bookmark28)/

if (_db_find_and_lock(db, key, 1) == 0) {

_db_dodelete(db); db->cnt_de1o k++;

} else {

rc = -1;    /[4](#bookmark28) not found [4](#bookmark28)/

db->cnt_delerr++;

if (un_lock(db->idxfd, db->chainoff, SEEK_SET, 1) < 0)

[4](#footnote4)

   Return a pointer to the null-terminated data buffer.


   据长度的索引记录项-在这个简单的实现中，只有当一个已删除记录的键长度及 数据长度与要插入的新记录的键长度及数据长度一样时才重用己删除记录的空 间。还有其他更好的算法，但复杂度会增加。

[694-712]    如果找不到所要求键长度和数据长度的可用记录，则设置表示失败的返回码。否

贝IJ,将已找到记录的下一个链指针写至前一记录的链表指针。这样就从空闲链表 中移除了该记录。

740    * Return the next sequential record.

741    * We just step our way through the index file, ignoring deleted

742    * records. db_rewind must be called before this function is

743    * called the first time.

750    char    *ptr;

[720-738] db_rewind函数用于把数据库重置到“起始状态”，将索引文件的文件偏移量设置 为指向第一条索引记录(装跟在散列表之后)、(回忆图20-2中索引文件的结构。)

[739〜750]    db.nextrec函数返回数据库的下一条记录。返回值是指向数据缓冲区的指针。如

果调用者提供的key参数非空，将相应的键复制到该缓冲区中。调用者负责分配可 以存放键的足够大的缓冲区。大小为IDXLEN_MAX字节的缓冲区足够存放任意键。

记录按数据库文件中存放的顺序逐一返回。也就是说，记录并不按键值大小排序。

755    if (readw_lock(db->idxfd, FREE_OFF, SEEK_SET, 1) < 0)

756    err_dump("db_nextrec: readw_lock error");

765

766

767

768

769

770

771



\* Check if key is all blank (empty record).

*/

ptr = db->idxbuf;

while { {c = *ptr++) != 0    && c == SPACE)

;    /* skip until null byte or nonblank */

} while {c == 0); /* loop until a nonblank key is found */

772    if (key != NULL)

773    strcpy(key, db->idxbuf};    /* return key */

774    ptr = _db_readdat (db); /* return pointer to data buffer */

775    db->cnt_nextrec++;

776    doreturn:

777    if (unblock(db->idxfdx FREE_OFF, SEEK_SET, 1) < 0)

778    err_durnp("db_nextrec: un_lock error")；

779    return(ptr);

780    }

[751-756]    対空闲链表加读锁，使得正在读该链表时，其他进程不能从中移除记录。

[757-771]    调用_db_readi(ix读下一个记录。传送给该函数的偏移量参数值为0,以此通知

该函数从当前偏移量继续读索引记录。因为正在逐条顺序读索引文件，所以会读

到已删除的记录。仅需返回有效记录，所以跳过键是全空格的记录(回忆

_db_dodelete函数以设置全空格方式清除键)。

[772〜780]    当找到一有效键时，如果调用者已提供缓冲区，则将该键复制到该缓冲区。然后

[780]    读数据记录，并将返回值设置为指向包含数据记录的内部缓冲区的指针值。将统

计计数器值加1,对空闲链表解锁，最后返回指向数据记录的指针。

通常在下列形式的循环中使用db_rewind和db_nextrec这两个函数：

db_rewind(db);

while ((ptr = db_nextrec(db, key)) != NULL) {

/* process record */

I

前面曾警告过，记录的返回没有一定的顺序，它们并不按键的顺序返回。

如果db_nextrec函数在循环中被调用时数据库正在被修改，则db_nextrec返回的记录只

是变化中的数据库在某一时间点的快照(snapshot)。db_nextrec被调用时总是返回一条“正确” 的记录，也就是说它不会返回一条已删除的记录，但有可能一条记录刚被db_nextreC返回后就被 删除。类似地，如果db_nextreC刚跳过一条己删除的记录，这条记录的空间就被一条新记录重用， 除非用db_rewind重新遍历一遍，否则在结果中看不到这条新的记录。如果通过db_nextrec获 得一份数据库的准确的“冻结”的快照很重要，则在这段时间内应该不做插入和删除操作。

下面来看db_nextrec使用的加锁。因为并不使用任何散列链表，也不能判断每条记录属于 哪条散列链。所以有可能当db_nextreC读取一条记录时，其索引记录正在被删除。为了防止这 种情况，db_nextrec对空闲链表加读锁，这样就可避免indfree 相互影响。

在结束对db.c源文件的说明之前，对向文件末尾追加索引记录或数据记录时的加锁再做 一些说明。在第1种和第3种情况中，db_store调用_db_writeidx时， 第3个参数为0,第4个参数为SEEK_END。这里，第4个参数作为一个标志用来告诉这两个 函数，新的记录将被追加到文件的末尾。_dh_writeidx用到的技术是对索引文件加写锁，加 锁的范围从散列链的末尾到文件的末尾，这不会影响其他数据库的读进程和写进程（这些进程 将对散列链加锁），但如果其他进程此时调用db_store来追加数据则会被锁住。 _db_writedat使用的方法是对整个数据文件加写锁。同样这也不会影响其他数据库的读进程 和写进程（它们甚至不对数据文件加锁），但如果其他用户此时调用db„store来向数据文件 追加数据则会被锁住（见习题20.3）。

##### 20.9性能

为了测试这一数据库函数库，也为了获得一些与典型应用的数据访问模式有关的时间测量数 据，编写了一个测试程序。该程序接受两个命令行参数：要创建的子进程的个数和每个子进程向 数据库写的数据记录的条数（„reC）。然后（通过调用db_open）创建一个空的数据库，通过fork 创建指定数目的子进程，等待所有子进程结束，每个子进程执行以下步骤。    [781]

（1）    向数据库写nrec条记录。

（2）    通过键值读回nrec条记录。

（3）    执行下面的循环nrecX5次。

（a）    随机读一条记录。

（b）    每循环37次，随机删除一条记录。

（c）    每循环11次，随机插入一条记录并读取这条记录。

（d）    每循环17次，随机替换一条记录为新记录。在连续两次替换中，一次用同样大小的记 录替换，一次用比以前更长的记录替换。

（4）    将此子进程写的所有记录删除。每删除一条记录，随机地査找10条记录，

DB结构的cnt_Xxx变量记录对数据库进行的操作数，这些变量的值在函数中增加。每个子 进程的操作数一般都会与其他子进程不一样，因为每个子进程用来选择记录的随机数生成器是根 据其进程ID来初始化的。每个子进程操作的典型计数值见图20-6。

读取的次数大约是存储和删除的10倍，这可能是许多数据库应用程序的典型情况。

每一个子进程只对该子进程所写的记录执行这些操作（读取、存储和删除），由于所有的子 进程对同一个数据库进行操作（虽然对不同的记录），所以会使用并发控制-数据库中的记录总 数与子进程数成比例。（当只有一个子进程时，一开始有nw条记录写入数据库；当有两个子进 程时，一开始有条记录写入数据库，依此类推《＞）

通过运行测试程序的3个不同版本来比较加粗粒度锁和加细粒度锁提供的并发，并且比较3 种不同的加锁方式（不加锁、建议性锁和强制性锁）。第一个版本使用20.8节中的源代码，称为网 细粒度锁版本。第二个版本通过改变加锁调用而使用粗粒度锁，20.6节对此已介绍过。第三个版

本将所有加锁例程均去掉，这样可以计算出加锁的开销。通过改变数据库文件的权限标志位，还 可以使第一个版本和第二个版本（加细粒度锁和加粗粒度锁）使用建议性锁或强制性锁（本节所 有的测试中，仅对加细粒度锁的实现测量了采用强制性锁的时间）。

| 操作                                    | 调用fcntl （每个操作） | 操作计数(.nrvc^OOO) |        |
| --------------------------------------- | ---------------------- | ------------------- | ------ |
| 粗粒度锁                                | 细粒度锁               |                     |        |
| db_store、DB_INSERT，无空白记录，追加   | 2                      | 8                   | 2 920  |
| db_store、DB_INSERT,重用空白记录        | 2                      | 4                   | 468    |
| db.store, DB_REPLACE,数据长度不同，追加 | 2                      | 8                   | 405    |
| db_store、DB_REPLACE,数据长度相同       | 2                      | 2                   | 416    |
| db_store.没有找到记录                   | 2                      | 2                   | 71     |
| db_fetch,找到记录                       | 2                      | 2                   | 32 873 |
| db_fetch.没有找到记录                   | 2                      | 2                   | 2966   |
| db_delete.找到记录                      | 2                      | 4                   | 3 388  |
| db delete,没有找到记录                  | 2                      | 2                   | 422    |

图204每个子进程操作的典型计数值

本节所有的测试都是在一台运行Linux 3.2.0的Intel Core-i5系统上运行的。这个系统拥有4 个内核，因此可以允许至多4个进程并发运行。

1.单进程的结果

图20-7显示了只有一个子进程运行的结果，分别为2000、6000和12000。

| nrec     | 不加锁   | 建议性锁 | 强制性锁 |      |       |       |      |       |       |      |       |       |
| -------- | -------- | -------- | -------- | ---- | ----- | ----- | ---- | ----- | ----- | ---- | ----- | ----- |
| 粗粒度锁 | 细粒度锁 | 细粒度锁 |          |      |       |       |      |       |       |      |       |       |
| 用户     | 系统     | 时钟     | 用户     | 系统 | 时钟  | 用户  | 系统 | 时钟  | 用户  | 系统 | 时钟  |       |
| 2 000    | 0.10     | 0.22     | 0.33     | 0.17 | 0.33  | 0.51  | 0.13 | 0.38  | 0.51  | 0.14 | 0.43  | 0.58  |
| 6000     | 0.59     | 1.32     | 1.91     | 0.88 | 2.13  | 3.03  | 0.90 | 2.14  | 3.05  | 0.99 | 2.52  | 3+53  |
| 12 000   | 4.37     | 9.58     | 13.97    | 5,38 | 12.60 | 18.01 | 5.34 | 12.63 | 18.01 | 5.53 | 15.03 | 20.60 |

图20-7单子进程、不同的nrec和不同的加锁方法

最后12列显示的是以秒为单位的时间。在所有的情况下，用户CPU时间加上系统CPU时间 都基本上等于时钟时间。这一组测试受CPU限制而不是受磁盘操作限制。

中间6列（建议性锁）对加粗粒度锁和加细粒度锁的结果基本一样。这是可以理解的，因为 对于单个进程来说加粗粒度锁和加细粒度锁并没有区别，除了额外的fcntl调用，

比较不加锁和加建议性锁，可以看到加锁调用在系统CPU时间上增加了 32%〜73%。即使这 些锁实际上并没有使用过（因为只有一个进程运行），fcntl系统调用仍会有一些时间的开销。 用户CPU时间对4种不同的加锁方法基本上一样，这是因为用户代码基本上是一样的（除了调用 fcntl的次数有些不同）。

关于图20~7要注意的最后一点是强制性锁比建议性锁増加了 13%〜19%的系统CPU时间。由于对 岡加强制性细粒度锁和加建议性细粒度锁的调用次数是一样的，所以增加的系统开销来自读和写。

最后的测试是有多个子进程的不加锁的程序。与预期的一样，结果是随机的错误。一般错误 情况包括：添加到数据库中的记录找不到、测试程序异常退出等。几乎每次运行测试程序，都有 不同的错误发生。这是典型的竟争条件一多个进程在没有任何加锁的情况下修改同一个文件， 错误情况不可预测。

2.多进程的结果

下一组测试主要目的是比较粗粒度锁和细粒度锁的不同。前面说过，由于加细粒度锁时数据 库的各个部分被锁住的时间比加粗粒度锁少，所以从直觉上说，加细粒度锁应该能提供更好的并 发性。图20。8显示了取2000,子进程数从1〜16的测试结果。

| 进程数   | 建议性锁 | 强制性锁 |          |       |        |        |      |       |        |        |      |
| -------- | -------- | -------- | -------- | ----- | ------ | ------ | ---- | ----- | ------ | ------ | ---- |
| 粗粒度锁 | 细粒度锁 | A时钟    | 细粒度锁 | A系统 |        |        |      |       |        |        |      |
| 用户     | 系统     | 时钟     | 用户     | 系统  | 时钟   | 百分比 | 用户 | 系统  | 吋钟   | 百分比 |      |
| 1        | 0.14     | 0.35     | 0.50     | 0.14  | 0.35   | 0.50   | 0    | 0.15  | 0.42   | 0.58   | 20   |
| 2        | 0.60     | 1.43     | 1.88     | 0.54  | 1.36   | 1.10   | 71   | 0.65  | 2.01   | 1.59   | 48   |
| 3        | 0.97     | 2.67     | 3.18     | 1.37  | 3.73   | 220    | 45   | 1.62  | 5.67   | 3.28   | 52   |
| 4        | 2.38     | 6.17     | 5.59     | 2.83  | 8.15   | 4.07   | 37   | 3..29 | 12.35  | 6.31   | 52   |
| 5        | 3.72     | 10.17    | 8.37     | 4^8   | 11+86  | 6.09   | 37   | 4.96  | 18.47  | 9.49   | 56   |
| 6        | 5,02     | 14.52    | 11.52    | 6.04  | 17.46  | 8.89   | 30   | 6.66  | 26.38  | 13.22  | 51   |
| 7        | 7.00     | 20.16    | 15.84    | 8.06  | 2323   | 11.88  | 33   | 9.12  | 36.13  | 18.09  | 56   |
| 8        | 9.12     | 26.20    | 20.31    | 10.50 | 30.50  | 15.48  | 31   | 11.81 | 47.20  | 23.49  | 55   |
| 9        | 11.60    | 33.91    | 25.64    | 13.40 | 37.80  | 19.29  | 33   | 14.54 | 6023   | 29.66  | 59   |
| 10       | 14.28    | 42.24    | 31.35    | 16.39 | 47.01  | 23.74  | 32   | 17.84 | 74.05  | 36.27  | 58   |
| 11       | 17.37    | 51.12    | 37.50    | 19.71 | 56.59  | 28.57  | 31   | 21.57 | 90.14  | 44.10  | 59   |
| 12       | 20.70    | 60.48    | 44.24    | 23.47 | 66.10  | 33.34  | 33   | 25.57 | 108.94 | 53.11  | 65   |
| 13       | 25.13    | 70.67    | 51.96    | 27.70 | 77.76  | 39.21  | 33   | 29.71 | 133.31 | 63.07  | 71   |
| 14       | 28.40    | 82.23    | 59.88    | 32.34 | 91.45  | 46.22  | 30   | 34+22 | 155.80 | 73.86  | 70   |
| 15       | 32.23    | 94.26    | 68.30    | 36.32 | 102.97 | 51.82  | 32   | 39.05 | 180.66 | 84.14  | 75   |
| 16       | 37.24    | 107.87   | 78.67    | 42.17 | 118*20 | 59.72  | 32   | 44.11 | 208J8  | 96.82  | 76   |

图20-8 ww=2000时不同加锁方法的比较

所有的用户时间、系统时间和时钟时间的筚位均为秒，所有这些时间均是父进程与所有子进 程的总和，关于这些数据有许多需要考虑。

首先要注意的是，当使用多进程时，用户时间和系统时间之和超过了时钟时间。乍看起来这 有点奇怪，不过当采用多核时是正常的。此时，所有并发的进程在运行时其时间会累积起来；所 显示的CPU处理时间是程序运行的所有核运转的时间之和。因为可以并发多个进程（每个核运行 —个班程），所以CPU处理时间会超过时钟时间。

第8列（标记为“ A时钟”），是加建议性粗粒度锁与加建议性细粒度锁的运行时钟时间的百分比 差。从中可以看到使用细粒度锁得到了多大的井发性。在运行测试的系统上，对于单一进程加粗粒度[784] 锁与加細粒度锁相比效果几乎相同。而对于多进程，使用粗粒度锁的时间消耗会増大（约30%）。

我们希望从粗粒度锁到细粒度锁时钟时间会减少，当启用多进程后结果也确实如此。然而，

我们预期当对任意数量的进程使用细粒度锁时系统时间仍然会保持较高值，因为使用细粒度锁会 发出更多的fcntl调用。如果将图204中的fcntl调用次数加在一起，会发现对于粗粒度锁其 平均值为87858,对于细粒度锁其平均值为115520。基于此，我们认为由于增加了 31%的fcntl 调用，所以会增加细粒度锁的系统时间。然而，在测试中加细粒度锁的两个进程其系统时间减少 了，超过两个进程的系统时间只有小幅增加，这让人困惑。

出现这种情况有两个原因。首先，图20-7显示，当没有对锁进行竞争时，粗粒度锁和细粒度 锁的时间之间没有显著的差别。这说明对于额外的fcntl调用所引起的CPU负载并没有影响测 试程序的性能。其次，使用粗粒度锁时，持有锁的时间较长，这也就増加了其他进程因等待该锁 而陷入阻塞的可能性；而使用细粒度锁时，加锁的时间较短，进程被阻塞的可能性就降低了。如

果计算fcntl的阻塞次数，会发现在使用粗粒度锁时，进程阻塞频率更髙。例如，当有4个进 程时，使用粗粒度锁的阻塞次数几乎是使用细粒度锁的阻塞次数的5倍。正是这些粗粒度锁需要 休眠和唤醒进程的额外时间増加了系统时间，最终降低了两种锁的系统时间差异。

最后一列(标记为“△系统”)，是从加建议性细粒度锁到加强制性细粒度锁的系统CPU 时间百分比的増量。从这些值可以看到，随着并发数的增加，强制性锁显著增加了系统时间 (20%-76%)o

由于所有痒些测试的用户代码几乎一样(对加建议性细粒度锁和强制性细粒度锁增加了一些 fcntl调用)，因此预期对每一行的用户CPU时间应基本一样。

当我们第一次运行这些測试时，測试显示对于多进程完成镯的使用，其粗粒度锁的用户时间 几乎是细粒度锁的两倍。因为两个数据库版本是相同的，除了调用fcntl的次數不同，因此这说 不通。在调查研究之后，我们发现使用粗粒度销时会有更多的竞争，进程也就合等待更久，操作 系统于是就决定降低CPU时钟頻率来节约电量。在使用细粒度锁时，会有更多的活动，于是系统 提高了 CPU时钟頻率。这使得使用粗粒度锁比使用细粒度锁运行得慢。在禁用系统频率调整特性 后，我们的測试结果就没有这些偏差了，用户时间的差别也就小多了。

[785] 图20-8的第一行与图20-7中的wee取2000的那一行很相似。这与预期一致，

图20-9是图20-8中加建议性细粒度锁的数据图。我们绘制了进程数从1〜16的时钟时间，

也绘制了用户CPU时间除以进程数后的每进程用户CPU时间，另外还绘制了每进程系统CPU 时间。

注意，这两个每进程CPU时间都是线性的，但时钟时间是非线性的》可能的原因是：当进程 数增大时，操作系统用于进程切换的CPU时间增多。操作系统的开销会增加时钟时间，但不会影 响单个进程的CPU时间。

用户CPU时间随进程数增加的原因可能是因为数据库中有了更多的记录。每一条散列链更 长，所以_db_find_and_lock函数平均要运行更长时间来找到一条记录。

时钟时闾

(s)

毎进程系统CPU时间， 毎进程用户CPU时间 (s)

进程数

图20^9图20^8中使用建议性细粒度锁的数据

##### 20.10小结

本章详细介绍了一个数据库函数库的设计与实现。考虑到篇幅，这个函数库尽可能小和简单， 但也包括了多进程并发访问需要的对记录加锁的功能。

此外，还使用不同数量的进程以及不同的加锁方法：不加锁、建议性锁（细粒度锁和粗粒度 锁）和强制性锁，研究了这个函数库的性能。可以看到加建议性锁比不加锁在时钟时间上增加了 [786| 29%〜59%，加强制性锁比加建议性锁耗时再增加约15%。

习题

20.1中使用的加锁是比较保守的。例如，如果等到真正要用空闲链表时再加 锁，则可萩得更大的并发性。如果将调用writew_lock移到调和_他 _readptr之间会发生什么呢？

20.2如果db_neXtreC不对空闲链表加读锁而被读的记录正在被删除，描述在怎样的情况下， db.nextrec会返回正确的键但是空的（不正确的）数据记录。（提示：查看 _dodelete。）

20.3 20.8节的结尾部好描述了_db_writeidx的加锁。我们说过这种加锁 不会干涉除了调用db_store之外的其他的读进程和写进程。如果改为强制性锁，这还 成立吗？

20.4怎样把f sync集成到这个数据库函数库中？

20.5在db_Store中，先写数据记录，然后再写索引记录。如果将顺序颠倒，会发生什么？

20.6建立一个新的数据库并写入一些记录。写一个程序调用db_nextreC来读数据库中的每条

记录，并调用_db_haSh来计算每条记录的散列值。根据每条散列链上的记录数画出直方 图。_db_hash中的散列函数是否能满足需求？

20.7修改数据库函数，使得索引文件中散列链的数目可以在数据库建立时指定。

20.8比较两种情况下数据库函数的性能：（a）数据库与测试程序在同一台机器上：（b）数据库与 测试程序在不同的机器上，经由NFS进行访问。这个数据库函数库提供的记录锁机制还能 工作吗？

20.9只有当键缓冲区和数据缓冲区与其所需的大小精确匹配时，数据库才会返回空闲链表记录。

请修改数据库以使空闲链表可以使用于较大的缓冲区来满足需求。应该如何更改数据库的 永久格式来支持送种特性呢？

20.10在实现丁习题20.9的方案后，编写一个工具以使数据库格式可以从一种转换为另一种。[787]
