---
title: 12 线程控制
toc: true
date: 2018-06-26 19:06:08
---
### 第12章

#### _线程控制

##### 12.1引言

第11章讲了线程以及线程同步的基础知识。本章将讲解控制线程行为方面的详细内容，介 绍线程属性和同歩原语属性。前面的章节中使用的都它们的默认行为，没有进行详细介绍。

接下来还将介绍同一进程中的多个线程之间如何保持数据的私有性。最后讨论基于进程的系 统调用如何与线程进行交互。

###### 12.2线程限制

在2.5.4节中讨说了 sysconf函数。Single UNIX Specification定义了与线程操作有其的一些 限制，图2-11并没有列出这些限制。与其他的系统限制一样，这些限制也可以通过sysconf函 数进行查询。图12-1总结了这些限制。

| 限制名称                      | 描述                                                         | name参数                         |
| ----------------------------- | ------------------------------------------------------------ | -------------------------------- |
| PTHREAD_DESTRUCTOR_ITERATIONS | 线程退出时操作系统实现试图销毁线程特 定数据的最大次数（见12.6节） | _SC_THREAD_DESTRUCTOR_ITERATIONS |
| PTHREAD_KEYS_MAX              | 进程可以创建的键的最烦目（见12+6节）                         | SC THREAD KEYS MAX               |
| PTHREAD_STACK_MIN             | 一个线程的浅可用的最小字节数（见12_3节）                     | SC THREAD STACK MIN              |
| PTHREAD THREADSJ4AX           | 进程可以创建的最大线程数（见12.3节）                         | SG THREAD THREADS MAX            |

图12-1线程限制和sysconf的name参数

与sysconf报告的其他限制一样，这些限制的使用是为了增强应用程序在不同的操作系统 实现之间的可移植性。例如，如果应用程序需要为它管理的每个文件创建4个线程，但是系统却 并不允许创建所有这些线程，这时可能就必须限制当前可并发管理的文件数。

图12-2给出了本书描述的4种操作系统实现中线程限制的值。如果操作系统实现的限制是不 确定的，列出的值就是“没有确定的限制”（no limit）。但这并不意味着值是无限制的。

| 限制名称                                                     | FreeBSD 8.0           | Linux 3.2.0                | Mac OS X 10.6.8         | Solaris 10                                       |
| ------------------------------------------------------------ | --------------------- | -------------------------- | ----------------------- | ------------------------------------------------ |
| PTHREAD_DESTRUCTOR_ITERATIONSPTHREAD_KEYS_MAXPTHREAD_STACK_MINPTHREAD THREADS MAX | 42562 048没棚定的限制 | 41 02416 384没有确定的限制 | 45128 192没有确定的限制 | 没有确定的限制 没有确定的限制8 192没有确定的限制 |

图12-2线程配置限制的实例

注意，虽然某个操竹系统实现可能没有提供访问这些限制的方法，但这并不意味着这些限制 不存在，这只是意味着操作系统实现没有为使用sysconf访问这些值提供可用的方法。

###### 12.3线程属性

pthread接口允许我们通过设置每个对象关联的不同属性来细调线程和同步对象的行为。通 常，管理这些属性的函数都遵循相同的模式。

(1)    每个对象与它自己类型的属性对象进行关联(线程与线程属性关联，互斥量与互斥量属 性关联，等等)。一个属性对象可以代表多个属性。属性对象对应用程序来说是不透明的。这意 味着应用程序并不需要了解有关属性对象内部结构的详细细节，这样可以增强应用程序的可移植

425

I

426



|性。取而代之的是，需要提供相应的函数来管理这些属性对象。

(2)    有一个初始化函数，把属性设置为默认值。

(3)    还有一个销毁属性対象的函数。如果初始化函数分配了与属性对象关联的资源I销毁函 数负责释放这些资源。

(4)    每个属性都有一个从属性对象中获取属性值的函数。由于函数成功时会返回0,失败时会返回 错误编号，所以可以通过把属性值存储在函数的某一个参数指定的内存单元中，把属性值返回给调用者。

(5)    每个属性都有一个设置属性值的函数。在这种情况下，属性值作为参数按值传递。

在第11章所有调用pthread^create函数的实例中，传入的参数都是空指针，而不是指向

pthread_attr_t结构的指针。可以使用pthread_attr_t结构修改线程默认属性，并把这些 属性与创建的线程联系起来。可以使用pthread_attr_init函数初始化pthread_attr_t结 构。在调用pthread_attr_init以后，pthread_attr_t结构所包含的就是操作系统実现支 持的所有线程属性的默认值，

\#include <pthread.h>

int pthread_attr_init(pthread_attr_t *attr)； int pthread_attr_destroy(pthread_attr_t *affr);

两个函数的返回值：若成功，返回0:否则，返回错误编号

如果要反■初始化pthread_attr_t结构，可以调用pthread_attr_destroy函数。如果 pthread_attr_init的实现对属性対象的内存空间是动态分配的，pthread_attr_destroy 就会释放遂内存空间。除此之外，pthread_attr_destroy还会用无效的值初始化属性对象， 因此，如果该属性对象被误用，将会导致pthreacLcreate函数返回错误码。

图12-3总结了 POSIX.1定义的线程属性。POSIX.1还为线程执行调度(Thread Execution Scheduling)选项定义了额外的属性，用以支持实时应用，但我们并不打算在这里讨论这些属性。 图12-3同时给出了各个操作系统平台对每个线程属性的支持情况。

| 名称                                   | 描述                                                         | FreeBSD8.0 | Linux3.2.0 | Mac OSX 10.6.8 | Solaris10 |
| -------------------------------------- | ------------------------------------------------------------ | ---------- | ---------- | -------------- | --------- |
| detachstateguardsizestackaddrstacksize | 线程的分离状态属性 线程桟末尾的警戒缓冲区大小(字节数) 线程桟的最低地址线程栈的最小长度(字节数) | •          | -          | -              | •         |

图12-3 POS1X.1线程属性

11.5节介绍了分离线程的概念。如果对■现有的某个线程的终止状态不感兴趣的话，可以使用 pthread_detach函数让操作系统在线程退出时收回它所占用的资源。

如果在创建线程时就知道不需要了解线程的终止状态，就可以修改pthread_attr_t结构中的 detachstate线程属性，让线程—开始就处于分离状态。可以使用pthread_attr_setdetachstate 函数把线程属性rfetoctetfe设置成以下两个合法值之一：PTHREAD_CREATE_DETACHED,以分离状态 启动线程：或者PTHREAD_CREATE_JOINABLE，正常启动线程，应用程序可以获取线程的终止状态。

\#include <pthread.h>

int pthread_attr_getdetachstate(const pthread_attr_t *restrict attr, int * detachstate);

int pthread_attr_setdetachstate (pthread_attr_t *attr, int ★ detachstate);

两个函数的返回值：若成功，返回0:否则，返回错误编号

可以调用pthread_attr_getdetachstate函数获取当前的rfetoc/wtote线程属性。第二个参 数所指向的整数要么设置成PTHREAD_CREATE_DETACHED,要么设置成PTHREAD_CREATE_ JOINABLE,具伴要取快于给定pthread_attr_t结构中的属性值。

■实例

图12~4给出了一个以分离状态创建线程的函数。

\#include "apue.h" ttinclude <pthread.h>

int

makethread(void *(*fn)(void *), void *arg)

{

int    err;

pthread_t    tid;

pth read_a 11r_t    attr;

err = pthread_attr_init(&attr); if (err != 0)

return(err);

err = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED); if (err == 0)

err = pthread_create(&tid, &attr, fn, arg); pthread_attr_destroy(sattr); return(err);

}

图12>4以分离状态创建线程

注意，此例您略了 pthread_attr_destroy函数调用的返回值。在这个实例中，我们对线 程属性进行了合理的初始化，因此pthread_attr_destroy座该不会失败。但是，如果 pthread_attr_destroy确实出现了失败的情况，将难以清理：必须销毁刚刚创建的线程，也 许这个线程可能己经定行，并且与pthread_attr_destroy函数可能是异步执行的。忽略|428| pthread_attr_destroy的错误返回可能出现的最坏情况是，如果pthread_attr_init己 经分配了内存空间，就会有少量的内存泄漏。另一方面，如果pthread_attr_init成功地对 线程属性进行了初始化，但之后pthread_attr_destroy的清理工作失败，那么将没有任何补

救策略，因为线程属性结构对应用程序来说是不透明的，可以对线程属性结构进行清理的唯一接 口是 pthread_attr_destroy,但它失败了。

对于遵循POSIX标淮的操作系统来说，并不一定要支持线程桟属性，但是对于遵循Single UNIX Specification中XSI选项的系统来说，支持线程栈属性就是必需的。可以在编译阶段使用_POSIX_ THREAD_ATTR_STACKADDR ^1_POS IX_THREAD_ATTR_STACKSI ZE 符号来检査系统是否支持每一 个线程栈属性。如果系统定义了这些符号中的一个，就说明它支持相应的线程桟属性。或者，也可以 在运行阶段把_SC_THREAD_ATTR_ STACKADDR 和_3(?_71^7\0_7«^1<_53?7^1<5工ZE 参数传给 sysconf函数，检查运行时系统財线程桟属性的支持情况。

可以使用圉数pthread_attr_getstack和pthread„attr_setstack对线程桟属性进 行管理。

\#include <pthread.h>

int pthread_attr_getstack (const pthread_attr_t ^restrict attr, void **restrict stackaddr, size_t *restrict stacksize)；

int pthread_attr_setstack {pthread_attr_t *attr,

void *stackaddr, size_t stacksize);

两个函数的返回值：若成功，返回0;否则，返回错误编号

对于进程来说，虚地址空间的大小是固定的。因为进程中只有一个栈，所以它的大小通常不 是问题。但对于线程来说，同样大小的虚地址空间必须被所有的线程栈共享。如果应用程序使用 了许多线程，以致这些线程栈的累计大小超过了可用的虚地址空间，就需要减少默认的线程栈大 小。另一方面，如果线程调用的函数分配了大量的自动变量I或者调用的函数涉及许多很深的桟 帧(stackframe)，那么需要的桟大小可能要比默认的大。

如果线程栈的虚地址空间都用完了，那可以使用malloc或者mrnap (见14.8节)来为可替 代的桟好配空间，并用pthread_attr_setstack画数来改变新建线程的栈俊置。由stackaddr 参数指定的地址可以用作线程桟的内存范围中的最低可寻址地址，该地址与处理器结构相应的边 界应对齐。当然，这要假设malloc和nunap所用的虚地址范围与线程桟当前使用的虚地址范围 不同。

stodfcarf介线程属性被定义为桟的最低内存地址，但这并不一定是桟的开始位置。对于一个给 定的处理器结构来说，如果栈是从髙地址向低地址方向增长的，那么做线程属性将是桟的 结尾位置，而不是开始位置。

/Sffi®T"lk^rUl3fi5ipthread_attr_getstacksize ^Dpthread_attr_setstacksize ® [429]数读取或设置线程属性stodfc也e。

♦include <pthread.h>

int pthread_attr_getstacksize (const pthread_attr_t * restrict attr, size_t * restrict stacksize);

int pthread_attr_setstacksize (pthread_attr_t *attr, size_t stacksize};

两个函数的返回值：若成功，返回0;否则，返回错误编号.

如果希望改变默认的桟大小，但又不想自己处理线程栈的分配问题，这时使用pthread_attr_ setstacksize函数就非常有用。设置stacksize属性时，选择的stacksize不能小于PTHREAD_

STACK_MIN。

线程属性guardsize控制着线程栈末尾之后用以避免栈溢出的扩展内存的大小。这个属性默认 值是由具体实现来定义的，但常用值是系统页大小。可以把gwon&Zze线程属性设置为0,不允许 属性的这种特征行为发生：在这种情况下，不会提供警戒缓冲区。同样，如果修改了线程属性 stackaddr，系统就认为我们将自己管理桟，进而使栈警戒缓冲区机制无效，这等同于把gjwn/sfce 线程属性设置为0。

ttinclude <pthread.h>

iint pthread_attr_getguardsize (const pthread_attr_t * restrict attr, size_t *restrict guardsize};

int pthread_attr_setguardsize {pthread_attr_t *attr, size_t guardsize);

两个函数的返回值：若成功，返回0:否则，返回错误编号

如果线程属性被修改了，操作系统可能会把它取为页大小的整数倍。如果线程的栈 指针溢出到警戒E域，应用程序就可能通过信号接收到出错信息。

Single UNIX Specification还定义了一些其他的可选线程属性供实时应用程序使用，但在这里 不讨论这些属性。

线程还有一些其他的pthread_attr_t结构中没有表示的属性：可撤销状态和可撤销类型。 我们将在12.7节中讨论它们。

###### 12.4同步属性

就像线程具有属性一样，线程的同步对象也有属性。11.6.7节中介绍了自旋锁，它有一个属 性称为进租共享属性。本节讨论互斥量属性、读写锁属性、条件变量属性和屏障属性。

12.4.1互斥量属性

互斥量属性是用pthread_mutexattr_t结构表示的。第11章中每次对互斥量进行初始化 时，都是通过使用PTHREAD_MUTEX_INITIALIZER常量或者用指向互斥量属性结构的空指针作(430] 为参数调用pthread__mutex_init函数，得到互斥量的默认属性。

対于非默认属性，可以用pthread_mutexattr_init初始化pthread_mutexattr_t结 构，用 pthread_mutexattr_destroy 来反初始化。

^include <pthread.h>

int pthread_mutexattr_init (pthread_mutexattr_t *attr); int pthread_mutexattr_destroy (pthread_mutexattr_t ★attr);

两个函数的返回值：若成功，返回0:否则，返回错误编号

pthread_mutexattr_init函数将用默认的互斥量属性初始化pthread_mutexattr_t 结构。值得注意的3个属性是：进程共享属性、健壮属性以及类型属性。POSIX.1中，进程共享 属性是可选的。可以通过检査系统中是否定义了_POSIX_THREAD_PROCESS_SHARED符号来判 断这个平台是否支持进程共享这个属性，也可以在运行时把_SC_THREAD_PROCESS_SHARED参 数传给sysconf函数进行检查。虽然这个选项并不是遵循POSIX榇准的操作系统必须提供的，

但是Single UNIX Specification要求遵循XSI标准的操作系统支持这个选项，

在进程中，多个线程可以访问同一个同步对象。正如在第11章中看到的，这是默认的行为。 在这种情况下，进程共享互斥量属性需设置为PTHREAD_PROCESS_PRIVATEo

我们将在第14章和第15章中看到，存在这样的机制：允许相互独立的多个进程把同一个内 存数据块映射到它们各自独立的地址空间中。就像多个线程访问共享数据一样，多+进程访问共 享数据通常也需要同步。如果进程■共享互斥量属性设置为PTHREAD_PROCESS_SHARED,从多个 进程彼此之间共享的内存数据块中分配的互斥量就可以用于这些进程的同步。

可以使用 pthread_mutexattr_getpshared 函数査询 pthread_mutexattr_t 结构， 得到它的进租共享属性，使用pthread_mutexattr_setpshared函数修改进程共享属性。

\#include <pthread.h>

int pthread_mutexattr_getpshared(const pthread_mutexattr_t ★restrict attr, int ^restrict pshared);

int pthread_mutexattr_setpshared(pthread_mutexattr_t int pshared];

两个函数的返回值：若成功，返回0:否则f返回错误编号

进程共享互斥量属性设置为PTHREAD_PROCESS_PRIVATE时，允许pthread线程库提供更 岡有效的互斥量实现，这在多线程应用程序中是默认的情况。在多个进程共享多个互斥量的情况下，

pthread线程库可以限制开销较大的互斥量实现。

互斥量健壮属性与在多个进程间共享的互斥量有关。这意味着，当持有互斥量的进程终止时,

需要解決互斥量状态恢复的问题，这种情况发生时，互斥量处于锁定状态，恢复起来很困难。其 他阻塞在这个锁的进程将会一直阻塞下去。

可以使用pthread_mutexattr_getrobust函数获取健壮的互斥量属性的值。可以调 用pthread_mutexattr_setrobust函数设置健壮的互斥量属性的值。

\#include <pthread.h>

int pthread_mutexattr_getrobust(const pthread_mutexattr_t * restrict attr, int *restrict robust);

int pthread_mutexattr_setrobust (pthread_mutexattr_t *attr, int robust);

两个函数的返回值：若成功，返回0:否则，返回错误编号

健壮属性取值有两种可能的情况。默认值是PTHREAD_MUTEX_STALLED,这意味着持有互 斥量的进程终止时不需要采取特别的动作。这种情况下，使用互斥量后的行为是未定义的，等待 该互斥量解锁的应用程序会被有效地“拖住”。另一个取值是PTHREAD_MUTEX_ROBUST。这个值将 导致线程调用pthread_mUtex_lOCk获取锁，而该锁被另一个进程持有，但它终止时并没有对 该锁进行解锁，此时线程会阻塞，从pthread_mutex_lock返回的值为EOWNERDEAD而不是0。 应用程序可以通过这个特殊的返回值获知，若有可能（要保护状态的细节以及如何进行恢复会因 不同的应用程序而异〉，不管它们保护的互斥量状态如何，都需要进行恢复。

使用健壮的互斥量改变了我们使用pthread_mutex_lock的方式，因为现在必须检査3个 返回值而不是之前的两个：不需要恢复的成功、需要恢复的成功以及失败。但是，即使不用健壮 的互斥量，也可以只检査成功或者失败。

在本书的4个平台中，只有Linux 3.2.0目前支持键壮的线程互斥量。Solaris 10只在它的Solaris |线程库中支持健壮的线程互斥量(参阅Solaris手册的mutex_init(3C)获取相关的信息)。但是 ;Solaris 11支持徒壮的线程互斥量。

如果应用状态无法恢复，在线程对互斥量解锁以后，该互斥量将处于永久不可用状态。为了 避免这样的问题，线程可以调用pthread_mutex_consistent函数，指明与该互斥量相关的 状态在互斥量解锁之前是一致的。    [4321

\#include <pthread.h>

int pthread_mutex_consistent (pthread_mutex_t * mutex、；

返回值：若成功> 返回0;否则，返回错误编号

如果线程没有先调用pthread_mutex_consistent就对互斥量进行了解锁，那么其他试 图获取该互斥量的阻塞线程就会得到错误码ENOTRECOVERABLE。如果发生这种情况，互斥量将 不再可用。线程通过提前调用pthread_mutex_consistent，能让互斥量正常工作，这样它就 可以持续被使用。

类型互斥量属性控制着互斥量的锁定特性。POSIX.1定义了 4种类型。

PTHREAD_MUTEX_NORMAL    —种标准互斥量类型，不做任何特殊的错误检査或死锁检测。

PTHREAD_MUTEX„ERRORCHECK此互斥量类型提供错误检査，

PTHREAD_MUTEX_RECURS IVE 此互斥量类型允许同一线程在互斥量解锁之前对该互斥量 进行多次加锁。递归互斥量维护锁的计数，在解锁次数和 加锁次数不相同的情况下，不会释放锁。所以，如果对一 个递归互斥量加锁两次，然后解锁一次，那么这个互斥量 将依然处于加锁状态，对它再次解锁以前不能释放该锁。

PTHREAD_MUTEX_DEFAULT    此互斥量类型可以提供默认特性和行为、操作系统在实现它

的时候可以把这种类型自由地映射到其他互斥量类型中的 一种。例如，Linux 3.2.0把这种类型映射为普通的互斥量类 型，而FreeBSD 8.0则把它映射为错误检査互斥量类型。

这4种类型的行为如图12-5所示。“不占用时解锁”这一栏指的是，一个线程对被另一个线 程加锁的互斥量进行解锁的情况。“在己解锁时解锁”这一栏指的是，当一个线程对已经解锁的 互斥量进行解锁时将会发生什么，这通常是编码错误引起的。

| 互斥量类型               | 没有解锁时重新加锁？ | 不占用时解锁？ | 在己解锁时解锁？ |
| ------------------------ | -------------------- | -------------- | ---------------- |
| PTHREAD_MUTEX_NORMAL     | 死锁                 | 未定义         | 未定义           |
| PTHREAD_MUTEX_ERRORCHECK | 返回错误             | 返回错误       | 返回错误         |
| PTHREAD_MUTEX_RECURSIVE  | 允许                 | 返回错误       | 返回错误         |
| PTHREAD MUTEX DEFAULT    | 未定义               | 未定义         | 未定义           |

图12-5互斥量类型行为    岡

可以用 pthread_mutexattr_gettype 函数得至(J互斥量类型属性，用 pthread_mutexattr_ settype函数修改互斥量类型属性。

\#include <pthread.h>

int pthread_mutexattr_gettype (const pthread_mutexattr_t * restrict attr, int * restrict type};

int pthread_mutexattr_settype （pthread_mutexattr_t *attr, int type};

两个函数的返回值：若成功，返回0;否则，返回错误编号

回忆11.6.6节中学过的，互斥量用于保护与条件变量关联的条件。在阻塞线程之前，pthread_ cond_wait和pthread_cond_timedwait函数释放与条件相关的互斥量。这就允许其他线程获取 互斥量、改变条件、释放互斥量以及给条件变量发信号。既然改变条件时必须占有互斥量，使用递归互 斥量就不是一个好主意、如果递归互斥量被多次加锁，然后用在调用pthread_cOnd_Wait函数中， 那么条件永远都不会得到满足，因为pthread_cond_wait所做的解锁操作并不能释放互斥量、

如果需要把现有的单线程接口放到多线程环境中，递归互斥量是非常有用的，但由于现有程 序兼容性的限制，不能对函数接口进行修改。然而，使用递归锁可能很难处理，因此成该只在没 有其他可行方案的时候才使用它们。

%实例

图12-6描述了一种情况，在这种情况中递归互斥量看起来像是在解决并发问题。假设fund 和func2是函数库中现有的函数，其接口不能改变，因为存在调用这两个接口的应用程序，而 且应用程序不能改动。

| aain j

f unc l(x) -fund

'    pthread_mutex_lock(x->lock)

\-    £unc2<x)    -

\-    pthre«d_mutex_unlock(x->lock)

£unc2 (x)    -func2

pthread_mutex_lock(x->lock)

pthread_mutex_unlock（x->lock） 图12-6使用递归锁的一种可能情况

为了保持接口跟原来相同，我们把互斥量嵌入到了数据结构中，把这个数据结构的地址（x） 作为参数传入，这种方案只有在为此数据结构提供分記函数时才可行，所以应用程序并不知道数 据结构的大小（假设我们在其中増加互斥量之后必须扩大该数据结构的大小）。

如果在最早定义数据结构时，预留了足够的可填充字段，允许把某些填充字段势换成互斥量，这 种方法也是可行的。不过遣憾的是，大多数程序员并不善于预測未来，所以这并不是普遍可行的实践。

如果fxmcl和func2函数都必须操作这个结构，而且可能会有一个以上的线程同时访问该 数据结构，那么funcl和func2必须在操作数据以前对互斥量加锁。如果fimcl必须调用 func2,这时如果互斥量不是递归类型的，那么就会出现死锁。如果能在调用func2之前释放[^5] 互斥量，在func2返回后重新获取互斥量，那么就可以避免使用递归互斥量，但这也给其他的 线程提供了机会，其他的线程可以在funcl执行期间抓住互斥量的控制，修改这个数据结构，

这也许是不可接受的，当然具体的情况要取决于互斥量试图提供什么样的保护。

图12-7显示了这种情况下使用递归互斥量的一种替代方法。通过提供func2函数的私有版 本，称之为fUnc2_lOCked函数，可以保持funcl和fimc2函数接口不变，而且避免使用递 归互斥量。要调用func2_locked函数，必须占有嵌入在数据结构中的互斥量，这个数据结构 的地址是作为参数传入的。func2JLocked的函数体包含func2的副本，func2现在只是获取 互斥量，调用func2_locked，然后释放互斥量。

| main |

funcl(x) -fund

:    pthread_mutex_lock(x->lock)

:    func2_locked{x)-

:    pthread_mutex_unlock(x->lock)

func2 (x)    -func2

pthread_mutex_lock(x->lock)    ”

func2_locked(x) -m £unc2_locked

pthread_matex_unlock(x->lock)

图12-7避免使用递归锁的一种可能情况

如果并不一定要保持库函数接口不变，就可以在每个函数中增加第二个参数表明这个结构是 否被调用者锁定。但是，如果可以的话，保持接口不变通常是更好的选择，可以避免实现过程中 人为加入的东西对原有系统产生不良影响。

提供加锁和不加锁版本的函数，这样的策略在简单的情况下通常是可行的。在更加复杂的情况下，

比如，库需要调用库以外的函数，而且可能会再次回调库中的函数时，就需要依赖递归锁。    S35]

■实例

图12-8中的程序解释了有必要使用递归互斥量的另一种情况，这里，有一•个“超时”(timeout〉

函数，它允许安排另一个函数在未来的某个时间运行。假设线程并不是很昂贵的资源，就可以为每 个挂起的超时函数创建一个线程。线程在时间未到时将一直等待，时间到了以后再调用请求的函数。

\#include "apue.h"

♦include <pthread.h>

Sinclude <time.h>

\#include <sys/time.h>

extern int makethread(void *(*)(void *}, void *);

_ struct to_info (

14361 void    (*to_fn)(void *)；

/* function */

/* argument */

/* time to wait */



void    *to_arg;

struct timespec to_wait;

\#define SECTONSEC 1000000000    /* seconds to nanoseconds */

棒if !defined(CLOCK_REALTIME) I I defined(BSD)

释define clock_nanosleep(ID, FL, REQ, REM) nanosleep{(REQ), (REM)) lendif

參ifndef CLOCK_REALTIME

\#define CLOCK_REALTIME 0

\#define USECTONSEC 1000    /* microseconds to nanoseconds */

void

clock_gettime(int id, struct timespec *tsp)

{

struct timeval tv;

gettimeofday(Stv, HULL); tsp->tv_sec = tv.tv_sec?

tsp->tv_nsec = tv.tv_usec * USECTONSEC;

}

\#endif

void *

timeout_helper(void *arg)

1

struct to_info *tip;

tip = {struct to_info *)arg;

clock_nanosleep (CLOCK_RElALTIMEf 0, 6tip->to_wait, NULL}; {*tip->to_fn)(tip->to_arg)； free(argj;

return(0);

void

timeout(const struct timespec *when, void (*func) (void *), void *arg) {

struct timespec now; struct to_info *tip; int    err;

clock_gettime(CLOCK_REALTIME, &now);

if ((when->tv_sec > now.tv_sec) \ I

(when->tv_sec == now.tv_sec && when->tv_nsec > now.tv_nsec" {

tip = malloc(sizeof{struct to_info)); if (tip != NULL) {

tip->to_fn = func;

tip->to_arg = arg;

tip->to_wait.tv_sec = when->tv_sec - now.tv_sec;

if (when->tv_nsec >= now.tv_nsec) {

tip->to_wait.tv_nsec = when->tv_nsec - now.tv_nsec;

} else {    |437|

tip->to_wait.tv_sec--;

tip->to_wait.tv_nsec = SECTONSEC - now.tv_nsec + when->tv_nsec;

err = makethread(timeout_helper, (void *)tip);

if (err == 0} return;

else

free(tip)；

\*    We get here if (a) when <= now, or (b) malloc fails, or

\*    (c) we can't make a thread, so we just call the function now. */

(*func)(arg);

}

pthread_mutexattr_t attr；

pthread_mutex_t mutex;

void

retry{void *arg)

t

pthread_mutex_lock{&mutex);

/* perform retry steps ... */

pthread_mutex_unlock(&mutex);

int

main (void)

int    err, condition, arg;

struct timespec when;

if ((err = pthread_mutexattr_init(Sattr)) != 0)

err_exit(err, "pthread_mutexattr_init failed");

if ((err = pthread_mutexattr_3ettype(&attr, PTHREAD_MUTEX_RECURSIVE> )    != 0)

err_exit(err, "can't set recursive type"); if ((err = pthread_mutex_init(smutex, fiattr)) != 0)

err_exit (err, "can' t create recursive mutex'*);

/* continue processing ... */ pthread_tnutex_lock{&mutex);

\*    Check the condition under the protection of a lock to

\*    make the check and the call to timeout atomic.

*/

if (condition) {

/*

\* Calculate the absolute time when we want to retry */

clock_gettime(CLOCK_REALTIME, Swhen); when.tv_sec += 10;    /* 10 seconds from now */

timeout(&when, retry, (void *)((unsigned long}arg))；

}

pthread_mutex_unlock(&mutex);

/* continue processing ... ♦/

exit(0);

图12-8使用递归互斥量

如果我们不能创建线程，或者安排函数运行的时间已过，这时问题就出现了。在这些情况下， 我们只需在当前上下文中调用之前请求运行的函数。因为函数要获取的锁和我们现在占有的锁是 同一个，所以除非该锁是递归的，否则就会出现死锁。

在图124中我们使用makethread函数以分■离状态创建线程。因为侍递给timeout圉数 的func函数参数将在未来运行，所以我们不希望一直空等线程结束。

可以调用sleep等待超时到期，但它提供的时间粒度是秒级的。如果希望等待的时间不是整数 秒，就需要用nanosleep或者clock_nanosleep函数，它们两个提供了更髙精度的休眠时间。

在未定义CLOCK_REALTIME的系统中，我们根据nanosleep完义clock_nanosleep0 然而，FreeBSD 8.0定义这个符号支持clock_gettime和clock_settime,但并不支持 clock_nanosleep。(只有 Linux 3.2.0 和 Solaris 10 目前支持 clock_nanosleep。)

' 另外，在未定义CLOCK_REALTIME的系统中，我们提供了我们自己的clock_gettime实 j现，该实现■调用了 gettimeofday并把微妙转换成纳秒。

timeout的调用者需要占有互斥量来检査条件，并且把retry函数安排为原子操作。retry 函数试图对同一个互斥量进行加锁。除非互斥量是递归的，否则，如果timeout函数直接调用 retry,会导致死锁。    画

12.4.2读写锁属性

读写锁与互斥量类似，也是有属性的。可以用pthread_rwlockattr_init初始化 pthread_rwlockattr_t 结构，用 pthread_rwlockattr_destroy 反初始化该结构。 linclude <pthread.h>

int pthread_rwlockattr_init (pthread_rwlockattr_t *attr)； int pthread_rwlockattr_destroy {pthread_rwlockattr_t *attr);

两个函数的返回值：若成功，返回0:否则，返回错误编号

读写锁支持的唯一属性是进程共享属性。它与互斥量的进程共享属性是相同的。就像互斥量

的进糕共享属性一样，有一对函数用于读取和设置读写锁的进程共享属性。

ttinclude <pthread.h>

int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t * restrict attr, int *restrict pshared);

int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *attr, int pshared、；

两个函数的返回值：若成功，返回0:否则，返回错误编号

虽然POSIX只定义了一个读写锁属性，但不同平台的实现可以自由地定义额外的、非标准的 属性。

12.4.3条件变量属性

Single UNIX Specification目前定义了条件变量的两个属性：进程共享属性和时钟属性。与其 他的属性对象一样，有一对函数用于初始化和反初始化条件变量属性。

\#include <pthread.h>

int pthread_condattc_init (pthread_condattr_t *attr); int pthread__condattr_destroy (pthread_condattr_t *attr};

两个函数的返回值：若成功，返回0;否则，返回错误编号

与其他的同步属性一样，条例变量支持进程共享属性。它控制着条件变量是可以被单进程的多个 线程使用，还是可以被多进程的线程使用。要获取进程共享属性的当前值，可以用pthread_ condattr_getpshared 函数。设置该值可以用 pthread_condattr_setpshared 函数。

\#include <pthread.h>

int pthread_condattr_getpshared(const pthread_condattr_t * restrict attr, int * restrict pshared}；

int pthread_condattr_setpshared (pthread_condattr_t *attr, int pshared);

两个函数的返回值：若成功，返回0:否则，返回错误编号

时钟属性控制计算pthread_cond_timedwait函数的超时参数(tsptr)时采用的是哪个时钟。

合法值取自图6~8中列出的时钟ID。可以使用pthread_condattr_getclock国数获取可被用于|440| pthread_cond_timedwait 函数的时钟 ID，在使用 pthread_cond_timedwait 函数前需要用 pthread_condattr_t 对象对条件行初始化。可以用 pthread_condattr_setclock 函数 对时钟ID进行修改。

♦include <pthread.h>

int pthread_condattr_getclock(const pthread_condattr_t * restrict attr,

clockid_t ^restrict clock_id、；

int pthread_condattr_setclock (pthread_condattr_t *attr, clockid_t clock_id);

两个函数的返回值:若成功，返回0:否则，返回错误编号

奇怪的是，Single UNIX Specification并没有为其他有超时等待函数的属性对象定义时钟属14。

12.4.4屏障属性

屏障也有属性。可以使用pthread_barrierattr_init函数对屏障属性对象进行初始化, 用pthread_barrierattr_destroy函数对屏障属性对象进行反初始化。

\#include <pthread.h>

int pthread_barrierattr_init (pthread_barrierattr_t *attr); int pthread_barrierattr_destroy(pthread_barrierattr_t *attr);

两个函数的返回值：若成功，返回0;否则，返回错误编号

目前定义的屏障属性只有进程共享属性，它控制着屏障是可以被多进程的线程使用，还是只能被 初始化屏障的进程内的多线程使用。与其他属性对象一样，有一个获取属性值的函数(pthreacV barrierattr_getpshared)和~函数(pthread_barrierattr_ setpshared)。

♦include <pthread.h>

int pthread_barrierattr_getpshared(const pthread_barrierattr_t restrict attr, int * restrict pshared｝；

int pthread_barrierattr_setpshared (pthread_barrierattr_t *attr, int pshared);

两个函数的返回值：若成功，返回0:否则，返回错误编号

进程共享属性的值可以是PTHREAD_PROCESS_SHARED (多进程中的多个线程可用)，也可 以是PTHREAD_PROCESS_PRIVATE (只有初始化屏障的那个进程内的多个线程可用)。

##### 12-5重入

10.6节讨论了可重入函数和信号处理程序。线程在遇到重入问题时与信号处理程序是类似的。 在这两种情况下，多个控制线程在相同的时间有可能调用相同的函数。

如果一个函数在相同的时间点可以被多个线程安全地调用，就称该函数是线程安全的。在Single UNIX Specification中定义的所有函数中，除了图12-9中列出的函数，其他函数都保证是线程安全的。 另外，ctermid和tmpnam函数在参数传入空指针时并不能保证是线程安全的。类似地，如果参数 mbstate_t传入的是空指针，也不能保证wcrtomb和wcsrtorabs函数是线程宏全的。

支持线程安全函数的操作系统实现会在＜imistd.h＞中定义符号_POSIX_THREAD_SAFE_ FUNCTIONS。应用程序也可以在sysconf函数中传入_SC_THREAD_SAFE_FUNCTIONS参数在 运行时检査是否支持线程安全函数。在SUSv4之前，要求所有遵循XSI的实现都必须支持线程安 全函数，但是在SUSv4中，线程安全函数支持这个需求已经要求具体实现考虑遵循POSIX。

操作系统实现支持线程安全函数这个特性时，对POSDC1中的一些非线程安全函数，它会提 [442]供可替代的线程安全版本。图12-10列出了这些函数的线程安全版本》这些函数的命名方式与它 们的非线程安全版本的名字相似，只不过在名字最后加了表明这些版本是可重入的。很多函 数并不是线程安全的，因为它们返回的数据存放在静态的内存缓冲区中。通过修改接口，要求调

用者自己提供缓冲区可以使函数变为线程安全。

| basename               | getchar_unlocked           | getservent         | putc_unlocked    |
| ---------------------- | -------------------------- | ------------------ | ---------------- |
| catgets                | getdate                    | getutxent          | putchar_unlocked |
| crypt                  | getenv                     | getutxid           | putenv           |
| dbro_clearerr          | getgrent                   | getutxline         | pututxline       |
| dbm_close              | getgrgid                   | gmtime             | rand             |
| dbm_delete             | getgrnam                   | hcreate            | readdir          |
| dbm_error              | gethostent                 | hdestroy           | setenv           |
| dbm_fetch              | getlogin                   | hsearch            | setgrent         |
| dbm_firstkey           | getnetbyaddr               | inet_ntoa          | setkey           |
| dbm_nextkey            | getnetbyname               | 164a               | setpwent         |
| dbm_open               | getnetent                  | 1gamma             | setutxent        |
| dbm_store              | getopt                     | Igammaf            | strerror         |
| dirname                | getprotobyname             | lgammal            | strsignal        |
| dlerror                | getprotobynumber           | localeconv         | strtok           |
| drand48                | getprotoent                | localtime          | system           |
| encrypt                | getpwent                   | lrand48            | ttyname          |
| endgrent               | getpwnain                  | mrand48            | unsetenv         |
| endpwent               | getpwuid                   | nftw               | wcstombs         |
| endutxentgetc unlocked | getservbynamegetservbyport | nl_langinfoptsname | wctomb           |

图12-9 POSIX.1中不能保证线程安全的函数

| getgrgid_r         | localtime_r |
| ------------------ | ----------- |
| getgrnam_r         | readdir_r   |
| getlogin_r         | strerror_r  |
| getpwnam_r         | strtok_r    |
| getpwuid_rgmtime r | ttyname_r   |

图12-10替代的线程安全函数

如果一个函数对多个线程来说是可重入的，就说这个函数就是线程安全的。但这并不能说明对信 号处理程序来说该函数也是可重入的。如果函数对异步信号划遲程序的重入是安全的，那么就可以说函 数是异步信号安全的，我们在10.6节中讨讼可重入函数时，图1(M中的函数就是异步信号安全函数。

除了图12-10中列出的函数，POS1X.1还提供了以线程安全的方式管理FILE对象的方法。 可以使用flockfile和ftrylockfile获取给定FILE对象关联的锁。这个锁是递归的：当 你占有这把锁的时候，还是可以再次获取该锁，而且不会导致死锁。虽然这种锁的具体实现并无 规定，但要求所有操作FILE对象的标准I/O例程的动作行为必须看起来就像它们内部调用了 flockfile 和 funlockfile。

| ^include <stdio.h>          |                                                 |
| --------------------------- | ----------------------------------------------- |
| int ftrylockfile (FILE    ; | 返回值，若成功，返回0:若不能获取锁，返回非0数值 |
| void flockfile(FILE *fp};   |                                                 |
| void funlockfile (FILE    ; |                                                 |

虽然标准的I/O例程可能从它们各自的内部数据结构的角度出发，是以线程安全的方式实现的， 但有时把锁开放给应用程序也是非常有用的。这允许应用程序把多个对标准I/O函数的调用组合成原 子序列。当然，在处理多个FILE对象时，需要注意潜在的死锁，需要对所有的锁仔细地排序。

如果标准I/O例程都获取它们各自的锁，那么在做一次一个字符的I/O时就会出现严重的性 能下降。在这种情况下，需要对每一个字符的读写操作进行获取锁和释放锁的动作。为了避免这 闹种开销，出现了不加锁版本的基于字符的标准I/O例程。

\#include <stdio.h>

int getchar_unlocked(void);

int getc^unlocked (FILE ；

两个函数的返回值：若成功，返回下一个字符；若遇到文件尾或者出错，返回EOF int putchar_unlocked(int c); int putc_unlocked (int c, FILE ;

两个函数的返回值：若成功，返回c:若出错，返回EOF

險非被flockfile (或ftrylockfile)和funlockfile的调用包围，否贝•』尽•量不要调用这 4个函数，因为它们会导致不可预期的结果(比如，由于多个控制线程非同步访问数据弓胞的种种问题)。

一旦对FILE对象进行加锁，就可以在释放锁之前对这些函数进行多次调用。这样就可以在 多次的数据读写上分摊总的加解锁的开销。

I实例

图12-11显示丁 getenv (见7.9节)的一个可能实现。这个版本不是可重入的。如果两个线 程同时调用这个函数，就会看到不一致的结果，因为所有调用getenv的线程返回的字符串都存 储在同一个静态缓冲区中。

ttinclude <limits.h>

\#include <string.h>

\#define MAXSTRINGSZ 4096

static char envbuf[MAXSTRINGSZ];

extern char **environ;

char *

getenv(const char *name,

int i, len;

len = strlen(name);

for (i = 0; environ(i] != NULL; i++) {

if ((strncmp(name, environ[i], len) == 0) &&

(environ[i][len] == '=')) {

strncpy(envbuf, &environ【i][len+1], MAXSTRINGSZ-1); return(envbuf);

}

}

return(NULL);

图12-11 getenv的非可重入版本

图12-12给出了 getenv的可重入的版本。这个版本叫做getenv_r。它使用pthread_once

函数来确保不管多少线程同时竞争调用getenv.r,每个进程只调用thread_init函数一次。 12.6节会详细描述pthread_once函数。

\#include

\#include

\#include

♦include



<string.h>

<errno.h>

<pthread.h>

<stdlib.h> extern char **environ;

pthread_mutex_t env_mutex;

static pthread_once_t init_done = PTHREAD_ONCE_INIT;

static void

thread_init(void)

{

pthread_mutexattr_t attr;

pthread_mutexattr_init(fiattr);

pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE); pthread_mutex_init(&env_mutex, sattr)； pthread_mutexattr_destroy(Sattr);

int

getenv_r{const char *name, char *buff int buflen) {

int i, len, olen；

pthread_once(&init_done, thread_init);

len = strlen(name)；

pthread_mutex_lock(&env_mutex);

for (i = 0; environ[i] != NULL; i++) {

if ((strncmp(name, environ[i] , len) == 0) &&

(environ[i][len】=='=')){

olen = strlen(Senviron[i][len+1]); if (olen >= buflen) {

pthread_mutex_unlock(&env_mutex); return(ENOSPC);

}

strcpy(buf, &environ[i][len+1]); pthread_mutex_unlock(&env_mutex); return(0);

}

}

pthread_mutex_unlock{&env_mutex);

return(ENOENT);

图12-12 getenv的可重入（线程安全）版本    1秘|

要使重入，需要改变接口，调用者必须提供它自己的缓冲区，这样每个线程可

以使用各自不同的缓冲区避免其他线程的干扰。但是，注意，要想使geterw_r成为线程安全的，

这样做还不够，需要在搜索请求的字符时保护环境不被修改。可以使用互斥量，通过getenv_r

和putenv函数对环境列表的访问进行串行化。

可以使用读写锁，从而允许对getenv_r进行多次并发访问，但增加的并发性可能并不会在

很大程度上改善程序的性能，这里面有两个原因：第一，环境列表通常并不会很长，所以扫描列 表时并不需要长时间地占有互斥量：第二，对getenv和putenv的调用也不是频繁发生的，所 以改善它们的性能并不会対程序的整体性能产生很大的影响。

即使可以把getenv_r变成线程安全的，这也不意味着它对信号如®程序是可重入的。如果使用 的是非递归的互斥量，线程从信号处理程序中调用getenv_r就有可能出现死锁。如果信号处理程序 在线程执行getenvj时中断了该线程，这时我们已经占有加锁的erw_mUtex，这样其他线程试图对 这个互斥量的加锁就会被阻塞，最终导致线程进入死锁状态。所以，必须使用递归互斥量阻止其他线程 改变我们正需要的数据结构，还要阻止来自信号处理程序的死锁。问题是pthread函数并不保证是异步 信号安全的，所以不能把pthread函数用于其他函数，让该函数成为异步信号安全的。    ■

12.6线程特定数据

线程特定数据(thread-specific data)，也称为线程私有数据(thread-private data)，是存储和查 询某个特定线程相关数据的一种机制。我们把这种数据称为线程特定数据或线程私有数据的原因 是，我们希望每个线程可以访问它自己单独的数据副本，而不需要担心与其他线程的同步访问问题。

线程模型促进了进程中数据和属性的共享，许多人在设计线程模型时会遇到各种麻烦》那么 为什么有人想在这样的模型中促进阻止共享的接口呢？这其中有两个原因。

第一，有时候需要维护基于每线程(per-Aread)的数据。因为线程ID并不能保证是小而连续的整 数，所以就不能简单地分配一个每线程数据数组，用线程ID作为数组的索引。即使线程ID确实是小而 连续的整数，我们可能述希望有一咎额外的保护，防止某个线程的数据与其他线程的数据相混淆。

采用线程私有数据的第二个原因是，它提供了让基于进程的接口适应多线程环境的机制。一 个很明显的实例就是errnoo回忆1.7节中对errno的讨论。以前的接口(线程出现以前)把 errno定义为进程上下文中全局可访问的整数。系统调用和库例程在调用或执行失败时设置

[446] errno,把它作为操作失败时的附属结果。为了让线程也能够使用那些原本基于进程的系统调用 和库例程，errno被重新定义为线程私有数据。这样，一个线程做了重置errno的操作也不会 影响进程中其他线程的errno值。

我们知道一个进程中的所有线程都可以访问这个进程的整个地址空间，除了使用寄存器以 外，一个线程没有办法阻止另一个线程访问它的数据。线程特定数据也不例外。虽然底层的实现 部分并不能阻止这种访问能力，但管理线程特定数据的函数可以提高线程间的数据独立性，使得 线程不太容易访问到其他线程的线程特定数据。

在分配线程特定数据之前，需要创建与该数据关联的键。这个键将用于获取对线程特定数据 的i方问。使用pthread_key_create创建一个键。

\#include <pthread.h>

int pthread_key_create (pthread_key_t *keyp, void destructor) {void ”)；

返回值：若成功，返回th否则，返回错误编号

创建的键存储在teyp指向的内存单元中，这个键可以被进程中的所有线程使用，但每个线程 把这个键与不同的线程特定数据地址进行关联。创建新键时，每个线程的数据地址设为空值。

降了创建键以外，pthread_key_create可以为该键关験一个可选择的析构函数。当这个

线程退出时，如果数据地址己经被置为非空值，那么析构函数就会被调用，它唯一的参数就是该 数据地址。如果传入的析构函数为空，就表明没有析构函数与这个键关联。当线程调用 pthread_eXit或者线程执行返回，正常退出时，析构函数就会被调用。同样，线程取消时，只 有在最后的清理处理程序返回之后，析构函数才会被调用。如果线程调用了 exit、_exit、_Exit 或abort,或者出现其他非正常的退出时，就不会调用析构函数。

线程通常使用malloc为线程特定数据分配内存。析构函数通常释放已分配的内存。如果线 程在没有释放内存之前就退出了，那么这块内存就会丢失，即线程所属进程就出现了内存泄漏。

线程可以为线程特定数据分配多个键，每个键都可以有一个析构函数与它关联，每个键的析 构函数可以互不相同，当然所有键也可以使用相同的析构函数。每个操作系统实现可以对进程可 分配的键的数量进行限制（回忆一下图12-1中的PTHREAD_KEYS_MAX）。

线程退出时，线程特定数据的析构函数将按照操作系统实现中定义的顺序被调用，析构函数 可能会调用另一个函数，该函数可能会创建新的线程特定数据，并且把这个数据与当前的键关联起 来。当所有的析构函数都调用完成以后，系统会检査是否还有非空的线程特定数据值与键关联，如 果有的话，再次调用析构函数。这个过程将会一直重复直到线程所有的键都为空线程特定数据值，

或者已经做了 PTHREAD_DESTRUCTOR_ITERATIONS （见图12-1）中定义的最大次数的尝试。

对所有的线程，我们都可以通过调用pthread_key_delete来取消键与线程特定数据值之 间的关联关系。    [53

^include <pthread.h>

int pthread_key_delete (pthread_key_t key);

返回值：若成功，返回0:否则，返回错误编号

注意，调用pthreadUceyjelete并不会激活与键关联的析构函数。要释放任何与键关联 的线程特定数据值的内存，需要在应用程序中采取额外的步骤。

需要确保分配的键并不会由于在初始化阶段的竞争而发生变动。下面的代码会导致两个线程 都调用 pthread_key_createo

void destructor（void *）;

pthread_key_t key; int init_done = 0;

int

threadfunc(void *arg)

{

if (!init_done) { init_done = 1;

err = pthread_key_create(&key, destructor);

J

}

有些线程可能看到一个键值，而其他的线程看到的可能是另一个不同的键值，这取決于系统是如 何调度线程的，解决这种竞争的办法是使用pthread_onceo #include <pthread.h>

pthread_once_t initflag = PTHREAD_ONCE_INIT;

int pthread_once (pthread_once_t *initflag, void {★initfh} (void));

返回值：若成功.返回0:否则.返回错误编号

initflag必须是一个非本地变量(如全局变量或静态变量)，而且必须初始化为PTHREAD, 0NCE_INITo

如果每个线程都调用pthread_onCe,系统就能保证初始化例程Zm*诉只被调用一次，即系 统首次调用pthread_Once时。创建键时避免出现冲突的一个正确方法如下：

void destructor(void *); pthread_key_t key;

j448| pthread_once_t init_done = PTHREAD_ONCE_INIT； void

thread_init(void)

t

err = pthread_key_create(skey, destructor);

}

int

threadfunc(void *arg)

1

pthread_once(&init_done, thread_init);

键一旦创建以后，就可以通过调用pthread_setspecific函数把键和线程特定数据关联 起来。可以通过pthread_getspecific函数获得线程特定数据的地址。

♦include <pthread.h>

void *pthread_get5pecif ic (pthread_key_t key);

返回值：线程特定数据值：若没有值与该键关联，返回HULL

int pt hread_set specif ic (pthread_key_t key, const void * value};

返回值：若成功i返回0;否则，返回错误编号

如果没有线程特定数据值与键关联，pthreac^getspecific将返回一个空指针，我们可 以用这个返回值来确定是否需要调用pthread_setspecifico 珀■实例

图12-11给出了 getenv的假设实现。接着又给出了一个新的接口，提供的功能相同，不过 它是线程安全的(见图12-12)。但是如果不修改应用程序，直接使用新的接口会出现什么问题呢？ 这种情况下，可以使用线程特定数据来维护每个线程的数据缓冲区副本，用于存放各自的返回字 符串，如图12-13所示。

ttinclude <limits.h> ♦include <string.h> linclude <pthread.h> #include <stdlib.h> #define MAXSTRINGSZ 4096

static pthread_key_t key;

static pthread_once_t init_done = PTHREAD_ONCE_INIT;

pthread_mutex_t env_mutex = PTHREAD_MUTEX_INITIALIZER;    |449!

extern char **environ;

static void

thread_init(void)

(

pthread_key_create(&key, free);

} char getenv(const char *name)

int    i, len;

char    *envbuf;

pthread_once{&init_done, thread_init);

pthread_mutex_lock(&env_mutex);

envbuf = (char *)pthread_getspecific(key)；

if (envbuf == NULL)(

envbuf = malloc(MAXSTRINGSZ); if {envbuf == NULL) {

pthread_mutex_unlock(&env_mutex); return(NULL》；

pthread_setspecific(key, envbuf); f

len = strlen(name);

for (i = 0; environ[i] != NULL; i++) {

if ((strncmp(name, environ[i], len) == 0) &&

{environ[i][len] — '=')}    {

strncpy(envbuf, fienviron[i][len+1], MAXSTRINGSZ-1); pthread_mutex_unlock{&env_mutex);

return(envbuf);

}

pthread_mutex_unlock(&env_mutex)；

return(NULL)；

图12-13线程安全的getenv的兼容版本

我们使用pthread„once来确保只为我们将使用的线程特定数据创建一个键。如果 pthread.getspecific返回的是空指针，就需要先分配内存缓冲区，然后再把键与该内存缓 冲区凳联。否则，如果返回的不是空指针，就使用pthread_getspecific返回的内存缓冲区。 对析构函数，使用free来释放之前由malloc分配的内存。只有当线程特定数据值为非空时，

析构函数才会被调用。

注意，虽然这个版本的getenv是线程安全的，但它并不是异步信号安全的，对信号处理程 序而言，即使使用递归的互斥量，这个版本的getenv也不可能是可重入的，因为定调用了 malloc,而malloc函数本身并不是异步信号安全的。    ®


###### 12.7取消选项

有两个线程属性并没有包含在pthread_attr_t结构中，它们是可承消状态和可取消类型。 这两个属性影响着线程在响应pthread_canCel函数调用时所呈现的行为（见11.5节〉。

可取消状态属性可以是 PTHREAD_CANCEL_ENABLE,也可以是 PTHREAD_CANCEL_DISABLE。 线程可以通过调用pthread_set cancel state修改定的可取消状态。

^include <pthread.h>

int pthread_setcancelstate (int state, int *oldstate};

返回值：若成功，返回0:否则，返回错误编号

pthread_setcancelstate把当前的可取消状态设置为state,把原来的可取消状态存储在由 o/Aw佗指向的内存单元t这两步是一个原子操作。

回忆11.5节，pthreadcancel调用并不等待线程终止。在默认情况下，线程在取消请求发出 以后还是继续运行，直到线程到迖某个取消点。取消点是线程检査它是否被取消的一个位置，如果取 消了，则按照请求行事。POSIX.I保证在线程调用图12-14中列出的任何函数时，取消点都会出现。

| accept          | mq timedsend           | pthread join       | sendto       |
| --------------- | ---------------------- | ------------------ | ------------ |
| aio suspend     | msgrcv                 | pthread testcancel | sigsuspend   |
| clock nanosleep | msgsnd                 | pwrite             | sigtimedwait |
| close           | msync                  | read               | sigwait      |
| connect         | nanosleep              | readv              | sigwaitinfo  |
| creat           | open                   | recv               | sleep        |
| fcntl           | openat                 | recvfrom           | system       |
| fdatasync       | pause                  | recvmsg            | tcdrain      |
| f sync          | poll                   | select             | wait         |
| lockf           | pread                  | sem timedwait      | waitid       |
| mq receive      | pselect                | sem wait           | waitpid      |
| mq send         | pthread cond timedwait | send               | write        |
| mq timedreceive | pthread cond wait      | sendmsg            | writev       |

图12-14 P0SEX.1定义的取消点

线程启动时默认的可取消状态是PTHREAD_CANCEL_ENABLE。当状态设为PTHREAD_ CANCELDISABLE时，对pthread_cancel的调用并不会杀死线程。相反，取消请求对这个线 程来说还处于挂起状态，当取消状态再次变为PTHREAD_CANCEL_ENABLE时，线程将在下一个 取消点上对所有挂起的取消请求进行处理。

[45?| 除了图12-14中列出的函数，POSIX.1还指定了图12-15中列出的函数作为可选的取消点。

图12-15中列出的有些函数并没有在本书中进一步讨论，例如，处理消息分类和宽字符集的函数。

如果应用程序在很长的一段时间内都不会调用图12-14或图12-15中的函数（如数学计算领

域的应用程序），那么你可以调用pthread_testcancel函数在程序中添加自己的取消点。

\#include <pthread.h>

void pthread„testcancel(void);

调用pthreadjiestcancel时，如果有某个取消请求正处于挂起状态，而且取消并没有置 为无效，那么线程就会被取消。但是，如果取消被置为无效，pthreacCtestcancel调用就没 有任何效果了a

| access      | fseeko           | getwchar                   | putwc       |
| ----------- | ---------------- | -------------------------- | ----------- |
| catclose    | fsetpos          | glob                       | putwchar    |
| catgets     | fstat            | iconv close                | readdir     |
| catopen     | fstatat          | iconv open                 | readdir r   |
| chmod       | ftell            | ioctl                      | readlink    |
| chown       | ftello           | link                       | readlinkat  |
| closedir    | futiraens        | linkat                     | remove      |
| closelog    | fwpxintf         | lio listio                 | rename      |
| ctermid     | fwrite           | localtime                  | renameat    |
| dbm close   | fwscanf          | localtime r                | rewind      |
| dbm delete  | getaddrinfo      | lockf                      | rewinddir   |
| dbm fetch   | getc             | lseek                      | scandir     |
| dbm nextkey | getc unlocked    | lstat                      | scanf       |
| dbm open    | getchar          | mkdir                      | aeekdir     |
| dbm store   | getchar unlocked | mkdirat                    | semop       |
| dlclose     | getcwd           | mkdtemp                    | setgrent    |
| dlopen      | getdate          | mkfifo                     | sethostent  |
| dprintf     | getdelim         | mkfifoat                   | setnetent   |
| endgrent    | getgrent         | mknod                      | setprotoent |
| endhostent  | getgrgid         | mknodat                    | setpwent    |
| endnetent   | Qetqrqid r       | mkstemp                    | setservent  |
| endprotoent | getgrnam         | mktime                     | setutxent   |
| endpwent    | getgrnam r       | nftw                       | atat        |
| endservent  | gethostent       | opendir                    | strerror    |
| endutxent   | gethostid        | openlog                    | strerror r  |
| faccessat   | gethostname      | pathconf                   | strftime    |
| fchmod      | getline          | pclose                     | symlink     |
| fchmodat    | getlogin         | perror                     | symlinkat   |
| fchown      | getlogin r       | popen                      | sync        |
| fchownat    | getnameinfo      | posix fadvise              | syslog      |
| fclose      | getnetbyaddr     | posix fallocate            | tmpfile     |
| fcntl       | getnetbyname     | posix madvise              | ttyname     |
| fflush      | getnetent        | posix_openpt               | ttyname_r   |
| fgetc       | getopt           | posix spawn                | tzset       |
| fgetpos     | getprotobyname   | posix spawnp               | ungetc      |
| fgets       | getprotobynumber | posix typed mem open       | ungetwc     |
| fqetwc      | qetprotoent      | printf                     | unlink      |
| fgetws      | getpwent         | psiginfo                   | unlinkat    |
| fmtmsg      | getpwnam         | psignal                    | utimensat   |
| fopen       | getpwnam r       | pthread rwlock rdlock      | utimes      |
| fpathconf   | getpwuid         | pthread rwlock timedrdlock | vdprintf    |
| fprintf     | getpwuid r       | pthread rwlock timedwrlock | vfprintf    |
| fputc       | getservbyname    | pthread rwlock wrlock      | vfwprintf   |
| fputs       | getservbyport    | putc                       | vprintf     |
| fputwc      | getservent       | putc_unlocked              | vwprintf    |
| fputws      | getutxent        | putchar                    | wcsftime    |
| fread       | getutxid         | putchar unlocked           | wordexp     |
| freopen     | getutxline       | puts                       | wprintf     |
| fscanffseek | getwc            | pututxline                 | wscanf      |

图12-15 POSIX.1定义的可选取消点

我们所描述的默认的取消类型也称为推迟取消。调用pthreacLcancel以后，在线程到远取 消点之前，并不会出现真正的取消。可以通过调用pthreatsetcanceltype来修改取消类型。 #include <pthread.h>

int pthread_setcanceltype (int type, int *oldtype};

返回值：若成功，返回0:否则，返回错误编号

pthread_setcanceltype函数把取消类型设置为⑽e （类型参数可以是PTHREADCANCEL_ DEFERRED,也可以是PTHREAD_CANCEL_ASYNCHRONOUS ），把原来的取消类型返回到oWl）戸 指向的整型单元。

异步取消与推迟取消不同，因为使用异步取消时，线程可以在任意时间撤消，不是非得遇到 取消点才能被取消。

12.8线程和信号

即使是在基于进程的编程范型中，信号的处理有时候也是很复杂的。把线程引入编程范型， 就使信号的处理变得更加复杂。

每个线程都有自己的信号屏蔽字，但是信号的处理是进程中所有线程共享的。这意味着单个 线程可以阻止某些信号，但当某个线程修改了与某个给定信号相关的处理行为以后，所有的线程 都必须共享这个处理行为的改变8这样，如果一个线程选择忽略某个给定信号，那么另一个线程 就可以通过以下两种方式撤消上述线程的信号选择：恢复信号的默认处理行为，或者为信号设置 一个新的信号处理程序。

进程中的信号是递送到单个线程的。如果一个信号与硬件故障相关，那么该信号一般会被发 送到引起该事件的线程中去，而其他的信号则被发送到任意一个线程。

452

I

453



10.12节讨论了进程如何使用sigprocmask函数来阻止信号发送。然而，sigprocmask 的行为在多线程的进程中并没有定义，线程必须使用pthread_sigmasko #include <signal.h>

int pthread_sigmask （int haw, const sigset_t .restrict set, sigset_t ^restrict oset）;

返回值：若成功，返回0:否则，返回错误编号

pthread_sigmask 函数与 sigprocmask 函数基本相同，不过 pthread_sigmask 工作 在线程中，而且失败时返回错误码，不再像sigprocmask中那样设置errno并返回-1。参 数包含线程用于修改信号屏蔽字的信号集。Aow参数可以取下列3个值之一：SIG.BLOCK,把信 号集添加到线程信号屏蔽字中，SIG_SETMASK，用信号集替换线程的信号屏蔽字； SIG_UNBLOCK,从线程信号屏蔽字中移除信号集。如果ewe/参数不为空，线程之前的信号屏蔽 字就存储在它指向的sigsetj;结构中。线程可以通过把sef参数设置为NULL,并把w打参数 设置为sigset_t结构的地址，来获取当前的信号屏蔽字。这种情况中的/row参数会被忽略。

线程可以通过调用sigwait等待一个或多个信号的出现。

♦include <signal.h>

int sigwait (const sigset_t *restrict set, int * restrict signop);

返回值：若成功，返回(h否则，返回错误编号

参数指定了线程等待的信号集。返回时，指向的整数将包含发送信号的数量。 如果信号集中的某个信号在sigwait调用的时候处于賊状态，那么sigwait将无阻塞地返回。

在返回之前，sigwait将从进程中移除那些处于挂起等待状态的信号。如果具体实现支J辨队信号， 并且信号的多个实例被挂起，那么sigwait将会移除该信号的一个实例，其他的实例还要继续排队。

为了避免错误行为发生，线程在调用sigwait之前，必须阻塞那些它正在等待的信号。

sigwait函数会原子地取消信号集的阻塞状态，直到有新的信号被递送。在返囘之前，sigwait 将恢复线程的信号屏蔽字。如果信号在sigwait被调用的时候没有被阻塞，那么在线程完成対 sigwait的调用之前会出现一个时间窗，在这个时间窗中，信号就可以被发送给线程。

使用sigwait的好处在于它可以简化信号处理，允许把异步产生的信号用同步的方式处理。

为了防止信号中断线程，可以把信号加到每个线程的信号屏蔽字中。然后可以安排专用线程处理 信号。这些专用线程可以进行函数调用，不需要担心在信号处理程序中调用哪些函数是安全的，

因为这些函数调用来自正常的线程上下文，而非会中断线程正常执行的传统信号处理程序。

如果多个线程在sigwait的调用中因等待同一个信号而阻塞，那么在信号递送的时候，就 只有一个线程可以从sigwait中返回。如果一个信号被捕获（例如进程通过使用sigaction |454[ 建立了一个信号处理程序），而且一个线程正在sigwait调用中等待同一信号，那么这时将由操 作系统实现来决定以何种方式递送信号，操作系统实现可以让sigwait返回，也可以激活信号 处理程序，但这两种情况不会同时发生。

要把信号发送给进程，可以调用kill （见10.9节）。要把信号发送给线程，可以调用pthreacL kill。

\#include <signal.h>

int pthread_kill (pthread_t thread, int signoi ;

返回值：若成功，返回0:否则，返回错误编号

可以传一个0值的来检查线程是否存在。如果信号的默认处理动作是终止该进程，那 么把信号传递给某个线程仍然会杀死整个进程。

注意，闹钟定时器是进程资源，并且所有的线程共享相同的闹钟。所以，进程中的多个线程 不可能互不干扰（或互不合作）地使用闹钟定时器（这是习题12.6的内容

I实例

回忆图10-23所示的程序，我们等待信号处理程序设置标志表明主程序应孩退出。唯一可运 行的控制线程就是主线程和信号处理程序，所以阻塞信号足以避免错失标志修改。在线程中，我 们需要使用互斥量来保护标志，如图12-16中的程序所示。

Sinclude "apue.h"

番include <pthread.h>

int    quitflag;    /* set nonzero by thread */

sigset_t    mask;

pthread_mutex_t lock = PTHREADJ4UTEX_INITIALIZER; pthread_cond_t waitloc = PTHREAD_COND_INITIALIZER;

void *

thr_fn(void *arg)

int err, signo;

for (;;)(

err = sigwait(&mask, &signo); if (err != 0)

err_exit (err, "sigwait failed")，-

switch (signo) { case SIGINT:



printf("\ninterrupt\n"); break;

case SIGQUIT:

pthread_mutex_lock(slock); quitflag = 1;

pthread_mutex_unlock(&lock); pthread_cond_signal(fiwaitloc); return(0);

default:

printf("unexpected signal %d\n", signo); exit (1);



int

main(void)

int

sigset_t



err；

oldmask;



pthread_t tid;

sigemptyset(&mask); sigaddset(&mask, SIGINT); sigaddset(&mask, SIGQUIT>;

if ((err = pthread_sigmask(SIG^BLOCK, &mask, &oldmask)) := 0) err_exit(err, "SIG_BLOCK error"};

err = pthread_create(Stid, NULL, thr_fn, 0); if (err != 0)

err_exit(err, "can't create thread");

pthread_mutex_lock(Slock); while (quitflag == 0)

pthread_cond_wait(&waitloc, slock); pthread_mutex_unlock(Slock);

/* SIGQUIT has been caught and is now blocked； do whatever */ quitflag = 0;

/* reset signal mask which unblocks SIGQUIT */ if (sigprocmask{SIG_SETMASK, Soldmask, NULL) < 0)

err_sys「SIG_SETMASK error"); exit (0);

J

图12-16同步信号处理

我们不用依赖信号处理程序中断主控线程，有专门的独立控制线程进行信号处理。在互斥量的 |456j保护下改动quitflag的值，这样主授线程不会在调用pthread_cond_signal时错失唤醒调用。

在主控线程中使用相同的互斥量来检查标志的值，并且原子地释放互斥量，等待条件的发生。

注意，在主线程开始时阻塞SIGINT和SIGQUIT。当创建线程进行信号处理时，新建线程 继承了现有的信号屏蔽字。因为sigwait会解除信号的阻塞状态，所有只有一个线程可以用于 信兮的接收。这可以使我们对主线程进行编码时不必担心来自这些信号的中断。

运行这个程序可以得到与图10-23类似的输出结果：

$ ./a.out

*?    输入中断字符

interrupt

*?    再次输入中断字符

interrupt

*?    再次输入中断字符

interrupt

A\$    现在用退出符终止    ■

##### 12.9线程和fork

当线程调用fork时，就为子进程创建了整个进程地址空间的副本。回忆8.3节中讨论的写 时复制，子进程与父进程是完全不同的进程，只要两者都没有对内存内容做出改动，父进程和子 进程之间还可以共享内存页的副本。

子进程通过继承整个地址空间的副本，还从父进程那儿继承了每个互斥量、读写锁和条件变 量的状态。如果父进程包含一个以上的线程，子进程在fork返回以后，如果紧接着不是马上调 用exec的话，就需要清理锁状态。

在子进程内部，只存在一个线程，它是由父进程中调用fork的线程的副本构成的。如果父 进程中的线程占有锁，子进程将同样占有这些锁。问题是子进程并不包含占有锁的线程的副本，

所以子进程没有办法知道它占有了哪些锁、需要释放哪些锁。

如果子进程从fork返回以后马上调用其中一个exec函数，就可以避免这样的问题，这种 情况下，旧的地址空间就被丢弃，所以锁的状态无关紧要。但如果子进程需要继续做处理工作的 话，这种策略就行不通，还需要使用其他的策略。

在多线程的进程中，为了避免不一致状态的问题，POSIX.1声明，在fork返回和子进程调 用其中一个exec函数之间，子进程只能调用异步信号安全的函数。这就限制了在调用exec之 前子进程能做什么，但不涉及子进程中锁状态的问题。

要清除锁状态，可以通过调用pthread_atfork函数建立fork处理程序。    岡

\#include <pthread.h>

int pthread^atfork {void prepare) (void} , void {★parent} (void), void child} (void));

返回值：若成功，返回0:否则，返回错误编号

用pthread_atfork函数最多可以安装3个帮助清理锁的函数。pr^are fork处理程序由父进程 在fork创建子进程前调用。这个fork处理程序的任务是获取父进程定义的所有锁。戸咖foric处理 程序是在fork创建子进程以后、返回之前在父进程上下文中调用的。这个fork处理程序的任务是对 prepare fork处理程序萩取的所有锁进行解锁。child folk处理程序在fork返回之前在子进程上下文中 调用。与/wjrenffolk处理程序一样，cAi/rffoik处理程序也必须释放处理程序获取的所有锁。

注意，不会出现加锁一次解锁两次的情况，虽然看起来也许会出现。子进程地址空间在创建时就

得到了父进程定义的所有锁的副本。因为prepare fork处理程序获取了所有的锁，父进程中的内存和 子进程中的内存内容在开始的时候是相同的。当父进程和子进程对它们锁的副本进程解锁的时候，新 的内存是分配给子进程的，父进程的内存内容是复制到子进程的内存中(写时复制)，所以我们就会 陷入这样的假象，看起来父进程对它所有的锁的副本进行了加锁，子进程对它所有的锁的副本进行了 加锁。父进程和子进程対在不同内存单元的重复的锁都进行了解锁操作，就好像出现了下列事件序列。

U)父进程获取所有的锁。

(2)    子进程获取所有的锁。

(3)    父进程释放它的锁。

(4)    子进程释放它的锁。

可以多次调用pthread.atfork函数从而设置多套fork处理程序，如果不需要使用其中某 个处理程序，可以给特定的处理程序参数传入空指针，它就不会起任何作用了。使用多个fork处 理程序时，处理程序的调用顺序并不相同。/wren/和：/Wfork处理程序是以它们注册时的顺序进 行调用的，而prepare fork处理程序的调用顺序与它们注册时的顺序相反。这样可以允许多个模 块注册它们自己的fork处理程序，而且可以保持锁的层次。

例如，假设模块乂调用模块S中的函数，而且每个模块有自己的一套锁。如果锁的层次是

在S之前，模块S必须在模块之前设置它的fork处理程序。当父进程调用fork时，就会执行 以下的步骤，假设子进程在父进程之前运行：

(1)    调用模块的prepare fork处理程序获取模块乂的所有锁。

(2)    调用模块S的处理程序获取模块5的所有锁。

(3)    创建子进程。

(4)    调用模块S中的fork处理程序释放子进程中模块B的所有锁。

(5)    调用模块中的fork处理程序释放子进程中模块的所有锁。

(6)    fork函数返回到子进程。

(7)    调用模块S中的parenz fork处理程序释放父进程中模块B的所有锁。

(8)    调用模块X中的处理程序来释放父进程中模块J的所有锁。

(9) fork函数返回到父进程。

如果fork处理程序是用来清理锁状态的，那么又由谁来负责清理条件变量的状态呢？在有些 操作系统的实现中，条件变量可能并不需要做任何清理。但是有些操作系统实现把锁作为条件变 量实现的一部分，这种情况下的条件变量就需要清理。问题是目前不存在允评清理锁状态的接口。 如果锁是嵌入到条件变量的数据结构中的，那么在调用fork之后就不能使用条件变量，因为还 没有可移植的方法对锁进行状态清理。另外，如果操作系统的实现是使用全局锁保护进程中所有 的条件变量数据结构，那么操作系统实现本身可以在fork库例程中做清理锁的工作，但是应用 程序不应该依赖操作系统实现中类似这样的细节。

、实例

图12-17中的程序描述了如何使用pthreaci_atfork和fork处理程序。

\#include "apue.h"

\#include <pthread.h>

pthread_mutex_t lockl = PTHREAD_MUTEX_INITIALIZER; pthread_mutex_t lock2 = PTHREAD_MUTEX_INITIALIZER;

void

prepare(void)

{

int err;

printf("preparing locks.,.\n");

if ((err = pthread_mutex_lock(filockl)) != 0)

err_cont(err, "can't lock lockl in prepare handler"); if ((err = pthread_mutex_lock(&lock2)) != 0)

err_cont{err, "can't lock lock2 in prepare handler")；

void

parent(void)

{

int err;

printf{"parent unlocking locks...\n");

if “err = pthread_mutex_unlock(filockl))    != 0)

err_cont(err, "can't unlock lockl in parent handler");

if {(err = pthread_mutex_unlock(&lock2))    != 0)

err_cont (err, "can' t unlock lock2 in parent handler'*)；

void

child(void)

1

int err;

printf{"child unlocking locks...\n");

if ((err = pthread_mutex_unlock(Slockl)) != 0)

err_cont(err, "can't unlock lockl in child handler"

if (<err = pthread_mutex_unlock(&lock2)) != 0)

err_cont(err, "can't unlock lock2 in child handler"

void *

thr_fn(void *arg)

{

printf("thread started...\n"); pause (); return (0);

int

main(void)

(

int    err;

pid_t    pid;

pthread_t    tid;

if {(err = pthread_atfork(prepare, parent, child)) != 0) err_exit (err, "can't install fork handlers'”；

if ((err = pthread_create(Stid, NULL, thr_fn, 0)) != 0)

err_exit (err, ’’can’t create thread");

sleep(2);

printf("parent about to fork...\n");

if {(pid = fork<)) < 0)

err_quit("fork failed");

else if {pid == 0)    /* child */

printf("child returned from fork\n");

else /* parent */

printf("parent returned from fork\n");

exit(0);

14601    图 12-17 pthread_atfork 实例

图12-17中定义了两个互斥量，lockl和lock2,    fork处理程序萩取这两把锁，child

fork处理程序在子进程上下文中释放它们，parent fork处理程序在父进程上下文中释放它们， 运行该程序，得到如下输出：

$ ./a.out

thread started... parent about to fork.,. preparing locks... child unlocking locks... child returned from fork parent unlocking locks... parent returned from fork

可以看到，pre/wre fork处理程序在调用fork以后运行，cA/Wfork处理程序在fork调用返回到 子进程之前运行，parent fork处理程序在fork调用返回给父进程之前运行。    ■

虽然pthread_atfork机制的意图是使fork之后的锁状态保持一致，但它还是存在一些 不足之处，只能在有限情况下可用。

•没有很好的办法对较复杂的同步对象（如条件变量或者屏障）进行状态的重新初始化。

•某些错误检查的互斥量实现在child fork处理程序试图对被父进程加锁的互斥量进行解锁

时会产生错误。

•递归互斥量不能在child fork处理程序中清理，因为没有办法确定该互斥量被加锁的次数。 •如果子进程只允许调用异步信号安全的函数，fork处理程序就不可能清理同步对象，

因为用于操作清理的所有函数都不是异步信号安全的。实际的问题是同步对象在某个线 程调用fork时可能处于中间状态，除非同步对象处于一致状态，否则无法被清理。

•如果应用程序在信号处理程序中调用了 fork （这是合法的，因为fork本身是异步信号安 全的），pthreacLatfork注册的fork处理程序只能调用异步信号安全的函数，否则结 果将是未定义的。

##### 12.10线程和I/O

3.11节介绍了 pread和pwrite函数。这些函数在多线程环境下是非常有用的，因为进程 中的所有线程共享相同的文件描述符。

考虑两个线程，在同一时间对同一个文件描述符进行读写操作。

线程A    线程B

Iseektfd, 300, SEEK_SET);    lseekffd, 700, SEEK_SET);

read(fd, bufl, 100);    read(fd, buf2, 100);

如果线程A执行lseek然后线程B在线程A调用read之前调用Iseek,那么两个线程最 终会读取同一条记录。很显然这不是我们希望的。

为了解决这个问题，可以使用pread,使偏移量的设定和数据的读取成为一个原子操作。

线程A    线程B

pread(fd, bufl, 100, 300);    pread(fd, buf2, 100, 700);

使用pread可以确保线程A读取偏移量为300的记录,而线程B读取偏移量为700的记录，

可以使用pwrite来解决并发线程对同一文件进行写操作的问题。

##### 12.11小结

在UNIX系统中，线程提供了分解并发任务的另一种模型。线程促进了独立控制线程之间的 共享，但也出现了它特有的同步问题。本章中，我们了解了如何调整线程和它们的同步原语，讨 论了线程的可重入性，还学习了线程如何与其他面向进程的系统调用进行交互，

习题

12.1在Linux系统中运行图12-17中的程序，但把输出结果重定向到一个文件中，并解释结果。

12.2实现putenv_r，即putenv的可重入版本。确保你的实现既是线程安全的，也是异步信

号安全的。

12.3是否可以通过在getenv函数开始的时候阻塞信号，并在getenv函数返回之前恢复原來 的信号屏蔽字这种方法，让图12-13中的getenv函数变成异步信号安全的？解释其原因。

12.4写一个程序练习图12-13中的getenv版本，在FreeBSD上编译并运行程序，会出现什么 结果？解释其原因。

12.5假设可以在一个程序中创建多个线程执行不同的任务，为什么还是有可能会需要用fork?

解释其原因。

12.6重新宪现图10-29中的程序，在不使用nanosleep或clock_nanosleep的情况下使它 成为线程安全的。

12.7调用fork以后，是舌可以通过首先用pthread_cond_destroy销毁条件变量，然后用 Pthread_cond_init初始化条件变量这种方法安全地在子进程中对条件变量进行重新初 始化？

12.8图12-8中的timeout函数可以大大简化，解释其原因=    1舶21
