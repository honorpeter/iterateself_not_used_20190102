---
title: 04 文件和目录
toc: true
date: 2018-08-21 18:15:07
---
#### 文件和目录

###### 4.1引言

上一章我们说明了执行I/O操作的基本函数，其中的讨论是围绕普通文件I/O进行的——打开 文件、读文件或写文件。本章将描述文件系统的其他特征和文件的性质。我们将从stat函数开始， 逐个说明stat结构的每一个成员以了解文件的所有属性。在此过程中，我们将说明修改这些属性 的各个函数（更改所有者、更改权限等），还将更详细地说明UNIX文件系统的结构以及符号链接。 本章最后介绍对目录进行操作的各个函数，并且开发了一个以降序遍历目录层次结构的函数。

##### 4-2 函数 stat、fstat〜fstatat 和 lstat

本章主要讨论4个stat函数以及它们的返回信息。

\#include <sys/stat.h>

int stat {const char ^restrict pathname, struct stat ^restrict buf}; int fstat (int fd, struct stat *buj);

int lstat (const char * restrict pathname, struct stat * restrict buf};

int fstatat (int fd, const char * restrict patimame, struct stat * restrict btf, int fiag}:

[93]



所有4个函数的返回值：若成功：返回0;若出错I返回-1

一-旦给出po决name，stat函数将返回与此命名文件有关的信息结构D fstat函数获得已 在描述符人/上打开文件的有关信息。lstat函数类似于stat，但是当命名的文件是一个符号 链接时，lstat返回该符号链接的有关信息，而不是由该符号链接引用的文件的信息。（在4.22 节中，当以降序遍历目录层次结构时，需要用到lstat。4.17节将更详细地说明符号链接。）

fstatat函数为一个相对于当前打开目录（由参数指向〉的路径名返回文件统计信息。 A/g参数控制着是否跟随着一个符号链接。当TVTLSYMLINICNOFOLLOW标志被设置时，fstatat 不会跟随符号链接，而是返回符号链接本身的信息。否则，在默认情况下，返回的是符号链接所 指向的实际文件的信息。如果/rf参数的值是AT_FDCWD,并且参数是一个相对路径名， fstatat会计算相対于当前目录的pathname参数。如果pathname是一个绝对路轻，参数就会 被，忽略。送两种情况下，根据及呀的取值，fstatat的作用就跟stat或lstat 样

第2个参数是一个指针，它指向一个我们必须提供的结构。函数来填充由指向的结 构。结构的实际定义可能随具体实现有所不同，但其基本形式是：

struct stat {

mode_t

ino_t

dev_t

dev_t

nlink_t

uid_t

gicLt

off_t

struct timespec struct timespec struct timespec blksize_t blkcnt_t



st_mode;

st_ino;

st_dev;

st_rdev;

st_nlink;

st_uid;

st_gid;

st_size;

st_atime;

st_mtime;

st_ctime;

st_blksize;

st_blocks;



/* file type & mode (permissions) */ /* i-node number (serial number) */

/* device number {file system) */

/* device number for special files */ /* number of links *Z

/* user ID of owner */ /* group ID of owner */

/* size in bytes, for regular files */ /* time of last access */

/* time of last modification */

/* time of last file status change */ /* best I/O block size */

/* number of disk blocks allocated */

j POSIX.l 未要求 st_rdev、st_blksize 和 st_blocks 字段。Single UNIX Specification XSI i扩展定义了这些字段。

timespec结构类型按照秒和纳秒定义了时间，至少包括下面两个字段：

time_t tv_sec; long Cv_nsec；

在2008年版以前的标准中，时间字段定义成st_atime、st_mtime以及st_ctime，它 j们都是tiine_t类型的(以秒来表示)。timespec结构提供了更高精度的时间戳。为了保持兼

容性，旧的名字可以定义成tv_sec成员。例如，st_atime可以定义成st_atim.tv_secD !叫|

注意，stat结构中的大多数成员都是基本系统数据类型(见2.8节)。我们将说明此结构的 每个成员以了解文件属性。

使用stat函数最多的地方可能就是Is -1命令，用其可以获得有关一个文件的所有 信息。

4.3文件类型

至此我们已经介绍了两种不同的文件类型：普通文件和目录。UNIX系统的大多数文件是普 通文件或目录，但是也有另外一些文件类型。文件类型包括如下几种。

(1)    普通文件(regular file)。这是最常用的文件樊型，这种文件包含了某种形式的数据。至 于这种数据是文本还是二进制数据，对于UNIX内核而言并无医别。对普通文件内容的解释由处 理该文件的应用程序进行。

:    一个值得注意的例外是二进制可执行文件。为了执行程序，内核必须理解其格式。所

j有二进制可执行文件都遵循一种标准化的格式，这种格式使内核能够确定程序文本和数据 ;的加载位置。

(2)    目录文件(directory file)。这种文件包含了其他文件的名字以及指向与这些文件有关信 息的指针=对一个目彔文件具有读权限的任一进程都可以读该目录的内容，但只有内核可以直接 写目录文件。进程必须使用本章介绍的函数才能更改目录。

(3)    块特殊文件(blockspecial file)。这种类型的文件提供对设备(如磁盘)带缓冲的访问， 每次访问以固定长度为单位进行。

注意，FreeBSD不再支持块特殊文件。对设备的所有访问需要通过字符特殊文件进行。

(4)    字符特殊文件(character special file)。这种类型的文件提供对设备不带缓冲的访问，每 次访问长度可变。系统中的所有设备要么是字符特殊文件，要么是块特殊文件。

(5)    FIFO。这种类型的文件用于进程间通信，有时也称为命名管道(namedpipe)、15.5节将 对其进行说明。

(6)    套接字(socket)。这种类型的文件用于进程间的网络通信。套接字也可用于在一台宿主 机上进程之间的非网络通信。第16章将用套接字进行进程间的通信。

(7)    符号链接(symbolic link)。这种类型的文件指向另一个文件。4.17节将更多地描述符号 链接。

|-95~|    文件类型信息包含在stat结构的st_mOde成员中。可以用图4-1中的宏确定文件类型。这

咎定的参数都是stat结构中的st_mode成员。

| 宏         | 文件类型     |
| ---------- | ------------ |
| S_ISREG()  | 普通文件     |
| S_ISDIR()  | 目录文件     |
| S_ISCHR()  | 字符特殊文件 |
| S_ISBLK()  | 块特殊文件   |
| S_ISFIFO() | 管道或FIFO   |
| S_ISLNK()  | 符号链接     |
| S ISSOCK{) | 套接字       |

图4~1在＜sys/stat.h＞^的文件类型宏

POSIX.1允许实现将进程间通信(IPC)对象(如消息队列和信号量等)说明为文件。图4^2中 的宏可用来从stat结构中确定IPC对象的类型。这些宏与图4-1中的不同，它们的参数并非 st_mode,而是指向stat结构的指针。

| 宏            | 对象的类型   |
| ------------- | ------------ |
| S_TYPEISMQ()  | 消息队列     |
| S_TYPEISSEM() | 信号量       |
| S TYPEISSHM() | 共享存储对象 |

图在＜373/3七31:.^1＞中的IPC类型宏

消息队列、信号量以及共享存储对象等将在第15章中讨论。但是，本书讨论的4种UNIX 系统都不将这些対象表示为文件。

■实例

图4-3程序取其命令行参数，然后针对每一个命令行参数打印其文件类型。

^include "apue.h" int

main(int argc, char *argv[]) {

int i; struct stat buf; char *ptr;

for (i = 1; i < argc; i++) { printf("%s: ", argv[i]); if {lstat(argv[i], &buf) < 0) {

err^ret("lstat error"); continue;

}

if {S_ISREG(buf.st_mode)) ptr = "regular";

else if (S_ISDIR(buf.st_mode)) ptr = "directory";

else if (S_ISCHR(buf.st_mode)) ptr = "character special"; else if (S_ISBLK(buf.st_mode),

ptr = "block special"; else if {S_ISFIFO{buf-st_mode))

ptr = "fifo";

else if (S_ISLNK(buf.st_mode)) ptr = "symbolic link";

else if (S„ISSOCK(buf.st_mode)) ptr = "socket";

else

ptr = "** unknown mode ** printf("%s\n", ptr);

}

exit (0);

图4-3对每个命令行参数打印文件类型

图4-3程序的示例输出是：

$ ./a.out /etc/passwd /etc /dev/log /dev/tty \

＞ /var/lib/oprofile/opd_pipd /dev/srO /dev/cdcom

/etc/passwd： regular

/etc: directory

/dev/log： socket

/dev/tty: character special

/var/lib/oprofile/opdj)ipe: fifo

/dev/srO: block special

/dev/cdrom: symbolic link

(其中，在第一个命令行末端我们键入了一个反斜杠，通知shell要在下一行继续键入命令，然后， shell在下一行上用其辅助提示符＞提示我们。)我们特地使用了 lstat函数而不是stat函数以 便检测符号链接。如若使用stat函数，则不会观察到符号链接。

早期的UNIX版本并不提供S_ISxxx宏，于是就需要将st_mode与屏蔽字S_IFMT进行逻 辑“与”运算，然后与名为s_IFxxx的常量相比较。大多数系统在文件＜sys/stat.h＞中定义 了此屏蔽字和相关的常量。如若査看此文件，则可找到S_ISDIR宏定义为：

ftdefine S_ISDIR (mode) (((mode) & S_IFMT) == S_IFDIR)

我们说过，普通文件是最主要的文件类型，但是观察一下在一个给定的系统中各种文件的比 例是很有意思的。图4-4显示了在一个单用户工作站Linux系统中的统计值和百分比。这些数据 是由4.22节中的程序得到的。

| 文件类型 | 统计值  | 百分比(％) |
| -------- | ------- | ---------- |
| 普通文件 | 415 803 | 79.77      |
| 目彔     | 62 197  | 11.93      |
| 符号链接 | 40 018  | 8.25       |
| 字符特殊 | 155     | 0+03       |
| 块特殊   | 47      | 0.01       |
| 套接字   | 45      | 0.01       |
| FIFO     | 0       | 0.00       |

图本4不同类型文件的统计值和百分比



1~971



###### 4.4设置用户ID和设置组ID

与一个进程相关联的ID有6个或更多，如图4-5所示。

| 实际用户1D实际组ID              | 我们实际上是谁                 |
| ------------------------------- | ------------------------------ |
| 有效用户ID 有效组ID 附属组ID    | 用于文件访问权限检査           |
| 保存的设置用户ID 保存的设置组ID | 由exec函数保存                 |
| 图4-5                           | 与每个进程相关联的用户ID和组ID |

•实际用户1D和实际组ID标识我们究竟是谁。这两个字段在登录时取自口令文件中的登 录项。通常，在一个登录会话期间这些值并不改变，但是超级用户进程有方法改变它们， 8.11节将说明这些方法。

•有效用户ID、有效组ID以及附属组ID决定了我:们的文件访问权限，下一节将对此进行 说明(我们已在1.8节中说明了附属组ID)。

•保存的设置用户ID和保存的设置组ID在执行一个程序时包含了有效用户ID和有效组ID 的副本，在8.11节中说明setuid函数时，将说明这两个保存值的作用。

在P0SIX.1 2001年版中，要求这些保存的ID。在早期POSIX版本中，它们是可选的。一个 应用程序在编译时可测试常f_POSIX_SAVED_IDS,或在运行时以参教_SC_SAVED_IDS调

；用函数sysconf,以判断此实现是否支持这一功能。

通常，有效用户ID等于实际用户ID，有效组ID等于实际组ID。

每个文件有一个所有者和组所有者，所有者由stat结构中的st_uid指定，组所有者则由 1^1 st_gid 指定。

当执行一个程序文件时，进程的有效用户ID通常就是实际用户ID，有效组ID通常是实际组 ID。但是可以在文件模式字(strode)中设置一个特殊标志，其含义是“当执行此文件时，将 进程的有效用户ID设置为文件所有者的用户ID (st_uid) ”。与此相类似，在文件模式字中可 以设置另一位，它将执行此文件的进程的有效组ID设置为文件的组所有者ID (St_gid)o在文 件模式字中的这两位被称为设置用户ID (set-user-ID)位和设置组ID (set-group4D)位。

例如，若文件所有者是超级用户，而且设置了该文件的设置用户ID位，那么当该程序文件

由一个进程执行时，该进程具有超级用户权限。不管执行此文件的进程的实际用户ID是什么， 都会是这样。例如，UNIX系统程序paSSwd（l）允许任一用户改变其口令，该程序是一个设置用 户ID程序。因为该程序应能将用户的新口令写入口令文件中（一般是/etc/passwd或/etc/ shadow）,而只有超级用户才具有对孩文件的写权限，所以需要使用设置用户ID功能。因为运 行设置用户ID程序的进程通常会得到额外的权限，所以编写这种程序时要特别谨慎。第8章将 更详细地讨论这种类型的程序。

再回到stat函数，设置用户江＞ 位及设置组ID位都包含在文件的st_mode值中。这两位 可计别用常量S_ISUID和S_ISGID测试。


4.5文件访问权限

strode值也包含了对文件的访问权限位。当提及文件时，指的是前面所提到的任何类型的 文件。所有文件类型（目录、字符特别文件等）都有访问权限（access permission）.,很多人认为 只有普通文件有访问权限，这是一种误解。

每个文件有9个诂问权限位，可将它们分成3类，见图4-6。

| st_mode 屏厳 | 含义     |
| ------------ | -------- |
| S_IRUSR      | 用户读   |
| S_IWUSR      | 用户写   |
| S IXUSR      | 用户执行 |
| S_IRGRP      | 组读     |
| S_IWGRP      | 组写     |
| S IXGRP      | 组执行   |
| S_IROTH      | 其他读   |
| S_IWOTH      | 其他写   |
| S IXOTH      | 其他执行 |

图4-6 9个访问权限位，取自＜sys/stat.h＞

在图4-6前3行中，术语用户指的是文件所有者（owner）。chmod（l）命令用于修改送9个权 限位。该命令允许我们用u表示用户（所有者），用g表示组，用o表示其他。有些书把这3种 用户类型分别称为所有者、组和世界。这会造成混乱，因为chmod命令用o表示其他，而不是间 所有者。我们将使用术语用户、组和其他，以便与chmod命令保持一致。

图4-6中的3类访问权限（即读、写及执行）以各种方式由不同的函数使用。我们将这些不 同的使用方式汇总在下面。当说明相关函数时，再进一步讨论。

•第一个规则是，我们用名字打开任一类型的文件时，对该名字中包含的每一个目录，包 括它可能隐含的当前工作目录都应具有执行权限。这就是为什么对于目录其执行权限位 常被称为搜索位的原因。

例如，力了打开文件/usr/include/stdio.h，需要射目录/、/usr 和/usr/include 具有执行权限。然后，需要具有对文件本身的适当权限|这取决于以何种模式打开它（只 读、读-写等）。

如果当前目录是/usr/include，那么为了打开文件stdio.h，需要对当前目录有执行 权限。送是隐含当前目录的一个示例。打开stdio.h文件与打开./stdio.h作用相同。

注意，对于目录的读权限和执行权限的意义是不相同的。读权限允许我们读目录，获得在 该目录中所有文件名的列表。当一个目录是我们要访问文件的路径名的一个组成部分时， 对读目录的执行权限使我们可通过该目录（也就是搜索该目录，寻找一个特定的文件名）。 引用隐含目录的另一个例子是，如果PATH环境变量（8.10节将对其进行说明）指定了~ 个我们不具有执行权限的目录，那么shell绝不会在该目录下找到可执行文件。

•对于一个文件的读权限决定了我们是否能够打开现有文件进行读操作c•这与open函数的 O_RDONLY和O_RDWR标志相关。

•对于一个文件的写权限决定了我们是否能够打开现有文件进行写操作。这与open函数的 O_WRONLY和O_RDWR标志相关。

•为了在open函数中对一个文件指定O_TRUNC标志，必须对该文件具有写权限。

•为了在一个目录中创建一个新文件，必须对该目录具有写权限和执行权限。

•为了删除一个现有文件，必须对包含该文件的目录具有写权限和执行权限。对该文件本 身则不需要有读、写权限。

•如果用7个exec函数（见8.10节）中的任何一个执行某个文件，都必须对该文件具有 晒    执行权限。该文件还必须是一个普通文件。

进程每次打开、创建或删除一个文件时，内核就进行文件访问权限测试，而这种测试可能涉 及文件的所有者（st_uid和st_gid）、进程的有效ID （有效用户ID和有效组ID）以及进程的 附属组ID （若支持的话两个所有者ID是文件的性质，而两个有效ID和附属组ID则是进程 的性质。内核进行的测试具体如下。

（1）    若进程的有效用户ID是0 （超级用户），则允许访问。这给予了超级用户对整个文件系 统进行处理的最充分的自由。

（2）    若进程的有效用户ID等于文件的所有者ID （也就是进程拥有此文件），那么如果所有者 适当的访问权限位被设置，则允许访问；否则拒绝访问。适当的访问权限位指的是，若进程为读 而打开该文件，则用户读位应为1;若进程为写而打开该文件，则用户写位应为1:若进程将执行 该文件，则用户执行位应为1。

（3）    若进程的有效组ID或进程的附属组ID之一等于文件的组ID，那么如果组适当的访问权 限位被设置，则允许访问：否则拒绝访问。

（4）    若其他用户适当的访问权限位被设置，则允许访问；否则拒绝访问。

按顺序执行这4步。注意，如果进程拥有此文件（第2步），则按用户访问权限批准或拒绝 该进程对文件的访问——不查看组访问权限。类似地，若进程并不拥有该文件。但进程属于某个 适当的组，则按组访问权限批准或拒绝该进程对文件的访问——不査看其他用户的访问权限。

4.6新文件和目录的所有权

在第3章中讲述用open或creat创建新文件时，我们并没有说明赋予新文件的用户ID和 组ID是什么。4.21节将说明mkdir函数，此时就会了解如何创建一个新目录。关于新目录的所 有权规则与本节将说明的新文件所有权规则相同。

新文件的用户ID设置为进程的有效用户ID。关于组ID, POSIX.1允许实现选择下列之一作 为新文件的组ID。

（1）新文件的组ID可以是进程的有效组ID。

（2）新文件的组ID可以是它所在目录的组ID。

"011    | FreeBSD 8.0和Mac OS X 10.6.8总是使用目录的组1D作为新文件的组IDd有些Linux文件

j系统使用mount（l）命令选项允许在POSEX.I提出的两种选项中进行选择。对于Linux 3.2.0和 i Solaris 10,默认情况下，新文件的组ID粗决于它所在的目录的设置组ID位是否枝设置。如果该目录的

这一位已经被设置，则新文件的组ID设置为目录的组ID;否则新文件的组ID设置为进程的有效组ID。

使用POSIX.1所允许的第二个选项（继承目录的组ID）使得在某个目录下创建的文件和目录 都具有该目录的组ID。于是文件和目录的组所有权从该点向下传递。例如，在Linux的/var/mail 目录中就使用了途种方法。

；    正如前面提到的，这种设置组所有权的方法是FreeBSD 8.0和Mac OS X 10.6.8系统获认的，

=但对于Linux和Solaris则是可选的。在Linux 3.2.0和Solaris 10之下，必须使设置组1D位起作用。 I更进一步，为使这种方法能够正常工作，ntkdir函数要自动地传递一个目录的设置组ID位（4.21 j节将说明mkdir就是这样做的）。

##### 4.7 函数 access 和 faccessat

正如前面所说，当用open函数打开一个文件时，内核以进程的有效用户ID和有效组ID 为基础执行其访问权限测试。有时，进程也希望按其实际用户ID和实际组ID来测试其访问能 力。例如，当一个进程使用设置用户ID或设置组ID功能作为另一个用户（或组）运行时，就 可能会有这种需要。即使一个进程可能已经通过设置用户ID以超级用户权限运行，它仍可能想 验证其实际用户能否访问一个给定的文件。access和faccessat函数是按实际用户ID和实 际组ID进行访问权限测试的。（该测试也分成4步，这与4.5节中所述的一样，但将有效改为 实际。〉

\#include <unistd.h>

int access （const char * pathname, int mode、；

int faccessat （int fd, const char * pathname, int mode, int flag、；

两个函数的返回值：若成功，返回0;若出错，返回-1

其中，如果测试文件是否已经存在，motfe就为F_OK:否则mode是图17中所列常量的按位或。

| mode | 说明         |
| ---- | ------------ |
| R_OK | 測试读权限   |
| W_OK | 测试写权限   |
| X OK | 测试执行权限 |

图4-7 access函数的wocfe标志，取自<unistd.h> faccessat函数与access函数在下面两种情况下是相同的：一种楚pcrZ/wwme参数为绝对

路径，另一种是/£/参数取值为AT_FDCWD而pW肺做参数为相对路径。否则，faccessat计 算相对于打开目录（由片参数指向）的pathname。

脚g参数可以用于改变faccessat的行为，如果y/ag设置为AT_EACCESS，访问检查用的 是调用进程的有效用户ID和有效组ID,而不是实际用户ID和实际组ID。

■实例

图4~8显示了 access函数的使用方法。

\#include "apue.h"

♦include <fcntl.h>

int

main(int argc, char *argv[])

f

if (argc != 2)

err_quit("usage: a.out <pathname>"); if {access(argv[l], R_OK) < 0)

err_ret("access error for %s", argv[l])；

else

printf("read access 0K\n"); if {open(argv[l]( O_RDONLYJ < 0)

err_ret("open error for %s", argv[l]);

else

printf("open for reading 0K\n"); exit(0);

J

图4-8 access函数实例

下面是该程序的示例会话:

$ Is -1 a.out

15945 Nov 30 12:10 a.out



-rwxrwxr-x 1 sar $ ./a.out a.out read access OK open for reading OK $ Is -1 /ate/shadow

1315 Jul 17 2002 /etc/shadow

Permission denied Permission denied

成为超级用户 输入超级用户口令 将文件用户ID改为root 并打开设置用户ID位 检査所有者和SU1D位 15945 Nov 30 12:10 a.out 恢复为正常用户

Permission denied



-r--------1 root

$ ./a.out: /etc/shadow

access error for /etc/shadow：

open error for /etc/shadow:

$ su

Password：

\#    chown root a.out

\#    chnod u+s a.out

\#    Is -1 a.out

-rwsrwxr-x 1 root

\#    axit

$ ./a.out /etc/shadow

_    access error for /etc/shadow:

画 open for reading OK

在本例中，尽管open函数能打开文件，但通过设置用户辽）程序可以确定实际用户不能正常 读指定的文件。

在上例及第8章中，我们有时要成为超级用户，以便演示某些功能是如何工作的。如果你使 用多用户系统，但无超级用户权限，那么你就不能完整地重复这些实例。

##### 4,8 函数 umask

至此我们已说明了与每个文件相关联的9个访问权限位，在此基础上我们可以说明与每个进 程相关联的文件模式创建屏蔽字。

umask函数为进程设置文件模式创建屏蔽字，并返回之前的值。（这是少数几个没有出错返 回函数中的一个。）

| #include <sys/stat.h>         |                                  |
| ----------------------------- | -------------------------------- |
| rnode_t umask (mode_t cmask); | 返回值：之前的文件模式创建屏蔽字 |

其中，参数cmoyA是由图4-6中列出的9个常量（S_IRUSR、S_IWUSR等）中的若干个按位 “或”构成的，

在进程创建一个新文件或新目录时，就一定会使用文件模式创建屏蔽字（回忆3.3节和3.4 节，在那里我们说明了 open和creat函数。这两个函数都有一个参数也，它指定了新文件 的访问权限位〉。我们将在4.21节说明如何创建一个新目录。在文件模式创建屏蔽字中为1的位， 在文件mode中的相应位一定被关闭。

I实例

图4-9程序创建了两个文件，创建第一个时，umask值为0，创建第二个时，umask值禁止 所有组和其他用户的访问权限。

tinclude "apue.h"

\#include <fcntl.h>

\#define RWRWRW （S_IRUSRIS_IWUSR 丨 S_IRGRPIS_IMGRPIS_IROTH|S_IWOTH） int

main(void)

umask(0);

if (creat("foo", RWRWRW) < 0)

err_sys("creat error for foo");

umask (S_IRGRP I S_IWGRP I S_IROTH | S_IWOTH); if (creat("bar", RWRWRW) < 0)

err_sys{"creat error for bar"); exit(0);

}

图4-9 umask函数实例

若运行此程序可得如下结果，从中可见访问权限位是如何设置的。    E04]

$ umask    先打印当前文件模式创建屏蔽字

002

$ ./a.out

$ Is -1 foo bar

-rw-------1 sar    0 Dec 7 21:20 bar

-rw-rw-rw- 1 sar    0 Dec 7 21:20 foo

5 wnaafc    观察文件模式创建屏蔽字是否更改

002 ■-

UNIX系统的大多数用户从不处理他们的umask值。通常在登录时，由shell的启动文件设

置一次，然后，再不改变。尽管如此，当编写创建新文件的程序时，如果我们想确保指定的访问 权限位已经激活，那么必须在进程运行时修改umask值。例如，如果我们想确保任何用户都能 读文件，则应将umask设置为（K否则，当我们的进程运行时，有效的umask值可能关闭该权 限位，

在前面的示例中，我们用shell的umask命令在运行程序的前、后打印文件模式创建屏蔽字。 从中可见，更改进程的文件模式创建屏蔽字并不影响其父进程（常常是shell）的屏蔽字。所有shell 都有内置umask命令，我们可以用该命令设置或打印当前文件模式创建屏蔽字。

用户可以设置umask值以控制他们所创建文件的默认权限。该值表示成八进制数，一位 代表一种要屏蔽的权限，这示于图4-10中。设置了相应位后，它所对应的权限就会被拒绝。 常用的几种umask值是002、022和027。002阻止其他用户写入你的文件，022阻止同组 成员和其他用户写入你的文件，027阻止同组成员写你的文件以及其他用户读、写或执行你的 文件。

| 屏薮位 | 含义     |
| ------ | -------- |
| 0400   | 用户读   |
| 0200   | 用户写   |
| 0100   | 用户执行 |
| 0040   | 组读     |
| 0020   | 组写     |
| 0010   | 组执行   |
| 0004   | 其他读   |
| 0002   | 其他写   |
| 0001   | 其他执行 |

图4-10 umask文件访问权限位

Single UNIX Specification要求shell应该支持符号港式的umask命令。与八进制格式不同， 符号格式指定许可的权限（即在文件创建屏蔽字中为0的位）而非拒绝的权限（即在文件创建屏 蔽字中为丨的位）。下面显示了两种格式的命令。

S umask    先打印当前文件模式创建屏蔽字

002

$ umask    -S    打印符号格式

u=rwx,g=rwx, o=rx

$ uoask    027    更改文件摸式创建屏葱字

$ umask    -S    打印符号格式

u=rwx,g=rx,o=

##### 4-9 函数 chmod、fchmod 和 f chmodat

chmod、f chmod和f chmodat这3个函数使我们可以更改现有文件的访问权限。

\#include <sys/stat.h〉

int chmod (const char * pathname, mode_t mode);

int fchmod(int fd, mode_t mode、；

int fchmodat (int fd, const char ★ pathname, mode_t mode, int flag)；

3个函数返回值：若成功.返回0;若出错，返回-1

chmod函数在指定的文件上进行操作，而fchmod函数则对已打开的文件进行操作。 fchmodat函数与chmod函数在下面两种情况下是相同的：一种是port/wme参数为绝对路径， 另一种是知参数取值为AT_FDCWD而/wwTwame参数为相对路轻。否则，fchmodat计算相对于 打开目录（由％参数指向）的加g参数可以用于改变fchmodat的行为，当设置了 AT_SYMLINK_NOFOLLOW标志时，fchmodat并不会跟随符号链接。

为了改变一个文件的权限位，进程的有效用户ID必须等于文件的所有者ID,或者该进程必 须具有超级用户权限。

参数mo也是图4-11中所示常量的按位或。

| mode    | 说明                        |
| ------- | --------------------------- |
| S_ISUID | 执行时设置用户ID            |
| S_ISGID | 执行时设置组ID              |
| S ISVTX | 保存正文（粘着位）          |
| S_IRWXU | 用户（所有者）读、写和执 行 |
| S_IRUSR | 用户（所有者）读            |
| S_IWUSR | 用户（所有者）写            |
| S^IXUSR | 用户（所有者）执行          |
| S_IRWXG | 组读、写和执行              |
| S_IRGRP | 组渎                        |
| S_IWGRP | 组写                        |
| S IXGRP | 组执行                      |
| S_IRWXO | 其他读、写和执行            |
| S_IROTH | 其他读                      |
| S„IWOTH | 其他写                      |
| S IXOTH | 其他执行                    |

图 4-11 chmod 函数的 mode 常量，取自 <sys/stat .h>

注意，在图4-11中，有9项是取自图4-6中的9个文件访问权限位。我们另外加了 6个，它 们是两个设置ID常量（S_ISUID和S_ISGID）、保存正文常量（S_ISVTX）以及3个组合常量 （S_IRWXU> S_IRWXG 和 S_IRWXO）»

保存正文位（S.ISVTX）不是POSIX.1的一部分。在Single UNIX Specification中，它被定义 在XSI扩展中。我们在下一节说明其目的。

-实例

为了演示umask函数，我们在前面运行了图4-9程序，先让我们回忆文件foo和bar当时 的最后状态：

$ Is -1 foo bar

-rw-------1 sar

-rw-rw-rw- 1 sar



0 Dec 7 21:20 bar 0 Dec 7 21:20 foo



图4-12的程序修改了这两个文件的模式，

\#include "apue.h"

int

main(void)

{

struct stat statbuf;

/* turn on set-group-ID and turn off group-execute */

if (stat("foo", fistatbuf) < 0)

err_sys("stat error for foo");

if {chmodC'foo", (statbuf.st_mode & ~S_IXGRP) | S_ISGID) < 0) err_sys("chmod error for foo");

/* set absolute mode to '*rw-r--r--" */

if {chmod{"bar", S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) < 0) err_sys("chmod error for bar");

exit(0);

J

图4-12 chmod函数实例

在运行图4-12程序后，这两个文件的最后状态是：

S Is -1 foo bar

-rw-r--r-- 1 sar    0 Dec 7 21:20 bar

-rw-rwSrw- 1 sar    0 Dec 7 21:20 foo

在本例中，不管文件bar的当前权限位如何，我们都将其权限设置为一个绝对值。对文件foo, 我们相对于其当前状态设置权限。为此，先调用stat获得其当前权限，然后修改它。我们显式 地打开了设置组ID位、关闭了组执行位。注意，Is命令将组执行权限表示为S,它表示设置组

闹ID位已经设置，同时，组执行位未设置。

在Solaris中，Is命令置示1而非S，这表明对该文件可以加强制性文件或记录锁。这只能

;用于普通文件，14.3节将更详细地讨论这一点。

最后还要注意，在运行图4-]2程序后，Is命令列出的时间和日期并没有改变。在4.19节中， 我们会了解到chmod函数更新的只是i节点最近一次被更改的时间。按系统默认方式，Is -1 列出的是最后修改文件内容的时间。

chmod函数在下列条件下自动清除两个权限位。

• Solaris等系统对用于普通文件的粘着位賦予了特殊含义，在这些系统上如果我们试图设 置普通文件的粘着位（S_ISVTX），而且又没有超级用户权限，那么morfe中的粘着位自 动被关闭（我们将在下一节说明粘着位）。这意味着只有超级用户才能设置普通文件的粘 着位。这样做的理由是防止恶意用户设置粘着位，由此影响系统性能。

在FreeBSD 8.0和Solaris 10中，只有超级用户才能对普通文件设置粘着位。Linux 3.2.0 ；和Mac OS X 10.6.8对设置粘着位并无此种限制，其原因是，粘着位对Linux普通文件并无意 i义。虽然粘着位对FreeBSD的普通文件也无意义，但还是阻止除超级用户以外的任何用户对 *普通文件设置该位。

•新创建文件的组ID可能不是调用进程所属的组。回忆一下4.6节，新文件的组ID 可能是父目录的组ID。特别地，如果新文件的组江＞ 不等于进程的有效组ID或者进 程附属组ID中的一个，而且进程没有超级用户权限，那么设置组ID位会被自动被 关闭。这就防止了用户创建一个设置组ID文件，而该文件是由并非该用户所属的组 拥有的。

这种情况下，FreeBSD 8.0对试困设置组ID的操作肯定会返回失败，而其他的系统则无 声息地关闭该位，但不会对试图改变文件访问权限的操作直接做失败处理。

FreeBSD 8.0、Linux 3.2.0、Mac OS X 10.6.8 和 Solaris 10 增加了另一个安全性功能以试 图阻止误用某些保护位。如果没有超级用户权限的进程写一个文件，则设置用户ID位和设 置组ID位会被自动清除。如果恶意用户找到一个他们可以写的设置组ID和设置用户ID文

:件，即使可以修改此文件，他们也没有对该文件的特殊权限。

###### 4.10粘着位

SJESVTX位有一段有趣的历史，在UNIX尚未使用请求分页式技术的早期版本中，S_ISVTX 位被称为粘着位(sticky bit)。如果一个可执行程序文件的这一位被设置了，那么当该程序第一次 被执行，在其终止时，程序正文部分的一个副本仍被保存在交换区(程序的正文部分是机器指令)。® 这使得下次执行该程序时能较快地将其装载入内存。其原因是：通常的UNIX文件系统中，文件 的各数据块很可能是随机存放的，相比较而言，交换区是被作为一个连续文件来处理的。对于通 用的应用程序，如文本编缉程序和C语言编译器，我们常常设置它们所在文件的粘着位。自然地， 对于在交换区中可以同时存放的设置了粘着位的文件数是有限制的，以免过多占用交换区空间，

但无论如何这是一个有用的技术。因为在系统再次自举前，文件的正文部分总是在交换区中，这 正是名字中“粘着”的由来。后来的UNIX版本称它为保存正文位(saved-textbit)，因此也就有 了常量S_ISVTX。现今较新的UNIX系统大多数都配置了虚拟存储系统以及快速文件系统，所以 不再需要使用这种技术。

现今的系统扩展了粘着位的使用范围，Single UNIX Specification允许针对目录设置粘着位。

如果对一个目录设置了粘着位，只有对读目录具有写权限的用户并且满足下列条件之一，才能删 除或重命名垓目录下的文件：

•拥有此文件；

•拥有此目录：

•是超级用户。

目录/tmP和/var/tmp是设置粘着位的典型候选者——任何用户都可在这两个目录 中创建文件》任一用户(用户、组和其他)对这两个目录的权限通常都是读、写和执行。

但是用户不应能删除或重命名属于其他人的文件，为此在这两个目录的文件模式中都设置 了粘着位。

POSIX.1没有定义保存正文位，Single UNIX Specification将它定义在XSI扩展部分。FreeBSD 8.0. Linux 3.2.0、Mac OS X 10.6.8 和 Solaris 10 则支持这种功能。

在Solaris 10中，如果对普通文件设置了粘着位，那么它就具有特殊含义。在这种恃况下，如 果任何执行位都没有设I，那么操作系统就不会缓存文件内容。

##### 4.11 函数 chown、fchown、fchownat 和 lchown

下面几个chown函数可用于更改文件的用户ID和组ID。如果两个参数owner■或gmup中的 任意一个是-1，则对应的ID不变。

\#include <unistd.h>

int chown (const char * pathname, uid_t owner, gid_t group)； int fchown (int fd, uid_t owner, gid_t group);

int fchownat (int fd, const char ★ pathname, uid_t owner, gid_t group, int flag}; int lchown (const char * pathname, uid_t owner, gid_t group);

4个函数的返回值：若成功，返回0:若出错，返回-1

除了所引用的文件是符号链接以外，这4个函数的操作类似。在符号链接情况下，lchown 和fchownat (设置了 AT_SYMLINK_NOFOLLOW标志)更改符号链接本身的所有者，而不是该 符号链接所指向的文件的所有者。

fchown函数改变片参数指向的打开文件的所有者，既然它在一个已打开的文件上操作，就 不能用于改变符号链接的所有者。

fchownat函数与chown或者lchown函数在下面两种情况下是相同的：一种是 参数为绝对路径，另一种是炎参数取值为AT_FDCWD而par/wwme参数为相对路径。在这两种情 况下，如果_/?呀参数中设置了 AT_SYMLINKJWFOLLOW标志，fchownat与lchown行为相同， 如果flag参数中清除了 AT_SYMLXNK_NOFOLLOW标志，则fchownat与chown行为相同。如 果只参数设置为打开目录的文件描述符，并且汝zwme参数是一个相对路径名，fchownat函 数计算相对于打开目录的pathname o

基于BSD的系统一直规定只有超级用户才能更改一个文件的所有者。这样做的原因是防止用 户改变其文件的所有者从而摆脱磁盘空间限额对他们的限制。System V则允许任一用户更改他们 所拥有的文件的所有者。

'    按照_POSIX_CHOWN_RESTRICTED的值，POSIX.1允许在这两种形式的操作中选用一种。

对于Solaris 10,此功能是个配置选项，其默认值是施加限制。而FreeBSD 8.0、Linux 3.2.0

和Mac OS X 10.6.8则总对chown施加限制。

回忆2.6节，_POSIX_CHOWN_RESTRICTED常量可选地定义在头文件<unistd.h>中，而且 总是可以用pathconf或fpathconf函数进行查询£■此选项还与所引用的文件有关一可在每个 文件系统基础上，使该选项起作用或不起作用，在下文中，如提及“若_POSIX_CHOWN_ RESTRICTED生效”，则表示“这适用于我们正在谈及的文件”，而不管该实际常量是否在头文件 中定义。

g_POSIX_CHOWN_RESTRICTED对指定的文件生效，则

(1)    只有超级用户进程能更改该文件的用户ID:

(2)    如果进程拥有此文件(其有效用户ID等于该文件的用户ID),参数owner等于-1或文 件的用户ID,并且参数等于进程的有效组ID或进程的附属组ID之一，那么一个非超级用 户进程可以更改该文件的组ID。

这意味着，有效时，不能更改其他用户文件的用户ID。你 可以更改你所拥用的文件的组ID,但只能改到你所属的组，

E3    如果这些函数由非超级用户进程调用，则在成功返回时，该文件的设置用户ID位和设置组

ID位都被清除。

###### 4.12文件长度

Stat结构成员st_siZe表示以字节为单位的文件的长度。此字段只对普通文件、目录文件 和符号链接有意义。

FreeBSD 8.0、Mac OS X 10.6.8和Solaris 10对管道也定义了文件长度，它表示可从该管道中 读到的字节数，我们将在丨5.2中讨论管道。

对于普通文件，其文件长度可以是0,在开始读这种文件时，将得到文件结束（end-of-file）指示。 対于目录.文件长度通常是一个数（如16或512）的整倍数，我们将在4.22节中说明读目录操作。

对于符号链接，文件长度是在文件名中的实际字节数。例如，在下面的例子中I文件长度7 就是路径名usr/lib的长度：

Irwxrwxrwx 1 root    7 Sep 25 07:14 lib -> usr/lib

（注意，因为符号链接文件长度总是由st_Size指示，所以它并不包含通常C语言用作名字结尾 的null字节。）

现今，大多数现代的UNIX系统提供字段31：_1311^1汗和51：_1010<^5«>其中，第一个是対 文件I/O较合适的块长度，第二个是所分配的实际512字节块块数。回忆3.9节，其中提到了当 我们将于读操作时，读一个文件所需的时间量最少。为了提高效率，标准VO库 （我们将在第5章中说明）也试图一次读、写字节。

应当了解的是，不同的UNIX版本其st_blocks所用的单位可能不是512字节的块。使用 此值并不是可移植的。

文件中的空洞

在3.6节中，我们提及普通文件可以包含空洞。在图3-2程序中例示了这一点。空洞是由所 设置的偏移量超过文件尾端，并写入了某些数据后造成的。作为一个例子，考虑下列情况：

$ la -1 coca

-rw-r--r-- 1 sar    8483248 Nov 18 12:18 core

$ du -» core 212    core

文件core的长度稍稍超过8 MB，可是du命令报告该文件所使用的磁盘空间总量是272个512 字节块（即139264字节）。很明显，此文件中有很多空洞。

在很多BSD类系统上，du命令报告的是1024字节块的块数，Solaris报告的是512字节块的 块数。在Linux上.报告的块数单位取决于是否设置了环境变量POSIXLY_CORRECT。当设置了 该环境变量，du命令报告的是1 024字节块的块数；没有设置该环境变量时，du命令报告的是 512字节块的块數。

正如我们在3.6节中提及的，对于没有写过的字节位置，read函数读到的字节是0。如果执 行下面的命令，可以看出正常的I/O操作读整个文件长度：    EB

$ wc -o core

8483248 core

带-c选项的wc（l）命令计算文件中的字符数（字节）。

如果使用实用程序（如cat（l））复制这个文件，那么所有这些空洞都会被填满，其中所有实 际数据字节皆填写为0。

$ cat core > core.copy

$ Is -1 core*

-rw-r--r-- 1 sar    8483248 Nov 18 12:18 core

-rw-rw-r-- 1 sar    8483248 Nov 18 12:27 core.copy

5 du -s core*

272 core

16592 core.copy

从中可见，新文件所用的实际字节数是8 495 104 （512x16 592）。此长度与Is命令报告的长度不 同，其原因是，文件系统使用了若干块以存放指向实际数据块的各个指针。

有兴趣的读者可以参阅Bach［1986］的4.2节、McKusick等［1996】的7.2节和7.3节（或McKusick 和 NeviUe-Neil［2005］的 8.2 节和 8.3 节）、McDougall 和 Mauro［2007］的 15.2 节以及 Singh［2006］的 第12章，以更详细地了解文件的物理结构。

###### 4.13文件截断

有时我们需要在文件尾端处截去一些数据以缩短文件。将一个文件的长度截断为o是一个特 例，在打开文件时使用O_TRUNC标志可以做到这一点。为了截断文件可以调用函数truncate 和 ftruncateo

\#include <unistd.h>

int truncate {const char * pathname, off_t length); int ftruncate (int fd, of f_t length);

两个函数的返回值：若成功，返回0;若出错，返回

这两个函数将一个现有文件长度截断为length.如果该文件以前的长度大于length,则超过 length以外的数据就不再能访问。如果以前的长度小于length,文件长度将増加，在以前的文件 尾端和新的文件尾端之间的数据将读作0 （也就是可能在文件中创建了一个空洞）。

早于4.4BSD的BSD系统只能用truncate函数截短一个文件，不能用它扩展一个文件„

1112-1    Solaris对fcntl函数进行了扩展，增加了 F_FREESP,它允许释放一个文件中的任何一部分,

而不只是文件尾端处的一部分。

图13-6的程序使用了 ftruncate函数，以便在获得对一个文件的锁后，清空该文件。

###### 4.14文件系统

为了说明文件链接的概念，先要介绍UNIX文件系统的基本结构。同时，了解i节点和指向

i节点的目录项之间的区别也是很有益的。

目前，正在使用的UNIX文件系统有多种实现。例如，Solaris支持多种不同类型的磁盘文件 系统：传统的基于BSD的UNIX文件系统（称为UFS）,读、写DOS格式软盘的文件系统（称 为PCFS），以及读CD的文件系统（称为HSFS）。在图2-20中，我们已经看到了不同类型文件 系统的一个区别。UFS是以Berkeley快速文件系统为基础的。本节讨论该文件系统。

每一种文件系统类型都有它各自的特征，有些特征可能是混淆不清的。例如，大部分UNIX 文件系统支持大小写敏感的文件名。因此，如果创建了一个名为file.txt的文件以及另外一 个名为file.TXT的文件，就是创建了两个不同的文件。在MacOSX上，HFS文件系统是大 小写保留的，并且是大小写不敏感比较的。因此，如果创建了一个名为file.txt的文件，当 你再创建名为file.TXT的文件时，就会覆盖原来的file.txt文件。但是，保存在文件系统 中的是文件创建时的文件名（即file.txt,因为是大小写保留的）。事实上，在“f, i, 1, e, t, x, t”这个序列中的大写或小写字母的排列都会在搜索这个文件时得到匹配（大小 写不教感比校J。因此，除了 file. txt和file.TXT,我们还可以用File.txt、fILE.tXt

:以及FiLe.TxT等名字来访问该文件o

我们可以把一个磁盘分成一个或多个分区。每个分区可以包含一个文件系统（见图4-13）。i岡 节点是固定长度的记录项，它包含有关文件的大部分信息。

磁盘    分区



文件系统



白举块

超级块



分区



分区



柱面组0



柱面组1



柱面组n



| 超级块副本 | 配置信息 | i节点 團 | 块位图 | i节点 | 観块 |
| ---------- | -------- | -------- | ------ | ----- | ---- |
|            |          |          |        |       |      |



| i节点 | i节点 |      | i节点 |
| ----- | ----- | ---- | ----- |
|       |       |      |       |

图4-13磁盘、分区和文件系统

如果更仔细地观察一个柱面组的i节点和数据块部分，则可以看到图4-14中所示的情况。 注意图4-14中的下列各点。

•在圉中有两个目录项指向同一个i节点。每个i节点中都有一个链接计数，其值是指向该 i节点的目录项数。只有当链接计数减少至0时，才可删除该文件（也就是可以释放该文 件占用的数据块）。这就是为什么“解除对一个文件的链接”操作并不总是意味着“释放 该文件占用的磁盘块”的原因。这也是为什么删除一■个目录项的函数被称之为unlink 而不是delete的原因。在stat结构中，链接计数包含在st_nlink成员中，其基本 系统数据类型是nlink_t。这种链接类型称为硬链接。回忆2.5.2节，其中，POSIX.1常

量LINK_MAX指定了一个文件链接数的最大值，

图4-14较详细的柱面组的i节点和数据块

•另外一种链接类型称为符号链接（symbolic link）。符号链接文件的实际内容（在数据块 中）包含了该符号链接所指向的文件的名字。在下面的例子中，目录项中的文件名是3 个字符的字符串lib,而在该文件中包含了 7个字节的数据usr/lib：

lrwxrwxrwx 1 root    7 Sep 25 07:14 lib -> urs/lib

该i节点中的文件类型是S_IFLNK,于是系统知道这是一个符号链接。

• i节点包含了文件有关的所有信息：文件类型、文件访问权限位、文件长度和指向文件数 据块的指针等。stat结构中的大多数信息都取自i节点。只有两项重要数据存放在目录 项中：文件名和i节点编号。其他的数据项（如文件名长度和目录记录长度）并不是本书 关心的=i节点编号的数据类型是ino_t。

•因为目录项中的i节点编号指向同一文件系统中的相应i节点，一个目录项不能指向另一 个文件系统的i节点。这就是为什么ln（l）命令（构造一个指向一个现有文件的新目录项） 不能跨越文件系统的原因=我们将在下一节说明link函数。

•当在不更换文件系统的情况下为一个文件重命名时，孩文件的实际肉容并未移动，只需 构造一个指向现有i节点的新目录项，并删除老的目录项。链接计数不会改变。例如，为 将文件/usr/lib/foo重命名为/usr/foo,如果目录/usr/lib和/usr在同一文件系 统中，则文件foo的内容无需移动。这就是mv（l）命令的通常操作方式。

我们说明了普通文件的链接计数概念，但是对于目录文件的链接计数字段又如何呢？假定我 们在工作目录中构造了一个新目录：

S mfcdic testdic

图4-15显示丁其结果。注意，该图显式地显示了.和..目录项。

编号为2549的i节点，其类型字段表示它是一个目录，链接计数为2。任何一个叶目录（不 包含任何其他目录的目录）的链接计数总是2,数值2来自于命名该目录（testdir）的目录项

[H5]以及在该目录中的.项。编号为1267的i节点，其类型字段表示它是一个目录，链接计数大于或 等于3。它大于或等于3的原因是，至少有3个目录项指向它：一个是命名它的目录项（在图4-15 中没有表示出来），第二个是在该目录中的.项，第三个是在其子目录testdir中的..项。注意， 在父目录中的每一个子目录都使该父目录的链接计数增加I。

图4-15创建了目录testdir后的文件系统实例

这种格式与UNIX文件系统的经典格式类似，在Bach［1986］的第4章中对此进行了详细说明。关于 伯克利快速文件系统对此所做的更改请参阅McKusick等［1996］的第7章以及McKusidc和 NeviUe*Neil［2005］中的第8章。关于UFS（伯克利快速文件系统的Solaris版）的详细情况，请参见McDougall 和Mauro［2007］的第15章。关于Mac OS X使用的HFS文件系统格式，请参阅Singh［2006］的第12章。

##### 4-15 函数 link' linkat、unlink、unlinkat 和 remove

如上节所述，任何一个文件可以有多个目录项指向其i节点，创建一个指向现有文件的链接 的方法是使用link函数或linkat函数。

\#include <unistd.h>

int link (const char *existing)atht const char *newpath);

int linkat (int efd, const char *existingpath, int nfd, const char *ncwpath, int flag);

两个函数的返回值：若成功，返回0:若出错，返回-1

这两个函数创建一个新目录项nenpcr汝，它引用现有文件如果已经存 在，则返回出错，只创建中的最后一个分量，路径中的其他部分应当已经存在。

对于linkat函数，现有文件是通过咖和existingpath参数指定的，新的路径名是通过；响 和newpa决参数指定的。默认情况下，如果两个路径名中的任一个是相对路径，那么它需要通过 相对于对应的文件描述符进行计算。如果两个文件描述符中的任一个设置为AT_FDCWD，那么相 应的路径名（如果它是相对路径）就通过相对于当前目录进行计算。如果任一路径名是绝对路径，

相应的文件描述符参数就会被忽略。

当现有文件是符号链接时，由参数来控制linkat函数是创建指向现有符号链接的链接还 是创建指向现有符号链接所指向的文件的链接。如果在#堪参数中设置了 AT_SYMLINK_FOLLOW标 志，就创建指向符号链接目标的链接。如果这个标志被清除了，则创建一个指向符号链接本身的链接。岡

创建新目录项和增加链接计数应当是一个原子操作（请回忆在3.11节中对原子操作的讨论）。

虽然POSDC1允许实现支持跨越文件系统的链接，但是大多数实现要求现有的和新建的两个 路径名在同一个文件系统中。如果实现支持创建指向一个目录的硬链接，那么也仅限于超级用户 才可以这样做。其理由是这样做可能在文件系统中形成循环，大多数处理文件系统的实用程序都 不能处理这种情况（4.17节将说明一个由符号链接引入循环的例子〉。因此，很多文件系统实现 不允许对于目录的硬链接。

为了删除一个现有的目录项，可以调用unlink函数。

\#include <unistd.h>

int unlink (const char * pathname、；

int unlinkat {int fd, const char ★ pathname, int flag);

两个函数的返回值：若成功，返回0;若出错，返回-1

这两个函数删除目录项，并将由汝zwme所引用文件的链接计数减1。如果对该文件还有其 他链接，则仍可通过其他链接访问该文件的数据。如果出错，则不対该文件做任何更改。

我们在前面已麵及，为了解除对文件的链接，必耐包含该目录项的目录具有写和执行权限。正 如4.10节所述，如果对该目录设置了粘着位，则対该目录必须具有写权限，并且具备下面三个条件之一：

•拥有该文件：

•拥有该目录：

•具有超级用户权限。

只有当链接计数达到0时，该文件的内容才可被删除。另一个条件也会阻止删除文件的内 容——只要有进程打开了该文件，其内容也不能删除，关闭一个文件时，内核首先检査打开该 文件的进程个数；如果这个计数达到0,内核再去检查其链接计数；如果计数也是0,那么就删 除该文件的内容。

如果戸如關e参数是相对路径名，那么unlinkat函数计算相对于由/rf文件描述符参数代 表的目录的路径名。如果/rf参数设置为AT_FDCWD，那么通过相对于调用进程的当前工作目录来 计算路径名。如果pa汝rnwie参数是绝对路径名，那么片参数被忽略。

\>/呀参数给出了一种方法,使调用进程可以改变unlinkat函数的默认行为。当AT_ REMOVEDIR E3标志被设置时，unlinkat函数可以类似于rmdir 一样删除目录。如果这个标志被清除，

unlinkat与unlink执行同样的操作。

■实例

图4-16的程序打开一个文件，然后解除它的链接。执行该程序的进程然后睡眠15秒，接着 就终止。

\#include "apue.h"

^include <fcntl.h> int

main(void)

i

if (openC'tempfile", O_RDWR) < 0) err_sys("open error");

if (unlink("tempfile") < 0) err_sys("unlink error");

printf("file unlinked\n"):

图4-16 打开一个文件，然后unlink它



运行该程序，其结果是：

$ Is -1

| -cw~r————             | 1 sar     | 413265408 |
| --------------------- | --------- | --------- |
| $ df /home            |           |           |
| Filesystem            | lK-blocks | Used      |
| /dev/hda4             | 11021440  | 1956332   |
| $ ./a.out £           |           |           |
| 1364                  |           |           |
| $ file unlinked       |           |           |
| la -1 taapfxle        |           |           |
| Is: tempfile: No such | file or ( |           |
| $ df /hoo«            |           |           |
| Filesystem            | lK-blocks | Used      |
| /dev/hda4             | 11021440  | 1956332   |
| $ done                |           |           |
| df /hone              |           |           |
| Filesystem            | lK-blocks | Used      |
| /dev/hda4             | 11021440  | 1552352   |



査看文件大小

Jan 21 07:14 tempfile 检査可用磁盘空间

Available Use% Mounted on 9065108    18% /home

在后台运行图446程序 shell打印其进程ID 解除文件链接 观察文件是否仍然存在 directory    目录项已刪除

检査可用磁盘空间有无变化 Available Use% Mounted on 9065108    18% /home

程序执行结束，关闭所有打开文件 现在，应当有更多可用磁盘空间 Available Use% Mounted on 9469088    15% /home

现在，394.1 MB磁盘空间可用

unlink的这种特性经常被程序用来确保即使是在程序崩溃时，它所创建的临时文件也不会遗

留下来。进程用open或creat创建一个文件，然后立即调用unlink，因为该文件仍旧是打开_

的，所以不会将其内容删除。只有当进程关闭该文件或终止时（在这种情况下，内核关闭该进程 所打开的全部文件），该文件的内容才被删除。

卸果pat/mame是符号链接，那么unlink删除该符号链接，而不是删除由该链接所引用的文件。 给出符号链接名的情况下，没有一个函数能删除由垓链接所引用的文件。

如果文件系统支持的话，超级用户可以调用unlink,其参数指定一个目录，

但是通常应当使用rmdir函数，而不使用unlink这种方式。我们将在4.21节中说明rmdir 函数。

我们也可以用remove函数解除对一个文件或目录的链接。射于文件，remove的功能与 unlink相同。对于目录，remove的功能与rmdir相同。

^include <stdio.h>

int remove {const char * pathname）;

返回值：若成功，返回th若出错，返回-1

ISO C指定remove函数删除一个文件，这更改了 UNIX历来使用的名字unlink，其原因是实 现C标准的大多数非UNIX系统并不支持文件链接。

##### 4.16 函数 rename 和 renameat

文件或目录可以用rename函数或者renameat函数进行重命名

\#include <stdio.h>

int rename (const char *oldname, const char *newname);

int renameat (int oldfd, const char *otdname, int newfd, const char *newname};

两个函数的返回值：若成功，返回0;若出错，返回-1

ISOC对文件定义了 rename函教（C标准不处理目录）。POSIX.1扩展此定义，使其包含了 目录和符号键接。

根据oW/wme是指文件、目录还是符号链接，有几种情况需要加以说明。我们也必须说明如 果newname已经存在时将会发生什么。

（1）    如果指的是一个文件而不是目录，那么为该文件或符号链接重命名。在这种情 况下，如果rtew/wme已存在，则它不能引用一个目录。如果new/wme已存在，而且不是一个目 录，则先将该目录项删除然后将oldname重命名为newname^对包含oldname的目录以及包含 rtewmwie的目录，调用进程必须具有写权限，因为将更改这两个目录。

（2）    如若o/t/rtome指的是一个目录，那么为该目录重命名。如果nevwiflme已存在，则它必须 引用一个目录，而且该目录应当是空目录（空目录指的是该目录中只有.和..项）。如果rtevwwme 存在（而且是一个空目录），则先将其删除，然后将oZtAwme重命名为z/ewzwme。另外，当为一 个目录重命名时，new/jome不能包含oZi/zwme作为其路授前缀。例如，不能将/usr/foo重命名 为/usr/foo/testdir，因为旧名字（/usr/foo）是新名字的路径前缀，因而不能将其删除。

（3）    如若oWname或newname引用符号链接，则处理的是符号链接本身，而不是它所引用的

文件。

（4）    不能对.和..重命名。更确切地说，.和..都不能出现在oWrtOTwe和wewTiame的最后部分。

（5）    作为一个特例，如果和newname引用同一文件，则函数不做任何更改而成功返回。

如若ziewwme已经存在，则调用进程对它需要有写权限（如同删除情况一样）。另外，调用

进程将删除oWname目录项，并可能要创建newwme目录项，所以它需要对包含oWname及包含 newname的目录具有写和执行权限。

捺了当oldname或newname指向相対路径名时，其他情况下renameat函数与rename函 数功能相同。如果oldname参数指定了相対路径，就相对于oW/tf参数引用的目录来计算oldname. 类似地，如果newname指定了相对路授，就相对于引用的目录采计算new/wme。oldfd或 «~人/参数（或两者）都能设置成AT^FDCWD,此时相对于当前目录来计算相应的路径名。

###### 4.17網链接

符号链接是对一个文件的间接指针，它与上一节所述的硬链接有所不同，硬链接直接指向文 件的i节点。引入符号链接的原因是为了避开硬链接的一些限制。

•硬链接通常要求链接和文件位于同一文件系统中。

•只有超级用户才能创建指向目录的硬链接（在底层文件系统支持的情况下）。

对符号链接以及它指向何种对象并无任何文件系统限制，任何用户都可以创建指向目录的符

号链接。符弓•链接一般用于将一个文件或整个目录结构移到系统中另一个位置=

当使用以名字引用文件的函数吋，应当了解该函数是否处理符号链接.也就是该函数是否跟

随符号链接到达它所链接的文件。如若该函数具有处理符号链接的功能，则其路径名参数引用由

符号链接指向的文件。否则，一个路径名参数引用链接本身，而不是由该链接指向的文件。图4-17 列出了本章中所说明的各个函数是否处理符号链接。在图4-17中没有列出mkdir. mkinfo, mknod和rmdir这些函数，其原因是，当路径名是符号链接时，它们都出错返回。以文件描述 符作为参数的一些函数（如fstat、fchmod等）也未在该图中列出，其原因是，对符号链接的 处理是由返回文件描述符的函数（通常是open）进行的。chovrn是否跟随符号链接取决于实现， 在所有现代的系统中，chown函数都跟随符号链接。

符号链接由4.2BSD引入，chown最初并不跟随符号链接，但在4.4BSD中情况发生了变化。 I SVR4中的System V包含了对符号链接的支持，但与原始BSD中的行为已大不相同，也实现了 chown函数跟随符号链接。早期Linux版本中（Linux 2.1.81以前的版本），chown并不跟随符号

链接。从 2.1.81 版开始，chown 跟随符号链接。FreeBSD 8.0、Mac OS X 10.6.8 和 Solaris 10 中， chown跟随符号链接。所有这些平台都实现了 lchown,它改变符号健接自身的所有权。

| 函数     | 不跟随符号链接 | 跟随符号链接 |
| -------- | -------------- | ------------ |
| access   |                |              |
| chdir    |                | -            |
| chmod    |                |              |
| chown    |                | •            |
| creat    |                | •            |
| exec     |                | •            |
| lchown   | •              |              |
| link     |                |              |
| Istat    | •              |              |
| open     |                | •            |
| opendir  |                | •            |
| pathconf |                | •            |
| readlink | •              |              |
| remove   | •              |              |
| rename   | •              |              |
| stat     |                | •            |
| truncate |                | •            |
| unlink   | •              |              |

图4-17各个函数对符号链接的处理

图4-17的一个例外是，同时用O_CREAT和O_EXCL两者调用open函数。在此情况下，若 路径名引用符号链接，open将出错返回，errno设置为EEXIST。这种处理方式的意图是堵塞 一个安全性漏洞，以防止具有特权的进程被诱骗写错误的文件。

■实例

使用符号链接可能在文件系统中引入循环。大多数查找路径名的函数在这种情况发生时都将 出错返回，errno值为ELOOP。考虑下列命令序列：

$ afcdxz £oo

$ touch £oo/a

$ In -a ../foo foo/testdlr $ Is -1 foo

total 0

-rw-r-----1 sar    0

lrwxrwxrwx 1 sar    6



创建一个新目录 创建一个0长度的文件 创建一个符号链接



Jan 22 00:16 a

Jan 22 00:16 testdir -> ../foo



这创建了一个目录foo,它包含了一个名为a的文件以及一个指向foo的符号链接。在图冬18 中显示了这种结果，图中以圆表示目录，以正方形表示 一个文件。

![img](UNIXaf83d8a7160b-14.png)



如果我们写一段简单的程序，使用Solaris的标准函 数ftw(3)以降序遍历文件结构，打印每个遇到的路径名，

则其输出是：

foo//a    图4»18构成循环的符号链接testdir

foo/testdir

foo/testdir/a

foo/testdir/testdir

foo/testdir/testdir/a

foo/testdir/testdir/testdir

foo/testdir/testdir/testdir/a

(更多行，直至ftw出错返回，此时，errno值为ELOOP)

4.22节提供了我们自己的ftw函数版本，它用lstat代替stat以阻止它跟随符号链接。

| 注意，Linux的ftw和nftw函数记录了所有看到的目录并避免多次重复处理一个目录，因 j此这两个函数不显示这种程序运行行为。

这样一个循环是很容易消除的。因为unlink并不跟随符号链接，所以可以unlink文件 foo/testdir。但是如果创建了一个构成这种循环的硬链接，那么就很难消除它，这就是为什 么link函数不允许构造指向目录的硬链接的原因(除非进程具有超级用户权限)。

实际上，Rich Stevens在写本节的袭初版本时，在自己的系统上做了一个这样的实验。结果文 件系统变得错误百出。正常的fsck⑴实用程序不能修复问题。为了修复文件系统，不得不使用

=了并不推荐使用的工具clri⑻和dcheck(8)。

对目录的硬链接的需求由来已久，但是使用符号键接和mkdir函数，用户就不再需要创建指

:向目录的硬链接了。

用open打开文件时，如果传递给open函数的路径名指定了一个符号链接，那么open跟 随此链接到达所指定的文件。若此符号链接所指向的文件并不存在，则open返回出错，表示它

岡不能打开该文件，这可能会使不熟悉符号链接的用户感到迷惑，例如：

$ In -a /no/sueh/filo norfil*    创建一个符号链接

S Is nyfile

myfile    Is査到该文件

$ cat ny£ila    试图査看该文件

cat: myfile: No such file or directory

$ Is —1 nyfila    尝试-1 选项

lrwxrwxrwx 1 sar    13 Jan 22 00:26 myfile -> /no/such/file

文件myfile存在，但cat却栋没有这一文件，其原因是myfile是个符号链接，由该符 号链接所指向的文件并不存在。Is命令的-1选项给我们两个提示：第一个字符是1，它表示这 是一个符号链接，而->也表明这是一个符号链接。Is命令还有另一个选项-F,它会在符号链接 的文件名后加一个@符号，在未使用-1选项时，这可以帮助我们识别出符号链接。    ■

4.18创建和读取符号链接

可以用symlink或symlinkat函数创建一个符号链接。

♦include <unistd.h>

int symlink （const char *actualpath, const char *sympath）;

int symlinkat （const char *actualpath, int fd, const char * sympathy ；

_两个函数的返回值：若成功，返回0:若出错，返回-1

函数创建了一个指向即也的新目录项叹mport。往仓1J建此符号链接时，并不要求actuaipat/i 已经存在（在上一节结束部分的例子中我们已经看到了这一点）。并且，actu咖油和押atft并 不需要位于同一文件系统中。

symlinkat函数与symlink函数类似，但吵/叩£油参数根据相射于打开文件描述符引用的 目录（由片参数指定）进行计算。如果sympath参数指定的是绝对路径或者/rf参数设置了 AT_FDCWD值，那么symlinkat就等同于symlink函数。

因为open函数跟随符号链接，所以需要有一种方法打开该链接本身，并读该链接中的名字。 readlink和readlinkat固数提供了这种功能。

ttinclude <unistd.h>

ssize_t readlink (const char * restrict pathname, char * restrict buf, size_t bufsize);

ssize_t readlinkat (int fd, const char* restrict pathname, char *restrict buf, size_t bufsize};

两个函数的返回值：若成功，返回读取的字节数：若出错，返回-1

两个函数组合了 open、read和close的所有操作。如果函数成功执行，则返回读入Zuz/ 的字节数。在中返回的符号链接的内容不以null字节终止。

当pathname参数指定的是绝对路径名或者片参数的值为AT.FDCWD, readlinkat函数的 行为与readlink相同。但是，如果为参数是一个打开目录的有效文件描述符并且p也知wme参 数是相对路径名，则readlinkat计算相对于由只代表的打开目录的路径名。

4.19文件的时间

在4.2节中，我们讨论了 Single UNIX Specification 2008年版如何提高stat结构中时间字段 的精度，从原来的秒提髙到秒加上纳秒。每个文件属性所保存的实际精度依赖于文件系统的实现。 対于把时间戳记录在秒级的文件系统来说，纳秒这个字段就会被填充为0。对于时间戳的记录精 度高于秒级的文件系统来说，不足秒的值被转换成纳秒并记录在纳秒这个字段中。

对每个文件维护3个时间字段，它们的意义示于图4-19中。

| 字段    | 说明                    | 例子          | Is⑴选项 |
| ------- | ----------------------- | ------------- | ------- |
| st_atim | 文件数据的最后访问时间  | read          | -u      |
|         | 文件数据的最后修改时间  | write         | 默认    |
| st ctim | i节点状态的最后更改时间 | chmod-. chown | -c      |

图4-19与每个文件相关的3个时间值

注意，修改时间（st.mtim）和状态更改时间（st.ctim）之间的区别。修改时间是文件内容 最后--次被修改的时间。状态更改时间是该文件的i节点最后一次被修改的时间。在本章中我们己 说明了很多影响到i节点的操作，如更改文件的访问权限、更改用户江）、更改链接数等，但它们并 没有更改文件的实际内容。因为i节点中的所有信息都是与文件的实际内容分开存放的，所以，除 了要记录文件数据修改时间以外，还需要记录状态更改时间，也就是更改i节点中信息的时间。

注意，系统并不维护对一个i节点的最后一次访问时间，所以access和stat函数并不更 改这3个时间中的任一个。

系统管理员常常使用访问时间来删除在一定时间范围内没有被话问过的文件。典型的例子是删除在 过去一周内没有被访问过的名为a. out或core的文件。f ind（l偷令常被用来进行这种类型的操作。

闹    修改时间和状态更改时间可被用来归档那些内容已经被修改或i节点已经被更改的文件。

Is命令按这3个时间值中的一个排序进行显示。系统默认（用-1或-t选项调用时）是按文件的 修改时间的先后排序显示。-u选项使Is命令按访问时间排序，-c选项则使其按状态更改时间排序。

图4-20列出了我们已说明过的各种函数对这3个时间的作用。回忆4.14节中所述，目录是 包含目录项（文件名和相关的i节点编号）的文件，增加、删除或修改目录项会影响到它所在目 录相关的3个时间。这就是在图本20中包含两列的原因，其中一列是与该文件（或目录）相关的 3个时间，另一列是与所引用的文件（或目录）的父目录相关的3个时间。例如，创建一个新文 件影响到包含此新文件的目录，也影响该新文件的i节点。但是，读或写一个文件只影响该文件 的i节点，而对目录则无影响。

| 函数                         | 引用的文件或目录 | 所引用文件或目录 的父目录 | 节   | 备注 |      |      |      |                    |
| ---------------------------- | ---------------- | ------------------------- | ---- | ---- | ---- | ---- | ---- | ------------------ |
| a                            | m                | c                         | a    | m    | c    |      |      |                    |
| chmod、 fchmod               |                  |                           |      |      |      |      | 4.9  |                    |
| chown、 fchown               |                  |                           |      |      |      |      | 4.11 |                    |
| creat                        | •                | ■                         |      |      | •    | •    | 3.4  | O.CREAT新文件      |
| creat                        |                  | •                         |      |      |      |      | 3.4  | O_TRUNC现有文件    |
| exec                         |                  |                           |      |      |      |      | 8.10 |                    |
| lchown                       |                  |                           |      |      |      |      | 4.11 |                    |
| link                         |                  |                           |      |      | •    | •    | 4.15 | 第二个参数的父目录 |
| mkdir                        | •                |                           |      |      | •    | •    | 4.21 |                    |
| mkfifo                       | -                |                           |      |      | •    | •    | 15.5 |                    |
| open                         | •                |                           |      |      | •    | •    | 3.3  | O_CREAT新文件      |
| open                         |                  |                           |      |      |      |      | 3.3  | O_TRUNC现有文件    |
| pipe                         | ■                |                           |      |      |      |      | 15.2 |                    |
| read                         | •                |                           |      |      |      |      | 3.7  |                    |
| remove                       |                  |                           |      |      | •    | •    | 4.15 | 刪除文件=unlink    |
| remove                       |                  |                           |      |      | •    | •    | 4.15 | 刪除目录=rmdir     |
| rename                       |                  |                           |      |      | •    | -    | 4.16 | 对于两个参数       |
| rmdir                        |                  |                           |      |      | •    | •    | 421  |                    |
| truncate、ftruncate          |                  | •                         |      |      |      |      | 4.13 |                    |
| unlink                       |                  |                           |      |      | •    | •    | 4.15 |                    |
| utimes、utimensat-. futimens | •                |                           |      |      |      |      | 4^0  |                    |
| write                        |                  |                           |      |      |      |      | 3.8  |                    |

图4~20各种函数对访问、修改和状态更改时间的作用

(mkdir 和 rmdir 函数蒋在 4.21 节-中说明。utimes、utimensat、futimens 函数将在 下一节中说明。7个exec函数将在8.10节中讨论。第]5章将说明mkfifo和pipe圉数。)

##### 4-20 函数 futimens、utimensat 和 utimes

—个文件的访问和修改时间可以用以下几个函数更改。futimens和utimensat函数可以指 定纳秒级精度的时间戳。用到的数据结构是与stat函数族相同的timespec结构(见4.2节)。

\#include <sys/stat.h>

int futimens (int fd, const struct timespec times[2]);

int utimensat (int fd, const char ★path, const struct timespec times 12], int flag);

两个函数返回值：若成功，返回0;若出错，返回-1

这两个函数的rt+mes数组参数的第一个元素包含访问时间，第二元素包含修改时间》这两个 时间值是日历时间，如1.10节所述，这是自特定时间(1970年1月1日00:00:00)以来所经过的 秒数。不足秒的部分用纳秒表示。

时间戳可以按下列4种方式之一进行指定。

(1)    如果rimes参数是一个空指针，则访问时间和修改时间两者都设置为当前时间。

(2)    如果times参数指向两个timespec结构的数组，任一数组元素的tv_nsec字段的值 为UTIME_N0Wt相应的时间戳就设置为当前时间，忽略相应的tv_sec字段。

(3)    如果times参数指向两个timespec结构的数组，任一数组元素的tv_nsec字段的值 为UTIMEJ3MIT:相应的时间戳保持不变，忽略相应的tv_sec字段。

(4)    如果times参数指向两个timespec结构的数组，且tv_nsec字段的值为既不是 UTIME_NOW也不是UTIME_OMIT,在这种情况下，相应的时间戳设置为相应的tv_sec和 tv_nsec字段的值。

执行这些函数所要求的优先权取决于参数的值。

•如果times是一个空指针，或者任一tv_nsec字段设为UTIME.NOW,则进程的有效用户ID 必须等于该文件的所有者ID;进程对该文件必须具有写权限，或者进程是一个超级用户进程。

•如果times是非空指针，并且任一 tv_nsec字段的值既不是UTIME_NOW也不是 UTIME_OMIT,则进程的有效用户ID必须等于该文件的所有者ID，或者进程必须是一个 超级用户进程。对文件只具有写权限是不够的。    Q26]

•如果是非空指针，并且两个字段的值都为UTIME_OMIT，就不执行任何的 权限检查。

futimens函数需要打开文件来更改它的时间，utimensat函数提供了一种使用文件名更 改文件时间的方法。pathname参数是相对于片参数进行计算的，只要么是打开目录的文件描述 符，要么设置为特殊值AT_FDCWD (强制通过相対于调用进程的当前目录计算如果 pathname指定了绝对路择，那么及参数被忽略。

utimensat的参数可用于进一步修改默认行为。如果设置了 AT_SYMLINK_NOFOLLOW 标志，则符号链接本身的时间就会被修改(如果路径名指向符号链接)。默认的行为是跟随符号 链接，并把文件的时间改成符号链接的时间。

futimens和utimensat函数都包含在POSIX.1中，第3个函数utimes包含在Single

UNIX Specification 的 XSI 扩展选项中。

\#include <sys/time.h>

int utimes (const char ★pathname, const struct timeval times[2]);

函数返回值i若成功，返回0:若出错，返回-1

utimes函数对路径名进行操作。参数是指向包含两个时间戳（访问时间和修改时间） 元素的数组的指针，两个时间戳是用秒和微妙表示的。

struct timeval {

tv_sec; /* seconds */

long tv_usec; /* microseconds */

}；

注意，我们不能对状态更改时间st_Ctim （i节点最近被修改的时间）指定一个值，因为调 用utimes函数时，此字段会被自动更新。

在某些UNIX版本中，touch（l）命令使用这些函数中的某一个。另外，标准归档程序tar（l） 和epical）可选地调用这些函数，以便将一个文件的时间值设置为将它归档时保存的时间。 ，■实例

图4-21的程序使用带O_TRUNC选项的open函数将文件长度截断为0,但并不更改其i方问 时间及修改时间。为了做到这一点，首先用stat函数得到这些时间，然后截断文件，最后再用 futimens函数重置这商个时间。

tinclude "apue.h"

\#include <fcntl.h>

|1271 int

main(int argc, char *argv[])

{

int    i, fd;

struct stat statbuf; struct timespec times[2]; for (i == 1; i < argc; i++) {

if (stat[argv[i], Sstatbuf) < 0) { /* fetch current times */ err_ret("%s: stat error", argv[i]); continue;

}

if ((fd = open(argv[i], O_RDWR t O_TRUNC)) < 0) { /* truncate */ err_ret("%s: open error", argvfi]); continue;

}

times[0] = statbuf.st_atim; times[1] = statbuf.

if {futimens(fd, times) < 0)    /* reset times */

err_ret("%s: futimens error", argv[i]);

close(fd);

J

exit 0);

图4-21 futimens函数实例

可以用以下Linux命令演示图本21中的程序:

$ Is -1 changamod tines

-rwxr-xr-x 1 sar 13792 Jan 22 -rwxr-xr-x 1 sar 13824 Jan 22 $ Is -lu changamod timaa -rwxr-xr-x 1 sar 13792 Jan 22

査看长度和最后修改时间 01:26 changemod 01:26 times

査看最后访问时间 22:22 changemod

-rwxr-xr-x 1 sar 13824 Jan 22

22:22 times

| $ data                                          | 打印当天日期             |
| ----------------------------------------------- | ------------------------ |
| Fri Jan 27 20:53:46 EST                         | 2012                     |
| $ ./a.out changanod tines    运行图 4-21 的程序 |                          |
| $ Is -1 changamod times                         | 检査结果                 |
| -rwxr-xr-x 1 sar                                | 0 Jan 22 01:26 changemod |
| -rwxr-xr-x 1 sar                                | 0 Jan 22 01:26 times     |
| $ Is -lu changamod tiaras                       | 捡査最后访问时间         |
| -rwxr-xr-x 1 sar                                | 0 Jan 22 22:22 changemod |
| -rwxr-xr-x 1 sar                                | 0 Jan 22 22:22 times     |
| $ la -1c changmod tines                         | 检査状态更改时间         |
| -rwxr-xr-x 1 sar                                | 0 Jan 27 20:53 changemod |
| -rwxr-xr-x 1 sar                                | 0 Jan 21 20:53 times     |

正如我们所预见的一样，最后修改时间和最后访问时间未变。但是，状态更改时间则更改为 程序运行时的时间。

##### 4-21 函数 mkdir、mkdirat 和 rmdir

用mkdir和mkdirat函数创建目录，用rmdir画数删除目录。

\#include <sys/stat.h>

int mkdir (const char * pathname, mode_t mode、；

int mkdirat (int fd, const char * pathname, mode_t mode、；

两个函数返回值，若成功，返回0;若出错，返回-1

这两个函数创建一个新的空目录。其中，.和..目录项是自动创建的。所指定的文件访问权 限mode由进程的文件模式创建屏蔽字修改。

常见的错误是指定与文件相同的morfe (只指定读、写权限)。但是，对于目录通常至少要设 置一个执行权限位，以允许访问该目录中的文件名(见习题4.16〉。

按照4.6节中讨论的规则来设置新目录的用户ID和组ID。

Solaris 10和Linux 3.2.0也使新目录继承父目录的设置组ID位。这就使得在新目录中创建的 文件将继水该目录的组ID。对于Linux,文件系统的实现决定是否支持此特征。例如，ext2、ext3 和ext4文件系统用mount(l)命令的一个选领来控制是否支持此特征。但是.Linux的UFS文件 系统实现则是不可选择的，新目录继承父目录的设置组ID位，这仿效了历史上BSD的实现。在 BSD系统中，新目录的组ID是从父目录继承的。

基于BSD的系统并不要求在目录间传递设里组ID位，因为不论设置组ID位如何，新创建的 文件和目录总是继承父目录的组IDd因为FreeBSD 8.0和Mac OS X 10.6.8是基于4.4BSD的，它 们不要求继承设置组ID位。在这些平台上，新创建的文件和目录总是继承父目录的组ID,这与 是否设置了设置组ID位无关。

早期的UNIX版本并没有mkdir函数，它是由4.2BSD和SVR3引入的。在早期版本中，进 程要调用mknod函数创建一个新目录，但是只有超级用户进程才能使用mknod函数》为了避免 这一点，创建目录的命令mkdir(l)必须由根用户拥有，而且对它设置了设置用户ID位。要通过 —个进程创建一个目录，必须用system(3)函数调用mkdir(l)命令，

mkdirat函数与mkdir函数类似。当押参数具有特殊值AT^FDCWD或者pathname参数指 定了绝对路径名时，mkdirat与mkdir完全一样。否则，/rf参数是一个打开目录，相对路径名 根据此打开目录进行计算。

Q2E    用rmdir函数可以删除一个空目录。空目录是只包含.和..这两项的目录■,

\#include <unistd.h>

int rmdir (const char * pathname):

返回值：若成功.返回0;若出错.返回-1

如果调用此函数使目录的链接计数成为0,并且也没有其他进程打开此目录，则释放由此目 录占用的空间。如果在链接计数达到0时，有一个或多个进程打开此目录，则在此函数返回前删 除最后一个链接及.和..项。另外，在此目录中不能再创建新文件。但是在最后一个进程关闭它 之前并不释放此目录。(即使另一些进程打开该目录，它们在此目录下也不能执行其他操作。这 样处理的原因是，为了使rmdir函数成功执行，该目录必须是空的。)

###### 4.22读目录

对某个目录具有访问权限的任一用户都可以读该目录，但是，为了防止文件系统产生混乱， 只有内核才能写目录。回忆4.5节，一个目录的写权限位和执行权限位决定了在该目录中能否创 建新文件以及删除文件，它们并不表示能否写目录本身。

目录的实际格式依赖于UNIX系统实现和文件系统的设计。早期的系统(如V7)有一个比 较简单的结构：每个目录项是16个字节，其中14个字节是文件名，2个字节是i节点编号■，而 对于4.2BSD，由于它允许更长的文件名，所以每个目录项的长度是可变的。这就意味着读目录的 程序与系统相关。为了简化读目录的过程，UNIX现在包含了一套与目录有关的例程，它们是 POSIX.1的一部分，很多实现阻止应用程序使用read函数读取目录的内容，由此进一步将应用 程序与目录格式中与实现相关的细节隔离》

\#include <dirent.h>

DIR *opendir (const char * pathname);

DIR *fdopendir (int fd};

两个函数返回值：若成功，返回指针；若出错，返回NULL

struct dirent *readdir(DIR *dp、；

返回值：若成功，返回指针：若在目录尾或出错，返回NULL

void rewinddir (DIR *dp); int closedir(DIR *dp、；

返回值：若成功，返回0:若出错，返回-1

long telldir (DIR *dp);

返回值：与分关联的目录中的当前位置

void seekdir(DIR *dp, long loc、；

fdopendir函数最早出现在SUSv4 (Single UNIX Specification第4版)中，它提供了一种 方法，可以把打开文件描述符转换成目录处理函数需要的DIR结构。

telldir和seekdir函数不是基本POSIX.1标准的组成部分。它们是Single UNIX Specification中的XSI扩展，所以可以期望所有符合UNIX系统的实现都会提供这两个函数。

回忆一下，在图1-3程序中(13命令的基本实现部分)使用了其中几个函数。

定义在头文件＜dirent.h＞中的dirent结构与实现有关。实现对此结构所做的定义至少包 含下列两个成员：

ino_t d_ino;    /* i-node number */

char d_name[];    /* null-terminated filename */

POSIX.1并没有定义d_ino项，因为这是一个实现特征，但在POSIX.1的XSI扩展中定义了 d_ino。POSIX.1在此结构中只定义了 d_name项。

注意，d_name项的大小并没有指定，但必须保证它能包含至少NAME_MAX个字节(不包含 终止null字节，回忆图2-15)。因为文件名是以null字节结束的，所以在头文件中如何定义数组 d_name并无多大关系，数组大小并不表示文件名的长度。

DIR结构是•一个内部结构，上述7个函数用这个内部结构保存当前正在被读的目录的有 关信息。其作用类似于FILE结构。FILE结构由标准I/O库维护，我们将在第5章中对它进 行说明。

由opendir和fdopendir退回的指向DIR结构的指针由另外5个函数使用。opendir执 行初始化操作，使第一个readdir返回目录中的第一个目录项。DIR结钩由fdopendir创建 时，readdir返回的第一项取决于传给fdopendir函数的文件描述符相关联的文件偏移量。注 意，目录中各目录项的顺序与实现有关。它们通常并不按字母顺序排列。

幽实例

我们将使用这些对目录进行操作的例程编写一个遍历文件层次结构的程序，其目的是得 到如图4-4中所示的各种类型的文件计数。图4-22的程序只有一个参数，它说明起点路径名， 从该点开始递归降序遍历文件层次结构。Solaris提供了一个遍历此层次结构的函数ftw(3), 对于每一个文件它都调用一个用户定义的函数。ftw函数的问题是：対于每一个文件，它都 调用stat函数，这就使程序跟随狩号链接。例如，如果从根目录(root)开始，并且有一个 名为/lib的符号链接，它指向/usr/lib,则所有在目录/usr/lib中的文件都会被计数两 次。为了纠正这一点，Solaris提供了另一个函数nftw(3)，它具有一个停止跟随符号链接的 选项。尽管可以使用nftw，但是为了说明目录例程的使用方法，我们还是编写了一个简单的 文件遍历程序。

在 SUSv4 中，nftw 包含在 XS1 选领中。FreeBSD 8.0, Linux 32.0, Mac OS X 10.6.8 以及Solaris 10 都包括了该&数的实现。(在SUSv4中，ftw函数已被标记为弃用a)基于BSD的UNIX系统则有另一个 函数fts(3),它提供类似的功能。该函数在FreeBSD 8.0、Unux 32.0和Mac OS X 10.6.8中是可用的。

\#include "apue.h" #include <dirent.h> #include <limits.h>

/* function type that is called for each filename */ typedef int Myfunc{const char *, const struct stat *, int);

static Myfunc myfunc;

static int myftw(char *, Myfunc *);

static int dopath{Myfunc *)；

static long nreg, ndir, nbllc, nchr, nfifo, nslink, nsock, ntot;

int main(int argc, char *argv[])

int    ret;

if (argc != 2)

err_quit("usage: ftw <starting-pathname>"); ret = myftw(argv[l], myfunc);    /* does it all */

ntot = nreg + ndir + nblk + nchr + nfifo + nslink + nsock; if (ntot == 0)

ntot = 1;    /* avoid divide by 0; print 0 for all counts *Z

printf("regular files = %71d, %5.2f    nreg,

nreg*100.0/ntot);

printf("directories = %71d, %5.2f    ndir,

ndir*100.0/ntot);

printf("block special = %71d, %5.2f    nblk,

nblk*100.0/ntot);

printf{"char special = %71d, %5.2f    nchr,

nchr*100.0/ntot);

printf("FIFOs    = %71d, %5.2f    nfifo,

nfifo*100.0/ntot)；

printf("symbolic links = %71d, %5.2f %%\n", nslink, nslink*100.0/ntot);

printf("sockets    = %71d, %5.2f    nsock,

nsock*100.0/ntot);

exit(ret);

画»

/*

\*    Descend through the hierarchy, starting at "pathname".

\*    The caller's func() is called for every file.

\#define FTW_F 1 /* #define FTW_D 2 /* #define FTW_DNR 3 /* #define FTW_NS 4 /*

file other than directory */ directory */

directory that can't be read */ file that we can't stat */

static char *fullpath; /* contains full pathname for every file */ static size_t pathlen;

static int    /* we return whatever func () returns */

myftw{char *pathname, Myfunc *func)

t

fullpath = path_alloc(&pathlen); /* malloc PATH_MAX+1 bytes */ /* “Figure 2.16}) */

if (pathlen <= strlen(pathname)) { pathlen = strlen(pathname) * 2;

if { {fullpath = realloc(fullpath, pathlen)) = NULL) err_sys{"realloc failed");

}

strcpy(fullpath, pathname); return(dopath(func) };

/*

\*    Descend through the hierarchy, starting at "fullpath".

\*    If "fullpath" is anything other than a directory, we lstat() it,

\*    call func{), and return. For a directory, we call ourself

\*    recursively for each name in the directory.

*Z

static int    /* we return whatever func() returns */

dopath(Myfunc* func)

t

struct    stat    statbuf;

struct    dirent    *dirp;

DIR    *dp;

int    ret, n;

if (lstat(fullpath, Sstatbuf) < 0) /* stat error */ return(func(fullpath, Sstatbuf, FTW_NS));

if (S_ISDIR(statbuf.st_raode) == 0) /* not a directory */ return{func(fullpath, &statbuf, FTW_F));

/*

\*    it’s a directory. First call funcU for the directory,

\*    then process each filename in the directory.

*/

if ((ret = func(fullpath, &statbuf, FTW_D)) != 0) return(ret);

n = strlen(fullpath);

if (n + NAME_MAX + 2 > pathlen) { /* expand path buffer */ pathlen *= 2;

if {(fullpath = realloc(fullpath, pathlen)) == NULL) err_sys("realloc failed");

}

fullpath[n++] = '/'； fullpath[n] = 0;

if ((dp = opendir(fullpath)) == NULL) /* can't read directory *Z return(func(fullpath, Sstatbuf, FTW_DNR));

while ((dirp = readdir(dp)) != NULL) {

if (strcmp(dirp->d_name, ".") == 0    | |

strcmp(dirp->d_name,    == 0)

continue;    /* ignore dot and dot-dot */

strcpy (&fullpath[n], dirp->d_name)，- /* append name after "/" */ if {(ret = dopath(func))    != 0)    Z* recursive */

break; /* time to leave */

}

fullpath[n-11 = 0; /* erase everything from slash onward */ if (closedir(dp) < 0)

err_ret{"can't close directory %s", fullpath); return(ret);

}

static int

myfunc(const char ^pathname, const struct stat *statptr, int type)

switch (type) { case FTW_F:



switch (statptr->st_mode &



case S_IFREG: case S_IFBLK: case S_IFCHR: case S_IFIFO: case S_IFLNK:



nreg++; nblk++; nchr++; nfifo++; nslink++;



S_IFMT) { break; break;



break;

break;



break;



case S_IFSOCK:    nsock++; break;

case S—IFDIR: /* directories should have type = FTW_D ★/ err_dump("for S_IFDIR for %s", pathname);



break;

case FTW_D： ndir++; break;

case FTW_DNR：

err_ret("can't read directory %s", pathname); break;

case FTW_NS:

err_ret{"stat error for %s", pathname); break;

default:

err_dump("unknown type %d for pathname %s", type, pathname);

}

return(0);

LSS    图4-22递归降序遍历目录层次结构，并按文件类型计数



在程序中，我们提供了比所要求的更多的通用性，这样做的目的是为了具体说明ftw和nftw函数 的应用。例如，函数myfunc总是退回0,即使调用它的函数准备了处理非0返回也是如此。    ■

关于降序遍历文件系统的更多信息，以及在很多标准UNIX命令(如find、Is、tar等) 中使用这种技术的情况，请参阅Fowler、Korn和Vo[1989]。

##### 4.23 函数 chdir、f chdir 和 getcwd

每个进程都有一个当前工作目录，此目录是搜索所有相对路径名的起点(不以斜线开始的路 径名为相对路径名)。当用户登录到UNIX系统时，其当前工作目录通常是口令文件

(/etc/passwd)中该用户登录项的第6个字段-用户的起始目录(home directory)。当前工

作目录是进程的一个属性，起始目录则是登录名的一个属性。

进程调用chdir或fchdir函数可以更改当前工作目录。

\#include <unistd.h>

int chdir (const char * pathname、；

int fchdir (int fd);

两个函数的返回值：若成功，返回0:若出错，返回-1

在这两个函数中，分别用汝zwme或打开文件描述符来指定新的当前工作目录。

实例

因为当前工作目录是进程的一个属性，所以它只影响调用chdir的进程本身，而不影响其 他进程（我们将在第8章更详细地说明进程之间的关系）。这就意味着图4-23的程序并不会产生 我们可能希望得到的结果。

\#include "apue.h" int

main(void)

if (chdir("/tmp") < 0)

err_sys("chdir failed");

printf("chdir to /tmp succeededXn"); exit(0);

图4 23 chdir函数实例    S3

如果编译图4-23程序，并且调用其可执行目标代码文件mycd，则可以得到下列结果：

$ pwd

/usr/lib

$ mycd

chdir to /tmp succeeded

$ pwd

/usr/lib

从中可以看出，执行mycd命令的shell的当前工作目录并没有改变，这是shell执行程序工作方 式的一个副作用。每个程序运行在独立的进程中，shell的当前工作目录并不会随着程序调用 chdir而改变。由此可见，为了改变shell进程自己的工作目录，shell应当直接调用chdir函数， 为此，cd命令内建在shell中。

因为内核必须维护当前工作目录的信息，所以我们应能获取其当前值。遗憾的是，内核 为每个进程只保存指向该目录v节点的指针等目录本身的信息，并不保存该目录的完整路 径名。

;    Linux内核可以确定完整路径名。完整路径名的各个组成部分分布在mount表和dcache表

中，然后进抒重新组装，比如在读取/proc/self/cwd符号链接时。

我们需要一个函数，它从当前工作目录（.）开始，用..找到其上一级目录，然后读其目录 项，直到该目录项中的i节点编号与工作目录i节点编号相同，这样地就找到了其对应的文件名。 按照这种方法，逐层上移，直到遇到根，这样就得到了当前工作目录完整的绝对路径名。很幸运， 函数getcwd就提供了这种功能。

^include <unistd.h>

char *getcwd （char *buf, size_t size）;

返回值：若成功，返回6妒若出错，返回NULL

必须向此函数传递两个参数，一个是缓冲区地址/>«/，另一个是缓冲区的长度Jize （以字节为 单位）。该缓冲区必须有足够的长度以容纳绝对路径名再加上一个终止null字节，否则返回出错

（请回忆2.5.5节中有关为最大长度路径名分配空间的讨论）。

丨 某些getcwd的早期实现允许第一个参数加*/为NULL。在这种情况下，此函数调用malloc 动态地分私jize字节數的空间。这不是POSDC1或Single UNIX Specification的所属部分，应当避

I免使用。

、实例

图4-24的程序将工作目录更改至一个指定的目录，然后调用getcwd,最后打印该工作 目录。如果运行该程序，则可得

S ./a.out

cwd = /var/spool/uucppublic

_    $ la -1 /usr/spool

画 lrwxrwxrwx 1 root 12 Jan 31 07:57 /usr/spool -> ../var/spool

\#include "apue.h1*

int

main(void)

{

char *ptr; size_t size;

if (chdir("/usr/spool/uucppublic") < 0) err^sys("chdir failed");

ptr = path_alloc (ssize)，- /* our own function */ if (getcwd(ptr, size) == NULL)

err_sys("getcwd failed"); printf("cwd = %s\n", ptr); exit(0);

图4-24 getcwd函数实例

注意，chdir跟随符号链接（正如我们希望的，如图4-17中所示），但是当getcwd沿目录 树上溯遇到/var/spool目录时，它并不了解该目录由符号链接/usr/spool所指向。这是符 号链接的一种特性。

当一个应用程序需要在文件系统中返回到它工作的出发点时，getcwd函数是有用的。 在更换工作目录之前，我们可以调用getcwd函数先将其保存起来。在完成了处理后，就可 将所保存的原工作目录路径名作为调用参数传送给chdir,这样就返回到了文件系统中的出 发点。

fchdir函数向我们提供了一种完成此任务的便捷方法。在更换到文件系统中的不同位置前， 无需调用getcwd函数，而是使用open打开当前工作目录，然后保存其返回的文件描述符。当 希望回到原工作目录时，只要简单地将该文件描述符传送给fchdiro

4.24设备特殊文件

st_dev和st_rdev这两个字段经常引起混淆，在18.9节，我们编写ttynarae函数时，需 要使用这两个字段。有关规则很简单：

•每个文件系统所在的存储设备都由其主、次设备号表示。设备号所用的数据类型是 基本系统数据类型dev_t。主设备号标识设备驱动程序，有时编码为与其通信的外 设板；次设备号标识特定的子设备。回忆图4-13, —个磁盘驱动器经常包含若干个 文件系统。在同一磁盘驱动器上的各文件系统通常具有相同的主设备号，但是次设QKI 备号却不同。

•我们通常可以使用两个宏：major和minor来访同主、次设备号，大多数实现都定义这 两个宏。这就意味着我们无需关心这两个数是如何存放在dev_t对象中的。

= 早期的系统用16位整型存放设备号：8位用于主设备号，8位用于次设备号。FreeBSD 8.0 ；和Mac OS X 10.6.8使用32位整型，其中8位表示主设备号，24位表示次设备号。在32位系 J统中，Solaris 10用32位整型表示dev_t，其中14位用于主设备号，18位用于次设备号。在 j 64位系统中，Solaris 10用64位整型表示dev_t,主设备号和次设备号各用其中的32位表示。

在Linux 3.2.0上，虽然dev_t是64位整型，但其中只有12位用于主设备号，20位用于次设 备号。

POSIX.1说明（1时_七类型是存在的，但没有定义它包含什么，或如何取得其内容。大多数实 ;现定义了宏major和minor，但在哪一个头文件中定义它们则与实现有关。基于BSD的UNIX 丨系统将它们定义在＜sys/types＞中。Solaris在＜3?5/1）1]«167.11＞中定义了它们的丞教原型，

因为在＜sys/sysmacros .h＞中的宏定义都弃用了。Linux将它4门定义S＜sys/sysmacros .h＞

中，而该头文件又包含在＜sys/type.h＞*o

•系统中与每个文件名关联的st_dev值是文件系统的设备号，该文件系统包含了这一文 件名以及与其对应的i节点。

•只有字符特殊文件和块特殊文件才有st_rdev值。此值包含实际设备的设备号。

I实例

图4-25的程序为每个命令行参数打印设备号，另外，若此参数引用的是字符特殊文件或块特 殊文件，则还打印该特殊文件的st_rdev值。

\#include "apue.h"

\#ifdef SOLARIS

\#include ＜sys/mkdev.h＞

\#endif int

main(int argc, char *argv[])

int    i;

struct stat buf;

for (i = 1; i < argc; i++) { printf ("%s: ", argv[i]) if (stat(argv[i], &buf) < 0) {

err_ret("stat error"); continue;

1

printf("dev = %d/%d", major(buf.st_dev), minor(buf.st^dev)); if (S_ISCHR(buf.st_mode) I| S_ISBLK(buf.st_mode))    {

printf (" (%s) rdev = %d/%d",

(S_ISCHR(buf.st_mode)) ? "character" : "block", major(buf.st_rdev), minor(buf.st_rdev));

}

printf ("\n");

}

exit{0);

图 4-25 打印 st_dev 和 st_rde▽值 在Linux上运行此程序得到下面的输出：

$ . /a.out / Zhnw/sar /dav/tty[01]

/: dev = 8/3

Zhome/sar： dev = 8/4

/dev/ttyO: dev = 0/5 (character) rdev = 4/0

/dev/ttyl: dev = 0/5 (character) rdev = 4/1

$ nount    哪些目录安装在哪些设备上？

/dev/sda3 on / type ext3 (rw, errors=remount-ro, coirunit=0) /dev/sda4 on /home type ext2 (rw,commit=0)

| $ Is -1 /<tev/tty[01] | /dev/sda[34] |      |      |      |            |       |           |
| --------------------- | ------------ | ---- | ---- | ---- | ---------- | ----- | --------- |
| brw-rw--              | —1           | root | 8,   | 3    | 2011-07-01 | 11:08 | /dev/sda3 |
| brw-rw--              | ___ i        | root | 8,   | 4    | 2011-07-01 | 11:08 | /dev/sda4 |
| crw--w--              | —1           | root | 4,   | 0    | 2011-07-01 | 11:00 | /dev/ttyO |
| crw-----              | —1           | root | 4,   | 1    | 2011-07-01 | 11:08 | /dev/ttyl |

传给该程序的前两个参数是目录（/和/home/sar），后两个参数是设备名/dev/tty [01]。（我 们用shell正则表达式语言以缩短所需的输入量。shell将字符串/dev/tty[01]扩展为 /dev/ttyO /dev/ttyl。）

我们期望设备是字符特殊文件。从程序的输出可见，根目录和/home/sar目录的设备号不 同，这表示它们位于不同的文件系统中。运行mOUnt（l）命令可以证明了这一•点。

然后用Is命令査看由mount命令报告的两个磁盘设备和两个终端设备，这两个磁盘设备是 块特殊文件，而两个终端设备是字符特殊文件。（通常，只有那些包含随机访问文件系统的设备 类型是块特殊文件设备，如硬盘驱动器、软盘驱动器和CD-ROM等，UNIX的早期版本支持磁带 存放文件系统，但这从未广泛使用过。）

注意，两个终端设备（st_dev）的文件名和i节点在设备0/5上（devtmpfs伪文件系统， 它实现了/dev文件系统），但是它们的实际设备号是4/0和4/1。

4.25文件访问权限位小结

我们己经说明了所有文件访问权限位，其中某些位有多种用途。图4-26列出了所有这些权限 位，以及它们对普通文件和目录文件的作用=

最后9个常量还可以分成如下3组：

S_IRWXU = S_IRUSR I S_IWUSR I S.IXUSR S_IRWXG = S_IRGRP I S_IWGRP I S_IXGRP S^IRWXO = S_IROTH I S.IWOTH I S_IXOTH

| 常量    | 说明       | 对普通文件的影响                                             | 对目录的影响                                  |
| ------- | ---------- | ------------------------------------------------------------ | --------------------------------------------- |
| S_ISUID | 设置用户ID | 执行吋设置有效用户ID                                         | （未使用）                                    |
| S_ISGID | 设置组ID   | 若组执行位设置，则执行时设置有效 组ID:否则使强制性锁起作用（若支持） | 将在目录中创建的新文件的组ID 设置为目录的组ID |
| S ISVTX | 粘着位     | 在交换区缓存程序正文（若支持）                               | 限止在目录中删除和重命名文件                  |
| S_IRUSR | 用户读     | 许可用户读文件                                               | 许可用户读目录项                              |
| S_IWUSR | 用户写     | 许可用户写文件                                               | 许可用户在目录中删除和创建文件                |
| S„IXUSR | 用户执行   | 许可用户执行文件                                             | 许可用户在目录中概给定蹄径名                  |
| S_IRGRP | 组读       | 许可组读文件                                                 | 许可组读目录项                                |
| S_IWGRP | 组写       | 许可组写文件                                                 | 许可组在目录中删除和创建文件                  |
| S IXGRP | 组执行     | 许可组执行文件                                               | 许可组在目录中搜索给定路径名                  |
| S_IROTH | 其他读     | 许可其他读文件                                               | 许可其他读目录项                              |
| S_IWOTH | 其他写     | 许可其他写文件                                               | 许可其他在目录中刪除和创建文件                |
| S IXOTH | 其他执行   | 许可其他执行文件                                             | 许可其他在冃录中触给定路径名                  |

图4,26文件访问权限位小结

##### 4.26小结

本章内容围绕stat函数，详细介绍了 stat结构中的每一个成员。这使我们对UNIX文件 和目录的各个属性都有所了解。我们讨论了文件和目录在文件系统中是如何设计的以及如何使用® 文件系统命名空间。对文件和目录的所有属性以及对文件和目录进行操作的所有函数的全面了 解，对于UNIX编程是非常重要的。

习题

4.1用stat函数替换图4-3程序中的lstat函数，如若命令行参数之一是符号链接，会发生 什么变化？

4.2如果文件模式创建屏蔽字是777 （八进制），结果会怎样？用shell的umask命令验证该结果。 4.3关闭一个你所拥有文件的用户读权限，将导致拒绝你访问自己的文件，对此进行验证。

4.4创建文件foo和bar后，运行图4-9的程序，将发生什么情况？

4.5    4.12节中讲到一个普通文件的大小可以为0,同时我们又知道st.size字段是为目录或符 号链接定义的，那么目录和符号链接的长度是否可以为0?

4.6    编写一个类似cp（l）的程序，它复制包含空洞的文件，但不将字节0写到输出文件中去。

4.7    在4.12节Is命令的输出中，core和core, copy的访问权限不同，如果创建两个文件时 umask没有变，说明为什么会发生这种差别。

4.8    在运行图4-16的程序时，使用了 df（l）命令来检查空闲的磁盘空间。为什么不使用du（l） 命令？

4.9图4-20中显示unlink函数会修改文件状态更改时间，这是怎样发生的？

4.10 4.22节中，系统对可打开文件数的限制对myftw函数会产生什么影响？

4.11在4.22节中的myftw从不改变其目录，对送种处理方法进行改动：每次遇到一个目录就用 其调用chdir，这样每次调用lstat时就可以使用文件名而非路径名，处理完所有的目录

项后执行chdir(» . .    》比较这种版本的程序和书中程序的运行时间。

4.12每个进程都有一个根目录用于解析绝对路径名，可以通过chroot函数改变根目录。在手 册中査阅此函数。说明这个函数什么时候有用。

4.13如何只设置两个时间值中的一个来使用utimes函数？

4.14 有些版本的 finger(l)命令输出 “New mail received …”和 “unread since ...”，其中...表示 相应的日期和时间，程序是如何决定这些日期和时间的？

4.15用cpio(l)和tar(l)命令检査档案文件的格式(请参阅《UNIX程序员手册》第5部分中的 说明)。3个可能的时间值中哪几个是为每一个文件保存的？你认为文件复原时，文件的访 问时间是什么？为什么？

4.16    UNIX系统对目录树的深度有限制吗？编写一个程序循环，在每次循环中，创建目录，并将 该目录更改为工作目录。确保叶节点的绝对路径名的长度大于系统的PATH_MAX限制。可 以调用getcwd得到目录的路径名吗？标准UNIX系统工具是如何处理长路径名的？对目 录可以使用tar或cpio命令归档吗？

4.17    3.16节中描述了/dev/fd特征。如果每个用户都可以访问这些文件，则其访问权限必须为 rw-rw-rw-o有些程序创建输出文件时，先删除该文件以确保该文件名不存在，忽略返回码。 unlink (path);

if ( (fd = creat(path, FILE^MODE)) < 0) err_sys(...);

® 如果path是/dev/fd/1,会出现什么情况？
