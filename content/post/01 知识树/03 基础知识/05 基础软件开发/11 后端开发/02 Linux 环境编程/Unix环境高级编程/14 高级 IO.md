---
title: 14 高级 IO
toc: true
date: 2018-08-21 18:16:23
---
### 第14章

## 离级I/O

##### 14.1引言

本章涵盖众多概念和函数，我们把它们统统都放到高级I/O下讨论：非阻塞I/O、记录锁、 I/O多路转接（select和poll函数）、异步I/O、readv和writev函数以及存储映射I/O （mmap）。第15章和第17章中的进程间通信以及以后各章中的很多实例都要使用本章所描述的 概念和函数。

##### 14.2非阻塞I/O

10.5节中曾将系统调用分成两类：“低速”系统调用和其他。低速系统调用是可能会使进程 永远阻塞的一类系统调用，包括：

•如果某些文件类型（如读管道、终端设备和网络设备）的数据并不存在，读操作可能会 使调用者永远阻塞；

•如果数裾不能被相同的文件类型立即接受（如管道中无空间、网络流控制），写操作可能 会使调用者永远阻塞；

•在某种条件发生之前打开某些文件类型可能会发生阻塞（如要打开一个终端设备，需要 先等待与之连接的调制解调器应答，又如若以只写模式打开FIFO,那么在没有其他进程 已用读模式打开读FIFO时也要等待）：

间 •对已经加上强制性记录锁的文件进行读写：

•某些ioctl操作；

•某些进程间通信函数（见第15章）。

我们也曾说过，虽然读写磁盘文件会暂时阻塞调用者，但并不能将与磁盘I/O有关的系统调 用视为“低速”。

非阻塞I/O使我们可以发出open、read和write送样的I/O操作，并使这些操作不会永 远阻塞。如果这种操作不能完成，则调用立即出错返回，表示该操作如继续执行将阻塞。

对于一个给定的描述符，有两种为其指定非阻塞I/O的方法。

（1）如果调用open获得描述符，则可指定0_NONBL0CK标志（见3.3节）。

（2〉对于已经打开的一个描述符，则可调用fcntl，由该函数打开O_NONBLOCK文件状态

标志（见3.14节〉。图3-12中的函数可用来为一个描述符打开任一文件状态标志，

I System V的早期版本使用标志O_NDELAY指定非阻塞方式。在这些System V版本中，如果无数 ,据可读，则read返回0。而UNIX系统又常将read的返田值0解释为文件结束，两者有所混淆。

POSIX.1提供了一个非阻塞标志，它的名字和语义都与O_NDELAY不同。确实，在System V的早期版 本中，当从read得到返回值0时，我们并不知道该调用是阻塞了还是遇到了文件尾端。P0SIX.1要 求，对于一个非阻塞的搞述符如果无数据可读，则read返回-1，errno被设置为EAGAIN。SystCTn V 派生的某些平台既支持较旧的O__NDELAY，又支持POSDC1的0_NONBLOCK,但在本书的实例中只使 用POSK.1规定的特征。较旧的O_NDELAY只是为了向后兼容，不应在新应用程序中使用。

4.3BSD为fcntl提供了 FNDELAY标志，其语义也稍有区别Q它不只影响描述符的文件状态 标志，还将终端设备或套接字的标志更改成非阻塞的，因此不仅影响共享同一文件表项的用户，

,而且对终端或套接字的所有用户起作用（4.3BSD非阻塞I/O只对终端和套接字起作用）。另外， 如果对一个非阻塞搞述符的操作不能无阻塞地完成，那么4.3BSD返回EWOULDBLOCK。现今，基

!于BSD的系统提供POSIX.1的O_NONBLOCK标志.并且将EWOULDBLOCK定义为与POSK」的 j EAGAIN相同。这些系统提供与其他POSIX兼容系统相一致的非阻塞语义：文件状态标志的更改 ，影响同一文件表领的所有用户，但与通过其他文件表项时同一设备的访问无关。

图144中的程序是一个非阻塞I/O的实例，它从标）聯r入读500 000字节，并试图将它们写到标准 输出上。该程序先将标准输出设置为非阻塞的，然后用for循环进行输出，每次write调用的结果都 在标准错误上打印。函数clr_fl类似于图3-12中的set_fl。这个新函数清除1个或多个标志位。闕

♦include "apue.h"

\#include <errno.h>

\#include <fcntl.h>

char buf[500000];

int

main(void)

int    ntowrite, nwrite;

char    *ptr;

ntowrite = read(STDIN_FILENO, buf, sizeof(buf)); fprintf(stderr, "read %d bytes\n", ntowrite);

set_fl(STDOUT_FILENO, O^NONBLOCK);    /* set nonblocking */

ptr = buf;

while (ntowrite > 0) { errno = 0;

nwrite = write(STDOUT_FILENO, ptr, ntowrite);

fprintf(stderr, "nwrite = %d, errno = %d\n", nwrite, errno);

if (nwrite > 0) { ptr += nwrite; ntowrite -= nwrite;

}

clr_fl(STDOUT_FILENO, O_NONBLOCK);    /* clear nonblocking */

exit(0)；

图14-1长的非阻塞write 若标准输出是普通文件，则可以期望write只执行一次。

$ Is -1 /etc /services    打印文件长度

-rw-r--r-- 1 root 677959 Jun 23 2009 /etc/services

9 . /a.out: < /etc/services >    . file    先试~个普通文件

read 500000 bytes

nwrite = 500000, errno = 0    一次写

$ Is -1    检验输出文件长度

-rw-rw-r-- 1 sar    500000 Apr 1 13:03 temp.file

但是，若标准输出是终端，则期望write有时返回小于500 000的一个数字，有时返回错误。下 513］面是运行结果：

$ . Za. out < /etc/services 2>stdarc.out    终端至输出

| $ cat sfcderz.out | 大量输出至终端- |           |       |       |               |               |
| ----------------- | --------------- | --------- | ----- | ----- | ------------- | ------------- |
| read 500000 bytes |                 |           |       |       |               |               |
| nwrite            | =               | 999,      | errnc | i :   | :0            |               |
| nwrite            | =               | -1, e     | rrno  | =     | 35            |               |
| nwrite            | =               | -1, e     | rrno  | =     | 35            |               |
| nwrite            | =               | -1, e     | rrno  | =     | 35            |               |
| nwrite            | =               | -1, errno | =     | 35    |               |               |
| nwrite            | =               | 1001,     | errr  | IO    | =0            |               |
| nwrite            | =               | -1, e     | rrno  | =     | 35            |               |
| nwrite            | =               | 1002,     | errno | =0    |               |               |
| nwrite            | =               | 1004,     | errr  | lO    | =0            |               |
| nwrite            | =               | 1003,     | errr  | IO    | =0            |               |
| nwrite            | =               | 1003,     | errr  | lO    | =0            |               |
| nwrite            | =               | 1005,     | errr  | lO    | =0            |               |
| nwrite            | =               | -1, e     | rrno  | =     | 35            | 61个此类错误  |
| nwrite            | =               | 1006,     | errr  | lO    | =0            |               |
| nwrite            | =               | 1004,     | errr  | IO    | =0            |               |
| nwrite            | =               | 1005,     | errr  | lO    | =0            |               |
| nwrite            | =               | 1006,     | errno | =0    |               |               |
| nwrite            | =               | -1, errno | =     | 35    | 108个此类错误 |               |
| nwrite            | =               | 1006,     | errr  | lO    | =0            |               |
| nwrite            |                 | 1005,     | errr  | IO    | =0            |               |
| nwrite            | =               | 1005,     | errr  | lO    | =0            |               |
| nwrite            | =               | -1» e     | rrno  | =     | 35            | 681个此类错误 |
|                   |                 |           |       |       |               | 等等          |
| nwrite            | =               | 347,      | errnc | 1 = 0 |               |               |

在该系统上，errno值35对应的是EAGAIN。终端驱动程序一次能接受的数据量随系统而 变。具体结果还会因登录系统时所使用的方式的不同而不同：在系统控制台上登录、在硬接线的

终端上登录或用伪终端在网络连接上登录。如果你在终端上运行一个窗口系统，那么也是经由伪 终端设备与系统交互。    ■

在此实例中，程序发出了 9 000多个write调用，但是只有500个真正输出了数据，其余的 都只返回了错误。这种形式的循环称为轮询，在多用户系统上用它会浪费CPU时间。14.4节将介 绍非阻塞描述符的I/O多路转接，这是进行这种操作的一种比较有效的方法。

有时，可以将应用程序设计成使用多线程的（见第11章），从而避免使用非阻塞I/O。如若我们 能在其他线程中继续进行，则可以允许单个线程在UO调用中阻塞。这种方法有时能简化应用程序的 设计（见第21章），但是，线程间同步的开销有时却可能增加复杂性f于是导致得不偿失的后果。[484]

###### 14.3记录锁

当两个人同时编辑一个文件时，其后果将如何呢？在大多数UNIX系统中，该文件的最后状 态取决于写该文件的最后一个进程。但是対于有些应用程序，如数据库，进程有时需要确保它正 在单独写一个文件。为了向进程提供这种功能，商用UNIX系统提供了记录锁机制。（第20章包 含了使用记录锁的数据库固数库。）

记录锁（record locking）的功能是：当第一个进程正在读或修改文件的某个部好时，使用记 录锁可以阻止其他进程修改同一文件区，对于UNIX系统而言，“记录”这个词是一种误用，因 为UNIX系统内核根本没有使用文件记录这种概念。一个更适合的术语可能是字节范围锁 （byte-range locking）,因为它锁定的只是文件中的一个区域（也可能是整个文件）。

1.历史

对早期UNIX系统的其中一个批评是它们不能用来运行数据库系统，其原因是这些系统不支 持对部分文件加锁。在UNIX系统寻找进入商用计算环境的途径时，很多系统开发小组以各种不 同方式增加了対记录锁的支持。

早期的伯克利版本只支持flock函数。该函数只能对整个文件加锁，不能对文件中的一部分加锁。

SVR3通过fcntl函数增加了记录锁功能。在此基础上构造了 lockf函数，它提供了一个 简化的接口。这些函数允许调用者对一个文件中任意字节数的区域加锁，长至整个文件，短至文 件中的一个字节。

POSIX.1标准的基础是fcntl方法。图14-2列出了各种系统提供的不同形式的记录锁。注 意，Single UNIX Specification 在其 XSI 扩展中包括了 lockf。

| 系统            | 建议性 | 强制性 | fcntl | lockf | flock |
| --------------- | ------ | ------ | ----- | ----- | ----- |
| SUS             |        |        |       | XSI   |       |
| FreeBSD 8.0     |        |        | •     | •     | •     |
| Linux 3.2.0     |        | •      | 暑    | 垂    | •     |
| Mac OS X 10.6+8 |        |        | •     | •     | •     |
| Solaris 10      |        | •      |       |       | •     |

图14-2各种UNIX系统支持的记录锁形式

本节最后部分将说明建议性锁和强制性锁之间的区别。本书只介绍POSIX.1的fcntl锁。

记录锁是1980年由John Bass最早添加到V7上的。内核中相应的系統调用入口项是名为 locking的函数。此函数提供了强制性记录锁功能，它被用在很多System in版本中。Xenix系统采用 了此函数，某些基于Intel的System V派生版表’如OpenServer5,在Xenix兼容库中仍旧支持该函数。

2. fcntl记录锁

3.14节中己经给出了 fcntl函数的原型，为了叙说方便，这里再重复一次。

\#include <fcntl.h>

int fcntl （int fd, int cmd, .../* struct flock *flockptr */）;

返回值，若成功，依赖于见下），否则，返回-1 对于记录锁，F_SETLK或ELSETLKW。第三个参数（我们将调用 是一个指向flock结构的指针。

struct flock { short l_type; short l_whence; off_t l_start; off_t l_len; pid_t l_pid;

}；



/* F_RDLCK, F_WRLCK, or F_UNLCK */

/* SEEK_SET, SEEK_CUR, or SEEK_END */

/* offset in bytes, relative to l_whence */ /* length, in bytes; 0 means lock to EOF */ /* returned with F_GETLK */

对flock结构说明如下。

•所希望的锁类型：F_RDLCK （共享读锁）、F_WRLCK （独占性写锁）或F_UNLCK （解锁 一个区域）。

•要加锁或解锁区域的起始字节偏穆量（l_start和l_whence）。

•区域的字节长度（lJLen）。

•进程的ID （l_pid）持有的锁能阻塞当前进程（仅由F_GETLK返回）。

关于加锁或解锁区域的说明还要注意下列几项规则。

•指定区域起始偏務量的两个元素与lseek函数（见3.6节）中最后两个錄类似。l_whence

可选用的值是 SEEK_SET、SEEK_CUR 或 SEEK_END。

•锁可以在当前文件尾端处开始或者越过尾端处开始，但是不能在文件起始位置之前开始。 •如若lJLen为0,则表示锁的范围可以扩展到最大可能偏移量。这意味着不管向该文件

中迫加写了多少数据，它们都可以处于锁的范围内（不必猜测会有多少字节被追加写到

了文件之后），而且起始位置可以是文件中的任意一个位置。

•为了对整个文件加锁，我们设置l_start和l_whence指向文件的起始位置，并且指定

长度（l_len）为0。（有多种方法可以指定文件起始处，但常用的方法是将l_start指 |486|    定为 0，l_whence 指定为 SEEK_SET。）

上面提到了两种类型的锁：共享读锁（l_type为L_RDLCK）和独占性写锁（L_WRLCK）。基本规 则是：任意多个进程在一个给定的字节上可以有一把共享的读锁，但是在一个给定字节上只能有一个进

程有一把独占写锁。进一步而言，如果在一个给定字节 上已经有一把或多把馈锁，则不能在读字节上再加写锁； 如果在一个字节上已经有一把独占性写锁，则不能再対 它加任何壊锁。在图143中示出了这壁兼容性规则，

请求

当前区域

|                   | 读锁 | 写锁 |
| ----------------- | ---- | ---- |
|                   | 允许 | 允许 |
| 有一把或 多把读锁 | 允忤 | 拒绝 |
| 有一把写锁        | 拒绝 | 拒绝 |

图14-3不同类型锁彼此之间的兼容性



上面说明的兼容性规则适用于不同进程提出的 锁请求，并不适用于单个进程提出的多个锁请求。如 果一个进程对一个文件E间已经有了一把锁，后来该 进程又企图在同一文件区间再加一把锁，那么新锁将

替换已有锁。因此，若一进程在某文件的16〜32字节区间有一把写锁，然后又试图在16〜32字 节区间加一把读锁，那么该请求将成功执行，原来的写锁会被替换为读锁。

加读锁时，该描述符必须是读打开，加写锁时，该描述符必须是写打开，

下面说明一下fcntl函数的3种命令。

F_GETLK    判断由TZoc吻Zr所描述的锁是否会被另外一把锁所排斥（阻塞）。如果存在一

把锁，它阻止创建由所描述的锁，则该现有锁的信息将重写yzoc扣Zr 指向的信息。如果不存在这种情况，则除了将l_type设置为F_UNLCK之外，

知fr所指向结构中的其他信息保持不变。

F_SETLK 设置由flockptr所描述的锁，如果我们试图获得一把谏锁（l_type为 F_RDLCK）或写锁（l_type为F_WRLCK），而兼容性规则阻止系统给我们这 把锁，那么fcntl会立即出错返回，此时errno设置为EACCES或EAGAIN。

虽然POSIX.1允许实现返回这两种出错代码中的任何一种，但本书说明的4种实现在锁 请求不能得到满足时，都返回EAGAIN。

此命令也用来清除由指定的锁（l_type为FLUNLCK）。    [487]

F_SETLKW    这个命令是F_SETLK的阻塞版本（命令名中的W表示等待（wait））。如果所

请求的读锁或写锁因另一个进程当前已经对所请求区域的某部分进行了加锁 而不能被授予，那么调用进程会被置为休眠。如果请求创建的锁已经可用，

或者休眠由信号中断，则该进程被唤醒。

应当了解，用F_GETLK测试能否建立一把锁，然后用企图建立那把锁，

这两者不是一个原子操作。因此不能保证在这两次fcntl调用之间不会有另一个进程插入并建立一 把相同的锁。如果不希望在等待锁变为可用时产生阻塞，就必须处理由F_SETLK返回的可能的出错■>

注意，P0SK.1并没有说明在下列情况下将发生什么：一个进程在某个文件的一个区间上设

置了一把读锁，第二个进程在试困对同一文件区间加一把写锁时阻塞，然后第三个进程则试图在 同一文件区间上得到另一把读锁。如果第三个进租只是因为读区间已有一把读锁，而被允许在该 区间放置另一把读锁，那么这种实现就可能会使希望加写锁的进程饿死。因此，当对同一区间加 另一把读锁的请求到达时，提出加写锁而阻塞的进程需等待的时间延长了。如果加读锁的请求来 得很频繁，使得该文件区间始终存在一把或几把读锁，那么欲加写锁的进程就将等待很长时间。

在设置或释放文件上的一把锁时，系统按要求组合或分裂相邻区。例如，若第100〜199字 节是加锁的区，需解锁第150字节，则内核将维持两把锁，一把用于第100〜149字节，另一把 用于第151〜199字节。图14-4说明了这种情况下的字节范围锁。

I    I    I    II    I

100    199    100    149 151    199

对第100-199字节加锁后的文件    对第150字节解锁后的文件

图144文件字节范围锁    [488]

假定我们又对第150字节加锁，那么系统将会再把3个相邻的加锁区合并成一个区（第100〜

199字节）。其结果如图144中的第一个图所示，又跟开始的时候一样了。

■实例：请求和释放1锁

为了避免每次分配flock结构，然后又填入各项信息，可以用图14-5所示的程序中的函数 lock^reg来处理所有这些细节。

\#include "apue.h"

\#include <fcntl.h> int

lock_reg(int fd, int cmd, int type, off_t offset, int whence, off_t len) {

struct flock lock;

lock.l_type = type; lock.l_start = offset; lock.l_whence = whence; lock.l_len = len;



/* F_RDLCK, F_WRLCK, F_UNLCK */

/* byte offset, relative to l_whence */ /* SEEK_SET, SEEK_COR, SEEK_END */

/* tbytes (0 means to EOF) */

return(fcntl(fd, cmd, Slock));

图14-5加锁或解锁一个文件区域的函数

因为大多数锁调用是加锁或解锁一个文件区域(命令F_GETLK很少使用)，故通常使用下列 5个宏中的一■个，这5个宏都定义在apue.h中(见附录B)»

\#define read_lock(fd,offset,whence,len) \

lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))

\#define readw_lock(fd,offset,whence,len) \

lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))

轉define write_lock(fd,offset,whence,len) \

lock_reg((fd), F—SETLK, F_WBLCK, (offset), (whence), (len))

\#define writew_lock(fd,offset,whence,len) \

lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))

\#define un_lock(fd,offset,whence,len) \

lock_reg((fd), F_SETLK, F_UNLCK, (offset), {whence}, (len))

我们有目的地用与lseek函数同样的顺序定义了这些宏中的前3个参数。    ■

、实例：測试一把锁

图14-6中定义了一个函数lock.test,我们将用它测试一把锁。

linclude "apue.h"

\#include <fcntl.h>

pid_t

off_t offset, int whence, off_t len)



lock_test(int fd, int type, {

struct flock lock;

lock.l_type = type; lock.l_start = offset; lock.l_whence = whence; lock.l_len = len;



"F_RDLCK or F_WRLCK */

/* byte offset, relative Co l_whence */ /* SEEK_SET, SEEK_CUR, SEEK_END *Z /* 番bytes (0 means to EOF) */

if (fcntl(fd, F_GETLK, &lock) < 0) err_sys("fcntl error"!;

if (lock.l_type == F_UNLCK)

return (0);    /* false, region isn’t locked by another proc */

return(lock.l_pid);    /* true, return pid of lock owner */

图14-6测试_个锁条件的函数

如果存在一把锁，它阻塞由参数指定的锁请求，则此函数返回持有这把现有锁的进程的进程 ED,否则此函数返回0。通常用下面两个宏来调用此函数(它们也定义在apue.h中)。

\#define is_read_lockable(fd, offset, whence, len) \

(lock_test((fd), F_RDLCK, (offset!, (whence), (len)) == 0)

\#define is_write_lockable(fd, offset, whence, len) \

(lock_test((fd), F_WRLCK, (offset), (whence), (len)) = 0)

注意，进程不能使用lock_test函数测试它自己是否在文件的某一部分持有一把锁。 F_GETLK命令的定义说明，返回信息指示是否有现有的锁阻止调用进程设置它自己的锁。因为 F_SETLK和FLSETLKW命令总是替换调用进程现有的锁(若已存在)，所以调用进程决不会阻塞 在自己持有的锁上，于是，F_GETLK命令决不会报告调用进程自己持有的锁。

■实例：死锁

如果两个进程相互等待对方持有并且不释放(锁定)的资源时，则这两个进程就处于死锁状 态。如果一个进程已经控制了文件中的一个加锁区域，然后它又试图对另一个进程控制的区域加 锁，那么它就会休眠，茌这种情况下，有发生死锁的可能性。

图1本7所示的程序给出了一个死锁的例子。子进程对第0字节加锁，父进程对第1字节加锁。然 后，它们中的每一个又试图对对方已经加锁的字节加锁。在该程序中使用了 8.9节中介绍的父进程和子 进程同步例程(TELL_xxx和WA工以便每个进程能够等待另一个进程获得它设置的第一把锁。

^include "apue.h"

\#include <fcntl.h>

static void

14901



lockabyte{const char *name, int fd, off_t offset)

t

if (writew_lock{fd, offset, SEEK_SET, 1) < 0) err_sys("%s: writew_lock error", name);

printf("%s: got the lock, byte %lld\n", name, (long long)offset); I

int

main(void)

{

int    fd;

pid_t    pid;

/*

\* Create a file and write two bytes to it. */

if ((fd = creat("templock", FILE_MODE)) < 0) err_sys ("creat error1*);

if (write{fd, "ab", 2)    != 2)

err_sys("write error");

TELL_WAIT();

if ((pid = fork()) < 0)( err_sys("fork error");

} else if (pid == 0》{    /* child */

lockabyte("child", fd, 0); TELL_PARENT{getppid());

WAIT_PARENT()；

lockabyte{"child", fd, 1);

} else (    /* parent */

lockabyte("parent", fd, 1); TELL_CHILD(pid>;

WAIT_CHILD ();

lockabyte("parent", fd, 0);

}

exit (0);

图14~7死锁检测实例

运行图14-7中的程序得到：

$ ./a.out

parent: got the lock, byte 1 child: got the lock, byte 0

parent: writew^lock error： Resource deadlock avoided child: got the lock, byte 1

检测到死锁时，内核必须选择一M程接收出错返回。在本实例中，选择了父进程，但这是一个实 醐节。在某些系统上，子进程总是接到出错信息，在另一壁系统上，父进程总是接到出错信息。在某

[491]些系统上，当试图使用多把锁时，有时是子进程接到出错信息，有时则是父进程接到出错信息。

3.锁的隐含继承和释放

关于记录锁的自动继承和释放有3条规则。

(1)    锁与进程和文件两者相关联，这有两重含义：第一重很明显，当一个进程终止时，它所 建立的锁全部释放；第二重则不太明显，无论一个描述符何时关闭，该进程通过这一描述符引用 的文件上的任何一把锁都会释放(这些锁都是该进程设置的)。这就意味着，如果执行下列4步：

fdl = open(pathname, read^lock(fdl,...); fd2 = dup(fdl); close(fd2);

则在close (fd2)后，在fdl上设置的锁被释放。如果将dup替换为open,其效果也一样：

fdl = open(pathname,...); read_lock(fdl,...); fd2 = open(pathname,...) close (fd2);

(2)    由fork产生的子进程不继承父进程所设置的锁。这意味着，若一个进程得到一把锁， 然后调用fork,那么对于父进程获得的锁而言，子进程被视为另一个进程。对于通过fork从

父进程处继承过来的描述符，子进程需要调用fcntl才能获得它自己的锁。这个约束是有道理 的，因为锁的作用是阻止多个进程同时写同一个文件。如果子进程通过fork继承父进程的锁， 则父进程和子进程就可以同时写同一个文件。

(3)在执行exec后，新程序可以继承原执行程序的锁。但是注意，如果对一个文件描述符设置 了执行时关闭标志，那么当作为exec的一部分关闭该文件描述符时，将释放相应文件的所有锁。

\4. FreeBSD 实现

先简要地观察FreeBSD实现中使用的数据结构。这会帮助我们进一步理解记录锁的自动继承 和释故的第一条规则：锁与进程和文件两者相关联。

考虑一个进程，它执行下列语句(忽略出错返回)。

fdl = open(pathname, ...); write_lock(fdl, 0, SEEK_SET, 1) if {(pid = fork。)> 0)( fd2 = dup(fdl);

/* parent write locks byte 0 */ /* parent */



fd3 = open{pathname,...);

} else if {pid == 0) {

read_lock<fdl, 1, SEEK_SET, 1); /* child read locks byte 1 */

}

pause ();

图14-8显示了父进程和子进程暂停(执行pause ())后的数据结构情况。

父进程表项_

'    文件表项



| entry 列表         | struct lockf entry |      |
| ------------------ | ------------------ | ---- |
| struct lockf entry |                    |      |
| 链接    一         | -►                 | 结接 |
| 标志               | 标志               |      |
| 起始侷移量         | 起始偏移量         |      |
| 结束偏移量         | 结東偏移量         |      |
| —lock owner 摘针   | —lock^owner 相针   |      |

struct lock I



struct lock」

| 所有者信息 |      | 所有者信息 |
| ---------- | ---- | ---------- |
| 父进程ID   |      | 子进程ID   |



图14-8关于记录锁的FreeBSD数据结构

前面已经给出了 open, fork以及dup调用后的数据结构(见图3-9和图8-2)。有了记录 锁后，在原来的这些图上新加了 lockf结构，它们由i节点结构开始相互链接起来。每个lockf 结构描述了一个给定进程的一个加锁区域(由偏移量和长度定义的)。图中显示了两个lockf结 构，一■个是由父进程调用write_lock形成的，另一个则是由子进程调用rea^lock形成的。 每一个结构都包含了相应的进程ID。

[493]    在父进程中，关闭fdl、fd2或fd3中的任意一个都将释放由父进程设置的写锁。在关闭这

3个描述符中的任意一个时，内核会从该描述符所关联的i节点开始，逐个检査lockf链接表中 的各项，并释放由调用进程持有的各把锁。内核并不清楚(也不关心)父进程是用这3个描述中 的哪一个来设置这把锁的。

，■实例

在图13-6所示的程序中，我们了解到，守护进程可用一把文件锁来保证只有该守护进程的唯 一副本在运行。图14-9展示了 lockfile函数的实现，守护进程可用该函数在文件上加写锁。

\#include <unistd.h> ♦include <fcntl.h>

int

lockfile(int fd)

struct flock fl;

£l.l_type = F_WRLCK; f1. l_start = 0; fl.l_whence = SEEK_SET; f 1. l_len = 0;

return (fcntl (fd, F_SETLK, &fl” ； J

图14-9在文件整体上加一把写锁 另一种方法是用write_lock函数定义lockfile函数》

\#define lockfile (fd) write_lock((fd), 0, SEEK_SET, 0>    ■

5.在文件尾嫌加锁

在对相对于文件尾端的字节范围加锁或解锁时需要特别小心。大多数实现按照l_whence 的SEEK_CUR或SEEIVEND值，用l.start以及文件当前位置或当前长度得到绝对文件偏移 量。但是，常常需要相对于文件的当前长度指定一把锁，但又不能调用fstat来得到当前文件 长度，因为我们在该文件上没有锁。(在fstat和锁调用之间，可能会有另一个进程改变该文

件长度。)

考虑以下代码序列，

writew_lock(fd, 0, SEEK_END, 0); write(fd, buf, 1); un_lock(fd, 0, SEEK_END); write(fd, buf, 1);

[4941该代码序列所做的可能并不是你所期望的。它得刴一把写锁，该写锁从当前文件尾端起，包括以 后可能追加写到该文件的任何数据。假定，该文件偏移量处于文件尾端时，执行第一个write,

这个操作将文件延伸了 1个字节，而该字节将被加锁。跟随其后的是解锁操作，其作用是对以 后追加写到文件上的数据不再加锁。但在其之前刚追加写的一个字节则保留加锁状态。当执行 第二个写时，文件尾端又延伸了 1个字节，但该字节并未加锁。由此代码序列造成的文件锁状态 如图14-10所示。

己加锁

第一个write之后的文件状态

迫加写入的 第一个字节



第二个write之后的文件状态



迫加写入的 迫加写入的 第一个字节 第二个字节



图14-10文件区域锁

当对文件的一部分加锁时，内核将指定的偏務量变换成绝对文件偏移量。另外，除了指定一个 绝对偏移量(SEEK_SET)之外，fcntl还允许我们相对于文件中的某个点指定该偏移量，这个点 是指当前偏移量(SEEK.CUR)或文件尾端(SEEK_END\当前偏移量和文件尾端可能会不断变化，

而这种变化又不应影响现有锁的状态，所以内核必须独立于当前文件偏移量或文件尾端而记住锁。

如果想解除的锁中包括第一次write所写的1个字节，那么应指定长度为-1。负的长度值 表示在指定偏移量之前的字节数。

6.建议性锁和强制性锁

考虑数据库访问例程库。如果该库中所有函数都以一致的方法处理记录锁，则称使用这些函 数i方问数据库的进程集为合作进程(cooperating process)»如果这些函数是唯一地用来坊问数据 库的函数，那么它们使用建议性锁是可行的。但是建议性锁并不能阻止对数据库文件有写权限的 任何其他进程写这个数据库文件。不使用数据库访问例程库协同一致的方法来访问数据库的进程 是非合作进程。

强制性锁会让内核检查每一个open、read和write,验证调用进程是否违背了正在访问 的文件上的某一把锁。强制性锁有时也称为强迫方式锁(enforcement-mode locking)o    l49^l

从图14~2中可以看出，Linux 3.2.0和Solaris 10提供强制性记录锁，而FreeBSD 8.0和Mac OS X 10.6.8则不提供。强制性记录锁不是Single UNIX Specification的组成部分。在Linux中，如果用户 想要使用强制性锁，则需要在各个文件系统基础上用mount命令的-o mand选项来打开该机制。

对一个特定文件打开其设置组ID位、关闭其组执行位便开启了对该文件的强制性锁机制(回 忆图4-12)。因为当组执行位关闭时，设置组ID位不再有意义，所以SVR3的设计者借用两者的 这种组合来指定対一个文件的锁是强制性的而非建议性的。

如果一个进程试图读(read)或写(write) 一个强制性锁起作用的文件，而欲读、写的部 分又由其他进程加上了锁，此时会发生什么呢？对这一问题的回答取决于3方面的因素：操作类 型(read或write)、其他进程持有的锁的类型(读锁或写锁)以及read或write的描述符 是阻塞还是非阻塞的。图14-11列出了 8种可能性。

| 其他进程在该区域上 持有的现有锁的类型 | 阻塞描述符 | 非阻塞描述符 |        |        |
| ------------------------------------- | ---------- | ------------ | ------ | ------ |
| read                                  | write      | read         | write  |        |
| 读锁                                  | 允许       | 阻塞         | 允许   | EAGAIN |
| 写锁                                  | 阻塞       | 阻塞         | EAGAIN | EAGAIN |

图14-11强制性锁对其他进程的read和write的影响 除了图14-11中的read和write函数，另一个进程持有的强制性锁也会对open函数产生

影响。通常，即使正在打开的文件具有强制性记录锁，该open也会成功。随后的read或write 依从于图14-11中所示的规则。但是，如果欲打开的文件具有强制性记录锁（读锁或写锁），而且 open调用中的标志指定为O_TRUNC或O_CREAT,则不沧是西指定O_NONBLOCK, open都立即 出错返回，errno设置为EAGA工N。

只有Solaris对O_CREAT标志处理为出错。当打开一个具强制性锁的文件时，Linux允许指定 O_CREAT标志。对O_TRUNC标志产生open出错是有意义的，因为对于一个文件来讲，若另一 个进程持有它的读锁或写锁，那么它就不能被截短为0。但是对O_CREAT标志在返回时设置出错 就没什么意义了，因为该标志表示，只有在该文件不存在时才刻建，但由于另一个进程持有该文 件的记录锁，所以该文件肯定是存在的。

这种open的锁冲突处理方式可能会导致令人惊异的结果。在开发本节习题的时候，我们曾 编写过一个测试程序，它打开一个文件（其模式指定为强制性锁），对该文件整体设置一把读锁， 然后休眠一段时间。（回忆图14-11，读锁应当阻止其他进程写该文件。）在这段休眠时间内，用 某些典型的UNIX系统程序和操作符对该文件进行处理，发现下列情况。

•可用ed编辑器对该文件进行编辑操作，而且编辑结果可以写回磁盘！强制性记录锁根本 [496]    不起作用。用某些UNIX系统版本提供的系统调用跟踪特性，对ed操作进行跟踪分析发

现，ed将新内容写到一个临时文件中，然后删除原文件，最后将临时文件名改为原文件

名。强制性锁机制对unlink函数没有影响，于是这一切就发生了。

在FreeBSD 8.0和Solaris 10中，用truss（l）^令可以得到一个进程的系统调用跟踩信

息;，Linux 3^.0出于相同的目的提供了 strace⑴命令。Mac OS X 10.6.8提供了 dtruss（Im） 命令来追踪系统调用，但该命令的使用需要超级用户的权限。

•不能用vi编辑器编辑该文件。vi可以读该文件的内容，但是如果试图将新的数据写到 该文件中，就会出错返回（EAGAIN）。如果试图将新数据追加写到该文件中，则write 阻塞。vi的这种行为与我们所希望的一样。

•使用Korn shell的〉和＞＞操作符重写或追加写该文件，会产生出误信息“cannot create”。 •在Bourne sheU下使用＞操作符也会出错，但是使用》操作符时只阻塞，在解除强制性锁后会

继续进行处理。（这两种shell在孰行追加写操作时之所以会产生的差异，是因为Kom shell以 O_CREAT和O_APPEND标志打开文件，而上面已提及指定O_CREAT会产生出错返回。但是， Bourne shell在读文件已存在时并不指定OJ：REAT,所以open成功，而下一个write则阻塞。）

产生的结果随所用操作系统版本的不同而不同。从这样一个习题中可见，在使用强制性锁时 还需有所警惕。从ed实例可以看到，强制性锁是可以设法避开的。

—个恶意用户可以使用强制性记录锁，对大家都可读的文件加一把壌锁，这样就能阻止任何 人写该文件（当然，该文件应当是强制性锁机制起作用的，这可能要求该用户能够更改该文件的

权限位）。考虑一个数据库文件，它是大家都可读的，并且是强制性锁机制起作用的。如果一个 恶意用户要对整个这个文件持有一把读锁，其他进程就不能再写该文件。

麵实例

图14-12中的程序可以用于确定一个系统是否支持强制性锁机制。

\#include "apue.h" ttinclude <errno.h> #include <fcntl.h> #include <sys/wait.h>

int

main (int argc, char *argv⑴

{ _

int    fd;    |497|

pid_t    pid；

char    buf[5];

struct stat    statbuf;

if (argc != 2) {

fprintf(stderr, "usage: %s filenameXn", argv[0]); exit(1);

if ((fd = open(argv[l], O_RDWR I O_CREAT I O_TRUNC, FILE_MODE)} < 0) err_sys("open error");

if (write (fd, "abcdef", 6) != 6) err_sys("write error");

/* turn on set-group-ID and turn off group-execute */

if (fstat(fd, Sstatbuf) < 0) err_sys("fstat error");

if (fchmod(fd, (statbuf.st_mode & ~S_IXGRP) | S_ISGXD> < 0) err_sys("fchmod error");

TELL_WAIT<);

if ( (pid = forkO ) < 0) t err_sys("fork error");

} else if (pid > 0) ( /* parent */

/* write lock entire file */ if (write_lock{fd, 0, SEEK_SET, 0》< 0)

err_sys("write_lock error");

TELL_CHILD(ptd)；

if (waitpid(pid, NULL, 0) < 0) err_sys("waitpid error");

} else {    /* child */

WAIT_PARENT<);    /* wait for parent to set lock */ set_fl(fd, O_NONBLOCK);

/* first let's see what error we get if region is locked */ if Cread_lock(fd, 0, SEEK_SET, 0) != -1) /* no wait */

err_sys{"child: read_lock succeeded"); printf("read^lock of already-locked region returns %d\n",

errno);

/* now try to read the mandatory locked file */ if (lseekffd, 0, SEEK_SET) == -1)

err_sys("lseek error"); if (read(fd, buf, 2) < 0)

err_ret ("read failed (mandatory locking works)'1);

else

printf("read OK (no mandatory locking), buf = %2.2s\n", buf);

}

exit(0);

@    图14-12确定是否支持强制性锁

此程序首先创建一个文件，并使强制性锁机制対其起作用。然后程序分出一个父进程和一个 子进程。父进程对整个文件设置一把写锁，子进程则先将该文件的描述符设置为非阻塞的，然后 企图对该文件设置一把读锁，我们期望这会出错返回，并希望看到系统返回是EACCES或 EAGAINO接着，子进程将文件读、写位置调整到文件起点，并试图读（read）该文件。如果系 统提供强制性锁机制，则read应返回EACCES或EAGAIN （因为该描述符是非阻塞的），否则 read返回所读的数据。在Solaris 10上运行此程序（该系统支持强制性锁机制），得到：

S ./a. out    . lock

read_lock of already-locked region returns 11

read failed （mandatory locking works）: Resource temporarily unavailable

査看系统头文件或intro(2)手册页，可以看到errno值11対应于EAGAIN。若在FreeBSD 8.0 运行此程序，则得到：

$ ./a.out taap.lock

read_lock of already_locked region returns 35 read OK (no mandatory locking), buf = ab

其中，errno值35对应于EAGAIN。该系统不支持强制性锁6    ■

■实例

让我们回到本节的第一个问题：当两个人同时编耩同一个文件时将会怎样呢？ 一般的UNIX 系统文本编辑器并不使用记录锁，所以对此问题的回答仍然是：孩文件的最后结果取决于写该文 件的最后一个进程。

某些版本的vi编辑器使用建议性记录锁。即使我们使用这种版本的vi编辑器，它仍然不能 阻止其他用户使用另一个没有使用建议性记录锁的编寅器=

若系统提供强制性记录锁，那么我们可以修改自己常用的编辑器来使用它（如果我们有该编 辑器的源代码）。如果没有该编辑器的源代码，那么可以试一试下述方法。编写一个vi的前端程 序。该程序立即调用fork,然后父进程只等待子进程完成。子进程打开在命令行中指定的文件， 使强制性锁起作用，对整个文件设置一把写锁，然后执行vi。在vi运行时，该文件是加了写锁 的，所以其他用户不能修改它。当vi结束时，父进程从wait返回，自编的前端程序结束。

虽然可以编写这种类型的小型前端程序，但它却不起作用。问题出在大多数编辑器读它们的

输入文件，然后关闭它。只要引用被编辑文件的描述符关闭了，那么加在该文件上的锁就被释放 了。这意味着，在编辑器读了该文件的内容后，随即关闭了该文件，那么锁也就不存在了。这个 前端程序中没有任何方法可以阻止这一点。    ■*

在第20章中，我们将使用数据库函数库中的记录锁来提供多个进程的并发访问。我们还将 提供一些时间测量，以观察记录锁对进程的影响-    ®


##### 14.4 I/O多路转接

当从一个描述符读，然后又写刹另一个描述符时，可以在下列形式的循环中使用阻塞I/O:

while {(n=read(STDIN_FILENO, buf, BUFSIZ)) > 0) if (write{STDOUT_FILENO, buf, n) != n)

err_sys("write error");

这种形式的阻塞I/O到处可见。但是如果必须从两个描述符读，又将如何呢？在这种情况下， 我们不能在任一个描述符上进行阻塞读(read),否则可能会因为被阻塞在一个描述符的读操作 上而导致另一个描述符即使有数据也无法处理。所以为了处理这种情况需要另一种不同的技术。

让我们观察telnet(l)命令的结构。垓程序从终端(标准输入)读，将所得数据写到网络连 接上，同时从网络连接读，将所得数据写到终端上(标准输出)。在网络连接的另一端，telnetd 守护进程读用户键入的命令，并将所读到的送给shell,这如同用户登录到远程机器上一样。 telnetd守护进程将执行用户键入命令而产生的输出通过telnet命令送冋给用户，并显示在 用户终端上。图14-13显示了这种工作情景。

图14-13 telnet程序概观

telnet进程有两个输入，两个输出。我们不能对两个输入中的任一个使用阻塞read，因 为我们不知道到底哪一个输入会得到数据。

处理这种特殊问题的一种方法是，将一个进程变成两个进程(用fork),每个进程处理一条数据 通路。图14-14中显示了这种安排。(System V的UUCP通信包提供了 cu(l)命令，其结构与此相似。)

图14-14使用两个进程实现telnet程序

如果使用两个进程，则可使每个进程都执行阻塞read。但是这也产生了问题：操作什么时候终 止？如果子进程接收到文件结束符(telnetd守护进程使网络连接断开)，那么该子进程终止，然后网 父进程接收到SIGCHLD信号。但是，如果父进程终止(用户在终端上键入了文件结束符)，那么父 进程应通知子进程停止。为此可以使用一个信号(如SIGUSR1)，但这使程序变得更加复杂。

我们可以不使用两个进程，而是用一个进程中的两个线程。虽然这避免了终止的复杂性，但 却要求处理两个线程之间的同步，在复杂性方面这可能会得不偿失。

另一个方法是仍旧使用一个进程执行该程序，但使用非阻塞I/O读取数据。其基本思想是： 将两个输入描述符都设置为非阻塞的，对第一个描述符发一个reado如果该输入上有数据，则 读数据并处理它。如果无数据可读，则该调用立即返回。然后对第二个描述符作同样的处理。在 此之后，等待一定的时间（可能是若干秒），然后再尝试从第一个描述符读。这种形式的循环称 为轮询。这种方法的不足之处是浪费CPU时间。大多数时间实际上是无数据可谣，因此执行read 系统调用浪费了时间。在每次循环后要等多长时间再执行下一轮循环也很难确定。虽然轮询技术 在支持非阻塞I/O的所有系统上都可使用，但是在多任务系统中应当避免使用这种方法。

还有一种技本称为弃步I/O （asynchronous I/O）o利用这种技术，进程告诉内接：当描述狩准 备好可以进行I/O时，用一个信号通知它。这种技术有两个问题。首先，尽管一些系统提供了各 自的受限形式的异步1/0,但POSIX采纳了另外一套标准化接口，所以可移植性成为一个问题（以 前，POSIX异步I/O是Single UNIX Specification中是可选设施，但现在，这些接口在SUSv4中 是必需的）。System V提供了 SIGPOLL信号来支持受限形式的异步1/0,但是仅当描述符引用 STREAMS设备时，此信号才起作用。BSD有一个类似的信号SIGIO,但也有类似的限制：仅当 描述符引用终端设备或网络时它才能起作用。

这种技术的第二个问题是，这种信号对每个进程而言只有1个（SIGPOLL或SIGIO）。如果 使该信号对两个描述符都起作用（在我们正在讨论的实例中，从两个描述符读），那么进程在接到 此信号时将无法判别是哪一个描述符准备好了。尽管POSIX.1异步I/O接口允许选择哪个信号作为 通知，但能用的信号数量仍远小于潜在的打开文件描述符的数量。为了确定是哪一个描述符准备好 了，仍需将这两个描述符都设置为非阻塞的，并顺序尝试执行I/O。我们将在14.5节讨论异步I/O。

一种比较好的技术是使用I/O多路转接（I/Omultiplexing）。为了使用这种技术，先构造一张 我们感兴趣的描述符（通常都不止一个）的列表，然后调用一个函数，直到这些描述符中的一个 已准备好进行I/O时，该函数才返回、poll、pselect和select这3个函数使费们能够执行 I/O多路转接。在从这些函数返回时，进程会被告知哪些描述符己淮备好可以进行I/O。

POSIX指定，为了在程序中使用select,必须包括＜373/36]^（:七.11＞。但较老的系统还要 求包括＜sys/types .h＞、＜sys/time.h＞^＜unistd.h＞。查看 select 手册页可以并清楚你 的系统都支持什么。

I/O多路梓接在4.2BSD中是用select函数提供的。至然该函教主要用于终端I/O和网络I/O, 但它对其他据述符同样是起作用的。SVR3在增加STREAMS机制时增加了 poll函数。但在SVR4 之前，poll只对STREAMS设备起作用。SVR4支持对任意描述符起作用的poll。

14.4.1 函数 select 和 pselect

在所有POSIX兼容的平台上，select函数使我们可以执行I/O多路转接。传给select的 参数告诉内核：

•我们所关心的描述符；

.对于每个描述符我们所关心的条件（是否想从一个给定的描述符读，是否想写一个给定 的描述符，是否关心一个给定描述符的异常条件）；

•愿意等待多长时间（可以永远等待、等待一个固定的时间或者根本不等待）。

从select返回时，内核告诉我们：

•已准备好的描述符的总数量：

•对于读、写或异常这3个条件中的每一个，哪瘦描述符已准备好。

使用这种返回信息，就可调用相应的I/O函数（一般是read或write）,并且确知该函数

不会阻塞。

\#include <sys/select.h>

int select (int maxfdp!, fd_set ^restrict readfds,

fd_set * restrict -writefds, fd_set *restrict exceptfds, struct timeval *restrict tvptr};

   返回值t准备就绪的描述符数目；若超时，返回0;若出错，返回-1

先耒说明最后一个参数，它指定愿意等待的时间长度，单位为秒和微秒（回忆4.20节）。有 以下3种情况。

tvptr == NULL

永远等待。如果捕捉到一个信号则中断此无限期等待。当所指定的描述符中的一个已准备好或 捕捉至lj—个信号则返回。如果捕捉到一个信号，则select退回-1，errno设置为EINTR。

tvptr->tv_sec == 0 && tvptr->tv_usec == 0

根本不等待。测试所有指定的描述符并立即返回。这是轮询系统找到多个描述符状态而 不阻塞select函数的方法。

tvptr->tv_sec ! = 0 | | tvptr->tv_usec ! = 0    |502|

等待指定的秒数和微秒数。当指定的描述符之一己准备好，或当指定的时间值已经超过 时立即返回。如果在超时到期时还没有一个描述符准备好，则返回值是0。（如果系统不 提供微秒级的精度，则值取整到最近的支持值。）与第一种情况一样，这 种等待可被捕捉到的信号中断。

POSIX.1允许实现修改timeval结构中的值，所以在select返回后，你不能指望该结构仍旧保 持调用select之前它所包含的值。FreeBSD 8.0、Mac OS X 10.6.8和Solaris 10都保持该结构中的值不 变。担是，若在超时时间尚未到期时，select就送因，那么Linux3.2.0将用剩余时间值更新该结构。

中间3个参数wnYeyiZs和excep押是指向描述符■集的指针。这3个描述符集说明了 我们关心的可读、可写或处于异常条件的描述符集合。每个描述符集存储在一个fd_set数据类 型中。这个数据类型是由实现选择的，它可以为每一个可能的描述符保持一位。我们可以认为它 只是一个很大的字节数组，如图14-15所示。

readfds



writefds



| fdo fdl fd2 |                         |      |      |
| ----------- | ----------------------- | ---- | ---- |
| 0           | 0                       | 0    |      |
|             | 每                      |      |      |
|             | r 口J 肪口还刊「12    ► |      |      |
| 0           | 0                       | 0    |      |

H- fd_set数据类型

0 0 0



exceptfds



图］4-15对select指定读、写和异常条件描述符

对于fd_Set数据类型，唯一可以进行的处理是：分配一个这种类型的变量，将这种类型的 一个变量值赋给同类型的另一个变量，或对这种类型的变量使用下列4个函数中的一个。

^include <sys/select.h>

int FD_ISSET(int fd, fd_set *fdset};

返回值：若/rf在描述符集中，返回非0值：否则，返回0

void FD_CLR (int fd, fd_set *fdset}; void FD_SET (int fd, fd_set *fdset、； void FD ZERO(fd set *fdset);



画

这些接口可实现为宏或函数。调用FD.ZERO将一个fd_set变量的所有位设置为0。要开启 描述符集中的一位，可以调用FD_SET0调用FD_CLR可以清除一位。最后，可以调用FD_ISSET 测试描述符集中的一个指定位是否己打开。

在声明了一个描述符集之后，必须用FD_ZERO将这个描述符集置为0,然后在其中设置我们 关心的各个描述符的位。具体操作如下所示：

fd_set rset; int fd;

FD_ZERO（firset）;

FD_SET（fd, Srset）;

FD_SET（STDIN_FILENO, Srset）;

从select返回时，可以用FD_ISSET测试该集中的一个给定位是否仍处于打开状态： if （FD_ISSET（fd, Srset）） {

select的中间3个参数（指向描述符集的指针）中的任意一个（或全部）可以是空指针， 这表示对相应条件并不关心。如果所有3个指针都是NULL,则select提供了比sleep更精确 的定时器=（回忆10.19节，sleep等待整数秒，而select的等待时间则可以小于1秒，其实 际精度取决于系统时钟。）习题14.5给出了这样一个函数。

select第一今篸数maxfdpl的意思是“最大文件描述符编号值加1”。考虑所有3个描述符 集，在3个描述符集中找出最大描述符编号值，然后加1,这就是第一个参数值=也可将第一个参数 设置为FD_SETSIZE,这是＜sys/select.h；^的一个常量，它指定最大描述符数（经常是1024）, 但是对大多数应用程序而言，此值太大了。确实，大多数应用程序只使用3〜10个描述符（某些应用 程序需要更多的描述符，但这种UNIX程序并不典型）。通过指定我们所关注的最大描述符，内核就 只需在此范围内寻找打开的位，而不必在3个描述符集中的数百个没有使用的位内搜索。

例如，图14-16所示的两个描述符集的情况就好像是执行了下述操作：

fd_set readset, writeset； FD_ZERO(&readset); FD_ZERO(&writeset); FD_SET(0, &readset); FD_SET(3, &readset)/

FD_SET(1, &writeset)；

FD_SET (2 , (iwriteset};

select(4, &readset, &writeset, NULL, NULL);

因为描述符编号从o开始，所以要在最大描述狩编号值上加U第一个参数实际上是要检査

的描述符数（从描述符0开始\

select有3个可能的返回值。

fdO fdl fd2 fd3

| 1                        | 0    | 0    | 1       |      |
| ------------------------ | ---- | ---- | ------- | ---- |
| 1一►这以后的位都没有检査 |      |      |         |      |
| 0                        | 1    | 1    | 叫    I |      |

maxfdpl = 4

图14-16 select的样本描述符集

（1）    返回值-1表示出错。这是可能发生的，例如，在所指定的描述符一个都没准备好时捕捉 到一个信号。在此种情况下，一个描述符集都不修改。

（2）    返回值0表示没有描述符准备好。若指定的描述符一个都没准备好，指定的时间就过了，

那么就会发生这种情况。此时，所有描述符集都会置0，

（3）    —个正返回值说明了己经准备好的描述符数。孩值是3个描述符集中已准备好的描述符 数之和，所以如果同一描述符已准备好读和写，那么在返回值中会对其计两次数。在这种情况下，

3个描述符集中仍旧打开的位对应于己准备好的描述符。

对于“准备好”的含义要作一些更具体的说明。

•若射读集^adfds＞中的一个描述狩进行的^操作不会阻塞，则认为此描述符是准备好的。

•若对写集（⑽學）中的一个描述符进行的wnfc操作不会阻塞，则认为此描述符是准备好的。

•若对异常条件集（exceptfds、中的一个描述符有一个未抉异常条件，则认为此描述符是准 备好的。现在，异常条件包括：在网络连接上到达带外的数据，或者在处于数据包模式 的伪终端上发生了某些条件。（StevenS[1990]的15.10节中描述了后一种条件。）

•对于读、写和异常条件，普通文件的文件描述符总是返回准备好。    [Ml

一个描述符阻塞与否并不影响select是否阻塞，理解送一点很重要。也就是说，如果希望读

一个非阻塞描述符，并且以超时值为5秒调用select,则select最多阻塞5s。相类似，如果指 定一个无限的超时值，则在该描述符数据准备好，或捕捉到一个信号之前，select会一直阻塞。

如果在一个描述符上碰到了文件尾端，则select会认为该描述符是可读的。然后调用read, 它返回0,这是UNIX系统指示到迖文件尾端的方法。（很多人错误地认为，当到迖文件尾端时， select会指示一个异常条件。）

POSIX.1也定义了一个select的变体，称为pselect。

\#include <sys/select.h>

int pselect (int maxfdpl, fd_set ^restrict readfds,

fd_set * restrict writefds, fd_set * restrict exceptfds, const struct timespec * restrict tsptr,

const sigset_t ^restrict sigmask)；

   返回值：准备就绪的描述狩数目：若超时，返回0;若出错，返回-1

隐下列几点外，pselect与select相同。

• select的超时值用timeval结构指定，但pselect使用timespec结构（回忆4.2 节中timespec结构的定义）。timespec結构以秒和纳秒表不超时值，而非秒和微秒。 如果平台支持这样的时间精度，那么timespec就能提供更精准的超时时间。

•    pselect的超时值被声明为const，这保证了调用pselect不会改变此值。

•    pselect可使用可选信号屏厳字》若sigmask为NULL,那么在与信号有关的方面， pselect的运行状况和select相同，否则，sigmask指向-信号屏厳字，在调用 pselect时，以原子操作的方式安装该信号屏蔽字。在返回时，恢复以前的信号屏蔽字。

14.4.2 函数 poll

poll函数类似于select，但是程序员接口有所不同。虽然poll函数是System V引入进 来支持STREAMS子系统的，但是poll函数可用于任何类型的文件描述符。

\#include <poll.h>

int poll (struct pollfd fdarray [], nfds_t nfds, int timeout);

返回值：准备就绪的描述符数目：若超时，返回0;若出错，返回-1

与select不同，poll不是为每个条件（可读性、可写性和异常条件）构造一个描述符集， 而是构造一个pollfd结构的数组，每个数组元素指定一个描述符编号以及我们对该描述符感兴 趣的条件。

struct pollfd { int fd; short events; short revents;

};



/* file descriptor to check, or < 0 to ignore */ /* events of interest on fd */

/* events that occurred on fd */

fdarray数组中的元素数由指定„

由于历史原因，在如何声明nfds参数方面有几种不同的方式。SVR3将nfds的类型指定为 unsigned long,这似乎是太大了。在SVR4手册［AT&T 1990d］中，poll原型的第二个参数的 数据类型为 size_t （见图2-21中的基本系统教据类型）。但在＜poll.h＞包含的实际原型中，第 二个参教的数据类型仍招定为unsigned longoSingle UNIX Specification定义了新类型nfds_t,

!该类型允许实现选择对其合适的类型并且隐藏了应用细节。注意，因为返回值表示数组中满足事 件的项数，所以这种类型必须大得足以保存一个整数。

对应于SVR4的SVID［AT&T 1989］上显示，poll的第一个参数是struct pollfd fdarray［｝,而SVR4手册页［AT&T 1990d］上则显示该参数为struct pollfd 砂。在C语 言中，这两种声明是等价的。我们使用第一种声明是为了重申fdarray指向的是一个结构数组， 而不是指向单个结构的指针。

应将每个数组元素的events成员设置为图14-17中所示值的一个或几个，通过这些值告诉 内核我们关心的是每个描述符的哪些事件。返回时，revents成员由内核设置，用于说明每个描 述符发生了哪些事件。（注意，poll没有更改events成员。这与select不同.select修改 其参数以指示哪一个描述符己准备好了。）

图14-17中的前4行测试的是可读性，接下来的3行测试的是可写性，最后3行测试的是异 常条件。最后3行是由内核在返回时设置的。即使在events字段中没有指定这3个值，如果相 应条件发生，在revents中也会返回定们。

有些poll事件的名字中包含SK,它指的是STREAMS当中的优先级波段。感要了解关 于STREAMS和优先级波段的更多信息，可以查看Rago［1993］o

| 标志名                 | 输/\至 events? | 从revents得到结果？ | 说明                                                         |
| ---------------------- | -------------- | ------------------- | ------------------------------------------------------------ |
| POLLIN                 |                | •                   | 可以不阻塞地读髙优先级数据以外的数                           |
| POLLRDNORM             |                |                     | 据（等效于 POLLRDNORM \| POLLRDBAND） 可以不阻塞地读普通数据 |
| POLLRDBAND             |                |                     | 可以不阻塞地读优先级数据                                     |
| POLLPRI                |                |                     | 可以不阻塞地读髙优先级数据                                   |
| POLLOUT                |                |                     | 可以不阻塞地写普通数据                                       |
| POLLWRNORM             |                |                     | 与POLLOUT相同                                                |
| POLLWRBAND             |                |                     | 可以不阻塞地写优先级数据                                     |
| POLLERRPOLLHUPPOLLNVAL |                |                     | 已出错已挂断描述符没有引用一个打开文件                       |

图 14-17 poll 的 events 和 revents 标志    ［元7.|

当一个描述符被挂断（POLLHUP）后，就不能再写该描述符，但是有可能仍然可以从该描述

符读取到数据。

poll的最后一个参数指定的是我们愿意等待多长时间。如同select—样，有3种不同的情形。 timeout == 一1

永远等待。（某些系统在＜3匕叩1：3上＞中定义了常量工NFTIM，其值通常是-1。）当所指 定的描述符中的一个己淮备好，或捕捉到一个信号时返回。如果捕捉到一个信号，则poll 返回-1，errno设置为EINTR。

timeout == 0

不等待。测试所有描述符并立即返回，这是一种轮询系统的方法，可以找到多个描述符 的状态而不阻塞poll函数。

timeout ＞ 0

等待rimeozrf毫秒。当指定的描述符之一已准备好，或伽eow/到期时立即返回。如果timeout 到期时述没有一个描述符准备好，则返回值是0。（如果系统不提供毫秒级精度，则 值取整到最近的支持值。）

理解文件尾端与挂断之间的区别是很重要的。如果我们正从终端输入数据，并键入文件 结束符，那么就会打开POLLIN,于是我们就可以读文件结束指示（read返回0）。revents 中的POLLHUP没有打开。如果正在读调制解调器，并且电话线己挂断，我们将接到POLLHUP 通知。

与select 一样，一个描述符是否阻塞不会影响poll是否阻塞。

select和poll的可中断性

中断的系统调用的自动重启是由4.2BSD引入的（见10.5节），但当时select函数是不重 启的。这种特性在大多数系统中一直延续了下来，即使指定了 SA_RESTART选项也是如此＜,但是，

在SVR4上，如果指定了 SA_RESTART,那么select和poll也是自动重启的。为了在将软件 移植到SVR4派生的系统上时阻止这一点，如果信号有可能会中断select或poll，就要使用 signal_intr 函数（见图 10-19）。    1刈8|

j    本书说明的各种实现在接到一信号时都不重启动poll和select，即便使用了 SA_RESTART

I赫志也是如此。

##### 14.5 异步 I/O

使用上一节说明的select和poll可以实现异步形式的通知。关于描述符的状态，系统并 不主动告诉我们任何信息，我们需要进行査询（调用select或poll）。如在第10章中所述， 信号机构提供了一种以异步形式通知某种事件已发生的方法，由BSD和System V派生的所有系 统都提供了某种形式的异步1/0,使用一个信号（在SystemV中是SIGPOLL，在BSD中是SIGIO） 通知进程，対某个描述符所关心的某个事件己经发生。费们在前面的章节中提到过，这些形式的异 步I/O是受限制的：它们并不能用在所有的文件类型上，而且只能使用一个信号。如果要对一个以 上的描述符进行异步1/0,那么在进程接收到该信号时并不知道这一信号对应于哪一个描述符。

SUSv4中将通用的异步I/O机制从实时扩展部分调整到基本规范部分。这种机制解决了这些 陈旧的异步I/O设施存在的局限性，

在我们了解使用异步I/O的不同方法之前，需要先讨论一下成本。在用异步I/O的时候，要 通过选择来灵活处理多个并发操作，这会使应用程序的设计复杂化。更简单的做法可能是使用多 线程，使用同步模型来编写程序，并让这些线程以异步的方式运行。

使用POSIX异步I/O接口，会带来下列麻烦。

•每个异步操作有3处可能产生错误的地方：一处在操作提交的部分，一处在操作本身的 结果，还有一处在用于决定异步操作状态的函数中。

•与POSIX异步I/O接口的传统方法相比，它们本身涉及大量的额外设置和处理规则。

J    事实上，并不能把非异步1/0函数称作“同步”的，因为尽管它们相对于程序流来说是同步的，

；但相对于I/O来说并非如此。回忆第3章中关于同步写的讨论。当从write函数的调用返回时，

写的教据是持久的，我们称这个写操作为“同歩的。也不能依靠把传统的调用归类为“标准’’的 ,I/O调用来区别传统的I/O函数和弄步I/O函数，因为这样会使它们和标准I/O库中的函数调用相

混•淆。为了避免产生这种现淆，表节中我们把read和write函数归类为“传统”的I/O函数o

•从错误中恢复可能会比较困难。举例来说，如果提交了多个异步写操作，其中一个失败 了，下一步我们应该怎么做？如果这些写操作是相关的，那么可能还需要撤销所有成功

[509]    的写操作。

14.5.1 SystemV 异步 I/O

在System V中，异步I/O是STREAMS系统的一部分，它只对STREAMS设备和STREAMS 管道起作用。SystemV的异步I/O信号是SIGP0LL。

为了对一个STREAMS设备启动异步1/0，需要调用ioctl,将它的第二个参数（request） 设置成I_SETSIG。第三个参数是由图1448中的一个或多个常量构成的整型值。这些常量是在 <stropts .h>中定义的。

与STREAMS机制相关的接口在SUSv4中已被标记为弃用，所以这里不讨论它们的任何细节。 关于STREAMS的信息详见Rago[1993]。

除了调用ioctl指定产生SIGPOLL信号的条件以外，还应为该信号建立信号处理程序。回 忆图10-1，对于SIGPOLL的默认动作是终止该进程，所以应当在调用ioctl之前建立信号处理 程序。

| 常量      | 说明                                                         |
| --------- | ------------------------------------------------------------ |
| S_INPUT   | 可以不阻塞地读取数据（非髙优先级数据）                       |
| S_RDNORM  | 可以不阻塞地读取普通数据                                     |
| S_RDBAND  | 可以不阻塞地读取优先级数据                                   |
| S_BANDURG | 若此常量和S_RDBAND—起指定，当我们可以不阻塞地读取 优先数据时，产生SIGURG信号而非SIGPOLL |
| S HIPRI   | 可以不阻塞地读取髙优先级数据                                 |
| S_OUTPDT  | 可以不阻塞地写普通数据                                       |
| S_WRNORM  | 与S_OUTPUT相同                                               |
| S WRBAND  | 可以不阻塞地写优先级数据                                     |
| S_MSG     | 包含SIGPOLL信号的消息已经到达流头部                          |
| S_ERROR   | 流有错误                                                     |
| S HANGUP  | 流已挂起                                                     |

图14-18产生SIGPOLL信号的条件

14.5.2 BSD 异步 I/O

在BSD派生的系统中，异步I/O是信号SIGIO和SIGURG的组合。SIGIO是通用异步I/O 信号，SIGURG则只用来通知进程网络连接上的带外数据已经到达。

为了接收SIGIO信号，需执行以下3步。

（1）    调用signal或sigaction为SIGIO信号建立信号处理程序-

（2）    以命令F_SETOWN （见3.14节）调用fcntl来设置进程ID或进程组ID,用于接收对

于该描述符的信号。    UK]

（3）    以命令F_SETFL调用fcntl设置O_ASYNC文件状态标志（见图3-10），使在该描述符 上可以进行异步I/O。

第3步仅能对指向终端或网络的描述符执行，这是BSD异步I/O设施的一个基本限制。

对于SIGURG信号，只需执行第1步和第2步。该信号仅对引用支持带外数据的网络连接描

述符而产生，如TCP连接。

14.5.3 POSIX 异步 I/O

POSIX异步I/O接口为対不同类型的文件进行异步I/O提供了一套一致的方法。这些接口来 自实时草案标准，该禄准是Single UNIX Specification的可选项。在SUSv4中，这些接口被移到 了基本部分中，所以现在所有的平台都被要求支持这雙接口。

这些异步I/O接口使用AIO控制块来描述I/O操作。aiocb结构定义了 AIO控制块。该结 构至少包括下面这些字段（具体的实现可能还包含有额外的字段）：

struct aiocb {

| int              | aio_fildea;       |
| ---------------- | ----------------- |
| of f_t           | aio_offset;       |
| volatile    void | *aio_buf;         |
| size_t           | aio_nbytes;       |
| int              | aio_reqprio;      |
| struct sigevent  | aio_sigevent;     |
| int              | ai o_li o_opcode; |

/* file descriptor */

/* file offset for I/O */

/* buffer for I/O */

/* number of bytes to transfer /* priority */

/* signal information */

/* operation for list I/O */

aio_fields字段表示被打开用来读或写的文件描述符D读或写操作从aio^offset指定 的偏移量开始。对于读操作，数据会复制到缓冲区中，该缓冲区从aio.buf指定的地址开始。 対于写操作，数据会从这个缓冲区中复制出来。aiO_nbyteS字段包含了要读或写的字节数。

注意，异步I/O操作必须显式地指定偏移量。异步I/O接口并不影响由操作系统维护的文件 偏移量。只要不在同一个进程里把异步I/O函数和传统VO函数混在一起用在同一个文件上，就不 会导致什么问题。同时值得注意的是，如果使用异步I/O接口向一个以追加模式（使用O_APPEND） 打开的文件中写入数据，AIO控制块中的aio^offset字段会被系统忽略。

其他字段和传统I/O函数中的不一致。应用程序使用aio_reqprio字段为异步I/O请求提示 顺序。然而，系统对于读顺序只有有限的控制能力，因此不一定能遵循该提示。aio_lio_opcode

UH］字段只能用于基于列表的异步1/0,我们在稍后再讨论它。aiO_SigeVent字段控制，在I/O事 件完成后，如何通知应用程序。这个字段通过sigevent结构来描述。

struct sigevent {

int    sigev_notify;

/* notify type */

/* signal number */

Z* notify argument */ /* notify function */ /* notify attrs */



int    sigev_signo;

union    sigval    sigev_value;

void (*sigev_notify_function)(union sigval);

pthread_attr_t *sigev_notify_attributes;

sigev_notify字段控制通知的类型。取值可能是以下3个中的一个。

S工GEVJONE    异步I/O请求完成后，不通知进程。

SIGEV_SIGNAL 异步I/O请求完成后，产生由sigev_signo字段指定的信号。如果应用程 序已逸择捕捉信号，且在建立信号处理程序的时候指定了 SA_SIGINFO标 志，那么该信号将被入队（如果实现支持排队信号）。信号处理程序会传送 给一个siginfo结均，该结构的si_value字段被设置为sigev_value （如果使用了 SA_SIGINFO标志）。

SIGEV_THREAD 当异步I/O请求完成时，由sigev_notify_function字段指定的函数被 调用。sigev_value字段被传入作为它的唯一参数。除非sigev_notify_ attributes字段被设定为pthread属性结构的地址，且该结构指定了一 个另外的线程属性，否则该函数将在分离状态下的一个单独的线程中执行。

在进行异步I/O之前需要先初始化AIO控制块，调用aio_read函数来进行异步读操作，或 调用aio_write函数来进行异步写操作。

| ftinclude <aio.h> |                               |                                                |
| ----------------- | ----------------------------- | ---------------------------------------------- |
| int aio_          | read (struct aiocb *aiocb)；  |                                                |
| int aio_          | write (struct aiocb * aiocb); | 两个函数的返回值：若成功，返回0:若出错，返回-1 |

当这些函数返回成功时，异步I/O请求便已经被操作系统放入等待处理的队列中了，这些返 回值与实际I/O操作的结果没有任何关系。I/O操作在等待时，必须注意确保AIO控制块和数据库 缓冲区保持稳定；它们下面对应的内存必须始终是合法的，除非I/O操作完成，否则不能被复用。

要想强制所有等待中的异步操作不等待而写入持久化的存储中，可以设立一个AIO控制块并 1512~| 调用 aio_fsync 函数。

♦include <aio.h>

int aio_f sync (int op, struct aiocb *aiocb);

返回值：若成功，返回0:若出错.返回-I

AIO控制块中的aio„fildes字段指定了其异步写操作被同步的文件。如果op参数设定为 OJDSYNC,那么操作执行起来就会像调用了 fdatasync—样。否则，如果卬参数设定为O_SYNC’ 那么操作执行起来就会像调用了 fsync —样。

像aio_read和aio_write函数一样，在安排了同步时，aio_fsync操作返回。在异步 同步操作完成之前，数据不会被持久化。AIO控制块控制我们如何被通知，就像aio_read和 aio_write 函数一样。

为了获知一个异步读、写或者同步操作的完成状态，需要调用aio_errOr函数。

♦include <aio.h>

int aio_error (const struct aiocb * aiocb);

返回值：(见下)

返回值为下面4种情况中的一种。

0    异步操作成功完成。需要调用aio_return函数蘇取操作返回值。

-1    对aio_errOr的调用失败。这种情况下，errno会告诉我们为什么。

EINPROGRESS 异步读、写或同步操作仍在等待。

其他情况    其他任何返回值是相关的异步操作失败返回的错误码

如果异步操作成功，可以调用aio_return函数来获取异步操作的返回值。

| #include <aio.h> |                                       |                  |
| ---------------- | ------------------------------------- | ---------------- |
| ssize_t z        | io_return{const struct aiocb *aiocb): | 返回值：（见下） |

直到异步操作完成之前，都需要小心不要调用aio_return函数。操作完成之前的结果是未 定义的。还需要小心对每个异歩操作只调用一次一旦调用了该函数，操作系统就 可以释放掉包含了 I/O操作返回值的记录。

如果aio_return函数本身先败，会返回-1，并设置errno。其他情况下，它将返回异步 操作的结果，即会返回read、write或者fsync在被成功调用时可能返回的结果。

执行I/O操作时，如果还有其他事务要处理而不想被I/O操作阻塞，就可以使用异步I/O。然 而，如果在完成了所有事务时，还有异步操作未完成时，可以调用aio_SuSpend函数来阻塞进 程，直到操作完成。

♦include <aio.h>

int aio_suspend (const struct aiocb * const list [ ], int nent, const struct timespec ★timeout};

返回值：若成功，返回0;若出错，返回-I

aio_suspend可能会返回三种情况中的一种。如果栽们被一个信号中断，它将会返回-1， 并将errno设置为EINTR。如果在没有任何I/O操作完成的情况下，阻塞的时间超过了函数中 可选的timeout参数所指定的时间限制，那么aio_suspend将返回H，并将errno设置为 EAGAIN （不想设置任何时间限制的话，可以把空指针传给治neoirf参数）。如果有任何I/O操作完

成，aio_suspend将返回0»如果在我们调用aio_suspend操作时，所有的异步I/O操作都己 完成，那么aio_suspend将在不阻塞的情况下直接返回。

/初参数是一个指向AIO控制块数组的指针，m也参数表明了数组中的条目数。数组中的空 指针会被跳过，其他条目都必须指向已用于初始化异步I/O操作的AIO控制块。

当还有我们不想再完成的等待中的异步I/O操作时，可以尝试使用aiO_CanCel函数来取消它们。

\#include <aio.h> *

int aio_cancel (int fd, struct aiocb *aiocb);

返回值：(见下)

岁参数指定了那个未完成的异步I/O操作的文件描述符。如果triocfi参数为NULL,系统将会尝试 取消所有该文件上未完成的异步I/O操作。其他情况下，系统将尝试取消由AIO授制块描述的单个异步 I/O操作。我们之所以说系统“尝试”取消操作，是因为无法保证系统能够取消正在进程中的任何操作。

aio^cancel函数可能会返回以下4个值中的一个。

AIO_ALLDONE    所有操作在尝试取消它们之前已经完成。

AIO_CANCELED    所有要求的操作已被取消。

AIO_NOTCANCELED 至少有一个要求的操作没有被取消。

S3 -1    对aio_cancel的调用失败，错误码蒋被存储在errno中。

如果异步I/O操作被成功取消，对相应的AIO控制块调用aio.error函数将会返回错误 ECANCELEDo如果操作不能被取消，那么相应的AIO控制块不会因为对aio_cancel的调用而被修改。

还有一个函数也被包含在异步I/O接口当中，尽管它既能以同步的方式果使用，又能以异步的方 式来使用，这个函数就是lio_listioa该函数提交一系列由一个AIO控制块列表描述的I/O请求。

\#include <aio.h>

int lio_listio (int mode, struct aiocb ^restrict const "s'[restrict], int nent, struct sigevent ^restrict sigev);

返回值：若成功，返回0;若出错，返回-1

mot/e参数决定了 I/O是否真的是异步的。如果该参数被设定为LIO.WAITr lio_listio函 数将在所有由列表指定的I/O操作完成后返回。在这种情况下，Wgev参数将被忽略。如果mo也 参数被设定为LIO_NOWAIT, lio.listio函数将在I/O请求入队后立即返回。进程将在所有I/O 操作完成后，按照Wgev参数指定的，被异步地通知。如果不想被通知，可以把Wgev设定为NULL。 注意，每个AIO控制块本身也可能启用了在各自操作完成时的异步通知。被参数指定的异 步通知是在此之外另加的，并且只会在所有的I/O操作完成后发送。

list参数指向AIO控制块列表，该列表指定了要运行的I/O操作的。参数指定了数组中 的元素个数。AIO控制块列表可以包含NULL指针，这些条目将被忽略。

在每一个AIO控制块中，aio_lio_opcode字段指定了该操作是一个读操作（LIO_READ）、写操 作（LIO_WRITE），还是将被忽略的空操作（LIO_NOP）。读操作会按照对应的AIO控制决被传给了 aio_read函数来处理。类似地，写操作会按照財应的AIO接制块被传给了 aio_write函数来处理。

实现会限制我们不想完成的异步I/O操作的数量。这些限制都是运行时不变量，其总结如 图14-19所示。

可以通过调用sysconf函数并把name参数设置为_SC_IO_LISTIO_MAX来设定AI0_ LISTIO_MAX的值。类j以地，可以通过调用sysconf并把参数设置为_SC_AIO_MAX来设

定AIO^MAX的值，通过调用sysconf并把其参数设置为_SC_AIO_PRIO_DELTA__MAX来设定 AIO_PRXO„DELTA_MAX 的值。

| 名称                                    | 描述                                                         | 可接受的最小值                                |
| --------------------------------------- | ------------------------------------------------------------ | --------------------------------------------- |
| AXO_LISTXO_MAXAIO_MAXAIO PRIO DELTA MAX | 单个列表I/O调用中的最大I/O操作数 未完成的异歩I/O操作的最大数目 进程可以减少的其异步I/O优先级的最大值 | _POSIX_AIO_LIS TIO_MAX (2)_POSIX_AIO_MAX (1)0 |

图14-19 POSIX.1中的异歩I/O运行时不变量的值 引入POSIX异步操作I/O接口的初衷是为实时应用提供一种方法I避免在执行I/O操作时阻

塞进程。接下来就让我们来看一个使用这些接口的例子。

■实例

虽然我们不会在本文中讨论实时编程，但因为POSIX异步I/O接口现在是Single UNIX Specification的基本部分，所以我们要了解一下怎么使用它们。为了対比异步I/O接口和相应的传 统I/O接口，我们来研究一个任务，将一个文件从一种格式翻译成另一种格式。

图14-20中展示的程序，使用20世纪80年代流行的USENET新闻系统中使用的ROT-13算 法，翻译文件，该算法原本用于将文本中的带有侵犯性的或者含有剧透和笑话笑点部分的文本模 糊化。该算法将文本中的英文字符a〜z和A〜Z分别循环向右偏移13个字母位移，但不改变其 他字符。

\#include "apue.h"

^include <ctype.h>

\#include <fcntl.h>

^define BSZ 4096

unsigned char bufIBSZ]；

unsigned char

translate(unsigned char c)

{

if (isalpha(c)) { if (c >= 'n')

c -= 13;

else if (c >= 'a') c += 13;

else if (c >= 'N') c -= 13;

else

c += 13;

}

return(c);

J

int

main(int argc, char* argv[])

int ifd, ofd, i, n, nw；

| if (argc != 3)err_quit("usage: rotl3 infile outfile"); if ((ifd = open(argv[1], O_RDONLY)) < 0)err_sys("can*t open %s", argv[l]); if ((ofd = open(argv【2], O_RDWRI0_CREAT\|O_TRUNCZ FILE_MODE)) < 0)err_sys("can't create %s", argv[2]); |
| ------------------------------------------------------------ |
| while ((n = read(ifd, buf, BSZ)) >0) {                       |
| for (i = 0; i < n; i++)                                      |
| buf[i] = translate(buf[i]);                                  |
| if ((nw = write (ofd, buf, n)) ! = n) {                      |
| if (nw < 0}                                                  |
| err_sys("write failed");                                     |
| else                                                         |
| err_quit{"short write (%d/%d)", nw, n);}                     |
| fsync(ofd);                                                  |
| exit(0);1                                                    |
| 图14-20用ROT-13翻译一个文件                                  |
| 程序中的I/O部分是很直接的：从输入文件中读取一个块，翻译之，然后再把这个块写到输 |
| 出文件中。重复该步骤直到遇到文件尾端，read返回0。图1本21中的程序展示了如何使用等价 |
| 的异步I/O函数做同样的任务。                                  |

\#include ’’apue. h" #include <ctype.h>

\#include <fcntl.h> #include <aio.h>

♦include



<errno.h>



\#define BSZ 4096 #define NBUF 8

enum rwop {

UNUSED = 0,

READ_PENDING = 1, WRITE_PENDING = 2


}；

struct buf {

enum rwop    op;

int    last;

struct aiocb aiocb;

i__i    unsigned char data [BSZ]；

晒”

struct buf bufs[NBUF];

unsigned char

translate(unsigned char c)

{

/* same as before */

int

main(int argc, char* argv[])

int

struct stat

const struct aiocb

off_t



ifd, ofd, i, j, n, err, numop; sbuf ;

*aiolist[NBUF];

off = 0;

if (argc != 3)

err_quit("usage: rotl3 infile outfile"); if ((ifd = open(argv[l], O_RDONLY)) < 0)

err_sys("can*t open %s", argv[l])； if ((Ofd = open(argv[2], O_RDWRIO_CREATIO_TRUNCZ FILE_MODE)) < 0)

err_sys (**canf t create %s", argv 12]); if (fstat(ifd, Ssbuf) < 0)

err_sys("fstat failed");

/* initialize the buffers */

for (i = 0; i < NBUF; i++) { bufs[i].op = UNUSED;

bufs[i].aiocb.aio_buf = bufs[i].data;

bufs[i].aiocb.aio_sigevent.sigev_notify = SIGEV_NONE；

aiolist[i] = NULL;

J

numop = 0;

for (;;) f

for (i = 0; i < NBUF; i++) { switch {bufs[i].op) { case UNUSED:

/*

\*    Read from the input file if more data

\*    remains unread.

*/

if (off < sbuf.st_size) {

bufs[i].op = READ_PENDING; bufs[i].aiocb.aio_fildes = ifd; bufs [i]. aioc±i.aio_offset = off; off += BSZ;

if (off >= sbuf.st_size) bufs[i].last = 1;

bufs[i].aiocb.aio_nbytes = BSZ; if (aio_read(&bufs[i].aiocb} < 0)

err_sys (*'aio_read failed");    ，—，

aiolist[i] = &bufs[i].aiocb;    画

numop++;

}

break;

case READ_PENDING:



==EINPROGRESS)



if ((err = aio_error(&bufs[i].aiocb)) continue;

if (err != 0)    {

if (err == -1)

err_sys("aio_error failed");

else

err_exit(err, "read failed");

\*    A read is complete; translate the buffer

\*    and write it.

*/

if ((n = aio_return(&bufs【i].aiocb}) < 0) err_sys ("aio__return failed");

if (n != BSZ && Jbufs[i].last)

err_quit("short read (%d/%d)", n, BSZ);

for (j = 0; j < n; j++)

bufs[i].data[j] = translate(bufs[i].data[j]);

bufs[i].Op = WRITE_PENDING;

bufs[i].aiocb.aio_fildes = ofd;

bufs[i].aiocb.aio_nbytes = n;

if (aio_write(&bufs[i].aiocb) < 0) err_sys("aio_write failed")；

/* retain our spot in aiolist */

break;

case MRITE_PENDING:

if ((err = aio_error(Sbufs[i].aiocb)) == EINPROGRESS) continue;

if (err != 0) {

if {err == -1)

err_sys("aio_error failed");

else

err_exit(err, "write failed");

J

\* A write is complete; mark the buffer as unused. */

if ({n = aio_return(fibufs[i].aiocb)) < 0) err_sys("aio_return failed");

if {n != bufs[i],aiocb.aio_nbytes)

err_quit("short write    ", n, BSZ);

[5191



aiolist[i] = NULL; bufs[i].op = UNUSED； numop;

break;

1

if (numop == 0) {

if (off >= sbuf.st_size)

break;

} else [

if (aio_suspend(aiolist, NBUF, NULL) < 0) err_sys("aio_suspend failed");

bufs[O],aiocb.aio_fildes = ofd;

if (aio_fsync(O_SYNC, &bufs[0].aiocb) < 0) err_sys("aio_fsync failed");

exit(0);

图14-21用ROT-13和异步I/O翻译一个文件

注意，我们使用了 8个缓冲区，因此可以有最多8个异步I/O请求处于等待状态。令人惊讶 的是，实际上这可能会降低性能，因为如果读操作是以无序的方式提交给文件系统的，操作系统 提前读的算法便会失效。

在檢查操作的返回值之前，必须确认操作已经完成。当aio_error返回的值既非EINPROGRESS 亦非-1时，表明操作完成。除了这坚值之外，如果返回值是0以外的任何值，说明操作失败了(，一 旦检査过这些情况，便可以安全地调用aio_retUrn来萩取I/O操作的返回值了。

只要还有事情要做，就可以提交异步I/O操作。当存在未使用的AIO控制块时，可以提交一 个异步读操作。读操作完成后，翻译缓冲区中的内容并将它提交给一个异步写请求。当所有AIO 控制块都在使用中时，通过调用aiO_SUSpend等待操作完成。

在把一个块写入输出文件时，我们保留了在从输入文件读取数据时的偏移量。因而写的顺序 并不重要。这一策略仅在输入文件中每个字符和输出文件中对应的字符的偏移量相同的情况下适 用，我们在输出文件中既没有添加字符也没有删除字符。

这个实例中并没有使用异步通知，因为使用同步编程模型更加简单。如果在I/O操作进行时 还有别的事情要做，那么额外的工作可以包含在for循环当中。然而，如果需要阻止这些额外的 工作延迟翻译文件的任务，那么就需要组织下代码使用异步通知。多任务情况下，决定程序如何 建构之前需要先考虑各个任务的优先级。    ,[520]

##### 14-6 函数 readv 和 writev

readv和writev函数用于在一次函数调用中读、写多个非连续缓冲区。有时也将这两个函 数嵇力散布读(seatterread)和聚集写(gatherwrite)。

\#include <sys/uio.h>

ssize_t readv(int fd, const struct iovec *iov, int iovcnt}; ssize_t writev (int fd, const struct iovec *iov, int iovcnt};

两个函数的返回值：已读或已写的字节数：若出错，返回-1

这两个函数的第二个参数是指向iovec结钩数组的一个指针： struct iovec {

void *iov_base; /* starting address of buffer */ size_t iov_len; /* size of buffer */

}；

如v数组中的元素数由ZomU指定，其最大值受限于IOV_MAX (回忆图2-11)。图14-22显示 了这两个函数的参数和iovec结构之间的关系。

writev函数从缓冲区中聚集输出数据的顺序是：iov[0] >    直至。

writev返回输出的字节总数，通常应等于所有缓冲E长度之和。

iou[0] K7U[ 0] »’刪 1] iot»l 1 ]

iov[ iovcnt-1 J iov[iovcnt-l]

| iov_base |       | -级冲区o            |
| -------- | ----- | ------------------- |
| iov_len  | 长度0 | H-长度0 -H          |
| iov base |       |                     |
|          |       | ■*)    缓冲区1    I |
| iov len  | 长度1 |                     |
|          |       | —长度1 一H          |
| iov_base |       | -H    缓冲区n       |
| iov_len  | 长度W | H-长 &N-H           |

图 14-22 readv 和 writev 的 iovec 结构

readv函数则将读入的数据按上述同样顺序散布到缓冲区中。readv总是先填满一个缓冲 区，然后再填写下一个。readv返回读到的字节总数。如果遇到文件尾端，己无数据可读，则返 回0。

这两个函数始于4.2BSD,后来，SVR4也提供它们。在Single UNIX Specification的XSI ；扩展中包括了这两个函数。

、实例

在20.8节的_db_writeidx函数中，需将两个缓冲E中的内容连续地写到一个文件中。第 二个缓冲区是调用者传递过来的一个参数，第一个缓冲区是我们创建的，它包含了第二个缓冲的 长度以及文件中其他信息的文件偏移量。有以下3种方法可以实现这一要求。

(1)    调用两次write,每个缓冲区一次。

(2)    分配一个大到足以包含两个缓冲区的新缓冲区。将两个缓冲区的内容复制到新缓冲区中。 然后对这个新缓冲区调用一次write。

(3)    调用writev输出两个缓冲区。

20.8节的解决方案使用丁 writev,但是将它与另外两种方法进行比较，对我们是很有启发 的。图14-23显示了上面所述3种方法的结果。

| 操作                      | Linux (Intel x86) | Mac OS X (Intel x86) |      |      |      |       |
| ------------------------- | ----------------- | -------------------- | ---- | ---- | ---- | ----- |
| 用户                      | 系统              | 时钟                 | 用户 | 系统 | 吋钟 |       |
| 两次write                 | 0.06              | 2.04                 | 2.13 | 0.85 | 8.33 | 13.83 |
| 缓冲区复制，然后一次write | 0+03              | 1.13                 | 1.16 | 0.70 | 4+87 | 9.25  |
| 次 writev                 | 0.04              | 1.21                 | 1.26 | 0.43 | 5.34 | 9.24  |

图14-23比较writev和其他技术所得的时间结果 用于测量的测试程序输出一个100字节的头文件，接着又输出200字节的数据。这样做1 048 576

次，产生了一个300 MB的文件。该测试程序有3个版本——针对图14-23中的每一种测量技木 编写了一个版本。使用times (见8.17节)测得它们在写操作前、后各使用的用户CPU时间、 系统CPU时间和时钟时间。这3个时间的单位都是秒。

正如我们所预料的，调用两吹write的系统时间比调用一砍write或writev的长，这与 图3-6的结果类似。

接着要注意的是，在缓冲区复制后跟随一个write所用的CPU时间(用户时间加系统时间)要 少于调用一次writev所耗费的CPU时间。对于单一 write的情况，我们先将用户层次的两个缓冲

区复制到一个分段缓冲區(staging buffer),然后在调用write时内核将该分段缓冲匡中的数据 复制到其内部缓冲区。对于writev的情况，因为内核只需将数据直接复制进其分段缓冲区，所 以复制工作应当会少一些。但是，对于选种少量数据，使用writev的固定成本大于收益。随着 需复制数据的增加，程序中复制缓冲区的成本也会増多，此时，writev这种替代方法将更具吸 引力。

不要依据图1本23中的数字对Linux和MacOSX之间的相对性能作过多的推断。这两种计算 |机有很大差别：它们有不同的处理器结构、不同数量的RAM以及不同速度的磁盘。为了在操诈

系统之间进行公平的比较，需要对每一种操作系统都使用相同的硬件。    [522]

总之，应当用尽量少的系统调用次数来完成任务。如果我们只写少量的数据，将会发现自己 复制数据然后使用一次write会比用writev更合算。但也可能发现，我们管理自己的分段缓 冲区会增加程序额外的复杂性成本，所以从性能成本的角度来看不合算。

##### 14.7 函数 readn 和 writen

管道、FIFO以及某些设备(特别是终端和阔络)有下列两种性质。

(1)    一次read操作所返回的数据可能少于所要求的数据，即使还没迖到文件尾端也可能是 选样。这不是一个错误，应当继续读该设备。

(2)    —次write操作的返回值也可能少于指定输出的字节数。这可能是由某个因素造成的， 例如，内棱输出缓冲区变满。这也不是错误，应当继续写余下的数据。(通常，只有非阻塞描述 符，或捕捉到一个信号时，才发生选种write的中途返回。)

在读、写磁盘文件时从未见到过这种情况，除非文件系统用完了空间，或者接近了配额限制， 不能将要求写的数据全部写出。

通常，在读、写一个管道、网络设备或终端时，需要考虑这些特性。下面两个函数readn 和writer!的功能分别是读、写指定的况字节数据，并处理返回值可能小于要求值的情况。这两 个函数只是按需多次调用read和write直至读、写了 #字节数据。

\#include "apue.h"

ssize_t readn (int fd, void *buf, size_t nbytes、； ssize_t writen (int fd, void *buf, size_t nbyles);

两个函数的返回值：读、写的字节数；若出错，返回-1

j    类似于本书很多实例所使用的出错处理例程，我们定义这两个函数的目的是便于在后面实例

j中使用。readn和writen函数并不是哪个标准的组成部分。

在要将数据写到上面提到的文件类型上时，就可调用writen,但是仅当事先就知道要接收 数据的数量时，才调用readn。图14-24包食了 readn和writen的实现，在后面的实例中，

我们还会用到。    [5231

size_t nleft; ssize_t nread;

nleft = n;

while (nleft > 0) {

if Unread = read(fd, ptr, nleft)) < 0)( if (nleft == n)

return(-1); /* error, return -1 */

else

break; /* error, return amount read so far */ } else if {nread == 0) {

break; /* EOF */

}

nleft -= nread; ptr += nread;

}

return{n - nleft); /* return >= 0 */

ssize_t

writen(int fd,

size_t

ssize_t



/* Write "n" bytes to a descriptor *, const void *ptr, size_t n)

nleft;

nwritten;

nleft = n;

while (nleft > 0) {

if ((nwritten = write(fd, ptr, nleft)) < 0) { if (nleft == n)

return{-1); /* error, return -1 */

else

break;    /* error, return amount written so far */

)else if {nwritten == 0} {

break;

nleft -= nwritten; ptr += nwritten;

}

return(n - nleft);    /* return >= 0 */

图 14-24 readn 和 writen 函数

注意，若在己经读、写了一些数据之后出错，则这两个函数返回的是已传输的数据量，而非 错误。与此类似，在读时，如达到文件尾端，而且在此之前已成功地读了一些数据，但尚未满足

®所要求的量，则readn返回已复制到调用者缓冲区中的字节数。

##### 14-8存储映射I/O

存储映射I/O (memory-mapped I/O)能将一个磁盘文件映射到存储空间中的一个缓冲区上， 于是，当从缓冲区中取数据时，就相当于读文件中的相应字节。与此类似，将数据存入缓冲区时, 相应字节就自动写入文件。这样，就可以在不使用read和write的情况下执行I/O。

j    存倚映射I/O伴随虎拟奔错系统已经用了很多年。］981年，4.1BSD以其vread和vwrite

函数提供了一种不同形式的存储映射I/O。4.2BSD中刪除了这两个函數，试图替换成mmap函數。 但是4.2BSD实际上并没有包含mmap函数（原因见McKusick等［1996］中2.5节的描述）。Gingell、 Moran和Shannon［1987］描述了 mmap的一种实现。SUSv4把mmap函救从可选项梘范中移到了基 础规范中。所有的遵循POSIX的系统都需要支持它。

为了使用这种功能，应首先告诉内核将一个给定的文件映射到一个存储区域中。这是由mmap 函数实现的。

\#include <sys/mman.h>

void *mmap （void *addr, size_t len, int prot, int flag, int fd, off_t off）;

返回值：若成功，返回映射区的起始地址：若出镑，返回MAP FAILED

adtfr参数用于指定映射存储医的起始地址。通常将其设置为0,这表示由系统选择该映射区 的起始地址。此函数的返回值是该映射区的起始地址。

片参数是指定要被映射文件的描述符。在文件映射到地址空间之前，必须先打开该文件。len参 数是映射的字节数，<是要映射字节在文件中的起始偏移量（有关<值的一些限制将在后面说明）。

pror参数指定了映射存储区的保护要求，如图14-25所示。

| prat       | 说明           |
| ---------- | -------------- |
| PROT_READ  | 映射区可读     |
| PROT_WRITE | 映射区可写     |
| PROT_EXEC  | 映射区可执行   |
| PROT NONE  | 映射区不可访问 |

图14-25映射存储区的保护要求

可将pro/参数指定为 PROT__NONE，也可指定为 PROT_READ、PROT_WRITE 和 PROT_EXEC 的任意组合的按位或。对指定映射存储区的保护要求不能超过文件open模式访问权限。例如，

若该文件是只读打开的，那么对映射存储区就不能指定PROT_WRITE-

在说明77呢参数之前，先看一下存储映射文件的基本情况。图14~26显示了一个存储映射文@ 件。（见图7-6中所示的典型进程的存储器安排。）在此图中，“起始地址”是mmap的返回值。映 射存储区位于堆和桟之间：这属于实现细节，各种实现之间可能不同，

下面是7?呀参数影响映射存储区的多种属性。

MAP.FIXED    返回值必须等于办。因为这不利于可移植性，所以不鼓励使用此标志。

如果未指定此标志，而且flA/r非0,则内核只把twWr视为在何处设置映 射区的一种建议，但是不保证会使用所要求的地址。将指定为0可 获得最大可移植性。

j    在遵循POSIX的系统中，对MAP_FIXED标志的支持是可选择的，但遵榍XSI的系统则

;要求支持MAP_FIXED。

MAP.SHARED    这一标志描述了本进程对映射区所进行的存储操作的配置。此标志指定

存储操作修改映射文件，也就是，存储操作相当于对该文件的write。

必须指定本标志或下一个标志（MAP_PR工VATE〉，但不能同时指定两者。

MAP_PRIVATE    本标志说明，对映射区的存储操作导致创建该映射文件的一个私有副本。（526］

所有后来対该映射区的引用都是引用该副本，（此标志的一种用途是用于 调试程序，它将程序文件的正文部分映射至存储区，但允许用户修改其 中的指令。任何修改只影响程序文件的副本，而不影响原文件。）

起始地址

| 髙地址                 |      |                   |
| ---------------------- | ---- | ----------------- |
| 栈                     |      |                   |
|                        |      |                   |
| len                    |      | 文件的存槠 喊部分 |
| 低地址                 |      |                   |
| 堆                     |      |                   |
| 未初始化的数据 （bss） |      |                   |
| 已初始化的数提         |      |                   |
| 正文                   |      |                   |



文件的存储 映射部分



图14-26存储映射文件的例子



len



每种实现都可能还有另外一些MAP.xxx标志僮，它们是那种实现所特有的，详细情况请参 见你所使用系统的mmap（2）手册页。

畋的值和《齡的值（如果指定了 MAELFIXED）通常被要求是系统虚拟存储页长度的倍数。 虚拟存储页长可用带参数_SC_PAGESIZE 或_SC_PAGE_SIZE的sysconf函数（见2.5.4节）得 到。因为0#和twWr常常指定为0,所以这种要求一般并不重要。

I    这一要求通常是由系统实现强加的。尽管Single UNIX Specification不再要求满足该条件，但

是所有本书中讲到的除了 FreeBSD 8.0以外的所有平台都满足了这一要求。FreeBSD 8.0允许我们

j使用任意的地址对齐和偏移对齐，只要对齐匹配即可。

既然映射文件的起始偏移量受系统虚拟存储页长度的限制，那么如果映射区的长度不是页长 的整数倍时，会怎么样呢？假定文件长为12字节，系统页长为512字节，则系统通常提供512 字节的映射区，其中后500字节被设置为0„可以修改后面的这500字节，但任何变动都不会在 文件中反映出来。于是，不能用minap将数据添加到文件中，我们必须先加长该文件，如后面的 图14^27中的程序所示。

与映射区相关的信号有SIGSEGV和SIGBUS。信号SIGSEGV通常用于指示进程试图访问对 兌不可用的存储区。如果映射存储区被mmap指定成了只读的，那么进程试图将数据存入这个映 射存储区的时候，也会产生此信号。如果映射E的某个部好在访问时已不存在，则产生SIGBUS 信号。例如，假设用文件长度映射了一个文件，但在引用该映射区之前，另一个进程已将该文件 截断。此时，如果进程试图访问对应于该文件已截去部分的映射区，将会接收到SIGBUS信号。

子进程能通过fork继承存储映射区（因为子进程复制父进程地址空间，而存储映射区是该 地址空间中的一部分），但是由于同样的原因，新程序则不能通过exec继承存储映射区。

调用mprotect可以更改一个现有映射的权限。

♦include <3ys/mman.h>

int mprotect （void *addr, size_t len, int proi）;

返回值：若成功i返回0;若出错，返回-1

pro/的合法值与mmap中戸^参数的一样（见图14-25）。请注意，地址参数at/t/r的值必须是 系统页长的整数倍D

如果修改的页是通过MAP_SHARED标志映射到地址空间的，那么修改并不会立即写回到文件[527] 中。相反，何时写回脏页由内核的守护进程决定，决定的依据是系统负载和用来限制在系统失败 事件中的数据损失的配置参数。因此，如果只修改了一页中的一个字节，当修改被写回到文件中 时，整个页都会被写回。

如果共享映射中的页已修改，那么可以调用msync将该页冲洗到被映射的文件中。msync 函数类似于fsync （见3.13节〉，但作用于存储映射区。

^include <sys/mman.h>

int msync (void *addr, size_t len, int flags);

返回值：若成功，返回0;若出错，返回-I

如果映射是私有的，那么不修改被映射的文件。与其他存储映射函数一样，地址必须与页边 界对齐。

flags参数使我们対如何冲洗存储区有某种程度的控制。可以指定MS_ASYNC标志来简单地调 试要写的页。如果希望在返回之前等待写操作完成，则可指定MS_SYNC标志。一定要指定 MS_ASYNC 和 MS_SYNC 中的一个。

MS„INVALIDATE是一个可选标志，允i午我们通知操作系统丢弃那些与底层存储器没有同步 的页。若使用了此标志，某些实现将丢弃指定范围中的所有页，但这种行为并不是必需的。

msync函数包含在Single UNIX Specification的XS1选项中。因此，所有UNIX系统必须支持它。

当进程终止时，会自动解除存储映射区的映射，或者直接调用munmap函数也可以解除映射 区。关闭映射存储区时使用的文件描述符并不解除映射区。

\# include <sys/mman.h>

int munmap (void *addr, size_t len)；

返回值：若成功，返回0:若出错，返回-1

munmap并不影响被映射的对象，也就是说，调用munmap并不会使映射医的内容写到磁盘 文件上。对于MAP_SHAREDg磁盘文件的更新，会在我们将数据写到存储映射区后的某个时刻， 按内核虚故存储算法自动进行。在存储区解除映射后，对MAP_PRIVATE存储区的修改会被丢弃。

■实例

图14-27中的程序用存储映射I/O复制文件（类似于cp（l）命令）。

律include "apue.h" ♦include <fcntl.h> #include <sys/mman.h>

禅define COPYINCR (1024*1024*1024)    /* 1 GB */ int

main(int argc, char *argv[])

int

void size_t struct stat of f_t



fdin, fdout; *src, *dst; copysz; sbuf ； fsz = 0;



if (argc != 3)

err_quit("usage: %s <fromfile> <tofile>", argv[0]);

if ((fdin = open(argv[l], O_RDONLY)) < 0)

err_sys("can't open %s for reading", argv[1]);

if ((fdout « open(argv[2], O_RDWR | O_CREAT I O_TRUNC,

FILE_MODE)» < 0)

err_sys("can't creat %s for writing", argv[2]);

if {fstat(fdin, &sbuf) < 0}    /* need size of input file */

err_sys("fstat error");

if {ftruncate(fdout, sbuf.st_size) < 0) /* set output file size */ err_sys("ftruncate error");

while (fsz < sbuf.st_size) {

if {(sbuf.st_size - fsz) > COPYINCR)

copysz = COPYINCR;

else

copysz = sbuf.st_size - fsz;

if ((src = nunap (0, copysz, PROT_READ, MAP_SHARED, fdin, fsz)) == MRP_FAILED)

err_sys("mmap error for input")； if ((dst = mmap(0, copysz, PROT_READ 1 PROT_WRITE,

MAP_SHARED, fdout, fsz} } == MAP_FAILED) err_sys("mmap error for output");

memcpy(dst, src, copysz);    /* does the file copy */

munmap(src, copysz); munmap(dst, copysz); fsz += copysz;

exit{0);

图14-27用存俺映射I/O复制文件

该程序首先打开两个文件，然后调用fstat得到输入文件的长度。在为输入文件调用醐ap 和设置输出文件长度时都需使用输入文件长度。可以调用ftruncate设置输出文件的长度。如 果不设置输出文件的长度，则对输出文件调用mmap也可以，但是对相关存储E的第一次引用会 产生SIGBUS信号e

然后对每个文件调用mrnap，将文件映射到内存，最后调用inemcpy将输入缓冲区的内容复 制到输出缓冲区。为了限制使用内存的量，我们每次最多复制1GB的数据（如果系统没有足够 的内存，可能无法把一个很大的文件中的所有内容都映射到内存中）。在映射文件中的后一部分 数据之前，我们需要解除前一部分数据的映射。

在从输入缓冲区（src）取数据字节时，内核自动读输入文件:在将数据存入输出缓冲区（dst） 时，内核自动将数据写到输出文件中。

: 数据被写到文件的确切时间依赖于系统的页管理算法。某些系统设置了守护进程，在系统运 :行期间，它慢条斯理地将改写过的页写到磁盘上。如果想要戏保數据安全地写到文件中，则需在 ；进程终止前以MS_SYNC标志调用msynCc

将存储区映射复制与用read和write进行的复制（缓冲区长度为8 192）相比较，得到 图14-28中所示的结果。其中，时间单位是秒，被复制文件的长度是300MB。注意，我们并没有 在退出前将数据同步到磁盘。

| 操作        | Linux 32.0 (Intel x86) | Solaris 10 (SPARC) |       |      |       |       |
| ----------- | ---------------------- | ------------------ | ----- | ---- | ----- | ----- |
| 用户        | 系统                   | 时钟               | 用户  | 系统 | 时钟  |       |
| read/write  | 0,01                   | 0.54               | 5.67  | 0.29 | 10.60 | 43.67 |
| mmap/memcpy | 0.08                   | 0.65               | 22.54 | 1.89 | 8.56  | 38.42 |

图14-28 read/write与mmap/memcpy比较的时间结果 在Linux 3.2.0和Solaris 10中，两种方法的总的CPU时间（用户时间+系统时间）几乎是相

同的。在Solaris中，使用mmap和memcpy复制，与使用read和write相比，获费了更多的 用户时间，但却减少了系统时间。在Linux中，用户时间的结果很相似，但是用read和write 消耗的系统时间要比使用nunap和memcpy略好一些》这两种版本的方法是殊途同归的。

二者的主要区别在于，与mmap和memcpy相比，read和write执行了更多的系统调用，并 做了更多的复制。read和write将数据从内核缓冲区中复制到应用缓冲区（read），然后再把数 据从应用缓冲区复制到内核缓冲区（write）-而mmap和memcpy则直接把数据从映射到地址空 间的一个内核缓冲区复制到另一个内核缓冲区。当引用尚不存在的内存页时，这样的复制过程就会作 为处理页错误的结果而出现（每次错页读发生一次错误，每次错页写发生一况错误）。如果系统调用.__. 和额外的复制操作的开销和页错误的开銷不同，那么这两种方法中就会有一种比另一种表现更好。

在Linux 3.2.0中，相对于运行时间，两种版本的程序在时钟时间上显示出了巨大的差异：使 用read和write的版本完成任务比使用mmap和memcpy的版本快了 4倍。然而在Solaris 10 中，使用mmap和memcpy的版本比使用read和write的版本要快。既然二者的CPU时间几 乎是相同的，为何它们的时钟时间差异却如此之大呢？ 一种可能是，在一种版本中需要较长的时 间来等待I/O完成。这个等待时间并没有计算在CPU的处理时间中。另一种可能是，某些系统 处理的时间可能并没有在程序中计算，比如系统守护进程把页写到磁盘中的操作。由于需要为 读和写分配页，系统的守护进程会帮助我们准备可用的页。如果页的写操作是随机的而非连续 的，那么把它们写入磁盘所需要的时间会更长，因此在页可以被用来复用之前所需等待的时间也 会更长。    ■*

有的系统将一个普通文件复制到另一个普通文件中时，存储映射I/O可能会比较快。但是有一 些限制，例如，不能用这种技术在某些设备之间（如网络设备或终端设备）进行复制，井且在对被

复制的文件进行映射后，也要注意该文件的长度是否改变。尽管如此，某些应用程序仍然能得益于 存储映射1/0,因为它处理的是存储空间而不是读、写一个文件，所以常常可以简化算法。从存储 映射I/O中得益的一个例子是对帧缓冲设备的操作，该设备引用位图式显示（bit-mappeddisplay）。

Krieger、Stumm和Unrau[1992]描述了一个使用存储映射I/O的标准I/O库（见第5章）。

15.9节还会提到存储映射I/O,其中还举了一个例子，说明如何使用存储映射I/O在两个相关

进程间提供共享存储区。

##### 14.9小结

本章描述了很多高级I/O功能，其中有许多将用在后面章节的实例中。

•非阻塞I/O—发一个I/O操作，不使其阻塞。

•记录锁（在第20章中有一个实例，该实例会对此进行更详细的讨论）。

•    I/O多路转接——select和poll函数（在后面的很多实例中会用到这两个函数）。

•    readv和writev函数（在后面的很多实例中也会用到这两个函数）。

[5311    •存储映射 I/O （minap）。

习题

14.1编写一个测试程序说明你所用系统在下列情况下的运行情况：一个进程在试图对一个文件 的某个范围加写锁的时候阻塞，之后其他进程又提出了一些相关的加读锁请求。试图加写 锁的进程会不会因此而饿死？

14.2査看你所用系统的头文件，并研究select和4个FD_定的实现。

14.3系统头文件通常对fd_set数据类型可以处理的最大描述符数有一个内置的限制，假设需 要将描述符数增加到2048,该如何实现？

14.4比较处理信号量集的函数（见10.11节）和处理fd_set描述符集的函数，并比较这两类函 数在你系统上的实现。

14.5用select或poll实现一个与sleep类似的函数sleep_us，不同之处是要等待指定的 若干微秒。比较这个函数和BSD中的usleep函数。

14.6是否可以利用建议性记录锁来实现图10-24中的函数TELL_WAIT、TELL_PARENT、 TELL_CHILD、WAIT_PARENT以及WAIT_CHILD?如果可以，编写这些函数并测试其功能。

14.7用非阻塞写来确定管道的容量。将其值与第2章的PIPE_BUF值进行比较。

14.8重写图14-21中的程序来制作一个过滤器：从标准输入中读入并向标准输出写，但是要使用

异步I/O接口。为了使之能正常工作，你都需要修改些什么？记住，无论你的标淮输出被连 接到终端、管道述是一个普通文件，都应该得到相同的结果。

14.9回忆图14-23,在你的系统上找到一个损益平衡点，从此点开始，使用writev将快于你自 己使用单个write复制数据。

14.10运行图14-27中的程序复制一个文件，检査输入文件的上一次访问时间是否更新了？

14.11在图14-27的程序中，在调用minap后调用close关闭输入文件，以验证关闭描述符不会

岡    使内存映射I/O失效。
