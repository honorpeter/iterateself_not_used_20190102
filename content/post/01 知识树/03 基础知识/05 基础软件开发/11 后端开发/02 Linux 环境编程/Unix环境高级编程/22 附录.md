---
title: 22 附录
toc: true
date: 2018-08-21 18:15:07
---


### 附录A

本附录包含了正文中说明过的标准ISO C、POSIX和UNIX系统的函数原型。通常我们想了 解的是函数的参数(fgets的哪一个参数是文件指针？)或者返回值(sprintf返回的是指针 还是计数值？)。这些函数原型还说明了要包含哪些头文件，以获得特定常量的定义，或获得ISO C函数原型，以帮助在编译时进行错误检测。

每个函数原型的引用页号出现在为该函数列出的第一个头文件的右边。引用页号提供的是包 含该函数原型的页。为获得该函数原型的附加信息可参阅该页。

某些函数原型仅受本书说明的4种平台中某几种的支持。另外，某些平台支持的函数标志在 另一些平台上并不提供支持。对于这些情况，我们通常列出提供支持的平台。但是对于有些情况， 我们列出了不提供支持的平台。

冬附录中标注的页码为英文版原书的页码，与书中页边标注的页码对座。

void



int



int



int



abort(void);

<stdlib.h>    p. 365

此函数不返回值

accept (int sock'd, struct sockaddr * restrict addr, socklen_t * restrict len);

<sys/socket.h>    p. 608

返回值：若成功，返回文件(套接字)描述符;若出错则返回-1    闹

acoess (const char *path, int mode);

<unistd. h>    p. 102

mode： R_OK、W_0K、X_0K、F_OK

返回值：_若成功，返回0:若出返回-1

axo_cancel {int fd, struct aiocb *aiocb);

<aio.h>    p.514



int



int



int



返回值：AIO_ALLDONE、AIO_CANCELED、AIO_NOTCANCELED;若出错，返回-1

aio_err or (const struct aiocb * aiocb);

<aio.h>    p.513

返回值，若操作成功，返回0:若操作仍在进行中，返回EINPROGRESS:若操

作先败，返回错误码：若出错，返回-1

aio_fsync (int op, struct aiocb * aiocb);

<aio.h>    p. 513

返回值：若成功，返回0:若出错，返回-1

aio_read(struct aiocb *aiocb];

<aio h>

返回值：若成功则，返回0;若出错则返回-1



p. 512



<aio.h>

返回值：异步操作的结果：若出错，返回-1

int    axo_suspend (const struct aiocb * const list t ] , int nent,

const struct timespec * timeout);

<aio.h>

返回值：若成功，返回0:若出错，返回4

int    aio_wr±ta (struct aiocb * aiocb):

<aio.h>

返回值：若成功，返回0:若出错，返回-1

unsigned

int    alum (unsigned int seconds);

<unistd.h>

返回值：0或以前设置的闹钟吋间的余留秒数

int    ataxit(void    (void));

<stdlib.h>

闹    返回值：若成功，返回0:若出错，返回非0

int    bind(int sock'd, const struct sockaddr ★addr, socklen_t len、；

<sys/socket.h>

返回值：若成功，返回0:若出错，返回-1

void    *calloc{size_t nobj, size_t size);

<atdlib.h>

返回值：若成功，返回非空指针：若出错，返回NULL

speed_t    cfgatispead (const struct termios *termptr);

<teirmios.h>

返回值：返回波特率值

speed_t    cfgotospeed (const struct termios ^termptr);

<termios.h>

返回值t返回波特率值

int    cfsatxspead(struct termios *termptr, apeed_t speed};

<termios.h>

返回值：若成功，返回0:若出错，返回H

int    cfsatospead (struct termios *termptr, speed_t speed);

<termios.h>

返回值：若成功.返回0:若出错，返回-1

int    chdir (const char *path);

<unistd.h>

返回值：若成功，返回0:若出错，返回-1

int    cbnod(const char *path, mode一t mode、；

<sys/stat.h>

mode: S_IS[UG]ID、S_ISVTX、

S_I[RWX] (USR|GRP IOTH)

返回值：若成功，返回0;若出错，返回-1

int    chown {const char *path, uid_t owner, gid_t group、：

<unistd.h>

返回值：若成功，返回0;若出错，返回H

void    cloararr (FILE ;

<stdio.h>

int    cloek_g«'trea (clockid_t clock^id, struct timespec *tsp);

p.513

p.5I4

p.512

p.338

p. 200

p. 604

p. 207

p. 692

p, 692

p.692

p. 692

p. 135

p. 106

p. 109

p. 151



int



int



int



<sys/time.h>    p. 190

clockjdi CLOCK_REALTIME、CLOCK_MONOTONIC>

CLOCK_PROCESS_CPUTIME_ID、

CLOCK_THREAD_CPUTIME_ID    _

返回值：若成功，返回0: 出错，i回H    岡

clock_gettuite (clockid_t clock_id, struct timespec *tsp);

<sys/time.h>    p. 189

clock_id-. CLOCK_REALTIME、CLOCK_MONOTONIC、

CLOCK_PROCESS_CPUTIME_ID、

CLOCK_THREAD_CPUTIME_ID

返回值：若成坊，返回0:、出错，if回-1

clock._nanoslaap (clockid_t clock_id, int flags,

const struct timespec *reqtp, structtimespec *remtp);

<time.h>    p. 375

clockjdi CLOCK_REALTIME、CLOCK_MONOTONIC、

CLOCK_PROCESS_CPUTIME_ID,

CLOCK_THREAD_CPUTIME_XD

flags-. TIMER_ABSTIME

返回值：若休眠够要求的时间，返回0;若失败，返回错误码 clock_sabtime(clockid_t clock_id, const struct timespec *tsp、；

<sys/time.h>    p. 190

clockjdi CLOCK—REALTIME、CLOCK_MONOTONIC、

CLOCK_PROCESS_CPUTIME_ID、

CLOCK_THREAD_CPUTIME_ID

int

int

void

unsigned

char

struct

cmsghdr

unsigned

int



| 返回值：若成功,                                 | 返回0: | 若出错i  | 返回-1 |        |
| ----------------------------------------------- | ------ | -------- | ------ | ------ |
| dose (int fd};<unistd.h>返回值：若成功，        | 返回0: | 若出错， | 返回-1 | p. 66  |
| closedir(DIR *dp};<dirent.h>返回值：若成功，    | 返回0: | 若出错， | 返回-1 | p. 130 |
| closalog(void);<syslog.h>                       |        |          |        | p. 470 |
| *CHSG_DATA. (struct cmsghdr *cp);<sys/socket,h> |        |          | p. 645 |        |

返回值：一个指针，指向与cmsghdr结构相关联的数据



*CMSG_PIRSTHDR(struct msghdr *mp｝；

<sys/socket.h>    p. 645

返回值：一个指针I指向与msghdr结构相关联的第一个cmsghdr结构；若_

无这样的结构，返回NULL    [848]

CMS6_XiEH (unsigned int nbytes};

<sys/socket.h>    p. 645

返回值：为《知/«长的数据对象分配的长度

struct

cmsghdr



*CMSGJHXTHDR(struct msghdr *mp, struct cmsghdr *cp);



<sys/socket.h>    p. 645

返回值：一4•指针，指向与msghdr结构相关联的下f"msghdr结构，该msghdr

结构给出了当前的cmsghdr结构；若当前cmsghdr结构已是最后一 个，返回NULL

int



connect (int sock'd, const struct sockaddr *addr, socklen_t ten}；

<sys/socket.h>    p. 605

返回值：若成功.返回0;若出错，返回-1

int



exeat (const char *path, mode_t mode);

<fcntl. h>    p. 66

mode： S_IS [UG] ID. S_ISVTX、

S_I[RWX](USRIGRPIOTH)

返回值：若成功，返回为只写打开的文件描述符：若出错，返回-1

char



\* ctazmid {cha r *ptr};

<stdio.h>    p. 694

返回值：若成功，返回指向控制终端名的指针；若出错，返回指向空字符串的

指针

int



知rint£(int fd, const char ^restrict format, ...); <stdio.h>

返回值：若成功，返回输出字符数：若输出出错，返回负值



int



<unistd.h>

返回值：若成功，返回新的文件描述符：若出错，返回-1



int



void



void

画

void



void

void

void



void



dup2(int fd, int fd2);

<unistd.h>

返回值：若成功，返回新的文件描述符：若出错，返回-1

«ndgr«nt(void);

<grp.h>

endhostent(void);

<netdb-h>

endnatant(void);

<netdb.h>

andprotoant(void);

<netdb.h>

en(^nr«nt(void);

<pwd.h>

«ndsecrent(void)；

<netdb.h>

andspant(void);

<shadow.h>

平台：Linux 3.2.0、Solaris 10



int



int



int



axacl (const char ’path, const char ^argO, <unistd.h>

返回值，若出错，返回H:若成功，不返回

exacle(const char *path, const char *arg0,…' char *const emp[] */ );

<unistd.h>

返回值：若出错，返回-1:若成功，不返回 execlp (const char * filename, const char *arg0,..

/* (char *) 0 */ J;



/* (char *) 0 */ );



(char *) 0,



p. 159

p. 79

p.79

p. 183

p. 597

p. 598

p.598

p. 180

p. 599

p. 182

p. 249

p.249



<unistd.h>

p. 249



int



返回值：若出错，返回-1;若成功，不返回 oxecv (const char *path, char *const argv []);

p. 249



<unistd.h>

返回值：若出错，返回-1:若成功，不返回

int



execve (const char *path, char * const argv [], char * const envp []);

p. 249



<unistd.h>

返回值：若出错，返回-h若成功，不返回

int



execvp (const char * filename, char * const argv []); <unistd.h>

p. 249



返回值：若出错，返回-1;若成功，不返回

void



_Exit (int status);

p. 198



<stdlib.h>

这个函数从不返回

void



■exit(int status};

p. 198

f850l



<unistd.h>

这个函数从不返回

void



exit (int status);

p. 198



<stdlib.h>

这个函数从不返回

int



faccassat (int fd, const char *path, int mode, int flag); <unistd.h>

p. 102



mode-. R_OK, W_OK、X_OK, F_OK flag-. AT_EACCESS

int



返回值：若成功，返回0:若出错，返回-I fchdxr(int fd);

p. 135



<unistd.h>

返回值：若成功.返回0:若出错，返回-1

int



fchnodfint fd, rnode_t mode、；

p. 106



<sys/stat.h>

mode-. S_IS[UG]ID> S_ISVTX、

S_I[RWX](USR|GRP|OTH)

返回值：若成功，返回0;若出错，返回-1

int



fchmodat (int fd, const char *path, mode_t mode, int flag}; <sys/stat.h>

p. 106



mode: S_IS[UG]ID, S_ISVTX,

S_I[RWXJ (USR|GRP|OTH)

flag\ AT_SYMLINK_NOFOLLOW 返回值：若成功，返回0:若出错，返回-1

int



fchovm (int fd, uid_t owner, gid_t group)；

p. 109



<unistd.h>

int



返回值：若成功，返回0;若出错，返回-1 fchownah (int fd, const char *path, uid_t owner,

gid_tgroup, int flag};

p. 109



<unistd.h>

flag: AT_SYMLINK_NOFOLLOW 返回值：_若成功，i回o;若出错，返回-i

int

画

int



fclosa(FILE *加；

<stdio.h>

返回值：若成功，返回(h若出错，返回EOF fcntl (int fd, int cmd, ... /* int arg */ );

<fcntl.h>

cmd: F_DUPFD、F_DUPFD_CLOEXEC, F_GETFD,



p. 150



p. 82



int



F_SETFD、 F_GETFL、 F_SETFL、 F_GETOWN、



F_SETOWN、 F_GETLK、 F_SETLK, F_SETLKW 返回值：若成功，依▲于cmrf:    出错，返回-1



fdatasync (int fd}；

<unistd.h>

返回值：若成功，返回0:若出错.返回-1 平台：Linux 3.2.0^ Solaris 10



p. 81



void

int

FILE

DIR

void

void

int

int

int

int

int

int

char



ro_CLR(int fd, fd_set *fdset);

<sys/select. h>    p. 503

Il>_ISSBT(int fd, fd_set *fdset);

<sys/select.h>    p. 503

返回值：若片在描述符集中，返回非0值：否则，返回0

*fdopan(int fd, const char ^type);

<stdio.h>    p-148

type-, "r"、"w", "a'\ "r+"、"w+"、"a+"

返回值：若成功，返回文件指针：若出错，返回NULL

*fdopandxx (int fd};

< dirent. h>    p. 130

返回值：若成功，返回指针：若出错，返回NULL

ro_SBT {int fd, fd_set *fdset};

<sys/select .h>    p. 503

FD_2ERO (f d_set *fdset);

<sys/select .h>    p. 503

fOOf (FILE *Jp];

<stdio. h>    p. 151

返回值：若到达流的文件尾端，返回非0 (真)：否则，返回0 (假)

forror(FILE *jp);

<stdio.h>    p. 151

返回值：若流出错，返回非0 (真)：否则，返回0 (假)

fexecvafint fd, char * const argv[], char * const envp []);

<unistd.h>    P- 249

返回值：若出错，返回-h若成功，不返回值    [852]

fflush(FILE *Jp);

<stdio.h>    p. 147

返回值，若成功，返回0:若出错，返回EOF

fgete(FILE *#);

<stdio.h>    P. 150

返回值：若成功，返回下一个字符：若已到达文件尾端或出错，返回EOF

fgo^poa (FILE *restrict jp, fpos_t *restrict pos}；

<stdio.h>    p. 158

返回值：若成功，返回0;若出错，返回非0

*fgats (char * restrict buf, int n, FILE ^restrict 加；

int

void

FILE

FILE

pid_t

long



int

int

int

size_t

void

void

FILE



<stdio.h>

返回值：若成功，返回若已到达文件尾端或出错，返回NULL

fxleno (FILE *Jp};

<stdio.h>

返回值：与该流相关联的文件描述符：若出错，返回-I

flockfilo{FILE *jJ?);

<stdio.h>

*fmemopen (void * restrict buf, size_t size, const char * restrict type);

<stdio.h>

type-. "r'\ "w'\ "a"、"r+"、"w+'\ "a+"

返回值：若成功，返回流指针；若错误，返回NULL

*fopen (const char * restrict path, const char *restrict type); <stdio.h>

type-, "r"、"w"、"a"、"r+"、"w+"、"a+"

返回值：若成功，返回文件指针；若出错，返回NULL

fork(void);



<unistd.h>

p. 152



p. 164



p. 443



p. 171



p. 148



p. 229



返回值：若在子进程中，返回0:若在父进程中，返回子进程ID;若出错，返回-1

p. 42



fpathconf (int fd, int name、；

<unistd.h>

name： _PC_ASYNC_IO、_PC_CHOWN_RESTRICTED、 _PC_FILESIZEBITS、 _PC_LINK_MAX、 _PC_MAX_CANON> _PC_MAX_INPUT,

_PC_NAME_MAX、 _PC_NO_TRUNC、 _PC_PATH_MAX， _PC_PIPE_BUF, _PC„PRIO_IO, _PC_SYMLINK_MAX. _PC_SYNC_IO、 _PC_TIMESTAMP_RESOLUTION、 _PC_2_SYMLINKS、_PC_VDISABLE

返回值：若成返回相应i: i出错，返回-1

fprintf(FILE *restrict Jp, const char *restrict format,...);

<stdio.h>

返回值：若成功，返回输出字符数：若输出出错，返回负值

fputc(int c, FILE ;

<stdio.h>

返回值：若成功，返回c;若出错，返回EOF

fputs (const char ^restrict str, FILE ^restrict Jp);

<stdio.h>

返回值：若成功，返回非负值；若出错，返回EOF fcead(void ^restrict ptr, size_t size, size_t nobj,

FILE *restrict Jp);

<stdio.h>

返回值：读的对象数

p. 159

p. 152

p. 153

p. 156

p. 207

p. 599



free (void *ptr);

<stdlib.h>

fcaeaddrxnfo(struct addrinfo *ai);

<sys/socket.h>

<netdb.h>

*fraopen (const char *restrict path, const char * restrict 蜘,FILE ^restrict 矛)； <stdio.h>    p. 148

type-, "r"、"w"、"a"、"r+"、，，w+"、"a+"

返回值：若成功，返回文件指针：若出错，返回NULL

|      | int   | fseanf (FILE * restrict jp, const char *restrict format, ...);<stdio.h>    p. 162返回值：赋值的输入项数：剖I入出错或在任—转换前己到达文件尾端，返回EOF |               |        |
| ---- | ----- | ------------------------------------------------------------ | ------------- | ------ |
|      | int   | fseek (FILE *jp, long offset, int whence);<stdio.h>■whence-. SEEK_SET、SEEK_CUR、SEEK_END 返回值：若成&，返回o: i出错，返回-1 |               | p. 158 |
| 函   | int   | faeafco (FILE    off_t offset, int whence};<stdio.h>whence^ SEEK_SET、SEEK_CUR、SEEK_END 返回值：若成返回o; €出错，返回-1 |               | p. 158 |
|      | int   | fsetpos (FILE *Jp, const fpos_t *pos);<stdio.h>返回值：若成功，返回0:若出错，返回非0 |               | p. 158 |
|      | int   | fstat(int fd, struct stat *buf};<sys/stat.h>返回值：若成功，返回0;若出错，返回非-1 |               | p, 93  |
|      | int   | £statat(int fd, const char * restrict path,struct stat * restrict bttf, int flag、；<sys/stat.h>flag'. AT_S YMLI NK_NO FOLLOW返回值：若成功：ii回o:若出错，返回-1 |               | p.93   |
|      | int   | fsync(int fd);<unistd.h>返回值，若成功，返回0;若出错则返回-1 |               | p. 81  |
|      | long  | ftoll (FILE    ;<stdio.h>返回值：若成功，返回当前文件位置指示器；若出错， | 返回-IL       | p. 158 |
|      | off_t | ftello(FILE *加；<stdio.h>返回值：若成功，返回当前文件位置指示器：若出错， | 返回(off_t)-l | p. 158 |
|      | key_t | ftokfconst char ^path, int id);<sys/ipc.h>返回值：若成功，返回键：若出错，返回(key_U-l |               | p.557  |
|      | int   | ftruncate (int fd, off_t length};<unistd.h>返回值：若成功，返回0;若出错，返回-1 |               | p+112  |
|      | int   | ftzrylockfila (FILE    ;<stdio.h>返回值：若成功，返回0;若不能获取锁，返回非0数值 | p. 443        |        |
|      | void  | funlockfile{FILE    ;<stdio.h>                               |               | p. 443 |
| 画   | int   | futinens (int fd, const struct timespec times [2 ]); <sys/stat.h>返回值：若成功，返回0:若出错，返回-1 |               | p+126  |
|      | int   | f*ide(FILE 吻,int mode);                                     |               |        |

size_t



const

char



int



<stdio.h>    p. 144

<wchar.h>

返回值：若流是宽定向的，返回正值：若流是字节定向的，返回负值；若流是 未定向的，返回0

fwrite (const void [1](#bookmark5) restrict ptr, size_t size, size_t nobj,

FILE [1](#bookmark5)restrict fp};

<stdio.h>    p. 156

返回值：写的对象数

*gai_strerror (int error);

<netdb.h>    p. 600

返回值：指向描述错误的字符串的指针

gataddci-nfo (const char [1](#bookmark5)restrict host, const char [1](#bookmark5) restrict service, const struct addrinfo [1](#bookmark5) restrict hint, struct addrinfo “restrict res);

<sys/socket.h>    p. 599

<netdb.h>

返回值：若成功，返回0;若出错，返回非0错误码

int



int



int



int



char



gid_t



char



uid_t



gid_t



gate(FILE [1](#bookmark5)#)；

<stdio.h>    p-150

返回值：若成功，返回下一个字符；若已到达文件尾端或出错，返回EOF

gatchaz- (void);

<stdio.h>    p. 150

返回值：若成功，返回下一个字符：若已到达文件尾端或出错，返回EOF

gatchac_unlockad(vaid);

<stdio.h>    p. 444

返回值：若成劫，返回下一个字符；若已到达文件尾或者出错，返回EOF

gatc_unloek«d (PILE [1](#bookmark5)Jp);

<stdio.h>    p. 444

返回值：若成功，返回下一个字符：若已到达文件尾或者出错，返回EOF

*getcwd(char [1](#bookmark5)6uf, size_t size、；

<unistd.h>    p. 136

返回值：若成功，返回/»«/;若出错，返回NULL

gategid(void);

<unistd. h>    p. 228

返回值：调用进程的有效组ID    [856]

*g«tenv(const char [1](#bookmark5)name};

<stdlib.h>    p. 210

返回值：指向与name关联的va/ue的指针：若未找到，返回NULL

gateuid(void);

<unistd.h>    p. 228

返回值：调用进程的有效用户ID

gotgid(void);

<unistd.h>    p- 228

返回值：调用进程的实际组ID



struct

group    * getgcgid (g i d_t gid);

<grp.h>

返回值，若成功，返回指针；若出错，返回NULL

struct

group    *getgEnan(const char *name);

<grp.h>

返回值：若成功，返固指针；若出错，返回NULL

int    gotgroups (int gidsetsize, gid_t grouplist []);

<unistd.h>

返回值：若成功，返回附属组ID数量；若出错，返回-1

struct

hostent    *gathostsiit(void);

<netdb.h>

返回值：若成功，返回指针；若出错，返回NULL

int    g«thostiiaiM (char *name, int itamelen);

<unistd.h>

返回值：若成功，返回0:若出错，返回-1 char    *getlog±n{void)；

<unistd.h>

返回值：若成功.返回指向登录名字符串的指针：若出错，

int    getnaneinfo(const struct sockaddr ^restrict addr,

socklen_t alen, char * restrict host, socklen_t hostlen, char *restrict service, socklen_t servlen, unsigned int flags);

<sys/socket.h>

<netdb.h>

flags-. NI_DGRAM, NI_NAMEREQD、NI_NOFQDN, NI_NUMERICHOST、 NI_NUMERICSCOPE, NI_NUMERICSERV

返回值：¥成功.返回0:若出错，返回非0值

struct

netent    *getnatbyaddr (uint32_t net, int type、；

<netdb.h>

返回值：若成功，返回指针；若出错，返回NULL

struct

netent    *gatnetbynama (const char *name);

<netdb.h>

返回值：若成功，返回指针；若出错，返回NULL

struct

netent    *getnstent(void);

<netdh.h>

返回值，若成功，返回指针：若出错，返回NULL int    getopt(int argc, char * const argv[], const char ★ options);

<fcntl.h>

extern int opterr, optind, optopt; extern char *optarg；

返回值：下一个选项字符：若所有选项被处理完I返回-1

int    getpaenuma (int soclrfd, struct sockaddr * restrict addr,

socklen_t *restrict al&p);

p. 182

p. 182

p. 184

p. 597

p. 188

p. 275

返回NULL

p. 600

p. 598

p. 598

p. 598

p. 662



pid_t



pid_t



pid_t



pid_t



int



<sys/socket.h>    p. 605

返回值：若成功，返回0:若出错，返回-1

getpgid (pid_t pid);

<unistd.h>    p. 294

返回值：若成功，返回进程组ID:若出错，返回-1

ge^grp(void);

<unistd.h>    p. 293

返回值：调用进程的进程组ID    阙

gat5>id(void);

<unistd.h>    p. 228

返回值：调用进程的进程ID

getq^pxd (void);

<unistd. h>    p. 228

返回值：调用进程的父进程ID

getprxozity (int which, id_t who);

<sys/resource. h>    p. 277



which: PRIO_PROCESS> PRIO_PGRP、PRIO_USER

返回值：若成功，返回-NZERO〜NZERO-1的nice值；若出错，返回-1



struct

protoent



*getpcotobyname (const char [2](#bookmark6)name);

<netdb.h>    p. 598

返回值：若成功，返回指针：若出错，返回NULL

struct

protoent



*getprotobynunbac (int proto};

<netdb.h>



返回值：若成功，返回指针；若出错，



返回NULL



p. 598



struct

protoent



^gat^Kotoent (void);

<netdb.h>



返回值：若成功，



返回指针；若出错，返回NULL



p. 598



struct

passwd



*got^wont(void);

<pwd. h>    p. 180

返回值：若成功，返回指针：若出错或到达文件尾端，返回NULL

struct

passwd



*gat^>wnaD (const char [2](#bookmark6)name};

<pwd. h>    p. 179

返回值：若成功，返回指针：若出错，返回NULL

struct

passwd



int



struct

group



char



struct

servent



struct

servent



struct

servent



pid_t



int



[860]



int



struct

spwd



struct

spwd



int



Mac OS X 10.6.8), RLIMIT_MSGQUEUE (Linux 3.2.0),

RLIMIT_NICE (Linux 3.2.0),

RLIMIT_NPROC (FreeBSD 8.0、Linux 3.2.0,

Mac OS X 10.6.8),

RLIMIT_NPTS (FreeBSD 8.0),

RLIMIT_RSS (FreeBSD 8.0、Linux 3.2.0、

Mac OS X 10.6.8),

RLIMIT_SBSIZE (FreeBSD 8.0), RLIMIT_SIGPENDING (Linux 3.2.0),

RLIMIT_SWAP (FreeBSD 8.0),

RLIMIT_VMEM (Solaris 10)

返回值：若成功，&回0:若出错，返回-1

★gets (char *buft ；

<stdio.h>

返回值：若成功，返回扣6若已到达文件尾端或出错，返回NULL



^gatservbynaaie(const char <netdb.h>



★name, const char * proto)；



返回值：若成功，返回指针:



若出错.返回NULL



*getsaxvbypo£t (int port, const char



<netdb.h>

返回值：若成功，返回指针:



★proto};

若出错，返回NULL



*getsozvent(void);

<netdb.h>

返回值：若成功I返回指针：若出错，返回NULL

gotoid(pid_t pid);

<unistd.h>

返回值：若成功I返回会话首进程的进程组ID:若出错，返回-1

getsockname(int sockfd, struct sockaddr *restrict addr, socklen_t * restrict alenp);

<sys/socket.h>

返回值：若成功，返回0:若出错，返回-]

getsoclcopt(int socifd, int level, int option, void ^restrict vat, socklen_t * restrict lenp);

<sys/socket.h>

返回值：若成功，返回0;若出错，返回-]



*getspen,fc (void);

<shadow.h>

返回值，若成功，返回指针：若出错，返回NULL 平台：Linux 3.2.0、Solaris 10



*gatspnam(const char *name)；

<shadow.h>

返回值：若成功I返回指针：若出错，返回NULL 平台：Linux 3.2.0, Solaris 10

gattimeofday (struct timeval ^restrict tp, void * restrict tzp};



p. 152

p. 599

p. 599

p. 599

p. 296

p. 605

p.624

p. 182

p. 182



uid_t



<sys/time.h>    p. 190

返回值：总是返回0

getuid(void);

<unistd.h>    p. 228

返回值：调用进程的实际用户ID



struct

tm



int



uint32_t



uintl6_t



*gat±Bie(const time_t *calptr)；

<time.h>    p. 192

返回值：指向分解的tm结构的指针：若出错，返回NULL

gran^>t(int fd);

<stdlib.h>    p. 723

返回值：若成功.返回0:若出错，返回-1

htonl (uint32_t hostint32};

<arpa/inet .h>    p. 594

返回值：以网络字节序表示的32位整数

htons (uintl6_t hostinllG))

<arpa/inet.h>    p. 594

返回值：以网络字节序表示的16位整数    [86E



const

char



int



int



int



int



int



int



int



int



*in«t_ntop{int domain, const void *restrict addr, char * restrict sir, socklen^t size);

<arpa/inet.h>    p. 596

返回值：若成勒，返回地址字符串指针i若出错，返回NULL

xn«t_pton (int domain, const char * restrict str, void *restrict addr)；

<arpa/inet.h>    p. 596

返回值：若成功，返回1:若格式无效，返回0:若出错，返回-1

initgzoiqis (const char * username, gid_t basegid}:

<grp.h> /* Linux & Solaris */    p. 184

<unistd.h> /* FreeBSD & Mac OS X */

返回值：若成功，返回0:若出错，返回-1 xoctl (int fd, int request,

<unistd.h> /* System V */    p. 87

<sys/ioctl.h> /* BSD and Linux */

返回值：若出错，返回-1;若成功，返回其他值

isatty (int fd);

<unistd.h>    p. 695

返回值：若为终端设备，返回1 (真)：否则，返回0 (假)

kill (pid_t pid, int signo);

<signal.h>    p. 337

返回值：若成功，返回0:若出错，返回-1

lohown (const char *path, uid_t owner, gid_t group);

<unistd.h>    p. 109

返回值：若成功.返回0:若出错，返回

link (const char *existingpath, const char *newpath);

<unistd.h>    p. 116

返回值，若成功，返回0:若出错，返回-1

linfcat{int efd, const char *existingpath, int const char ★newpath, int flog);



| 画   |          | <unistd.h>flag-. AT_SYMLINK_NOFOLLOW 返回值，若成功，返回0:若出错，返回-1 | p. 116 |
| ---- | -------- | ------------------------------------------------------------ | ------ |
|      | int      | (int mode, struct aiocb *restrict const "对[restrict], int nent, struct sigevent * restrict sigev)；<aio.h>mode： LIO_NOWAIT、LIO_WAIT 返回值：若功，返回0; i出错，返回-1 | p. 515 |
|      | int      | li囂ten (int sockfd, int backlog};<sys/socket.h>返回值：若成功，返回0:若出错，返回-1 | p. 608 |
|      | structtm | * local time (const time_t ^calptr);<time.h>返回值：指向分解的tm结构的指针：若出错，返回NULL | p. 192 |
|      | void     | longj呼(jmp_buf env, int val);<setjmp.h>这个函数不返回       | p.215  |
|      | off_t    | ls««fc (int fd, of f_t offset, int whence);<unistd.h>whence： SEEK_SET, SEEK_CUR、SEEK_END 返回值：若成返回新的i件偏移量：出错，返回-1 | p. 67  |
|      | int      | lstat( const char * restrict path, struct stat * restrict buf}; <sys/stat.h>返回值：若成功，返回0:若出错，返回-1 | p.93   |
|      | void     | *malloc(si2e_t size、；<stdlib.h>返回值：若成功，返回非空指针：若出错，返回NULL | p.207  |
|      | int      | afcdxr (const char *path, mode_t mode、；<sys/stat.h>mode； S_IS[UG]ID、S_ISVTX,S_I[RWX](USRIGRPIOTH)返回值：若成功，返回0:若出错t返回-1 | p. 129 |
| 闽   | int      | mkdirat (int fd, const char *path, mode_t mode、；<sys/stat.h>mode-. S_IS[UG]ID、S_ISVTX、S_I[RWX](USRIGRPIOTH)返回值：若成功，返回0:若出错，返回-I | p. 129 |
|      | char     | (char ’template、；<stdlib.h>返回值：若成功，返回指向目录名的指针：若出错，返回NULL | p. 169 |
|      | int      | nkfifo(const char *path, mode_t mode、t <sys/stat.h>mode-. S_IS[UG]ID、S_ISVTX、S_I[RWX](USRIGRPIOTH)返回值：若成功，返回0:若出错，返回-1 | p. 553 |
|      | int      | mkfifoat：(int fd, const char ★path, mode_t mode、；<sys/stat.h> | p.553  |

mode-. S_XS [OG] ID, S_ISVTX、 S_I[RWXJ (USRIGRPIOTH)

返回值：若成功，返回0:若出错，返回-1

int



mks tsooqp {char * template);

<stdlib.h>    p. 169

返回值：若成功，返回文件描述符：若出错，返回-1

nfctime (struct tm *tmptr)；

<time.h>    p, 192

返回值：若成功，返回日历时间：若出错，返回-1

void



*mmap (void *addr, size_t len, int prot, int flag, int fd, off_t off};

p. 276

[1](#footnote1)

gatgran1: (void);

<grp.h>    p. 183

返回值：若成功，返回指针：若出错或到达文件尾端，返回NULL

[2](#footnote2)

gatpwuid (u id_ t uid};

<pwd. h>    p. 179 _

返回值：若成功，返回指针；若出错，返回NULL    [859]

getrlimittint resource, struct rlimit [2](#bookmark6)rlptr};

<sys/resource. h>    p. 220

resource； RLIMIT_CORE, RLIMXT_CPU,

RLIMIT_DATA, RLIMIT_FSIZE,

RLIMIT_NOFILE, RLIMIT_STACK,

RLIMIT_AS (FreeBSD 8.0、Linux 3.2.0、

Solaris 10),

RLIMIT_MEMLOCK (FreeBSD 8.0、Linux 3.2.0、


<sys/mman.h>    p. 525

proh PROT_READ、 PROT_WRITE、 PROT_EXEC、 PROT_NONE flag-. MAP_FIXED、MAP_SHARED, MAP_PRIVATE

返回值：成功，返回f射区的起始地若出错，返回MAP_FAILED

int



int



int



ssize_t



int



int



int



■)9>£otect (void *addr, size_t len, int prot)!

<sys/mman.h>

返回值：若成功.返回(h若出错，返回-1 msgctl (int msqid, int cmd, struct msqid_ds *buf};

<sys/msg.b>

cmd-. IPC_STAT, IPC_SET, IPC_RMID 返回值：i成功，返回0*若出错，返回-1

msgget (key_t key, int flag、；

<sys/msg.h>

flag-. IPC_CREAT、IPC_EXCL 返回值：i成功，返回消~息队列ID:若出错，返回-1

msgrcv(int msqid, void *ptr, size_t nbytes, long type, int flag); <sys/msg.h>

flag-. IPC_NOWAIT、MSG_NOERROR 返回值：i成功.返回消i数据部分的长度；若出错.返回-1

magsnd(int msqid, const void *ptr, size_t nbytes, int flag); <sys/msg.h> flag-. IPC_NOWAIT

返回值：i成功，返回0:若出错，返回-1

msync (void *addr, size_t len, int flags);

<sys/mman.h>

flag-. MS_ASYNC、HS_INVALIDATE. MS_SYNC 返回值：_若成功，返€o:若出错，返回-I

munmap (void *addr, size_t len);

<sys/mman.h>

返回值：若成功，返回0;若出错，返回-1



p. 527



p. 562



p. 562



p. 564



p. 563



p. 528



p. 528



int



nanoslaep(const struct timespec *reqtp, struct timespec *remtp);

p.374



<time.h>

返回值：若休眠够要求的时间，返回0:若出错，返回-1

int



nice (int incr);



<unistd.h>

返回值：若成功，返回新的nice值减掉nzero:若出错，返回-1

uint32_t



ntohl {uint32_t netint32、；

<arpa/inet.h>    p. 594

返回值：以主机字节序表示的32位整数

uintl6_t    ntohs (uint!6_t netintl6);

<arpa/inet.h>

返回值：以主机字节序表示的16位整数

int    cqpea(const char *path, int ofiag, — /* mode_t mode */ );

<fcntl.h>

oflagt O_RDONLY、 O_WRONLY、 O_RDWR、 O_EXEC、

O_SEARCH;

O_APPEND, O_CLOEXEC、 O_CREAT.

O_DIRECTOBY、 O_DSYNC、 O_EXCL、

O_NOCTTY、 O_NOFOLLOW、 O_NONBLOCK、

O_RSYNC、 O_SYNC、 O_TRUNC, O_TTY_INIT

mode： S_IS[UG]ID、S_ISVTX、

S_I[RWX](USRIGRPIOTH)

返回值： >成功，返回文件描述符；若出错，返回-1 平台：在FreeBSD 8.0和Mac OS X 10.6.8中还有一个O.FSYNC标志

int    c^tena-b(int fd, const char *path, int oflag, ...

/* mode_t mode */ )；

<fcntl.h>

ojlagi O_RDONLY、O_WRONLY、O_RDWR、O_EXEC、

O_SEARCH;

CLAPPEND、 O_CLOEXEC、 O_CREAT、

O_DIRECTORY、 O_DSYNC、 O_EXCL、

O_NOCTTY、 0_NOFOLLOW, 0_NONBLOCK,

O_RSYNC、 O_SYNC、 O_TRUNC、 O_TTY_INIT

mode-. S_IS[UG]ID、S_ISVTX、

S_I[RWX](USR|GRP|OTH)

返回值：成功，返回文件描述符：若出错，返回-1 平台：在FreeBSD 8.0和Mac OS X 10.6.8中还有一个O.FSYNC标志

DIR    *opandic {const char *path);

<dirent.h>

返回值：若成功，返回指针：若出错，返回NULL

void    openlog (const char *ident, int option, int facility);

<syslog.h>

option-. LOG_CONS、LOG_NDELAY、LOG_NOWAIT、

LOGJDDELAY、 LOG_PERROR， LOG_PID

facility. LOG_AUTH、LOG_AUTHPRIV, LOG_CRON、

LOG_DAEMON、 LOG_FTP、 LOG_KERN、

LOG_LOCAL[0-7]、 LOG_LPR, LOG_MAIL.

LOG_NEWS、 LOG_SYSLOG、 LOG_USER, LOG_UUCP

FILE    *c^sn_manstceon(char **bufp, size_t *sizep);

<stdio.h>

返回值：若成功，返回流指针：若出错，返回NULL

FILE    *呼助_waMaBtr«aai(wchar_t **bufp, size_t *sizep);

<wchar.h>

返回值：若成功，返回流指针；若出错，返回NULL

long    psthconf (const char *path, int name}；

<unistd.h>

name: _PC_ASYNC_IO, _PC_CHOWN_RESTRICTED, _PC_FILESIZEBITS, _PC_LINK_MAX、

_PC_MAX_CANON、 _PC_MAX_INPUT,

_PC_NAME_MAX、 _PC_NO_TRUNC、 _PC_PATH_MAX、 _PC_PIPE_BUF> _PC_PRIO_IO、 _PC_SYMLINK_MAJG

p. 594

p. 62



p. 62



p. 130

p. 470

p. 173

p. 173

p.42



_PC_SYNC_IO、_PC_TIMESTAMP_RESOLUTION, _PC_2_SYMLINKS、_PC_VDISABLE

返回值：若成功，返回相应值；若出错，返回-1



int

int

void

int

int

FILE

int

ssize_t

int

int

void

void

int



pause(void)；

<unistd.h>    p. 338

返回值：-1，errno 设置为 EINTR    18661

pclosa (FILE ;

<stdio.h>    p. 541

返回值：若成功，返回popen函数中的终止状态；若出错，返回-I

perror (const char *msg);

<stdio.h>    p. 15

pipe (int fd[2]}

<unistd.h>    p. 535

返回值：若成功，返回0:若出错，返回-1

poll (struct pollfd fdarrayl ], nfds_t nfds, int timeout);

<poll.h>    p. 506

返回值：准备就绪的描述符数：若超时，返回0:若出错，返回-1

★popen(const char *cmdstring, const char *type);

<stdio.h>    p. 541



type-, "r", "w"

返回值，若成功，返回文件指针：若出错，返回NULL poaix_openpt (int oflag);

<stdlib.h>    p. 722

<fcntl.h>

oflag： O_RWDR、O_NOCTTY

返回值：成功，回下一个可用的PTY主设备文件描述符：若出错，返回-1

praad(int fd, void *buf, size_t nbytes, of f_t offset};

<unistd.h>    p. 78

返回值：读到的字节数；若已到达文件尾端，返回0;若出错，返回-1



printf (const char * restrict format,

<stdio.h>

返回值：若成功，返回输出字符数：若输出出错，返回负值

psalect(int maxfdpl, fd_set ’restrict readfds,

fd_set * restrict writefds, fd_set ^restrict exceptfds, const struct timespec *reatrict tsptr,

const sigset_t * restrict si^nask);

<sys/select.h>

返回值：准备就绪的描述符数：若超时，返回0:若出错，返回-1 paxginfo(const siginfo_t ^info, const char *msg);

<signal.h>

psxgnal (int sign。, const char *msg、；

<signal.h>

<siginfo.h> /* on Solaris */

ptJixaad_at£ork(void {*prepare) (void), void {^parerti} (void), void {*chUd) (void));

<pthread.h>

返回值：若成功，返回0:否则，返回错误编号 pthraad_attr_destroy (pthread_attr_t *attr}；

<pthread.h>



p. 159



p. 506



p.379 18671



p.379



p. 427



int



int



int



int



int



int



|868j



int



int



int



int



int



返回值：若成功，返回0:否则，返回错误编号 pthraad_attx_gatdatachsfcate (const pthread_attr_t *attrf

int *detachsiate);

<pthread.h>

返回值：若成功，返回0:否则，返回错误编号 pthread attr qratquaxdaige (const pthread_attr_t

★restrict attr, size_t *restrict guardsize);

<pthread.h>

返回值：若成功，返回0:否则，返回错误编号 pthread_at;tc_getatack (const pthread_attr_t ^restrict attr,

void “restrict stackaddr, size_t *restrict stacksize);

<pthread.h>

返回值：若成功.返回0:否则，返回错误编号 pthreadnattr_gatstack8±Ee(const pthread_attr_t

\* restrict attr, size_t * restrict stacksize);

<pthread.h>

返回值，若成功，返回0;否则，返回错误编号

pthread.a^tr.init (pthread_attr_t *attr);

<pthread.h>

返回值，若成功，返回0;否则，返回错误编号

pthread_attr_sefcdet:achstate (pthread_attr_t *attr, int detachstate);

<pthread.h>

detachstate-. PTHREAD_CREATE_DETACHED、 PTHREAD_CREATE_JOINABLE

返回值：若成功，返回0:否则，返回错误编号

pthraad_abtr_setguacdsixe (pthread_attr_t *attr, size_t guardsize);

<pthread.h>

返回值：若成功，返回0;否则，返回错误编号

ptiiread_attr_setstack (const pthread_attr_t *aOr,

void ★stackackk, size_t *stadcsize};

<pthread.h>

返回值：若成功，返回0:否则*返回错误编号

pthread_at^r_setstacksxxe(pthread_attr_t ★attr, size_t stacksize};

<pthread.h>

返回值：若成功.返回0:否则，返回错误编号



p.428



p. 430



p. 429



p. 430



p. 427



p. 428



p. 430



p. 429



p. 430



pthread_barEa.erattx_dostroy (pthread_barrierattr_t *attr}; <pthread.h>

返回值：若成功，返回0:否则，返回错误编号

pthraad_ba£E±arattc^getpshared(const pthread_barrierattr_t * restrict attr,

int * restrict pshared、；

<pthread.h>

返回值：若成功.返回0:否则，返回错误编号 pthread_ba^riorattr_init (pthread_barrierattr_C *attr);



p.441



<pthread.h>    p. 441

返回值：若成功，返回0;否则，返回错误编号



int

int

int

int

int

Void

void

int

int

int

int

int



pthread_barriorattx_sotp8hared(pthread_barrierattr_t *attr, int pshared);

<pthread.h>    p. 441

pshared-. PTHREAD_PROCESS_PRIVATE,

PTHREAD_PROCESS_SHARED 返回值：若成功，ii回0;否则，返回错误编号

pthread_barri«r_dwtroy (pthread_barrier_t * barrier);

<pthread.h>    p. 418

返回值：若成功，返回0;否则，返回错误编号

pfchcead_barrier_±n±t (pthread_barrier_t * restrict barrier, constpthread_barrierattr_t

\* restrict attr, unsigned int count)；

<pthread.h>    p. 418

返回值：若成功，返回0:否则，返回错误编号

pthcead_barrier_wait (pthread_barrier_t *barrier);

<pthread.h>    p. 419

返回值：若成功，返回 0 或者 PTHREAD_BARRIER_SERIAL_THREAD:

否则，返回错误编号



pthcead-cancal (pthread_c tid};

<pthread.h>

返回值：若成功，返回0:否则，返回错误编号

pthzead_cleaniq>_pop (int execute);

<pthread.h>



pthread_daanup_push(void (*rfri) {void *) , void *arg): <pthread.h>

pthraad_condattr_d«stroy (pthread_condattr_t *attr); <pthread.h>

返回值：若成功，返回0;否则，返回错误编号



pthcead_condattx_getclock(const pthread_condattr_t ★restrict attr,

clockid_t ^restrict clocked};

<pthread.h>

返回值：若成功.返回0;否则.返回错误编号

pthraad-condattr-gatpshazed(const pthread_condattr_t ★restrict attr,

int *restrict pshared);

<pthread.h>

返回值，若成功，返回0;否则，返回错误编号 pthraad_condattr_init (pthread_condattr_t *attr)；

<pthread.h>

返回值：若成功，返回0:否则，返回错误编号

pthraad_condattr_setelock (pthread_condattr_t *attr, clockid_t clock_id);

<pthread.h>

返回值：若成功，返回0:否则，返回错误编号 pth£aad_conda-ttx_setpahazad (pthread_condattr_t *attr,



p. 393



p.394



p. 394



p. 440



p.441



p. 440



p. 440



187。|



int



int



int



int



int



int



int



int



int



void

画

void



int



int pshared};

<pthread.h>

pshared-. PTHREAD_PROCESS_PRIVATE、 PTHREAD_PROCESS_SHARED

返回值：若成功，ii回o:否则，返回错误编号 pthxaad_cond_broadcaat (pthread_cond_t *co«rf);

<pthread.h>

返回值：若成功，返回0:否则，返回错误编号

pthraad„aond._dastroy (pthread„cond_t *cond};

<pthread.h>

返回值：若成功，返回0:否则，返回错误编号

pthc«ad_eond_in±t (pthread_cond_t * restrict cond,

const pthread_condattr_t * restrict altr);

<pthread.h>

返回值：若成功.返回0;否则，返回错误编号

pthraad_cond_sxgnal (pthread_cond_t *cond);

<pthread.h>

返回值：若成功，返回0;否则，返回错误编号 pthread_eond_tiiBadwait： (pthread_cond_t *restrict cond,

pthread_rautex_t * restrict mutex, const struct timespec

★restrict timeout)；

<pthread.h>

返回值：若成功，返回0;否则，返回错误编号

pthread_cond_wait(pthread_cond_t * restrict cond,

pthread_mutex_t *restrict mutex);

<pthread.h>

返回值：若成功，返回0:否则，返回错误编号

pthzead_cca*t« (pthread_t *restrict tufyj,

const pthread_attr_t * restrict attr, void * (*start_rtn、{void *),

void *restrict arg}；

<pthread.h>

返回值，若成功，返回0:否则•返回错误编号

pthraad-detach (pthread_t tid);

<pthread.h>

返回值：若成功，返回0;否则，返回错误编号

pthraad_equal (pthread_t tidl, pthread_t tid2);

<pthread.h>

返回值：若相等，返回非0数值：否则，返回0

pth£aad_BX±t: (void *rval_ptr);

<pthread.h>

*pthcaad_getspac±fic (pthread_key„t key};

<pthread.h>

返回值：线程特定数据值；若没有值与该键关联，返回NULL

pthread_join (pthread_t thread, void **rval_ptr};

<pthread.h>

返回值：若成功，返回0;否则，返回错误编号 pthrsad_key_oraata (pthread_key_t *keyp,

p.440

p.415

p.414

p.414

p.415

p.414

p.414

p.385

p. 397

p. 385

p. 389

p. 449

p.389



int



int



int



int



int



int



int



int



int



int



void (* destructor) (void *)); <pthread.h>

返回值：若成功，返回0;吉则，返回错误编号 pthcead_kay_deleta (pthread_key_t key);

<pthread.h>

返回值，若成功,返回0:否则，返回错误编号 pthraad_kill (pthread_t thread, int signo);

<signal,h>

返回值：若成功，返回0:否则，返回错误编号 pthraad_mutaxattx_dastroy(pthread_mutexattr_t *attr);

<pthread.h>

返回值：若成功，返回0;否则，返回错误编号

pthxead_nutexattc_getgpahaced (const pthread_mutexattr_t ★restrict attr,

int ^restrict pshared};

<pthread.h>

返回值：若成功，返回0:否则，返回错误编号

pthreadunutaxattE_getrobu8t(const pthread_mutexattr_t * restrict attr,

int * restrict robust);

<pthread.h>

返回值：若成功，返回0:否则，返回错误编号 pthraad_mutaxat:to_gett:ype(const pthread_mutexattr_t

\* restrict attr, int * restrict type}；

<pthread.h>

返回值：若成功，返回0:否则，返回错误编号

pthread_autexattr_xn±t (pthread_mutexattr_t *a/tr);

<pthread.h>

返回值：若成功.返回0:否则.返回错误编号

pthxaad_mutft**tt£_satpshax«d (pthread_mutexattr_t *atlr, int pshared);

<pthread.h>

pshared： PTHREAD_PROCESS_PRIVATE. PTHREAD_PROCESS_SHARED

返回值，若成功，i回0:否则，返回错误编号 pthraad_aiutaxathr_aahr^ust {pthread_mutexattr_t *attr,

int robust);

<pthread.h>

robust-. PTHREAD_MUTEX_ROBUST、 PTHREAD_MUTEX_STALLED

返回值：若成功，返回0:否则，返回错误编号

pthrud_mutaxattx_sattypa (pthread_mutexattr_t *attr, int type};

<pthread.h>

type-. PTHREAD_MUTEX_NORMALx

PTHREAD_MUTEX_ERRORCHECK、 PTHREAD_MUTEX_RECURSIVE、 PTHREAD_MUTEX_DEFADLT

返回值：若成功，返回0:否则，返回错误编号 pthMad_aHitex_consistent(pthread_mutex_t * mutex、；

<pthread.h>

p. 447



p. 448



p. 455



p. 431



p.431



p. 432



p. 434



p.431



p.431



p. 432



p. 434



p. 433



返回值：若成功，返回0;否则，返回错误编号

|      | int  | pthcaad_mutax_destroy (pthread_mutex_t * mutex};<pthread.h>返回值：若成功，返回0:否则.返回错误编号 | p.400  |
| ---- | ---- | ------------------------------------------------------------ | ------ |
|      | int  | pthxead_aut«x_init (pthread_mutex_t ^restrict mutex,const pthread_mutexattr_t *restrict attr)；<pthread.h>返回值< 若成功，返回0:否则，返回错误编号 | p. 400 |
|      | int  | pthcaad_muteic_loclc (pthread_mutex_t * mutex);<pthread.h>返回值：若成功，返回0;否则，返回错误编号 | p. 400 |
|      | int  | pthreadjnutex_^iaedloek (pthread_mutex_t *restrict mutex,const struct time spec * restrict tsptr、；<pthread.h><time.h>返回值：若成功则，返回0:否则，返回错误编号 | p. 407 |
| 画   | int  | pthcflad_nmtax_1^rylock (pthread_mutex_t * mutex);<pthread.h>返回值：若成功，返回0:否则，返回错误编号 | p. 400 |
|      | int  | pthc«ad_mut«x_unlock (pthread_mutex_t * mutex};<pthread.h>返回值：若成功，返回0:否则，返回错误编号 | p. 400 |
|      | int  | pthraad_onca (pthread_once_t *initfiag, void    (void));<pthread.h>pthread_once_t initflag^ PTHREAD_ONCE_INIT;返回值：i成功，返回0:否则，返回错误编i | p. 448 |
|      | int  | pthraad_nrlockattr_dastcoy {pthread_rwlockattr_t    ;<pthread.h>返回值：若成功，返回否则，返回错误编号 | p. 439 |
|      | int  | pthcaad_nrlockattz;_g«tpshazed (const pthread_rwlockattr_t ★restrict attr,int * restrict pshared);<pthread.h>返回值：若成功.返回0;否则，返回错误编号 | p.440  |
|      | int  | pthre*d_rwlockattr_init (pthread_rwlockattr_t *attr、；<pthread.h>返回值：若成功，返回0;否则，返回错误编号 | p. 439 |
|      | int  | pthz«ad_cwlookattc_aetqpshaxad{pthread_rwlockattr_t *attr, int pshared);<pthread.h>pshared-. PTHREAD_PROCESS_PRIVATE. PTHREAD_PROCESS_SHARED返回值：若成功，i回0;否贝1返回错误编号 | p. 440 |
|      | int  | pthcead_rwlock_deatEoy <pthread_rwlock_t *rwlock}<pthread.h>返回值：若成功.返回0;否则，返回错误编号 | p. 409 |
|      | int  | pthcaad_xwlock_init(pthread_rwlock_t .restrict rwlock, const pthread_rwlockattr_t♦restrict attr); |        |

int



int



int



int



int



int



int



pthread_t



int



int



int



int



<pthread.h>    p, 409

返回值：若成功.返回0;否则，返回错误编号

pthraad_nrlock_rdloek (pthread_rwlock_t *rw/ocA);

<pthread.h>    p.410 _

返回值，若成功，返回0:否则，返回错误编号    [874]

pthEaad_rwlock_tijnadrdlock (pthread_rwlock_t ^restrict rwlock, const struct timespec

\* restrict tsptr);

<pthread.h>    p. 413

<time.h>

返回值：若成功，返回0:否则，返回错误编号

pthread_nrlock_tinedwrlocfc (pthread_rwlock_t *restrict rwlock, const struct timespec

♦restrict tsptr);

<p thread. h>    p.413

<time.h>

返回值：若成功，返回0:否则.返回错误编号

pthcead_rwlook_t£yrdlock (pthread_rwlock_t *rwlock);

<pthread.h>    p. 410

返回值：若成功，返回0:否则，返回错误编号

pthraad_rwlook_trywclock (pthread_rwlock_t *rwlock);

<pthread.h>    p. 410

返回值：若成功，返回0:否则.返回错误编号

pthr«ad_rwloek_unlock (pthread_rwlock_t *rwlock};

<pthread.h>    p.410

返回值：若成功，返回0:否则，返回错误编号

pthcaad_rwlock_w£lock (pthread_rwlock_t *rwlock);

<pthread.h>    p.410

返回值：若成功，返回(h否则，返回错误编号

pthxaad_Belf(void);

<pthread.h>    p. 385

返回值，调用线程的线程ID

pthxead_setcancalstate (int state, int *oldslate};

<pthread.h>    p. 451

slate-. PTHREAD_CANCEL_ENABLE、

PTHREAD_CANCEL_DISABLE 返回值：若成功，返回0:否则，返回错误编号

pthraad_se,bcancel'fcypa(int type, int *oldtype);

<pthread.h>    p. 453

type-. E»THREAD_CANCEL_DEFERRED、

PTHREAD_CANCEL_ASYNCHRONOUS    _

返回值：若成功，返回0;否则，返回错误编号    [^1

pthraad_setspeci£ic (pthread_key_t key, const void * value);

<pthread.h>    p. 449

返回值：若成功，返回0:否则，返回错误编号

ptJwead_sigBask (i nt how, const sigset_t * restrict set, sigset_t * restrict ase/);

<signal -h>    p. 454

how. SIG_BLOCK, SIG_UNBLOCK、SIG_SETMASK 返回值：¥成功，返回o;否则，返回错编号

|      | int     | pthrMd_spin_de»troy {pthread_spinlock_t ★lock);<pthread.h>返回值：若成功，返回0;否则，返回错误编号 | p.417          |
| ---- | ------- | ------------------------------------------------------------ | -------------- |
|      | int     | pthread_spin_init (pthread_spinlock_t *lock, int pshared)； <pthread.h>pshared-. PTHREAD_PROCESS_PRIVATE、 PTHREAD_PROCESS_SHARED返回值：若成功，i回o:否贝"i,返回错误编号 | p.417          |
|      | int     | pthread_spxn_lock (pthread_spinlock_t *lock);<pthread.h>返回值：若成功，返回0;否则，返回错误编号 | p.418          |
|      | int     | pthread_spin_tEylocfc {pthread_spinlock_t *lock};<pthread.h>返回值：若成功，返回0:否则，返回错误编号 | p.418          |
|      | int     | pthx：ead_apxn_unlock (pthread_spinlock_t ★lock');<pthread.h>返回值：若成功，返回0;否则.返回错误编号 | p.418          |
|      | void    | pthcaad_t«steancal(void);<pthread.h>                         | p. 453         |
|      | char    | *ptaname(int fd);<stdlib.h>返回值：若成功，返回指向PTY从设备名的指针：若出错, | p. 723返回NULL |
|      | int     | putc(int c, FILE *Jp);<stdio.h>返回值：若成功，返回q若出错，返回EOF | p. 152         |
| 画   | int     | putchar (int c);<stdio.h>返回值：若成功，返回c:若出错，返回EOF | p. 152         |
|      | int     | putchar_unlockad(int c);<stdio.h>返回值：若成功，返回c:若出错•返回EOF | p. 444         |
|      | int     | putC-unlockad (int c, FILE    ；<stdio.h>返回值：若成功，返回C:若出错，返回EOF | p. 444         |
|      | int     | putenv (char *str};<stdlib.h>返回值：若成功，返回0:若出错，返回非0 | p.212          |
|      | int     | puts (const char *s7r);<stdio.h>返回值：若成功，返回非负值；若出错•返回EOF | p. 153         |
|      | ssize_t | p»«rite(int fd, const void *buf, size_t nbytesr off_t offset); <unistd.h>返回值：若成功，返回已写的字节数：若出错，返回-1 | p. 78          |
|      | int     | raise (int signo};<signal.h>返回值：若成功，返回0:若出错，返回_1 | p. 337         |
|      | ssize_t | read (int fd, void *buf, size_t nbytes);<unistd.h>           | p.71           |

struct

dirent



ssize_t



ssize_t



ssize_t



void



ssize_t



ssize_t



ssize_t



返回值：读到的字节数：若已到达文件尾端，返回0:若出错，返回-1

*zeaddir (DIR *dp)；

<dirent.h>    p. 130

返回值：若成功，返回指针：若在目录尾或出错，返回NULL

raadl ink (const char * restrict path, char * restrict btrf, size_t birfsize};

<unistd.h>    p. 123

返回值：若成功，返回读取的字节数：若出错，返回-1

readlinfcat (int fd, const char* restrict path, char ^restrict buf, size_t bufsize);

<unistd.h>    p. 123

返回值：若成功，返回读取的字节数：若出错，返回-1

raadv (int fd, const struct iovec *iov, int iovcnt);

<sys/uio.h>    p.521 _

返回值：若成功，返回已读的字节数：若出错，返回-1    Bz3

\* realloc (void *ptr, size_t newsize);

<atdlib.h>    p.207

返回值：若成功，返回非空指针：若出错，返回NULL

recv<int soclrfd, void *buf, size_t nbytes, int flags、：

<sys/socket. h>    p. 612

flags-. MSG_PEEK, MSG_OOB, MSG_MAITALL,

MSG_CMSG_CLOEXEC (Linux 3.2.0),

MSG_DONTWAIT (FreeBSD 8.0、Linux 3.2.0、

Solaris 10),

MSG-ERRQUEUE (Linux 3.2.0),

MSG_TRUNC (Linux 3.2.0)

返回值：数b的字节长度：若无可用数据或对等方己经按序结束，返回0;

若出错，返回-1

recvfron(int sodrfd, void *restrict buf, size_t len, int flags, struct sockaddr *restrict addr, socklen_t * restrict addrlen);

<sys/socket.h>    p. 613

flags-. MSG_PEEK, MSG_OOB, MSG_WATTALL,

MSG_CMSG_CLOEXEC (Linux 3.2.0),

MSG_DONTWAIT (FreeBSD 8.0、Linux 3.2.0、

Solaris 10),

MSG_ERRQUEUE (Linux 3.2.0),

MSG_TRUNC (Linux 3.2.0)

返回值：数的宇节长度；若无可用数据或对等方已经按序结束，返回0:

若出错，返回-1

recvnsg(int socifd, struct msghdr *msg, int flags);

<sys/socket.h>    p.613

flags-. MSG_PEEK, MSG_OOB, MSG_MAITALL,

MSG_CMSG_CLOEXEC CLinux 3,2.0),

MSG_DONTWAIT (FreeBSD 8.0、Linux 3.2.0、

Solaris 10),

MSG_ERRQUEUE (Linux 3.2.0),

MSG_TRUNC (Linux 3.2.0)

返回值：数*b的字节长度：若无可用数据或对等方已经按序结束.返回0:

若出错，返回-1

|       | int  | reonova (const char ★path);<stdio.h>返回值：若成功，返回0;若出错.返回-1 | p. 119         |
| ----- | ---- | ------------------------------------------------------------ | -------------- |
| [878] | int  | rename (const char *oldname, const char *newname);<stdio.h>返回值：若成功，返回0:若出错，返回-1 | p. 119         |
|       | int  | cenameattint oldfd, const char *oldname, int newfd, const char *newname);<stdio.h>返回值：若成功f返回0;若出错，返回-1 | p. 119         |
|       | void | rewind(FILE *知)；<stdio.h>                                  | p. 158         |
|       | void | rewlnddir (DIR *dp);<dirent.h>                               | p. 130         |
|       | int  | nadir (const char *path};<unistd.h>返回值：若成功，返回0;若出错，返回-1 | p. 130         |
|       | int  | scanf (const char *restrict format, ...);<stdio.h>返回值：赋值的输入项数：若输入出错或在任一转换前已到达文件尾端, | p. 162 返回EOF |
|       | void | seekdic (DIR *dp, long loc);<dirent.h>                       | p. 130         |
|       | int  | select (int maxfdpl, fd_set ^restrict readfds,fd_set *restrict writefds, fd_set *restrict exceptfds, struct timeval ^restrict tvptr)；<sys/select.h>返回值：准备就绪的描述符数；若超时，返回0;若出错，返回-1 | p. 502         |
|       | int  | sem_closa(sem_t *sem);〈semaphore.h>返回值：若成功，返回0:若出错1返回-1 | p.580          |
|       | int  | semctl (int semid, int semnum, int cmd, .../* union semun arg */ )；<sys/seni.h>cmd: IPC_STAT、IPC_SET、IPC__RMID、GETPID、GETNCNT、 GETZCNT、 GETVAL、 SETVAL、GETALL、 SETALL返回值：(返回值取决于命令)：若出错，返回-1 | p. 567         |
| [^1   | int  | a«m_dastcoy {sem_t *sem、；〈semaphore.h>返回值：若成功.返回0:若出错1返回-1 | p. 582         |
|       | int  | semget<key_t key, int nsems, int flag、；<sys/sem.h>flag.. IPC_CREAT、IPC_EXCL 返回值：i成功.返回信号量若出错，返回-1 | p. 567         |
|       | int  | sem.ge'tvaXua (secn_t ^restrict sem, int * restrict valp、；〈semaphore.h>返回值：若成功，返回0:若出错，返回-1 | p.582          |
|       | int  | sffln_init (sem_t *sem, int pshared, unsigned int value};〈semaphore.h> | p. 582         |

int



返回值：若成功，返回0:若出错，返回_1 (int semid, struct sembuf semoparray[], size_t nops);

<sys/sem.h>    p. 568

返回值：若成功，返回0:若出错，返回-1

sem_t



*sem_apaD(const char *name, int ofiag, ... /* mode_t mode, unsigned int value */ );

〈semaphore. h>    p. 579

flag： IPC_CREAT、 IPC_EXCL

int



返回值：i成功，返回指_向信号量的指针：若出错，返回SEM_FAILED sen_post (sem_t *sem);

<semaphore.h>    p. 582

返回值：若成功，返回0:若出错.返回-1

int



aam.-timadwait(sem_t *restrict sem,

const struct timespec * restrict tsptr};

〈semaphore. h>    p. 581

<time.h>

int



返回值：若成乳返回0:若出错，返回-I aeB-trywait (sem_t *sem};

int



int



ssize_t



〈semaphore.h>    p. 581

返回值：若成功，返回0;若出错I返回-1

samjunlink(const char *name);

<semaphore.h>    p. 580

返回值：若成功，返回0:若出错，返回-1

sam_waxt (sem_t *sem);

<semaphore.h>    p. 581

返回值：若成功，返回0:若出错，返回-1    [880]

sand (int soclfd, const void *buf, size_t nbytes, int flags)；

<sys/socket .h>    p. 610



flags； MSG.EOR, MSG_OOB, MSG_NOSIGNAL,

MSG-CONFIRM (Linux3.2.0),

MSG^dontroute (FreeBSD 8.0、Linux 32.0、

Mac OS X 10,6.8、Solaris 10),

MSG_DONTWAIT (FreeBSD 8.0、Linux 3.2.0、

Mac OS X 10.6.8、Solaris 10),

MSG_EOF (FreeBSD 8.0、Mac OS X 10.6.8),

MSG_MORE (Linux 3.2.0)

返回值：若~成功，返回发送的字节数：若出错，返回-1

ssize_t



aendaiagfint sod^d, const struct maghdr *msg, int flags、；

<sys/socket. h>    p. 611

flags•• MSG_EO, MSG_OOB, MSG_NOSIGNAL,

MSG_CONFIRM (Linux 3.2.0),

MSG_DONTROUTE (FreeBSD8.0, Linux32.0, MacOSX 10.6.8、

Solaris 10),

MSG_DONTWAIT (FreeBSD 8.0x Linux 3.2.0> Mac OS X 10.6.8、

Solaris 10),

MSG_EOF (FreeBSD 8.0, Mac OS X 10.6.8),

MSG_MORE (Linux3.2.0)

ssize_t



返回值：若成功，返回发送字节数；若出错，返回-1 sendto (int sochfd, const void *buf, size_t nbytes, int flags,

const struct sockaddr *destaddr, socklen^t destlen)；

<sys/socket. h>    p. 610

void



int



int



圆

int



int



void



int



flags'. MSG_EOR, MSG_OOB, MSG_NOSIGNAL,

MSG_CONFIRM (Linux 3.2.0),

MSG_DONTROUTE(FreeBSD 8.0Linux 3.2.0、Mac OS X 10.6.8、Solaris 10), MSG_DONTWAIT(FreeBSD8.0、Linux3.2.0、MacOSX I0.6.8、Solaris 10),



MSG^EOF (FreeBSD 8.0^ Mac OS X 10.6.8〉，

MSG_MORE (Linux 3.2.0)

返回值：若_成功，返回发送的字节数：若出错，返回-I setbuf {FILE ^restrict fp, char * restrict buf};

<stdio.h>    p. 146

setegid (gid_t gid);

<unistd.h>    p. 258

返回值：若成功，返回0;若出错，返回-1

setenv{ const char * name, const char ★ value, int rewrite);

<stdlib.h>    p. 212

返回值：若成功，返回0;若出错，返回-1

aeteuid(uid_t uid};

<unistd.h>    p. 258

返回值：若成功，返回0:若出错I返回-1

setgid(gid_t gid);


<unistd.h>    p. 256

返回值：若成功，返回0:若出错，返回-1

setgcent(void);

<grp.h>    p. 183

setgroups (int ngroups, const gid_t grouplist []);

<grp.h> /* Linux */    p. 184

void



int



int



void

int



int



<unistd.h> /* FreeBSD, Mac OS X, and Solaris */



返回值：若成功，返回0;若出错，返回-1 sethostan-b(int stayopen};

<netdb.h>    p. 597

setj呼(jmp_t)uf env)；

<setjmp.h>    p. 215

返回值：若直接调用，返回0;若从longjmp返回I返回非0

setlogmask (int maskpri};

<syslog.h>    p. 470

返回值：前日志记录优先级屏蔽字值

setnetent (int stayopen);

<netdb.h>    p. 598

setpgxd (pid_t pid, pid_t pgid)；

<unistd.h>    p. 294

返回值：若成功，返回0:若出错，返回-1

set^prxoxx-ty (int which, id_t who, int value);

<sys/resource.h>    p. 277

which-. PRIO_PROCESS、PRIO_PGRP、PRXO_USER 返回值：若Z&功，返回0;若出“，返回-1

setprotoent(int stayopen);

<netdb.h>    p. 598

sa'fcpwent (void);

<pwd.h>



void



[8821



void



p. 180



int



int



int



void

pid_t



int



void



int



int



void



sefczegid(gid_t rgid, gid_t egid);

<unistd.h>    p. 257

返囲值：若成功，返回0;若出错，返回-1

satrauid (uid_t ruid, uid_t euid);

<unistd.h>    p. 257

返回值：若成功，返回0:若出错，返回H

satElind.t{int resource, const struct rlimit *rlptr);

<sys/resource.h>    p. 220

resource： RLIMIT_CORE, RLIMIT_CPU,

RLIMIT_DATA, RLIMIT_FSIZE,

RLIMIT_NOFILE、 RLIMIT_STACK,

RLIMIT_AS (FreeBSD 8.0、Linux 3.2.0、

Solaris 10) »

RLIMIT_MEMLOCK (FreeBSD 8.0、Linux 3.2.0>

Mac OS X 10.6.8),

RLIMIT_MSGQUEUE (Linux 3.2.0),

RLIMIT_NICE (Linux 3.2,0),

RLIMIT_NPROC (FreeBSD 8.0、Linux 3.2.0、

Mac OS X 10.6.8),

RLIMIT_NPTS (FreeBSD 8.0),

RLIMIT_RSS (FreeBSD 8.0、Linux 3.2.0、

Mac OS X 10.6.8),

RLIMIT_SBSIZE (FreeBSD 8.0),

RLIMIT_SIGPENDING (Linux 3.2.0),

RLIMIT_SWAP (FreeBSD 8.0), rlimit_vmem (Solaris 10)

返回值：若成功，i回0:若出错，返回-1 aehsacvent (int stayopen);

<netdb.h>    p. 599

setsid(void)；

<unistd.h>    p. 295

返回值：若成功，返回进程组ID:若出错，返回-1

setsockopt<int soclrfd, int level, int option, const void *va/,

socklen_t len)；

<sys/socket.h>    p. 624

返回值：若成功，返回0:若出错.返回-1

setapent(void);

〈shadow.h>    p. 182

平台：Linux 3.2.0、Solaris 10

satuid{uid_t uid);

<unistd.h>    p. 256

返回值：若成功，返回0:若出错，返回-1    [883]

satvbuf (FILE * restrict Jp, char *restrict ftwf, int mode, size_t size);

<stdio.h>    p. 146

mode-. _IOFBF、_IOLBF\ _IONBF 返回值：若成功，返回0: S出错，返回非0

*shmat (int shmid, const void *addr, int flag);

<sys/shm.h>    p. 574

flag-. SHM_RND、SHM_RDONLY



返回值：若成功，返回指向共享存傅段的指针；若出错，返回-1

| int  | shmetl{int shmid, int cmd, struct shmid_ds *buf};<sys/shm.h>cmd; IPC_STAT, IPC_SET, IPC_RMID,SHM_LOCK (Linux3.2.0, Solaris 10),SHM_UNLOCK (Linux3,2.0、Solaris 10)返回值：成功，返回0:若出错，返回-1 | p. 573 |
| ---- | ------------------------------------------------------------ | ------ |
| int  | shnd-t (const void *addr);<sys/shm.h>返回值：若成功，返回0;若出错，返回-1 | p. 574 |
| int  | shmgot (key_t key, size_t size, int flag、；<sys/shm.h>flag-. I PC CREAT、I PC EXCL返回值：S成功.返回负共孪存储ID;若出错，返回-1 | p.572  |
| int  | shutdown (int sock'd, int how)；<sys/socket.h>how-. SHUT RD、SHUT WR、SHUT RDWR 返回值：若&功，返回0;若出错.返回-1 | p. 592 |
| int  | 8ig2str (int signo, char *str);<signal.h>返回值：若成功，返回0:若出错，返回-1 平台：Solaris 10 | p.380  |
| int  | sigaction (int signo, const struct sigaction *restrict act,  |        |

struct sigaction * restrict oact};

|      | <signal.h>返回值：若成功，返回0;若出错，返回-1   | p.350  |
| ---- | ------------------------------------------------ | ------ |
| int  | sigaddsat (sigset_t *set, int j/gno) ?           |        |
|      | <signal.h>                                       | p. 344 |
|      | 返回值：若成功，返回0:若出错，返回-1             |        |
| int  | sigdelset (sigset_t *set, int signo);            |        |
|      | <signal.h>                                       | p. 344 |
|      | 返回值：若成功，返回0;若出错，返回-1             |        |
| int  | aigeoiptysat (sigset_t *je/);                    |        |
|      | <signal.h>                                       | p. 344 |
|      | 返回值：若成功，返回0:若出错，返回-1             |        |
| int  | sxgfillsat (sigset_t *set};                      |        |
|      | <signal.h>                                       | p.344  |
|      | 返回值：若成功，返回0:若出错，返回-1             |        |
| int  | sigismanibac(const sigset_t *set, int sign。、： |        |

<signal.h>    p. 344

返回值：若真，返回1:若假，返回0:若出错，返回-1

| void | slglongjn^ {sigjrap_buf env, int val);<setjmp.h>此函数不返回 | p. 356 |
| ---- | ------------------------------------------------------------ | ------ |
| void | (★signal (int sign。, void    (int))) (int);<signal-h>返回值：若成功，返回以前的信号处理配置：若出错，返回SIG_ERR | p. 323 |
| int  | sigpanding (s i gs e t_t *set、；〈signal.h>                 | p. 347 |

返回值：若成功，返回0;若出错，返回-I

int



int



int



int



int



sigpcocmask (int how, const sigset_t *restrict set, sigset_t ^restrict oset};

<signal.h>    p. 346

howt SIG_BLOCK. SIG_UNBLOCK、 SIG_SETMASK 返回值，若成功，返回0:若出错，返回H

sigqueue (pid_t pid, int sign。, const union sigval value)

<signal.h>    p. 376

返回值：若成功，返回0:若出错，返回-1

sigaatiiq>(sigjmp_buf env, int savemask);

<set jmp.h>    p. 356

返回值：若直接调用，返回0:若从siglongjmp调用返回，返回非0值 [885]

sigsuspand(const sigset„t *sigmask);

<signal.h>    p. 359

返回值：-1，errno设置为EINTR

sigwaxt (const sigset_t * restrict set, int * restrict signop、；

<signal.h>    p. 454

返回值：若成功，返回0:否则，返回错误编号



unsigned

int



int



int



int



int



int



int



int



int



sleep (unsigned int seconds、；

<unistd.h>    p. 373

返回值：0或未休眠的秒数

snprintf (char ^restrict buf, size„t n,

const char * restrict format, ...);

<stdio.h>    p. 159

返回值：若缓冲区足够大，返回存入数组的字符数：若编码出错，返回负值

sockatuark (int sock'd);

<sys/socket .h>    p. 626

返回值：若在标记处，返回I:若没在禄记处，返回0:若出错，返回-1

socket (int domain, int type, int protocol)；

<sys/socket ,h>    p. 590

type-. SOCK_STREAM, SOCK_DGRAM、SOCK_SEQPACKET

返回值：若&功，返回文件(套接字)描述?若出错，返回-1 soclce^pair (int domain, int type, int protocol, int sock'd[2 ]);

<sys/socket.h>    p. 630

type: SOCK_STREAM、SOCK_DGRAM、SOCK_SEQPACKET 返回值：若&功.返回0;若i错.返回-1

sprintf {char *restrict buf, const char * restrict format,...);

<stdio.h>    p. 159

返回值：若成功，返回存入数组的字符数；若编码出错，返回负值

sscanf (const char * restrict buf,

const char ^restrict format,...);

<stdio.h>    p. 162

返回值：赋值的输入项数：若输入出错或在任一转换前已到达文件尾端，返回EOF岡

shat (const char * restrict path, struct stat *restrict buf};

<sys/stat.h>    p. 93

返回值：若成功，返回0:若出错，返回-1

st£2aig(const char *str, int *s/gnop);

<signal.h>    p. 380

返回值：若成功.返回0:若出错.返回-1



|887|



平台：Solaris 10

char    *strarzoz (int ermum);

<string.h>

返回值：指向消息字符串的指针

size_t    ahrftime (char * restrict buf, size_t maxsixe,

const char *restrict format, const struct tm *restrict tmptr);

<time.h>

返回值：若有空间，返回存入数组的字狩数；否则，返回0 size_t    stz£time_l {char *restrict buf, size_t maxsize,

const char *restrict format,

const struct tm * restrict tmptr, locale_t locale}; <time.h>

返回值：若有空间，返回存入数组的字符数：否则，返回0

char    *strptiine (const char *restrict buf, const char * restrict format,

struct tm *restrict tmptr);

<time.h>

返回值：指向上次解析的字符的下一个字符的指针：否则，返回NULL

char    *strsignal (int signo);

<string.h>

返回值：说明该信号字符串的指针

int    symlink (const char *actualpath, const char *sympath、；

<unistd.h>

返回值：若成功，返回0;若出错，返回-1

int    symlinkat (const char *actualpath, int fd, const char *sympath);

<unistd.h>

返回值：若成功，返回0;若出错，返回H

void    sync(void);

<unistd.h>

long    sysconf (int name);

<unistd.h>

name-. _SC_ARG_MAX、_SC_ASYNCHRONOUS_IO、

_SC_ATEXIT_MAXx _SC_BARRIERS,

_SC_CHILD_MAX、 _SC_CLK_TCK、

_SC_CLOCK_SELECTION、 _SC_COLL_WEIGHTS_MAX, _SC_DELAYTIMER_MAX、 _SC_HOST_NAME_MAX、 _SC_IOV_MAX、 _SC_JOB_CONTROL、

_SC_LINE_MAX、 _SC_LOGIN_NAME_MAX、 _SC_MAPPED_FILED、 _SC_MEMORY_PROTECTION、 _SC_NGROUPS_MAX、 _SC_OPEN_MAX、

_SC_PAGESIZE、 _SC_PAGE_SIZE、 _SC_READER_WRITER_LOCKS、

_SC_REALTIME_SIGNALS、_SC_RE_DUP_MAX、 _SC_RTSIG_MAX、 _SC_SAVED_IDS、

_SC_SEMAPHORES, _SC_SEM_NSEMS_MAX、 _SC_SEM_VALUE_MAX、 _SC_SHELL、

_SC_SIGQUEUE_MAX, _SC_SPIN_LOCKS、 _SC_STREAM_MAX, _SC_SYMLOOP_MAX. _SC_THREAD_SAFE_FUNCTIONS、

_SC_THREADS、 _SC_TIMER_MAX、

_SC_TIMERS、 _SC_TTY_NAME_MAX、

p. 15

p. 192

p+192

p. 195

p.380

p+123

p. 123

p.81

p. 42



_SC_TZNAME_MAX、 _SC_VERSION、

_SC_XOPEN_CRYPT、 _SC_XOPEN_REALTIME， _SC_XOPEN_REALTIME_THREADS、 _SC_XOPEN_SHM _SC_XOPEN_VERSION

返回值：若&功，回相应值：若出错，返回-1

syslog (int priority, char * format,...);

<syslog.h>    p. 470

systws(const char *cmdstring);

<stdlib.h>    p. 265

返回值：shell的终端状态

tcdrain(int fd、；

<termios.h>    p. 693

返回值，若成功，返回0;若出错，返回-1

tcflow(int fd, int action};

<termios.h>    p.693

actiom TCOOFF、TCOON、TCIOFF、TCI ON 返回值：若成功，返回0:若出镑，返回-1

tcflush (int fd, int queue);



void

int

int

int

int

int

pid_t

pid 一 t

int

int

int

long

time_t

clock_t



<termios.h>    p. 693

queue： TCIFLUSH、TCOFLUSH、TCIOFLUSH

返回值：若成功，返回0;若出错，返回-1    [^1

tcgetettr (int fd, struct termios *termptr};

<termios.h>    p. 683

返回值：若成功，返回0:若出错I返回-1

tcgetpgcp (int fd);

<unistd.h>    p. 298

返固值：若成功f返回前台递程组ID:若出错，返回-1

tcgatsid(int fd):

<termios .h>    p. 299

返回值：若成功，返回会话首进程的进程组ID:若出错，返回-1

tcsendbraak {int fd, int duration、；

<termios .h>    p，693

返回值：若成功，返回0:若出错，返回-1

tcsetattr (int fd, int opt, const struct termios *termptr):

<termios.h>    p. 683

opt-. TCSANOW、TCSADRAIN、TCSAFLUSH

返回值：若成功，返回0:若出错，返回-1

tcse^grp(int fd, pid_t pgrpid);

<unistd.h>    p. 298

返回值，若成功，返回0:若出错.返回_1

telldiz(DIR *dp、；

<dirent.h>    p. 130

返回值：与却关联的目录中的当前位置

time    *calptr);

<time.h>    p. 189

返回值：若成功，返回时间值；若出错，返回-1

biaas (struct tms *6«/);

<sys/times.h>    P- 280

返回值：若成功，经过的墙上时钟吋间；若出错，返回-1

|         | FILE   | (void);<stdio.h>返回值：若成功，返回文件指针：若出错，返回NULL | p+167  |
| ------- | ------ | ------------------------------------------------------------ | ------ |
| [8891   | char   | *tn^nam{char ★ptr};<stdio.h>返回值：指向唯一路径名的指针：若出错，返回NULL | p, 167 |
|         | int    | truncate (const char *path, of f_t length)；<unistd.h>返回值，若成功，返回0:若出错，返画-1 | p. 112 |
|         | char   | *ttyname(int fd);<unistd.h>返回值：指向终端路径名的指针：若出错，返回NULL | p.695  |
|         | mode_t | umasfc (mode_t cmask);<sys/stat.h>返回值：之前的文件模式创建屏蔽字 | p. 104 |
|         | int    | uname( struct utsname ★name);<sys/utsname.h>返固值：若成功，返回非负值；若出错，返回-1 | p. 187 |
|         | int    | ungato(int c, FILE    ;<stdio.h>返回值：若成功，返回C;若出错，返回EOF | p. 151 |
|         | int    | unlink {const char *path);<unistd.h>返回值：若成功，返回0:若出错，返回-1 | p. 117 |
|         | int    | unlinkat(int fd, const char *path, int flag);<unistd.h> flag-. AT_REMOVEDIR 返回值：若成功，返回0:若出错，返回-1 | p. 117 |
|         | int    | unlockp-t (int fd);<stdlib.h>返回值：若成功，返固0:若出错，返回-1 | p. 723 |
|         | int    | unsetenv(const char *name);<stdlib.h>返回值：若成功，返回0;若出错f返回-1 | p.212  |
|         | int    | utlmensat (int fd, const char *path,const struct timespec times [2 ] , int flag};<sys/stat.h>flag-. AT SYMLINK NOFOLLOW返回值：若成功，i回0;若出错，返回-1 | p. 126 |
| \|890\| | int    | utimes {const char *path, const struct timeval times [ 2 ]); <sys/time.h>返回值：若成功，返回(h若出错，返回-1 | p. 127 |
|         | int    | vdprintf (int fd, const char * restrict format, va_list arg); <stdarg.h><stdio.h>返回值，若成功，返回输出字符数；若输出出错，返回负值 | p. 161 |
|         | int    | vfprintf (FILE *restrict fp, const char ^restrict format,    |        |

va_list arg);

<stdarg.h>    p. 161

<stdio.h>

int



返回值：若成功，返回输出字符数：若输出出错，返回负值 vfacanf (FILE *restrict Jp, const char * restrict formal, va_list arg);

<stdarg.h>    p. 163

<stdio.h>

int



返回值：指定的输入项目数：若输入出错或在任一转换前文件结束，返回EOF vprintf (const char * restrict format, va_list arg};

<stdarg.h>    p. 161

<stdio.h>

返回值：若成功，返回输出字符数：若输出出错.返回负值

int



Tacanf (const char * restrict format, va_list arg];

<stdarg.h>    p. 163

<stdio.h>

返回值：指定的输入项目数：若输入出错或在任一转换前文件结束，返回EOF

int



vsnprlntf (char * restrict buf, size_t n,

const char * restrict format, va_list arg};

<stdarg.h>    p. 161

<stdio.h>

返回值：若缓冲E足够大，返回存入数组的字符数：若编码出错，返回负值

int



vapcxntf (char * restrict buf, const char ^restrict format, va_list arg、；

<stdarg.h>    p. 161

<stdio.h>

返回值：若成功，返回存入数组的字符数：若编码出错，返回负值    岡

int



vsscanf (const char * restrict buf, const char * restrict format, va_list arg};

<stdarg.h>    p. 163

<stdio.h>

返回值：指定的输入项目数：若输入出错或在任一转换前文件结束，返回EOF

void



vsyslog(int priority, const char * format, va_list arg);

<syslog.h>    p. 472

<stdarg.h>

pid—t



平台：FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8, Solaris 10 irait(int *statloc);

<sys/wait .h>    p. 238

返回值：若成功，返回进程ID:若出错I返回0或-1

int



waitid (i dt ype_t idtype, id_t id, siginfo_t * infop, int options);

<sys/wait.h>    p. 244

idtype： P_PID、P_PGID、P_ALL

options-. WCONTINUED、WEXITED、WNOHANG、WNOWAIT、WSTOPPED 返回值：若成功，返回0;若出错，返回-1 平台：Linux 3.2.0, Solaris 10

pid_t



waitpid (pid_t pid, int *statloc, int options);

<sys/wait .h>    p. 238

options-. WCONTINUED、WNOHANG、WUNTRACED

返回值：若成功，返回进程ID:若出错.返回0或-1

pid_t



wait3(int *statloc, int options, struct rusage *rusage};

<sys/types. h>    p. 245

<sys/wait.h>

[8921



<sys/time.h>

<sys/resource.h>

options-. WNOHANG、WUNTRACED

返回值：若成功，返固进程ID:若出错，返回0或-1

平台：FreeBSD 8.0、Linux 3.2.0、Mac OS X 10.6.8、Solaris 10

pid_t    wait4 (pid_t pid, int *statloc, int options, struct rusage *rusage｝；

<sys/types.h>

<sys/wait.h>

<sys/time.h>

<sys/resource.h>

options-. WNOHANG、WUNTRACED

返回值：若成功，返回进程ID:若出错，返回0或-1

平台：FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8, Solaris 10

ssize_t    write (int fd, const void *buf, size_t nbytes);

<unistd.h>

返回值：若成功，返回已写的字节数；若出错，返回-1

ssize_t    wrxtav(int fd, const struct iovec *iov, int iovcnt);

<sys/uio.h>

返回值：若成功，返回己写的字节数；若出错，返回-1

p. 245

p. 72

p. 521



附录B

B.1本书使用的头文件

本书中的大多数程序都包含头文件apue.h,如图B-l所示。其中定义了常量（如MAXLINE） 和我们自编函数的原型。

大多数程序都需要包含下列头文件：＜stdio.h＞、＜stdlib.h＞ （其中有exit函数原型） （其中包含所有标准UNIX函数的原型），因此头文件apue.h自动包含了这些

系统头文件，同时还包含了＜String.h＞。这样就减少了本书中所有程序的长度。

\#if defined(MACOS) I I !defined(TIOCGWINSZ)



\#include <sys/ioctl.h> #endif

\#include <stdio.h>

\#include <stdlib.h> ♦include <stddef-h> #include <string.h> ♦include <unistd.h>

林include <signal.h>



/[1](#bookmark4) for convenience [1](#bookmark4)/ /[1](#bookmark4) for convenience [1](#bookmark4)/ /[1](#bookmark4) for offsetof [1](#bookmark4)/

/[1](#bookmark4) for convenience [1](#bookmark4)/ /[1](#bookmark4) for convenience [1](#bookmark4)/ /[1](#bookmark4) for SIG_ERR [1](#bookmark4)/



\* Default file access permissions for new files.

*Z

\#define FXLE_MODE (S_IRUSR I S_IWUSR | S_IRGRP | S_IROTH)

/*

Default permissions for new directories.

| #define | DIR_MODE | (FILE_MODE \| | S.IXUSR \| S_IXGRP \|     | 1 S^IXOTH) |
| ------- | -------- | ------------- | ------------------------- | ---------- |
| typedef | void     | Sigfunc(int); | /* for signal handlers */ |            |
| #define | min(a,b) | ((a) < (b) ?  | (a) : (b))                |            |
| #define | max(a,b) | ((a) > (b) ?  | (a) : (bj)                |            |

\* Prototypes for our own functions. */

| charlong | *path_alloc{aize_t *); open_max(void); | /* Figure 2.16 *//* Figure 2.17 */ |
| -------- | -------------------------------------- | ---------------------------------- |
| int      | set_cloexec(int};                      | /* Figure 13.9 */                  |
| void     | clr_f 1 (int, int"                     |                                    |
| void     | set_f1(int, int);                      | /* Figure 3.12 */                  |
| void     | pr_exit(int);                          | /* Figure 8.5 */                   |
| void     | pr_mask(const char *);                 | /* Figure 10.14 */                 |
| Sigfunc  | *signal_intr(int, Sigfunc *);          | /* Figure 10.19 */                 |
| void     | daemonize(const char *);               | /* Figure 13.1 */                  |
| void     | sleep_us{unsigned int);                | /* Exercise 14.5 */                |
| ssize_t  | readn(int, void *, size_t);            | /* Figure 14.24 */                 |
| ssize__t | writen(int, const void *, size_t);     | /* Figure 14.24 */                 |

| intint | fd_pipe(int *);recv_fd(int, ssize_t {*func)(int, | /* Figure                         | 17   | 2 *Z   |      |      |      |
| ------ | ------------------------------------------------ | --------------------------------- | ---- | ------ | ---- | ---- | ---- |
| 896\|  |                                                  | const void *, size_t));           | /*   | Figure | 17   | 14   | */   |
|        | int                                              | send_fd(int, int);                | /*   | Figure | 17   | 13   | *Z   |
|        | int                                              | send_err(int, int,                |      |        |      |      |      |
|        |                                                  | onst char *)；                    | /*   | Figure | 17   | 12   |      |
|        | int                                              | serv_listen(const char *);        | /*   | Figure | 17   | 8 *  | z    |
|        | int                                              | serv_accept(int, uid_t *);        | /*   | Figure | 17   | 9 *  | /    |
|        | int                                              | cli_conn《const char *);          | Z*   | Figure | 17   | 10   | */   |
|        | int                                              | buf_args(char *, int (*func)(int, |      |        |      |      |      |
|        |                                                  | char * *));                       | /*   | Figure | 17   | 23   | */   |
|        | int                                              | tty_cbreak(int);                  | /*   | Figure | 18   | 20   | */   |
|        | int                                              | tty_raw{int);                     | /*   | Figure | 18   | 20   | */   |
|        | int                                              | tty_reset(int);                   | /*   | Figure | 18   | 20   | */   |
|        | void                                             | tty_atexit(void);                 | /*   | Figure | 18   | 20   | */   |
|        | struct                                           | termios *tty_termios(void);       | /*   | Figure | 18   | 20   | */   |
|        | int                                              | ptym_open(char *, int};           | /*   | Figure | 19   | 9 *  | /    |
|        | int                                              | ptys_open (char ”；               | /*   | Figure | 19   | 9 *  | /    |

ttifdef TIOCGWINSZ

pid_t pty_fork(int *, char *, int, const struct termios *,

const struct winsize *)，-    /* Figure 19.10 */

\#define

\#define

\#define

\#define

\#define



\#endif read_lock(fd, offset, whence, len) \

int



lock_reg(int, int, int, off_t, int,    ; /*



Figure 14.5



lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))

readw_lock(fd, offset, whence, len) \

lock_reg{(fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))

write_lock(fd, offset, whence, len) \

lock_reg((fd), F—SETLK, F_WRLCK, (offset), (whence), (len))

writew_lock(fd, offset, whence, len) \

lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))

un_lock(fd, offset, whence, len) \

lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len)}

\#define

\#define



pid_t lock_test(int, int, off_t, int, off_t)； is_read_lockable(fd, offset, whence, len) \

/* Figure 14.6 */



(lock_test((fd), F_RDLCK, (offset), {whence), (len)) = 0)

is_write_lockable{fd, offset, whence, len) \

(lock_test((fd), F^WRLCK, (offset), (whence》， (len)) — 0)

| void   | err_msg{const char *,       |
| ------ | --------------------------- |
| void   | err_dump(const char *,...)  |
| void   | err_quit(const char *,...)  |
| void   | err_cont(int, const char *, |
| void   | err_exit(int, const char *, |
| void   | err_ret{const char *,       |
| void   | err_sys[const char *,       |
| void   | log_msg(const char *,...);  |
| void   | log_open(const char *, int, |
| void   | log_quit(const char *,...)  |
| void   | log_ret(const char *,       |
| void   | log_sys(const char *,...)   |
| void   | log_exit(int, const char *, |
| void   | TELL_WRIT(void);            |
| void   | TELL_PARENT(pid_t);         |
| void   | TELL_CHILD(pid_t);          |
| void   | WAIT_PARENT(void);          |
| void   | WAIT_CHILD(void);           |
| #endif | /* APUE H */                |



Z* Appendix B */

—attribute_((noreturn)); _attribute„( (noreturn));

■ ■ •) /

...)_attribute_((noreturn));

.attribute_((noreturn));

/* Appendix B */

int);

_attribute_((noreturn))，-

_attribute_((noreturn));

...)_attribute_((noreturn));

/* parent/child from Section 8.9 */



[897]



图B-l头文件apue.h

[1](#footnote1)

Our own header, to be included before all standard system headers.

*/

\#ifndef _APUE_H

\#define _APUE_H

\#define _POSIX_C_SOURCE 200809L

\#if defined(SOLARIS)    /[1](#bookmark4) Solaris 10 [1](#bookmark4)/

\#define _XOPEN_SOURCE 600

\#else

\#define _XOPEN_SOURCE 700

\#endif

\#include <sys/types.h>    /[1](#bookmark4) some systems still require this [1](#bookmark4)/

\#include <sys/stat.h>

ftinclude <sys/termios.h>    /[1](#bookmark4) for winsize [1](#bookmark4)/    函





程序中先包括apue.h,然后再包括一般系统头文件，这样就使我们易于做到下列各点：可 以先定义一些在此后包括的头文件可能要求的部分；能够控制头文件被包括的顺序；能够重定义 某些部分，而这正是为隐藏两个系统之间的差别而需要解决的。

B.2标准出错例程

我们提供了两套出错函数，用于本书中大多数实例以处理各种出错情况。一套以开头， 并向标准错误输出一条出错消息。另一套以log_开头，用于守护进程（见第13章），它们多半 没有控制终端。

之所以提供我们自己的出错函数，是为了能够编写只有一行C代码的出错处理程序，例如：

if （出错条件＞

err_dump《带任意参数的printf格式）；

这样就不再需要使用下列代码:

if （出错条件）1

char buf[200]；

sprintf {buf,带任意参数的printf格式＞ ; perror（buf）; abort ＜）;

}

我们的出错处理函数使用了 ISO C的变长参数表功能。其详细说明见Kemighan和 Ritchie[1988]的7.3节。应当注意的是，这个ISO C功能与早期系统（如SVR3和4.3BSD）提供

[8981的varargs功能不同。宏的名字相同，但更改了某些宏的参数。

图B-2列出了各个出错函数之间的区别，

| 函    数 | 从strerror添加字符串？ | strerror的参数 | 终止？      |
| -------- | ---------------------- | -------------- | ----------- |
| err_dump | 是                     | errno          | abort ();   |
| err_exit | 是                     | 显式参数       | exit ⑴；    |
| err_msg  | 否                     |                | return;     |
| err_quit | 否                     |                | exit(1);    |
| err_ret  | 是                     | errno          | return;     |
| err_sys  | 是                     | errno          | exit (1) '• |
| err cont | 是                     | 显式参数       | return;     |
| log_msg  | 否                     |                | return;     |
| log_quit | 否                     |                | exit(2);    |
| log_ret  | 是                     | errno          | return;     |
| log_sys  | 是                     | errno          | exit(2);    |
| log exit | 是                     | 显式参数       | exit(2);    |

图B-2标准出错函数

图B-3包括了输出至标准错误的各个出错函数。

\#include "apue.h"

\#include <errno.h>    /* for definition of errno */

\#include <stdarg.h>    /* ISO C variable aruments */

static void err_doit(int, int, const char *, va_list);

Nonfatal error related to a system call.

\* Print a message and return.

*/

void

err_ret(const char *fmt,...)

{

va_list    ap;

va_start(ap, Emt); err_doit(1, errno, fmt, ap); va_end{ap);

\*    Fatal error related to a system call.

\*    Print a message and terminate.

*/

void

err_sys(const char *fmt,...)

va_list    ap;

va_start(ap, fmt);    _

err_doit(1, errno, fmt, ap);    [^1

va_end(ap);

exit(l);

J

/*

\*    Nonfatal error unrelated to a system call.

\*    Error code passed as explict parameter.

\*    Print a message and return.

*/

void

err_cont{int error, const char *fmt, ...)

{

va_list    ap;

va_start(ap, fmt);

err_doit(l, error, fmt, ap); va_end(ap);

\*    Fatal error unrelated to a system call.

\*    Error code passed as explict parameter.

\*    Print a message and terminate.

*/

void

err_exit(int error, const char *fmt, ...)

{

va_list    ap;

va_start(ap, fmt);

err_doit(1, error, fmt, ap); va_end(ap>;

exit ⑴；

\*    Fatal error related to a system call.

\*    Print a message, dump core, and terminate. */

void

err_dump(const char *fmt, ...)

(

va_list    ap;

va_start(ap, fmt); err_doit(1, errno, fmt, ap); va_end(ap);

abort ();    /* dump core and terminate */

exit(1);    /* shouldn't get here */

J

19001    * Nonfatal error unrelated to a system call.

\*    Print a message and return.

*/

void

err_msg(const char *fmt,...)

{

va_list    ap;

va_start(ap, fmt); err_doit(0, 0, fmt, ap); va_end(ap);

}

\*    Fatal error unrelated to a system call.

\*    Print a message and terminate.

*/

void

err_quit(const char *fmt,...)

va_list    ap;

va_start(ap, fmt); err_doit(0, 0, fmt, ap》； va_end(ap);

exit ⑴； i

/*

\*    Print a message and return to caller.

\*    Caller specifies "errnoflag".

*/

static void

err_doittint errnoflag, int error, const char *fmt, va_list ap)

char    buf[MAXLINE];

vsnprintf(buf, MAXLINE-1, fmt, ap); if (errnoflag)

snprintf(buf+strlen(buf), MAXLINE-strlen(buf)-1, ": %s", strerror(error))；

strcat(buf, "\n");

fflush(stdout);    /[1](#bookmark8) [2](#bookmark9) in case stdout and stderr are the same [2](#bookmark9)/

fputs(buf, stderr)；

fflush(NULL);    /[2](#bookmark9) flushes all stdio output streams [2](#bookmark9)/

}

图B-3输出至标准错误的出错函数

图B-4包括了各log_XXX出错函数。若进程不以守护进程方式运行，那么调用者应当定义 变量lOg_to_stderr，井将其设置为非0值。在这种情况下，出错消息被发送至标准错误。若 log_to_stderr 标志为 0，则使用 syslog 设施（见 13.4 节）。

log_doit(1, errno, LOG_ERR, fmt, ap); va_end(ap);

\*    Fatal error related to a system call.

\*    Print a message and terminate.

*/

void

log_sys(const char *fmt,...)

{

va_list    ap;

va_start tap, fmt);

|90l|    log_doit {1, errno, LOG__ERR, fmt, ap);

va_end(ap); exit(2);

\*    Nonfatal error unrelated to a system call.

\*    Print a message and return.

*/

void

log_msg(const char *fmt, ...)

{

va_list    ap;

va_start(ap, fmt);

log_doit(0, 0, LOG_ERR, fmt, ap);

va_end(ap);

J

\*    Fatal error unrelated to a system call.

\*    Print a message and terminate.

*/

void

log_quit{const char *fmt, ...)

va_list    ap;

va_start {ap, fmt"

log_doit(0, 0, LOG_ERR, fmt, ap);

va_end(ap);

exit(2);

\*    Fatal error related to a system call.

\*    Error number passed as an explicit parameter.

\*    Print a message and terminate.

void

log’exit{int error, const char *fmt, ...)

{

va^list    ap;

va_start <ap, fmt);

log_doit(1, error, LOG_ERR, fmt, ap); va_end(ap); exit ⑵；

\*    Print a message and return to caller.

\*    Caller specifies "errnoflag" and "priority".

*/    画

static void

log_doit(int errnoflag, int error, int priority, const char *fmt, va_list ap)

{

char    buf[MAXLINE];

vsnprintf(buf, MAXLINE-1, fmt, ap); if (errnoflag)

snprintf(buf+strlen(buf), MAXLINE-strlen(buf)-1, ": %s", strerror(error));

strcat(buf, "\n"); if (log_to_stderr) {

fflush(stdout); fputs(buf, stderr); fflush(stderr);

} else {

syslog(priority, "%s", buf);

}

# 附录c

#### 部分习题答案

第1章

1.1这个习题利用ls（l＞命令的下面两个参数：-i打印文件或目录的i节点编号（4.14节详细讨 论了 i节点）；-d仅打印目录信息，而不是打印目录中所有文件的信息。

执行下列命令：

$ Is -ldi /etc/, /etc/..    -i要求打印i节点编号

| 162561           | drwxr-xr-x | 66   | root | 4096 | Feb               | 5 03:59  | /etc/./  |
| ---------------- | ---------- | ---- | ---- | ---- | ----------------- | -------- | -------- |
| 2                | drwxr-xr-x | 19   | root | 4096 | Jan               | 15 07:25 | /etc/../ |
| $ Is -ldi 八 /.. |            |      |      | .和. | .的i节点编号均为2 |          |          |
| 2                | drwxr-xr-x | 19   | root | 4096 | Jan               | 15 07:25 | /-/      |
| 2                | drwxr-xr-x | 19   | root | 4096 | Jan               | 15 07:25 | /. ./    |

1.2 UNK系统是多道程序或多任务系统，所以，在图1-6所示程序运行的同时其他两个进程也 在运行。

1.3因为perror的msg参数是一个指针，perror就可■以改变指向的字符串D然而使用 19。51 限定符const限制了 perror不能修敌msg指针指向的字符串。而对于strerror，其错 误号参数是整数类型，并且C是按值传递所有参数，因此即使strerror函数想修改参数 的值也修改不丁，也就没有必要使用const属性。（如果对C中函数参数的处理不是很清

楚，可参见 Kemighan 和 Ritchie[1988]的 5.2 节。）

1.4在2038年。将time_t数据类型定为64位整型，就可以解决该问题了。如果它现在是32 位整型，那么为使应用程序正常工作，应当对其重编译。但是这一问题还有更糟糕之处。 某些文件系统及备份介质以32位整型存放时间。对于这些同样需要加以更新，但又需要能 读旧的格式。

1.5 大约248天。

第2章

2.1 下面是FreeBSD中使用的技术。在头文件＜machine/_types.h＞中定义可在多个头文件中 出现的基本数锯类型。例如：

\#ifndef _MACHINE_TYPES_H_

\#define _MACHINE_TYPES_H_

typedef int    _int32_t;

typedef unsigned int _uint32_t;

\#endif /* _MACHXNE_TYPES_H_ */

在每个可以定义基本数据类型siZe_t的头文件中，包含下面的语句序列。

\#ifndef _SIZE_T_DECLARED typedef _size_t    size_t;

\#define _SIZE_T_DECLARED #endif

该样，实际上只执行一次size_t的typedef、

2.3如果OPEN_MAX是未确定的或大得出奇（即等于LONG_MAX），那么可以使用getrlimit 得到每个进程的最大打开文件描述符数。因为可以修改对每个进程的限制，所以我们不能 将前一个调用得到的值高速缓存起来（它可能已被更改），见图［9061

\#include ’■ apue.h"

♦include <limits.h>

\#include <sys/resource.h>

\#define OPEN_MAX_GUESS 256

long

open_max{void)

{

long openrnax; struct rlimit rl;

if ((openmax = sysconf (_SC_OPEN_MAX)) < 0 J| openmax == LONG_MAX) {

if (getrlimit(RLIMIT_NOFILE, &rl) < 0) err_sys("can't get file limit");

if (rl.rlim_max == RLIM_INFINITY) openmax = OPEN_MAX_GUESS;

else

openmax = rl.rlim_max;

}

return(openmax);

图C-l标识最大可能文件描述符的替换方法

第3章

3.1所有磁盘I/O都要经过内核的块缓存E （也称为内核的缓冲E髙速缓存）。唯一例外的是財 原始磁盘设备的1/0,但是我们不考虑这种情况（BaCh［1986］的第3章讲述了这种缓存区髙 速缓存的操作）。既然read或write的数据都要被内核缓冲，那么术语“不带缓冲的I/O” 指的是在用户的进程中对这两个函数不会自动缓冲，每次read或write就要进行一次系 统调用。

3.3 每次调用open函数就分配一个新的文件表项。但是因为两次打开的是同一个文件，则两个 文件表项指向相同的v节点。调用dup引用己存在的文件表项（此处指fdl的文件表项）， 见图C-2。当F_SETFD作用于fdl时，只影响fdl的文件描述符标志；F_SETFL作用于 fdl时，则影响fdl及fd2指向的文件表项。

3.4如果fd是1，执行duP2（fd, 1）后返回1，但没有关闭文件描述符1 （见3.12节）。调用

[907]    3次dup2后，3个描述符指向相同的文件表项，所以不需要关闭描述符。

如果fd为3,调用3次dup2后，有4个描述符指向相同的文件表项，这种情况下就需要 关闭描述符3。

3.5    因为shell从左到右处理命令行，所以 ./a.out > outfile 2>&1

首先设置标准输出到outfile,然后执行dup将标准输出复制到描述符2 （标准错误）上， 其结果是将标准输出和标准错误设置为同一个的文件，即描述符1和2指向同一个文件表 项。而对于命令行

./a.out 2>&1 > outfile

由于首先执行dup，所以描述符2成为终端（假设命令是交互执行的），标准输出重定向到 outfile。结果是描述符1指向outfile的文件表项，描述符2指向终端的文件表项。

3.6    这种情况下，仍然可以用lseek和read函数读文件中任意一个位置的内容。但是write 函数在写数据之前会自动将文件偏移量设置为文件尾，所以写文件时只能从文件尾端开始。

第4章

4.1 stat函数总是跟随符号链接（见图4-17）,所以该程序决不会显示文件类型是“符号链接' 例如，正如本书正文中所示，/dev/cdrom是/dev/srO的一•个符号链接，但是stat函 数的结果只显示/dev/cdrom是一个块特殊文件，而不报告它是一个符号链接。若符号链 接指向一个不存在的文件，stat会出错返回。

[908]    4.2将关闭该文件的所有访问权限。

$ uaask 777 $ date > taB^.foo $ la -1 tonq>. foo

----------1 sar    29 Feb 5 14:06 temp.foo

4.3 下面的命令显示了关闭用户读权限时所发生的情诨。

$ data > foo

$ chmod u-r foo 关闭用户读权限 ? Is -1 foo    检证文件的权限

--w-r--r--    1 sar    29 Feb 5 14:21 foo

S cat foo    读文件

cat: foo: Permission denied

4.4 如果用open或creat创建已经存在的文件，则该文件的访问权限位不变。运行图4-9中 的程序可以验证这点。

$ m foo bar 5 data > foo $ data > bar $ chnod a-r foo bar $ Is -1 foo bar

——w------- 1 sar

--w------- 1 sar

$ . /a.out $ Is -1 foo bar

--w------- 1 sar

—w---—— 1 sar



删除文件

创建文件

关闭所有的读权限 验证其权限

29 Feb 5 14:25 bar 29 Feb 5 14:25 foo 运行圈4-9程序 检查文件的权限和大小

0 Feb 5 14:26 bar 0 Feb 5 14:26 foo

可以看出访问权限没有改变，但是文件被截断了。

4.5目录的长度从来不会是0,因为它总是包含.和..两项。符号链接的长度指其路径名包含的

字符数，由于路径名中至少有一个字符，所以长度也不为0。

4.7当创建新的core文件时，内接对其■访问权限有一个默认设置，在本例中是rw-r-r--。这

一默认值可能会也可能不会被umask的值修改。shell对创建的重定向的新文件也有一个默 认的谛问祝限，本例中力rw-rw-rw-，送个值总是被当前的umask修改，在本例中umask 为02。

4.8不能使用du的原因是它需要文件名，如

du tempfile 或目录名，如 du .

只有当unlink函数返回时才择敢tempfile的目录项，du .命令没有计算仍然被 tempfile占用的空间。本例中只能使用df命令査看文件系统中实际可用的空闲空间。[w]

4.9如果被删除的链接不是该文件的最后一个链接，则不会删除该文件。此时，文件的状态更 改时间被更新。但是，如果被删除的链接是最后一个链接，则该文件将被物理删除。这时 再去更新文件的状态更改时间就没有意义，因为包含文件所有信息的i节点将会随着文件的 删除而被释放。

4.10用opendir打开一个目录后，递归调用函数dopath。假设opendir使用一个文件描述 符，并且只有在处理完目录后才调用closedir释放描述符，这就意味着每次降一级就要 使用另外一个描述符。所以进程可打开的最大描述符数就限制了我们可以遍历的文件系统 树的深度。Single UNIX Specification的XSI扩展中说明的ftw允许调用者指定使用的描述 符数，这隐含着可以关闭描述符并且重用它们。

4.12 chroot函数被因特网文件传输协议(Internet File Transfer Protocol, FTP)程序用于辅勘安 全性。系统中没有账户的用户(也称为匿名FTP)放在一个单独的目录下，利用chroot 将此目录当作新的根目录，就可以阻止用户访问此目录以外的文件。

chroot也用于在另一台机器上构造一个文件系统层次结构的副本，然后修改此副本，不会

更改原来的文件系统。这可用于测试新软件包的安装。

chroot只能由超级用户执行，一旦更改了一个进程的根，该进程及其后代进程就再也不能 恢复至原先的根。

4.13首先调用stat函数取得文件的3个时间值，然后调用utimes设置期望的值。在调用 utimes时我们不希望改变的值应当是stat中相应的值。

4.14    fingerG）对邮箱调用stat函数，最近一次的修改时间是上一次接收邮件的时间，最近访 问时间是上一次壞邮件的时间。

4.15    cpio和tar存储的只是归档文件的修改时间（st_mtim）n因为文件归档时一定会读它， 所以该文件的访问时间对应于创建归档文件的时间，因此没有存储其访问时间。cpio的-a 选项可以在读输入文件后重新设置该文件的访问时间，于是创建归档文件不改变文件的访 问时间。（但是，重置文件的访问时间确实改变了状态更改时间。）状态更改时间没有存储 在文挡上，因为即使它曾被归档，在抽取时也不能设置其值。（utimes函数极其相关的 futimens和utimensta函数可以更改的仅仅是坑向时间和修改时间。）

[9101 对tar来说，在抽取文件时，其默认方式是复原归档时的修改时间值，但是tar的-m选 项则将修改时间设置为抽取文件时的时间，而不是复原归档时的修改时间值。对于tar, 无论何种情况，在抽取后，文件的访问时间均是抽取文件时的时间。

另一方面，cpio将访问时间和修改时间设置为抽取文件时的时间。默认情况下，它并不试 图将修改时间设置为归档时的值。cpio的-m选项将文件的修改时间和访问时间设置为归 档时的值。

4.16内核对目录树的深度没有内在的限制，但是如果路径名的长度超出了 PATH_MAX,则有许多 命令会失败。图C-3程序创建了一个深度为1 000的目录树，每一级目录名有45个字符。 在所有平台上我们都能构建这样的结构，但并不是在所有平台上都能用getcwd得到第 1000级目录的绝对路径名。在Mac OS X 10.6.8中，当到达长路径的目录尾部时，getcwd 就不再成功了*在FreeBSD 8.0、Linux 3.2.0和Solaris 10中，getcwd可以获得路径名，但 是需要多次调用realloc得到一个足够大的缓冲区。在Linux 3.2.0上运行该程序后得到，

$ ./a.out

getcwd failed, size getcwd failed, size

getcwd failed, size getcwd failed, size length = 46004



4096: Numerical result out of range 4196: Numerical result out of range

省略了 418行

45896: Numerical result out of range 45996: Numerical result out of range

显示46004字节的路径名



然而，不能用cpio归档此目录，因为文件名太长了。事实上，cpio在所有4种平台上都不 能归档此目录。于此对比的是，在FreeBSD 8.0、Linux 3.2.0和Mac OS X 10.6.8上，可以用 tar归档此目录。然而，在Linux3.2.0上，我们不能从归档文件中抽取出目录的层次结构。

int

main(void)

{

int    i;

size_t size; char    *path;

if (chdir(STARTDXR) < 0)

err_sys("chdir error"J;

for (i = 0; i < DEPTH; i++) {

if (mkdir(NAME, DIR_MODE) < 0)

err_sys("mkdir failed, i = %d", i); if (chdir(NAME) < 0)

err_sys("chdir failed, i = %d", i);

}

if (creatC'afile", FILE_MODE) < 0) err_sys("creat error");

/*

\*    The deep directory is created, with a file at the leaf.

\*    Now let's try to obtain its pathname.

*/

path = path_alloc(&size);

for ( ; ; ) {

if (getcwd(path, size) != NULL} { break;

} else {

err_ret("getcwd failed, size = %ld", (long)size); size += 100; if (size > MAXSZ)

err_quit("giving up"); if ((path = realloc(path, size)) == NULL)

err_sys("realloc error");

}

printf("length = %ld\n%s\n", (long)strlen(path), path);

exit(0);

图C-3创建深目录树

4.17 /dev目录关闭了一般用户的写访问权限，以防止普通用户删除目录中的文件名。这就意味

着unlink失败。

第5章

5.2 fgets函数读入数据，直到行结束或缓冲区满（当然会留出一个字节存放终止null字节）。 同样，fputs只负责将缓冲区的内容输出直到遇到一个皿11字节t而并不考虑缓冲区中是 否包含换行符。所以，如果将MAXLINE设得很小，这两个函数仍然会正常工作；只不过在 缓冲区较大时，函数被执行的次数要多于MAXLINE值设置得较大的时候。

911    如果这些函数删除或添加换行符(如gets和puts函数的操作)，则必需保证对于最长的

9J2 行，缓冲区也足够大。

5.3当printf没有输出任何字符时，如printf ("••);，函数调用返回0。

5.4    这是一个比较常见的错误。getc以及getchar的返回值是int类型，而不是char类型。 由于EOF经常定义为-1,那么如果系统使用的是有符号的字符类型，程序还可以正常工作。 但如果使用的是无符号字符类型，那么返回的EOF被保存到字符c后将不再是-1，所以， 程序会进入死循环。本书说明的4种平台都使用带符号字符，所以实例代码都能工作。

5.5    使用方怯为：先调用fflush后调用fsync。fsync所使用的参数由fileno函数获得。 如果不调用fflush,所有的数据仍然在内存缓冲区中，此时调用fsync将没有任何效果。

5.6当程序交互运行时，标准输入和标准输出均为行缓冲方式。每次调用fgets时标准输出设 备将自动冲洗。

5.7 基于BSD系统的fmemopen的实现如图C~4所示。

♦include <stdio.h>

♦include <stdlib.h>

\#include <string.h>

\#include <errno.h>

\* Our internal structure tracking a memory stream */

struct memstream

| char   | *buf;   | /* in-memory buffer */           |
| ------ | ------- | -------------------------------- |
| size_t | rsize;  | /* real size of buffer */        |
| size_t | vsize;  | /* virtual size of buffer */     |
| size_t | curpos; | /* current position in buffer *, |
| int    | flags;  | /* see below */                  |

J；

/* flags */

| #define | MS.  | _READ     | 0x01 | /* open for reading */         |
| ------- | ---- | --------- | ---- | ------------------------------ |
| #define | MS.  | ■WRITE    | 0x02 | /* open for writing */         |
| #define | MS.  | ■APPEND   | 0x04 | /* append to stream ★/         |
| #define | MS.  | ■TRUNCATE | 0x08 | /* truncate the stream on open |
| #define | MS.  | _MYBUF    | 0x10 | /* free buffer on close */     |

\#ifndef MIN

\#define MIN(a, b) ((a) < (b) ? (a) : (b)) #endif

static int mstream_read(void *, char *, int);

static int mstream_write{void *, const char *, int)? static fpos_t mstream_seek(void *, fpos_t, int); static int mstream_close(void *);

static int type_to_flags(const char *_restrict type); static off_t find_end(char *buf, size_t len);

FILE *

fmemopen(void *_restrict buf, size_t size, const char *_restrict type)

struct memstream *ms;

FILE *fp;

if (size == 0) {

errno = EINVAL; return(NULL);

}

if ((ms = malloc(sizeof(struct memstream))) == NULL) { errno = ENOMEM; return(NULL);

}

if ((ms->flags = type_to_flags(type)) == 0) { errno = EINVAL; free(ras); return(NULL);

if (buf == NULL) {

if ((ms->flags & <MS_READ|MS_WRITE>> !=

(MS_READ|MS_WRITE))    {

errno = EINVAL; free(ms); return(NULL);

)

if ((ms->buf = malloc(size)) == NULL) { errno = ENOMEM; free(ms); return{NULL);

}

ms->rsize = size; ms->flags \= MS_MYBUF; ms->curpos = 0;

} else {

ms->buf = buf; ms->rsize = size; if <ms->flags & MS_APPEND>

ms->curpos = find_end(ms->buf, rns->rsize);

else

ms->curpos = 0;

}

if (ms->flags & MS_APPEND) (    /* "a" mode */

ms->vsize = ms->curpos;

} else if (ms->flags & MS_TRUNCATE) {    /* "w" mode */

ras->vsize = 0;    _

} else {    /* "r" mode */    |914|

ms->vsize = size;

f

fp = funopen(ns, mstream_read, mstream_write, mstreain._seek, mstream_close);

if (fp == NULL) {

if (ms->flags & MS_MYBUF)

free(ms->buf); free(ms);

return(fp);

static int

type_to_flags(const char *_restrict type)

const char *cp; int flags = 0;

for {cp = type; *cp != 0; cp++> { switch (*cp) { case 1r1:

if {flags != 0)

return (0);    /* error */

flags |= MS_READ; break;

case 'w':

if (flags != 0)

return (0);    /* error */

flags |= MS_WRITE|MS_TRUNCATE; break;

case * a*:

if (flags != 0)

return(0);    /* error */

flags |= MS_APPEND; break;

case :

if (flags == 0)

return{0);    /* error */

flags |= MS_READIMS_WRITE; break;

case 'b*:

if (flags == 0)

return(0);    /* error */

break;

default:

return⑼；    /* error */

}

画 J

return(flags)；

static off_t

find_end(char *buf, size_t len) {

off_t off = 0;

while (off < len) {

if (buf[off] == 0)

break;

off++;

return (off);

}

static int

mstream_read(void *cookie, char *buf, int len) t

int nr；

struct memstream *ms = cookie;

if (!(ms->flags & MS_READ)) { errno = EBADF; return(-1);

}

if (ms->curpos >= ms->vsize) return(0);

/* can only read from curpos to vsize */ nr = MIN(len, ms->vsize - ms->curpos); memcpy(buf, ms->buf + ms->curpos, nr}; ms->curpos += nr;

return(nr);

}

static int

mstream_write(void *cookie, const char *buf, int len) {

int nw, off;

struct memstream *ms = cookie;

if (!(ms->flags & {MS_APPENDIMS_WRITE)))    {

errno = EBADF; return(-1);

}

if (ms->flags & MS_APPEND) off = ms->vsize;

else

off = ms->curpos; nw = MIN(len, ms->rsize - off); memcpy(ms~>buf + off, buf, nw); ms->curpos = off + nw;

if (ms->curpos > ms->vsize》{    19161

ms->vsize = ms->curpos;

if (({ms->flags & (MS_READ|MS_WRITE))==

<MS_READIMSJQR工TE)} && (ms->vsize < ms->rsize))

*(ms->buf + ms->vsize) = 0;

)

if ((ms~>flags & (MS_WRITE|MS_APPEND)) &&

!{ras->flags & MS_READ)) {

if (ms->curpos < ns->rsize)

*(ms->buf + ms->curpos) = 0;

else

*(ms->buf + ms->rsize - 1) = 0;

}

return (nw);

static fpos_t

mstream_seek(void *cookie, fpos_t pos, int whence) f

int off;

struct memstream *ms = cookie;

switch (whence) { case SEEK_SET:

off = pos; break;

case SEEK_END:

off = ms->vsize + pos; break;

case SEEK_CUR:

off = ms->curpos + pos; break；

I

if (off <0|| off > ms->vsize) { errno = EINVAL; return -1;

J

ms->curpos = off; return(off)；

static int

m3tream_close(void *cookie)

{

struct memstream *ms = cookie;

if (ms->flags & MS_MYBUF) free(ms->buf);

free(ms); return(0);

(9171



图C~4 BSD系统的fmemopen实现



第6章

6.1    6.3节讲述了在Linux和Solaris系统中访问阴影口令文件的函数。不能使用6.2节所述函数 返回的pw_passwd字段值与加密口令相比较，因为此字段不是加密的口令。正确的方法是 使用阴影口令文件中对应用户的加密口令字段来进行比较。

在FreeBSD和Mac OS X中，口令文件的阴影是自动建立的。FreeBSD 8.0中，仅当调用者 的有效用户ID为0时，getpwnam或getpwuid函数返回的passed结构中的pw_passwd 字段包含有加密口令。在Mac OS X 10.6.8上，加密口令不能通过这瘦接口访问。

6.2    在Linux 3.2.0和Solaris 10中，图C-5程序输出加密口令。当然，除非有超级用户权限，否 则调用getspnam将返回EACCES错误。

\#include "apue.h" #include <shadow.h>

int

main(void)    /* Linux/Solaris version */

struct spwd *ptr;

if ( (ptr = getspnamC'sar") ) == NULL) err_sys("getspnam error");

printf("sp_pwdp = %s\n", ptr->sp_pwdp == NULL || ptr->sp_pwdp[0] == 0 ? "(null)" : ptr->sp_pwdp> ?

exit(0);

图C-5在Linux和Solaris系统中输出加密口令

在FreeBSD 8.0中，具有超级用户权限时，图C-6程序将输出加密口令，否则pw_passed 的返回值为星号(* )。在Mac OS X 10.6.8中，不管其运行时的用户权限是什么都输出星号。

♦include "apue.h"

掉include <pwd.h>

int

main(void)    Z* FreeBSD/Mac OS X version */

{

struct passwd *ptr;

if ((ptr = getpwnamf'sar")) == NULL)

err_sys("getpwnam error");    画

printf("pw_passwd = %s\n", ptr->pw_passwd == NULL I I

ptr->pw_passwd[0] == 0 ? "(null)" : ptr->pw_passwd); exit (0);

图C-6在FreeBSD和Mac OS X中输出加密口令

6.5图C-7程序以类似于date命令的格式输出日期。

♦include "apue.h" ♦include <time.h>

int

main(void)

{

caltime;

line[MAXLINE];



time_t struct tm char

if ((caltime = time(NULL)} = -1) err_sys("time error");

if ({tm = localtime(Scaltime)) == NULL) err„sys("localtime error")；

if (strftime(line, MAXLINE, "%a %b %d %X %Z %Y\n'\ tm) == 0) err_sys{"strftime error"};

fputs(line, stdout);

exit(0);

图07以date⑴的格式输出日期和时间

图C-7中程序的运行结果如下:

$ ./a.out

作者的駄认格式是美国东部

美国山地时间

曰本



Wed Jul 25 22:58:32 EDT 2012

$ TZ=US/Mountaxn ./a.out



Wed Jul 25 20:58:32 MDT 2012

$ TZ=Japan ./a.out



Thu Jul 26 11:58:32 JST 2012

第7章

7.1原因在于printf的返回值(输出的字符数)变成了 main函数的返回值。为了验证这一 结论，改变打印字符串的长度，然后运行程序，査看返回值是否与新的字符串长度值匹配。 当然，并不是所有的系统都会出现该情况。还要注意的是，如果在gcc中允许ISOC扩展 的编译选项，返回值将总是0,这是标准要求的。

7.2当程序处于交互运行方式时，标准输出通常处于行缓冲方式，所以当输出换行符时，上次 的结果才被真正输出。如果标准输出被定向到一个文件，而标准输出处于全缓冲方式，则 当标准I/O清理操作执行时，结果才真正被输出。

7.3 由于agrc和argv的副本不像environ—样保存在全局变量中，所以在大多数UNIX系 统中没有其他办法。

7.4当C程序解引用一个空指针出错时，执行该程序的进程将终止。可以利用这种方法终止 进程。

7.5    定义如下：

typedef void Exitfunc(void); int atexit (Exitfunc    ;

7.6    calloc将分配的内存空间初始化为(h但是ISO C并不保证0值与浮点0或空指针的值 相同。

7.7只有通过exec函数执行-•个程序时，才会分配堆和桟(见8.10节)。

7.8 可执行文件(a.out)包含了用于调试core文件的符号表信息。用strip⑴命令可以删 除这些信息，对两个a.out文件执行这条命令，它们的大小减为798760和6200字节。

7.9没有使用共享库时，可执行文件的大部分都被标准I/O库所占用。

7.10这段代码不正确。因为在自动变量val已经不存在之后，代码还通过指针引用这个已经不 存在的自动受量。自动变量val在复合语句开始的左花括号之后声明了，但当该复合语句 结束时，即在匹配的右花括号之后，自动变量就不存在了。

第8章

8.1为了仿真子进程终止时关闭标准输出的行为，在调用exit之前加下列代码行： fclose(stdout);

为了观察其效果，用下面几行代替程序中调用printf的语句。

i = printf("pid = %ld, glob = %d, var = %d\n",

(long)getpid(), glob, var);

sprintf(buf, "%d\n", i);

write<STDOUT_FILENO, buf, strlen(buf));

还需要定义变量i和buf。    网

这里假设子进程调用exit时关闭标准I/O流，但不关闭文件描述符STDOUTJILENO。有些 版本的标准I/O库会关闭与标准输出相关联的文件描述符从而引起write标准输出失败。在这 种情况下，调用dup将标准输出复制到另一个描述符，write则使用新复制的文件描述符。

8.2 可以通过图C-8程序来说明这个问题。

\#include "apue.h"

static void f1(void), f2(void)；

int

main(void)

1

f 1 (); f 2 ();

_exit(0);

static void

f1(void)

pid_t pid;

if ((pid = vfork()) < 0)

err^sys("vfork error");

/* child and parent both return */ i

static void

f2(void)

{

cha-r    buf [1000];    /* automatic variables */

int    i;

for (i =0; i < sizeof(buf); i++) buf[i] = 0;

}

图C-8错误使用vfork的例子

当函数f 1调用vfork时，父进程的栈指针指向fl函数的栈帧，见图C-9。vfork使得子 进程先执行然后从fl返回，接着子进程调用f2,并且f2的栈帧覆盖了 fl的桟帧，在f2 中子进程将自动变量tmf的值置为0,即将桟中的1 000个字节的值都置为0。从f2返回 后子进程调用_exit，这时桟中main桟帧以下的内容己经被f2修改了，然后，父进程从间 vfork调用后恢复继续，并从fl返回。返回信息虽然常常保存在桟中，但是多半可能已经 被子进程修改了。对于这个例子，父进程恢复继续执行的结果要依赖于你所使用的UNIX 系统的实现特征(如返回信息保存在栈帧中的具体位置、修改动态变量时覆盖了哪些信息 等)。通常的结果是一个core文件，但在你的系统中，产生的结果可能不同。

8.4在图8-13中，我们先让父进程输出，但是当父进程输出完毕子进程要输出时，要让父进程终止。 是父进程先终止述是子进程先执行输出，要依赖于内核対两个进程的调度(另一个竞争条件)。

在父进程终止后，shell会开始执行下一个程序，它也许会干扰子进程的输出。为了避免这种情 况，要在子进程完成输出后才终止父进程。用下面的语句替换程序中fork后面的代碍。 else if (pid == 0) {

WAIT_PARENT(》；    /* parent goes first */

charatatime{"output from child\n");

TELL_PARENT (getppid⑴；    /* tell parent we're done */

} else {

charatatime("output from parent\n");

TELL_CHILD(pid) ;    /* tell child we’re done */

WAIT_CHILD();    /* wait for child to finish *Z

栈的底部



main

的栈帧



fl

的栈帧



栈扩展的方向

图C-9调用vfork时的桟帧

由于只有终止父进程才能开始下一个程序，而该程序让子进程先运行，所以不会出现上面 的情况。

8.5 对 argv[2]打印的是相同的值(/home/sar/bin/testinterp)。原因是 execlp 在结 束时调用了 execve，并且与直接调用execl的路径名相同。回忆图8-15。

8.6图C-10程序创建了一个僵死进程。

\#include ’’apue.h" #ifdef SOLARIS

\#define PSCMD "ps -a -o pid,ppid,s,tty, comm" #else

\#define PSCMD "ps -o pid,ppid,state,tty,command" ttendif

int

main(void) t

pid_t pid;

if ( (pid = fork() ) < 0)

err_sys("fork error");

else if (pid == 0)    /* child */

exit(0);

/* parent */

sleep(4);

system(PSCMD);

exit(0);

图C-10创建一个僵死进程并用PS査看其状态

执行程序结果如下（ps（l）用Z表示僵死进程）:

$ ./a.out

| PID   | PPID | S    | TT    | COMMAND                                |
| ----- | ---- | ---- | ----- | -------------------------------------- |
| 2369  | 2208 | S    | pts/2 | -bash                                  |
| 7230  | 2369 | S    | pts/2 | ./a.out                                |
| 7231  | 7230 | Z    | pts/2 | [a.out] <defunct>                      |
| 7232  | 7230 | S    | pts/2 | sh -c ps -o pid,ppid,state,tty,command |
| 7233  | 7232 | R    | pts/2 | ps -o pid,ppid,state,tty,command       |
| 第9章 |      |      |       |                                        |

9.1因为init是登录shell的父进程，当登录shell终止时它收到SIGCHLD信号量，所以init 进程知道什么时候终端用户注销。

网络登录没有包含init,在utmp和wtmp文件中的登录项和相应的注销项是由一个处理 登录并检测注销的进程写的（本例中为telnetd）。    岡

第10章

10.1当程序第一次接收到发送给它的信号时就终止了。因为一捕捉到信号，pause函数就返回。 10.2桟帧见图C-11、

栈的底部|    ~

main 的栈帧

处理    处理    longjmp

SIGIMT    SIGALRM    后

图C-ll longjmp前后的钱顿



在sig_alrm中通过longjmp返回sleep2，有效地避免了继续执行sig_int。从这一 点，sleep2返回main （回忆图10-8）。

10.4在第一次调用alarm和setjinp之间又有一次宽争条件。如果进程在调用alarm和 setjmp之间被内核阻塞了，闹钟时间超过后就调用信号处理程序，然后调用longjmp。 但是由于没有调用过setjmp，所以没有设置env_alrm缓冲E。如果longjmp的跳转缓 冲区没有被setjmp初始化，则说明longjmp的操作是未定义的。

10.5 参见 Don Libes 的论文 “Implementing Software Timers” （C users Journal, Vol. 8, no. 11, Nov. 1990）中的例子。可以坑问 http:// www. kohala. com/start/ libes. timers . txt 获得该论文的电子版。

10.7如果仅仅调用_exit,则进程终止状态不能表示该进程是由于SIGABRT信号而终止的。 _ 10.8如果信号是由其他用户的进程发出的，进程必须设置用户ID为根或者是接收进程的所有者，

否则kill不能执行。所以实际用户ID为信号的接收者提供了更多的信息。

10.10对于本书作者所用的一个系统，每60〜90分钟増加一抄，这个误差是因为每次调用sleep 都要调度一次将来的时间事件，但是由于CPU调度，有时并没有在事件发生时立即被唤醒。 另外一个原因是进程开始运行和再次调用sleep都需要一定量的时间。

cron守护进程这样的程序每分钟都要获取当前时间，它首先设置一个休眠周期，然后在下 一分钟开始时唤醒。（将当前时间转换成本地时间并査看tm_sec值。）每一分钟，设置下 一个休眠周期，使得在下一分钟开始时可以唤醒。大多数调用是sleep （60），偶尔有一个 sleep <59）用于在下一分钟同步。但是，若在进程中花费了许多时间执行命令或者系统的 负载重、调度慢，这时休眠值可能远小于60。

10.11在Linux 3.2.0、Mac OS X 10.6.8和Solaris 10中，从来没有调用过SIGXFSZ的信号处理程 序，一旦文件的大小达到1024时，write就返回24。

在FreeBSD 8.0中，当文件大小已达到1000字节，在下一次准备写100字节时调用该信号 处理程序，write返回一1,并且将errno设置为EFBIG （文件太大）。

在所有4种平台上，如果在当前文件偏移量处（文件尾端）尝试再一次write,将收到 SIGXFSZ信号，write将失败，返回_1,并将errno设置为EFBIG。

10.12结果依赖于标准I/O库的实现：fwrite函数如何处理一个被中断的write。

例如，在Linux 3.2.0上，当使用fwrite函数写一个大的缓冲医时，fwrite以相同的字 节数直接调用write。在write系统调用当中，闹钟时间到，但我们直到写结束才看到信 号，看上去就好像在write系统调用进行当中内核阻塞了信号。

与此不同的是，在Solaris 10中，fwrite函数调用以8 KB的增量调用write，直到写完 整个要求的字节数。当闹钟时间到，会被捕捉到，中断write回到fwrite。当从信号处 理程序返回时，返回到fwrite函数内部的循环，并继续以8KB的增量写。

第11章

岡11.1图C-12给出了一个没有使用自动变量，而采用动态内存分配的程序。

ttinclude "apue.h"

\#include <pthread.h>

struct foo {

int a, b, c, d;

I；

void

printfoo(const char *s, const struct foo *fp)

1

fputs(s, stdout);

printf(" structure at 0x%lx\n"# (unsigned long)fp>;

| printf("  | foo.a = | %d\n". | fp->a); |
| --------- | ------- | ------ | ------- |
| printf (" | foo.b = | %d\n", | fp->b); |
| printf (" | foo.c = | %d\n", | fp->c); |
| printf("  | foo.d = | %d\n", | fp->d); |

void *

thr_fnl(void *arg)

{

struct foo *fp;

if { {fp = malloc{sizeof(struct foo))) == NULL) err_sys("can't allocate memory")；

fp->a = 1;

fp->b -2;

fp->c = 3;

fp->d =4;

printfoo <"thread:\n", fp);

return <(void *)fp);

int

main(void)

(

int err; pthread_t tidl; struct foo *fp;

err = pthread_create(&tidl, NULL, thr_fnl, NULL); if (err != 0)

err_exit(err, "can't create thread 1"); err = pthread_join(tidlz (void *)&fp); if (err != 0)

err_exit(err, "can't join with thread 1"); printfoo("parent:\n", fp); exit (0)；

}

图C-12线程返回值的正确使用

11.2要改变挂起作业的线程ID，必须持有写模式下的读写锁，防止ID在改变过程中有其他线程 在捜索该列表。目前定义该接口的方式存在的问题在于：调用job_find找到该作业以及 调用job_remove从列表中删除该作业这两个时间之间作业ID可以改动。这个问题可以通 过在job结构中嵌入引用计数和互斥量，然后让job_find增加引用计数的方法来解决。 这样修改ID的代码就可以避免対列表中非零引用计数的任何作业进行ID改动的情况。

11.3首先，列表是由读写锁保护的，但条件变量需要互斥量对条件进行保护。其次，每个线程 等待满足的条件应该是有某个作业进行处理时需要的条件，所以需要创建每线程数据结构 来表示这个条件。或者，可以把互斥量和条件变量嵌入到queue结构中，但这意味着所有 的工作线程将等待相同的条件。如果有很多工作线程存在，当唤醒了许多线程但又没有工 作可做时，就可能出现惊群效应问题，最后导致CPU资源的浪费，并且增加了锁的争夺。

11.4这根据具体情况而定总的来说，两种情况都可能是正确的，但每一种方法都有不足之处。 在第一种情况下，等待线程会被安排在调用pthread_COnd_broadcast之后运行。如果 程序适行在多处理器上，由于还持有互斥锁（pthread_cond_wait返回持有的互斥锁）， 一些线程就会运行而且马上阻塞。在第二种情况下，运行线程可以在第3步和第4步之间 萩取互斥锁，然后使条件先效，最后释披互斥锁。接着，当调用pthread_cond_broadcast

时，条件不再为真，线程无需运行，这就是为什么唤醒线程必须重新检査条件，不能仅仅 因为pthread_cond_wait返回就假定条件就为真。

第12章

12.1就像人们首先会猜到的，这并不是一个多线程问题。这些标准I/O例程事实上是线程安全的。 我们调用fork时，每个进程获得了标准I/O数据结构的一份副本。程序运行时把标准输出定 向到终端时，输出是行缓冲的，所以每次打印一行时，标准I/O库就把该行写到终端上。但是， 如果把标准输出重定向到文件的话，则标准输出就是全缓冲的。当缓冲区满或者进程关闭流时， 输出才会写到文件。在这个例子中，执行fork时，缓冲区中包含了还未写的几个打印行，所 以当父进程和子进程最终冲洗缓冲区中的副本时，最初的复制内容就会写入文件。

12.3理论上来讲，如果在信号处理程序运行时阻塞所有的信号，那么就能使函数成为异步信号 岡    安全的。问题是我们并不能知道调用的某个函数可能并没有屏蔽己经被阻塞的信号，这样

通过另一个信号处理程序可能会使该函数变成可重入的。

12.4在FreeBSD 8.0上，程序抛出core。用gdb的话，可以看到程序初始化过程将调用线程函数，这 些函数调用 getenv 找到环量 LIBPTHREAD_SPINLOOPS 和 LXBPTHREAD_YXELDLOOPS 的值。然而，我们的线程安全版本的getenv回调pthread库函数会处于一种中间的不一致状 态。另外，线程初始化函数会调用malloc，并在malloc中调用getenv来査找环境变量 MALLOC_OPTIONS 的值。

为丁避开这个问题，我们可以合理假定程序启动是单线程的，并使用一个标志来指示线程初 始化已经通过我们的getenv来完成了。但这个标志为假时，我们版本的getenv会和不可 重入版本一样操作（并且避免调用任何pthread函数和malloc）。然后我们提供一个独立 的初始化函数来调用pthread^once»而非从getenv里面来调用它》这就要求在调用 getenv之前程序调用我们的初始化函数，这就解决了我们的问题，因为只有程序启动初始化 完成后才能进行。当程序调用了我们的初始化函数后，这个版本的getenv就是线程安全的。

12.5如果希望在一个程序中运行另一个程序，还需要fork （即在调用exec之前）。

12.6图C-13给出了使用select实现线程安全的sleep函数，延迟一定数量的时间。它是线程安

全的，因为耷并不使用任何未经保护的全局或静态数据，并且只调用其他线程安全的函数。

\#include <unistd.h>

\#include <time.h>

♦include <sys/select.h>

unsigned

sleep(unsigned seconds)

{

int n;

unsigned slept; time_t start, end; struct timeval tv;

tv.tv_sec = seconds; tv.tv_usec = 0; time(Sstart);

n = select(0, NULL, NULL, NULL, &tv); if (n == 0)

return(0>; time{Send}; slept = end - start; if {slept >= seconds)

return(0};

return(seconds - slept);

图C-13 sieep的线程安全实现

12.7很多时候条件变量的实现都使用互斥锁来保护它的内部结构。由于这是实现细节，因而通 常是被隐藏起来的，所以在fork处理程序中没有可移植的方法获取或释放锁。既然在调用 fork后并不能确定条件变量中的内部锁状态，所以在子进程中使用条件变量是不安全的。

第13章

13.1如果进程调用chroot，它就不能打开/dev/log。解快的办法是，守护进程在调用chroot 之前调用选项为LOG_NDELAY的openlog。它打开特殊设备文件(UNIX域数据报套接字) 并生成一个描述符，即使调用了 chroot之后，该描述符仍然是有效的。这种场景在诸如 ftpd (文件传输协议守护进程)这样的守护进程中出现，为了安全起见，专门调用了 chroot,但仍需要调用syslog来对出错条件记录日志＜,

13.4图C-14展示了一种解决方案。

參include "apue.h"

int

main(void)

{

FILE *fp; char *p;

daemonize("getlog"); p = getlogin();

fp = fopen("/tmp/getlog.out", "w"); if (fp != NULL) {

if (p == NULL)

fprintf(fp, "no login name\n");

else

fprintf(fp, "login name: %s\n", p);

}

exit(0);

}    «—

-Q2g

图C-14调用daemonize然后获得登录名    ；

其结果依赖于不同的系统实现。daemonize关闭所有打开文件描述符，然后向/dev/null ^22 再打开前3个。这意味着进程不再有控制终端，所以getlogin不能在utmp文件中看到 进程的登录项。于是在Linux 3.2.0和Solaris 10中，我们发现守护进程没有登录名。

但是在FreeBSD 8.0和Mac OS X 10.6.8中，登录名是由进程表维护的，并且在执行fork 时复制。也就是说，除非其父进程没有登录名(如系统自引导时调用init),否则进程总 能获得其登录名。

第14章

14.1测试程序如图C-15所示。

\#include "apue.h"

番include <fcntlih> #include <errno.h>

void

sigint(int signo)

{

J

int

main(void)

{

pid_t pidl, pid2, pid3; int fd;

setbuf(stdout, NULL); signal_intr(SIGINT, sigint);

/[3](#bookmark28)

\* Create a file.

*/

if ((fd = open("lockfile", O_RDWR|O_CREAT, 0666)) < 0) err„sys ("can't open/create lockfile’’};

\* Read-lock the file.

*/

if {(pidl = fork()) < 0) { err_sys("fork failed");

} else if (pidl == 0) {    /[3](#bookmark28) child [3](#bookmark28)/

if (lock_reg(fd, F_SETLK, F_RDLCK, 0, SEEK_SET, 0》< 0)

_    err_sys("child 1: can't read-lock file");

19301    printf("child 1: obtained read lock on file\n");

pause ();

printf("child 1: exit after pause\n">; exit(0);

} else (    /[3](#bookmark28) parent [3](#bookmark28)/

sleep(2);

}

printf("child 2: exit after pause\n"); exit (0);

} else {    /* parent */

sleep(2);

\*    Parent continues ... block while trying to write-lock

\*    the file.

*/

if ( (pid3 = fork(》)< 0) { err_sys{"fork failed");

} else if (pid3 == 0) {    /* child "

if (lock_reg<fd, F_SETLK, F_WRLCK, 0, SEEK_SET, 0) < 0)

printf("child 3: can't set write lock: %s\n", strerror(errno));

printf("child 3 about to block in write-lock...\n"); if (lock_reg(fd, F_SETLKW, F_WRLCK, 0, SEEK_SET, 0) < 0)

err_sys("child 3: can't write-lock file"); printf("child 3 returned and got write lock????\n"); pause (};

printf("child 3: exit after pauseXn")； exit(0);

} else {    /* parent */

sleep(2);

}

\*    See if a pending write lock will block the next

\*    read-lock attempt.

*/

if (lock_reg(fd, F_SETLK, F_RDLCK, 0, SEEK_SET, 0) < 0) printf("parent: can't set read lock: %s\n'\

strerror(errno));

else

printf("parent: obtained additional read lock while"



pending\n"); 1-. An");

2..    .\n");

3..    .\nM);



"write lock is printf("killing child kill{pidl, SIGINT); printf("killing child kill(pid2/ SIGINT); printf("killing child kill(pid3, SIGINT); exit(0);

图C-15判断记录锁的行为

[1](#footnote1)

\*    Error routines for programs that can run as a daemon.

*/

\#include "apue.h"

\#include <errno.h>    /[2](#bookmark9) for definition of errno [2](#bookmark9)/

\#include <stdarg.h>    /[2](#bookmark9) ISO C variable arguments [2](#bookmark9)/

\#include <syslog.h>

static void log_doit(int, int, int, const char [2](#bookmark9), va_list ap);

\*    Caller must define and set this: nonzero if

\*    interactive, zero if daemon */

extern int log_to__stderr;

/[2](#bookmark9)

\*    Initialize syslog(), if running as daemon.

*/

void

log_open(const char [2](#bookmark9)ident, int option， int facility)

{

if (log_to_stderr == 0)

openlog(ident, option, facility);

}

\*    Nonfatal error related to a system call.

[2](#footnote2)

   Print a message with the system's errno value and return. */

void

log_ret(const char [2](#bookmark9)fmt, ...)

(

va_list    ap；

va_start(ap, fmt);

[3](#footnote3)

Parent continues ... read-lock the file again.

if ((pid2 = forkO) < 0) { err_sys ("fork failed[3](#bookmark28)1);

J else if {pid2 = 0) {    /[3](#bookmark28) child [3](#bookmark28)/

if (lock_reg(fd, F_SETLK, F_RDLCK, 0, SEEK_SET, 0) < 0)

err_sys("child 2: can't read-lock file"}; printf("child 2: obtained read lock on file\n"); pause ();


在FreeBSD 8.0、Linux 3.2.0和Mac OS X 10.6.8上，记录锁的行为是相同的，后增加的读者 可使未决的写者不断等待。运行该程序得到

child 1： obtained read lock on file

child 2: obtained read lock on file

child 3: can't set write lock: Resource temporarily unavailable

child 3 about to block in write-lock...

parent: obtained additional read lock while write lock is pending

killing child 1... child 1: exit after pause killing child 2… child 2： exit after pause killing child 3...

child 3: can't write-lock file: Interrupted system call

14.2大多数系统将数据类型fd_set定义为只包含一个成员的结构，该成员为一个长整型数组。 数组中每一位(bit)对应于一个描述符。4个FD_定通过开、关或测试指定的位对这个数组 进行操作。

将之定义为一个包含数组的结构而不仅仅是一个数组的原因是：通过C语言的赋值语句， 可以使fd_set类型的变量相互陚值

14.3大多数系统允许用户在包括头文件＜sys/select.h＞前定义常量FD_SETSIZEd例如，我 们可以写下面这样的代码来定义fd_set数据类型，使其可以包含2 048个描述符：

\#define FD_SETSIZE 2048

\#include ＜sys/select.h＞

遗憾的是，事情并非如此简单。为了在现代系统使用该技术，我们需要做以下几件事情。

(1)    在包含任何头文件之前，我们需要定义哪种符号来防止包含＜sys/select.h＞。

[9321    —些系统会使用一个单独的符号来保护fd_set类型的定义，我们也需要如此定义。

例如，在FreeBSD8.0中，我们需要定义_SYS_SELECT_H_来防止包含＜sys/select.h＞， 定义_FD_SET来防止包含fd_set数据类型的定义。

(2)    有时，为了和旧应用程序兼容，＜sys/types.h＞定义了 fd_set的大小，所以我们 必须首先包含它，然后去掉FD_SETSIZE的定义。注意，一些系统用_FD_SETSIZE来代替。

(3)    想能够使用select时，我们需要重新定义FD_SETSXZE (或_FD_SETSIZE) 来最大化文件描述符的数量，

(4)    我们需要取消定义第一步定义的符号。

(5)    最终，我们能够包含＜sys/select.h＞。

在运行程序之前，我们需要配置系统允许我们打开所需的文件描述符数量，这样我们能够 实际利用的文件描述符数量达到FD_SETSIZE个。

14.4下面列出了功能类似的函数。

fd_zero sigemptyset fd_set    sigaddset

fd_clr    sigdelset

fdjesset sigismember

没有与sigfillset对庙的FD_xxx画数■＞对信号量集来说，指向信号量集的指针思是第 一个参数，信号编号是第二个参数。对于描述符来说，描述符编号是第一个参数，指向描 述符集的指针是第二个参数，

14.5利用select实现的程序见图C-16。

♦include "apue.h"

番include ＜sys/select.h＞

void

sleep_us(unsigned int nusecs)

struct timeval    tval;

tval.tv_sec = nusecs / 1000000; tval.tv_usec = nusecs % 1000000; select(0, NULL, NULL, NULL, &tval);

}

图C-16用select实现sleep_us固数 利用poll实现的程序见图C-17。

| #include <poll.h>           |          |
| --------------------------- | -------- |
| voidsleep_us(unsigned int i | nusecs)  |
| istruct pollfd              | dummy;   |
| int                         | timeout; |

if ({timeout = nusecs / 1000) <= 0) timeout = 1;

poll(Sdummy, 0, timeout);

}

图C-17用poll实现sleep_us函数

如BSD usleep(3)手册页中所说明的，usleep使用nanosleep函数，该函数没有与调 用进程设置的定时器交互。

14.6不行。我们可以使TELL_WAIT创建一个临时文件，其中1个字节用做父进程的锁，另外1 个字节用做子进程的锁。WAIT_CHILD使得父进程等待获取子进程字节上的锁， TELL_PARENT使得子进程释放子进程字节上的锁。但是问题在于，调用fork会释放所有 子进程中的锁，使得子进程开始运行时不具有任何它自己的锁。

14.7图C-18中示出了一种解决方法。

\#include "apue.h"

\#include <fcntl.h>

int

main(void)

int i, n; int fd[2];

if (pipe(fd) < 0)

err_sys("pipe error",;

set_fl, O_NONBLOCK);

/* write 1 byte at a time until pipe is full */ for (n = 0; ; n++) {

if ((i = write(fd[l], "a", 1)) != 1) { printf("write ret %d, ", i); break;

printf("pipe capacity = %d\n", n); exit(O);

®    图C-18用非阻塞写计算管道的容量

下表列出了在本书所述的4种平台上计算出来的值。

| 平台            | 管道容量(字节) |
| --------------- | -------------- |
| FreeBSD 8.0     | 65 536         |
| Linux 3.2.0     | 65 536         |
| Mac OS X 10.6.8 | 16 384         |
| Solaris 10      | 16 384         |

这些值可能与对应的PIPE_BUF值不同，其原因是，PIPE_BUF被定义为可被自动原子地 写至一个管道的最大数据量。这里，我们计算的是一个管道独立于任何原子性限制可保持 的数据量。

14.10图14^27中的程序是否更新输入文件的上一次访问时间依赖于操作系统以及文件所属的文 件系统的类型。在所有4种平台中，当文件具有给定操作系统默认的文件系统类型，上一 次访问时间就会更新。

第15章

15.1如果管道的写端总是不关闭，则读者就决不会看到文件结束符。分页程序就会一直阻塞在 读标准输入。

15.2父进程向管道写完最后一行以后就终止，当父进程终止时管道的读端自动关闭。但是由于 子进程(分页程序)要等待输出的页，所以父进程可能比子进程领先一个管道缓冲区。如 果正在运行的是一个可对命令行进行编辑的交互式shell，如Komshell，那么当父进程终止 时，shell多半会改变终端的模式并打印一个提示。这个无疑会影响已经对终端模式进行修 改的分页程序(由于大部分分页程序在等待处理下一个页面时将终端置为非正规模式)，

15.3因为执行了 shell,所以popen返回一个文件指针。但是shell不能执行不存在的命令，因 此在标准错误上打印下面信息后终止： sh: line 1： ./a.out: No such file or directory

其退出状态为127 (该值取决于shell的类型)》pclose返回该命令的终止状态，这如同从 waitpid返回一样。

15.4当父进程终止时，用shell看忘的终止状态。对于Bourne shellBourne-again shell和Korn shell* 所用的命令是echo $?,打印的结果是128加信号编号。

15.5首先加入下面的声明：

|935|    FILE *fpin, *fpout；

然后用fdopen关联管道描述符和标准I/O流，并将流设置为行缓冲的。在从标淮输入读的 while循环之前做此工作。

if ((fpin = fdopen(fd2[0], "r")) == NULL) err_sys("fdopen error");

if ((fpout = fdopen(fdl[l], "w")) == NULL) err_sys("fdopen error");

if (setvbuf(fpin, NULL, _IOLBF, 0) < 0) err_sys("setvbuf error");

if (setvbuf {fpout, NULL, JEOLBF, 0) < 0) err_sys("setvbuf error");

while循环中的write和read用下面的语句代替：

if (fputs(line, fpout) == EOF)

err_sys("fputs error to pipe");

if (fgets(line, MAXLINE, fpin) == NULL》{ err_msg("child closed pipe"); break;

}

15.6 system函数调用了 wait，终止的第一个子进程是由poperi产生的。因为该子进程不是 system创建的，所以它将再次调用wait并一直阻塞到sleep完成。然后system返 回。当pclose调用wait时，由于没有子进程可等待所以返回出错，导致pclose也返 回出错。

15.7尽管具体细节会随平台不同而不同(见图C-19)，但是select表明描述符是可读的。调用 read读完所有的数据后，返回0就表明到达了文件尾端。但是对于poll来说，若返回 POLLHUP事件，则表明也许仍有数据可读。但是一旦读完了所有的数据，read就返回0 表明到达了文件尾端。在读完了所有的数据后，POLLIN事件就不会再返回了，即使需要再 调用一次read以接收文件尾端通知(返回值为0)。

| 操    作                     | FreeBSD 8.0 | Linux 3.2.0 | Mac OS X 10.6.8 | Solaris 10 |
| ---------------------------- | ----------- | ----------- | --------------- | ---------- |
| 管道写端关闭时读端上的select | R/W/E       | R           | R/W             | R/W/E      |
| 管道写端关闭时读端上的poll   | R/HUP       | HUP         | INV             | HUP        |
| 管道读端关闭时写埔上的select | R/W/E       | R/W         | R/W             | R/W        |
| 管道读端关闭时写端上的poll   | R7HUP       | W/ERR       | INV             | HUP        |

图019 select和poll的管道行为

图C-19中所示的条件包括R (可读)、W (可写)、E (异常)、HUP (挂断)、ERR (错误)

和INV (无效文件描述符)。对于引用已被读者关闭的管道的输出描述符来说，select表 明该描述符是可写的。但当我们调用write时，产生SIGPIPE信号。如果忽略该信号或函幻 从其信号处理程序中返回，write就会失败，将error设置成EPIPE。而对于poll，具 体的行为则会根裾平台的不同而不同。

15.8子进程向标准错误写的内容同样也会在父进程的标准错误中出现。只要在cmtfezHflg中包含 shell重定向2>&1，就可以将标准错误发回给父进程。

15.9 popen函数fork 一个子进程，子进程执行shell。然后shell再调用fork,最后由shell的 子进程执行命令串。当cmds/H叩终止时，shell恰好在等待该事件。然后shell退出，而这 一事件又是pclose中的waitpid所等待的。

15.10解决的办法是打开(open) FIFO两次：一次读；一次写。我们决不会使用为写而打开的描 述符，但是使该描述符打开就可在客户数从1变为0时，阻止产生文件尾端。打开FIFO两 次需要注意下列操作方式(如非阻塞open所要求的)：第一次以非阻塞、只读方式open;

第二次以阻塞、只写方式open。(如果先用非阻塞、R写方式open，将返回错误3然后 关闭读描述符的非阻塞属性。参见图C-20所示的代码。

tinclude "apue.h"

\#include <fcntl.h>

\#define FIFO "temp.fifo"

int

main(void)

int    fdread, fdwrite;

unlink(FIFO);

if (mkfifo(FIFO, FILE_MODE) < 0) err_sys("mkfifo error");

if ((fdread = open(FIFO, O.RDONLY 丨 O_NONBLOCK)) < 0) err_sys("open error for reading");

if ((fdwrite = open(FIFO, O_WRONLY)) < 0) err_sys("open error for writing"};

clr_fl(fdread, O_NONBLOCK);

exit(O);

图C-20以非阻基方式打开FIFO进行读、写操作

15.11随意读取现行队列中的消息会干扰客户进程-服务器进程协议，导致丢失客户进程请求或者 服务器进程的响应。只要知道队列的标识符或者该队列允许所有的用户读，进程就可以读 队列。

15.13由于服务器进程和各客户进程可能会将段连接到不同的地址，所以在共享存储段中决不会 [937|    存储实际物理地址。相反，当在共享存储段中建立链表时，链表指针的值会设置为共享存

储段内另一对象的偏移量。偏移量为所指对象的实际地址减去共享存储段的起始地址。

15.M图C-21显示了相关的事件。

| 父进程的i 设置成 | 子进程的i 设置成 | 共车值设置成 | update返回       | 注释                                             |
| ---------------- | ---------------- | ------------ | ---------------- | ------------------------------------------------ |
| 0                | 1                | 0            |                  | 由mmap初始化 子进程先运行，然后被阻塞 父进程运行 |
|                  |                  | 2            | 0                | 然后父进程被阻塞 子进程继续                      |
| 2                | 3                | 34           |                  | 然后子进程被阻塞 父进程继续                      |
|                  |                  | 2            | 然后父进程被阻塞 |                                                  |
| 4                | 5                |              |                  | 然后子进程被阻塞 父进程继续                      |

图C-21图15-33中父进程和子进程之间的交替过程

第16章

16.1图C-22显示了一个打印系统字节序的程序。

\#include <stdio.h>

\#include <stdlib.h>

\#include <inttypes.h>

int

main(void)

1

uint32_t    i = 0x04030201;

unsigned char *cp = (unsigned char *) &i;

if (*cp 1)

printf{"little-endianXn"); else if (*cp == 4)

printf("big-endianXn");

else

printf("who knows?\nn); exit(0);

图C-22判断系统字节序    ^38]

16.3对于我们将要监听的每个端点，需要绑定到一个合适的地址，并对应每个描述符在fd_set 结构中写一条记录。然后使用select等待从多个端点来的连接请求。回忆16.4节，当一 个连接请求达到时，一个被动的端点将会变得可读。当一个连接请求真的到达时，我们接 受该请求，并如以前一样处理。

16.5在main过程中，通过调用我们的signal函数(见图10-18)来捕捉SXGCHLD,该函数 将使用sigaction来安装处理程序指定可重启的系统调用选项。下一步，从serve函数

删除waitpid调用。当fork完子进程来处理请求后，父进程关闭新的文件描述符并继 续监听新的连接请求。最后，需要一个针对于SIGCHLD的信号处理程序，如下：

void

sigchld(int signo)

{

while (waitpid((pid_t)-l, NOLL, WNOHANG) >0)

}

16.6为了允许异步套接字I/O,需要使用？_3£10卵fcntl命令建立套接字所有权，然后使用 FIOASYNC ioctl命令允许异步信号。为了不允许异歩套接字1/0,只要简单地禁用异步 信号即可。我们混合使用fcntl和ioctl命令的理由是，想找到最可移植的方法。代码 如图C-23所示。

ftinclude "apue.h"

\#include <errno.h>

\#include <fcntl.h>

\#include <sys/socket.h>

\#include <sys/ioctl.h>

\#if defined(BSD) || defined(MACOS) || defined(SOLARIS)

♦include <sys/filio.h>

\#endif

int

setasync{int sockfd)

{

int n;

if (fcntl(sockfd, F_SETOWN, getpidt)) < 0) return (-1);

n = 1;

if (ioctl(sockfd, FIOASYNC, &n) < 0} return (-1};

|939|    return(0);

int

clrasync(int sockfd) t

int n;

n = 0;

if {ioctl(sockfd, FIOASYNC, &n) < 0) return(-1J;

return(0);

J

图023允许与不允许异步套接字I/O

第17章

17.1常规管道提供了一个字节流接口。为了确定消息边界，我们必须增加给每个消息增加一个 头部来指示长度。但这个仍涉及两个额外的复制操作：一个是写入至管道，另一个是从管 道读出。更加有效的方法是仅将管道用于告知主线程有一个新消息可用。我们用单个字节 用作通知。采用这种方法，我们需要移动mymesg结构到threadinfo结构，并使用一个 互斥量(mutex)和一个条件变量(condition variable)来防止辅助线程在主线程完成之前 重新使用mymesg结构。解决方案如图C-24所示。

\#include #include ♦include ^include ^include



•'apue.h'1 <poll.h> <pthread.h> <sys/msg.h> <sys/socket.h>

\#define NQ #define MAXMSZ 神define KEY



3    /* number of queues */

512    /* maximum message size */

0x123    /* key for first message queue */

struct mymesg { long char



nitype;

mtext[MAXMSZ+1];



｝；



struct threadinfo {

| int             | qid;    |
| --------------- | ------- |
| int             | fd;     |
| int             | len;    |
| pthread_mutex_t | mutex;  |
| pthread_cond_t  | ready； |
| struct mymesg   | m;      |

void *

helper(void *arg)

{

int    n;

struct threadinfo    *tip = arg;

for(;;) {

memset0, sizeof(struct mymsg)); if { {n = msgrcv(tip->qid, &tip->m, MAXMSZ, 0,

MSG_NOERROR)) < 0)

err_sys("msgrcv error");

tip->len = n;

pthread_inutex_lock (&tip->mutex); if {write(tip->fd, "a", sizeof(char>) < 0)

err_sys("write error"); pthread_cond_wait(stip->ready, &tip->mutex); pthread_mutex_unlock(&tip->mutex);

)

}

int

main{)

(

| char              | c;         |
| ----------------- | ---------- |
| int               | i, n, err; |
| int               | fd[2];     |
| int               | qid[NQ];   |
| struct pollfd     | pfd[NQ]?   |
| struct threadinfo | ti[NQ];    |
| pthread_t         | tid[NQ];   |

for (i = 0; i < NQ; i++) {

if ( (qid[i] >= magget ( (KEY+i), IPC_CREAT | 0666)) < 0)

err_sys("msgget error");

printf("queue ID %d is %d\n", i, qid[i]);

if (socketpair<AF_UNIX, SOCK_DGRAM, 0, fd) < 0) err_sys{"socketpair error");

pfd[i].fd = fd[0]; pfd[i].events = POLLIN; ti[i].qid = qid[i]; ti[i].fd = fd[l];

if (pthread_cond_init(&ti[i].ready, NULL) != 0) err_sys("pthread_cond_init error");

if {pthread_mutex_init(&ti[i].mutex, NULL) != 0)

err_sys("pthread_mutex_init error"); if (《err = pthread_create(&tid[i], NULL, helper,

&ti[i])) != 0)

err_exit{err, "pthread_create error");

[94?| I

for {;;) {

if (poll(pfd, NQ, -1) <0} err_sys("poll error"); for (i = 0; i < NQ; i++) {

if (pfd[i].revents & POLLIN)(

if ((n = read(pfd[i].fd, sc, sizeof(char))) < 0}

err_sys("read error"); ti[i].m.mtext[ti[i].len] = 0; printf("queue id %d, message %s\n", qid[i],

ti[i].m.mtext);

pthread_mutex_lock(&ti[i].mutex); pthread_cond_signal (&ti [i] .ready); pthread_mutex_unlock{fiti[i].mutex);

»

exit(O)，-

图C-24使用管道的XSI消息轮询

17.3声明指定了标识符集合的属性(如赛裾类型)。如果声明也导致好配了存储单元，那么这就是定义。 在头文件opend.h中，我们用extern存储类声明了 3个全局变量，这时并没有为它们分 配存储单元。在文件main.c中，我们定义了 3个全局变量，有时，我们也会在定义全局 变量时就初始化它，但通常是使用C的默认值。

17.5 select和poll返回就绪的描述符个数作为函数值。当将这些就绪描述符都处理完后，操 作client数组的循环就可以终止。

17.6建议的解决方案存在的第一个问题是，在文件可能发生变化的地方，调用stat和调用 unlink之间存在竞争。第二个问题是，如果名字是一个指向UNIX域套接字文件的符号链 接，那么stat会报告名字是一个套接字(回想一下后面跟一个符号链接的stat函数)， 但是调用unlink时，实际上我们是删除了这个符号链接而不是套接字文件。为了解决第 二个问题，应该使用lstat而不是stat，但这解决不了第一个问题。

17.7第一种选择是将两个文件描述符在一个控制消息中的发送，每一个文件描述符存储在相邻 的内存位置中。下面的代码展示了这种方法：

struct msghdr msg; struct cmsghdr *cmptr;

19421    int *ip/'

if ( (cmptr = callocd, CMSG_LEN (2*sizeof (int)) ) ) == NULL) err_sys("calloc error");

msg.msg_control = cmptr;

msg.msg_controllen = CMSG_LEN(2*sizeof(int));

/* continue initializing msghdr... */ cmptr->cm3g_len = CMSG_LEN(2*sizeof(int)); cmptr->cmsg_level = SOL_SOCKET;

cmptr->cmsg_type = SCM_RIGHTS; ip = (int *) CMSG_DATA{cmptr).;

*ip++ = fdl;

*ip = fd2;

这种方法在本书中涉及的4个平台上全都可以工作。第二种选择是将两个独立的cmsghdr 结构打包到一个消息中。

struct msghdr msg; struct cmsghdr *cmptr;

if ((cmptr = calloc(1, 2*CMSG_LEN(sizeof(int)))) == NULL) err_sys("calloc error")；

msg.msg_control = cmptr;

msg.msg_controllen = 2*CMSG_LEN(sizeof(int));

/* continue initializing msghdr... */ cmptr->cmsg_len = CMSG_LEN(sizeof(int)); cmptr->cmsg_level = SOL_SOCKET; cmptr->cmsg_type = SCM_RIGHTS;

*(int *)CMSG_DATA(cmptr) = fdl; cmptr = CMPTR_NXTHDR(&msg, cmptr); cmptr->cmsg_len = CMSG_LEN{sizeof(int)); cmptr->cmsg_level = SOL_SOCKET; cmptr->cmsg_type = SCM_RIGHTS;

*(int *)CMSG_DftTA(cmptr) = fd2;

与第一种方法不同，这个方法只在FreeBSD 8.0上能工作。

第18章

18.1注意，由于终端是非规范模式的，所以必须要用换行符而不是回车符终止reset命令。

18.2它为128个字符建了一张表，根据用户的要求设置最髙位(奇偶校验位)。然后使用8位I/O

处理奇偶位的产生=

18.3如果你使用的是窗口终端，那么你无需登录两次。在两个分开的窗口之间，你可以做这样 的实验。在Solaris中，运行stty -a,并且将标准输入重定向到运行vi的终端。结果显 示vi设置MIN为1、TIME为1。read调用会一直等待，直到至少键入一个字符，但是 该字符输入后，只对后继的字符等待十分之一秒即返回。    ®

第19章

19.1 telnetd和rlogind两个服务器均以超级用户权限运行，所以它们都可以成功地调用 chown 和 chmodo

19.2执行pty -n stty -a以避免伪终端从设备的termios结构和winsize结构初始化。

19.4很不幸，fcntl的F_SETFL命令不允许改变读写状态。

19.5有3个进程组：(1)登录shell，(2) pty父进程和子进程，(3) cat进程。前两个进程组 组成了一个会话，其中，登录shell为会话首进程。第二个会话仅包含cat进程。第一个进 程组(登录shell)是后台进程组，其他两个进程组是前台进程组。

19.6首先，当cat从其行规程模诀接收到文件结束符时会终止。这导致PTY从设备终止，进而 导致PTY主设备终止。接着，对于正从PTY主设备读取的pty父进程产生一个文件结束 符。该父进程将SIGTERM信号发送给子进程，于是子进程终止。(子进程不捕捉该信号。)

最后，父进程调用main函数尾端的exit (0)。

图8-29所示程序的相关输出为：

19.7这可通过使用shell的echo命令和date (1)命令实现，它们都在一个子shell中:

\#!/bin/sh

（echo "Script started on " 'date'; pty "${SHELL:-/bin/sh}";

echo "Script done on " 'date'） I tee typescript

19.8 PTY从设备上的行规程能够回显，所以pty从其标准输入所读取的以及写向PTY主设备的 按默认都回显。尽管程序（ttyname）从不读取数据，但是该回显也可通过从设备上的行 规程模块实现。

第20章

20.1 _db_dodelete中保守的加锁操作是为了避免和db_nextrec发生党争条件。如果没有使用 [944]    写锁保护jb_Writedat调用，则有可能在db_nextrec读某个记录时，该记录已被删除：

db.nextrec首先读入一个索引记录，判定该记录非空，接着读数据记录，但是在它调用 _db_readidx ^Q_db_readdat 之间，读记录却可能ldb_dodelete 删除了。

20.2假定db_nextrec调用_db_readidx，它将记录的键读入索引缓冲区<> 然后，该进程被内 核调度进程暂停，另一个进程运行，它刚好调用db_delete删除了这一条记录，使得索引文 件和数据记录文件中対应部分都被清空。当第一个进程恢复执行并调（在 db_nextreC函数体中）时，返回的是空数据记录。db_nextrec中的读锁使得读入索引记录 的过程和读入数据记录的过程是一个原子操作（对于其他操作同一数据库的合作进程而言）。

20.3强制性锁对其他的读进程和写进程产生了影响。设置 的锁被解除之前，其他的读操作和写操作都将被阻塞。

20.5在写索引记录之前写数据记录，通过这一方法来防止如下情形：若该进程在两次写之间被 杀死从而产生不正常的记录。如果进程先写索引记录，而在写数据记录之前被杀死，那么 就会得到一个有效的索引记录，但它却指向一个无效的数据记录。

第21章

21.5这里有一些提示。有两个地方可以检查队列中的作业：打印守护进程的队列和网络打印机 的内部队列。注意，不要让一个用户可以取消其他用户的打印作业。当然，超级用户可以 取消任何作业，

21.7不需要唤醒守护进程，因为知道需要打印一个文件时才需要重读配置文件。printer_thread 函数在每次向打印机发送作业之前检査是否需要重读配置文件。

21.9需要使用null字节来终止写到作业文件的字狩串（strlen在计算字符串长度时不包含终止 null字节）。有两种简单的方法：要么对写入的字节数加1，要么使用dprintf函数而不是

|945|    调用 sprintf 和 write。

Accetta, M., Baron, R., Bolosky, W., Golub, D., l^ishid，R.，Tevanian, A., and Young, M. 1986. “Mach:

A New Kernel Foundation for UNIX Development,” Proceedings of the 1986 Summer USEN1X Conference^ pp. 93-113, Atlanta, GA.

I    介绍Mach操作系统的一篇文章。

Adams, J.，Bustos, D.，Hahn，S.，Powell, D., and Praza, L. 2005. “Solaris Service Management Facility: Modem System Startup and Administration,Proceedings of the 19th Large Installation System Administration Conference (LISA r05), pp. 225-236, San Diego, CA.

描述Solaris中的Service Management Facility ( SMF )的一篇文章，它提供了一个框架，用于 (启动和监控管理流程，以及从影响其提供服务的故障中恢复。

Adobe Systems Inc. 1999. PostScript Language Reference Manual, Third Edition. Addison-Wesley, Reading, MA.

PostScript语言的参考手册。

Aho, A. V.，Kemighan, B. W., and Weinberger, P. J. 1988. The AWK Programming Language. Addison-Wesley, Reading, MA.

'    这本书对awk程序设计语言进行了完整的说明。这本书所说明的awk有时被称为皿wk(newawk)。

Andrade, J.M., Carges, M. T., and Kovach, K. R. 1989. “Building a Transaction Processing System on UNIX Systems,” Proceedings of the 1989 USENIX Transaction Processing Workshop^ pp. 13-22, Pittsburgh, PA.

说明AT&T Tuxedo事务处理系统。

Arnold, J. Q. 1986. “Shared Libraries on UNIX System V，” Proceedings of the 1986 Summer USENIX Conference, pp. 395-404, Atlanta, GA.

说明SVR3中共享库的实现。    [^3

AT&T. 1989. System V Interface Definition, Third Edition. Addison-Wesley, Reading, MA.

本书为四卷本，说明系统V的源代码界面和运行时的行为。其第3版对应于SVR4。1991年

出版了第5卷，它包含了第1〜4卷中更新的命令和函数部分。现已绝版。

AT&T. 1990a. UNIX Research System Programmer’s Manual, Tenth Edition, Volume I. Saunders College Publishing, Fort Worth, TX.

这是Research UNIX第10版(V10)的《UNIX程序员手册》。它包含了传统的UNIX手册页 (第1〜9节)。

AT&T. 1990b. UNIX Research System Papers, Tenth Edition, Volume II. Saunders College Publishing, Fort Worth, TX.

| Research UNIX第10版（V10）第2卷，它包含了说明该系统各个方面的40篇文幸。

AT&T. 1990c. UNIX System V Release 4 BSD/XENJX Compatability Guide. Prentice Hall, Englewood Cliffs, NJ.

j    包含说明兼容库的手册页。

AT&T. 1990d. UNIX System V Release 4 Programmer’s Guide: STREAMS. Prentice Hall, Englewood Cliffs, NJ.

] 说明SVR4的STREAMS （流）系统。

AT&T. 1990e. UNIX System V Release 4 Programmer's Reference Manual. Prentice Hall, Englewood Cliffs, NJ.

j 本书是针对Intel80386处理器的SVR4实现的程序员参考手册。它包含第丨节（命令）、第2 |节（系统调用）、第3节（子例程）、第4节（文件格式）和第5节（其他）。

AT&T. 1991. UNIX System V Release 4 System Administrator’s Reference Manual. Prentice Hall, Englewood Cliffe, NJ.

|    这本书是针对Intel 80386处理器的SVR4实现的管理员参考手册。它包含第1节（命令）、第

]4节（文件格式）、第5节（其他）、第7节（特殊文件）。

Bach, M. J. 1986. The Design of the UNIX Operating System. Prentice Hall, Englewood Cliffs, N J.

；    这本书详细说明UNIX操作系统的设计和实现。虽然这本书并不提供UNIX源代码（因为这是

J AT&T的财产），但提供并讨论了 UNIX内核使用的很多算法及数据结构。这本书说明的是SVR2。

Bolsky, M. I., and Kom, D. G. 1995. The New KomShell Command and Programming Language, Second Edition Prentice Hall, Englewood Cliffs, N J.

j    说明如何使用作为命令解释器和编程语言的Komshell。

Bovet, D. P. and Cesati, M. Understanding the Linux Kernel, Third Edition. O'Reilly Media, Sebastopol, CA.

全面描述了 Linux2.6内核体系结构。

Chen, D., Barkley, R. E., and Lee, T. P. 1990. “Insuring Improved VM Performance: Some NoFault Policies，” Proceedings of the 1990 Winter USENIX Conference^ pp. 11 -22, Washington, DC.

这篇论文说明对SVR4虚拟存储器实现的更改，其目的是改善该系统性能，特别是fork和 exec的性能。

Comer, D. E. 1979. “The Ubiquitous B-Tree，” ACM Computing Surveys, vol. 11, no. 2, pp. 121-137 （June）.

对于B树的一篇很好的综述文章。

Date, C. J. 2004. An Introduction to Database Systems, Eighth Edition. Addison-Wesley, Boston, MA.

j    对数据库的全面概述。

Evans, J. 2006.“A Scalable Concurrent malloc Implementation for FreeBSD，” Proceedings ofBSDCan. j    一篇描述FreeBSD中使用的动态存储分配函数库jemalloc实现的文章。

Fagin, R., Nievergelt, J.( Pippenger, N.，and Strong, H. R. 1979. “Extendible Hashing―A Fast Access Method for Dynamic Files,” ACM Transactions on Databases, vol. 4, no. 3, pp. 315-344 (September).

!    说明可扩展散列技术的一篇文章。

Fowler, G. S., Korn, D. G., and Vo, K. P. 1989. “An Efficient File Hierarchy Walker，” Proceedings of the 1989 Summer USENIX Conference^ pp. 173-188, Baltimore, MD.

|    说明一个替代的库函数，其作用是遍历文件系统层次结构。

Gallmeister, B. 0.1995. POSIX.4: Programming for the Real World. O’Reilly & Associates, Sebastopol, CA.

j    说明POSIX标准的实时接口。

Garfinkel, S., Spafford, G., and Schuartz A. 2003. Practical UNIX & Interent Security, Third Edition O’Reilly & Associates, Sebastopol, CA.

这本书详细说明UNIX系统的安全性。

Ghemawat, S., and Menage, P. 2005. “TCMalloc: Thread-Caching Malloc. ”

j    Google的TCMalloc存储分配器的概要描述。这个描述可以在http: //goog-perftools.

sourceforge.net/doc/tcmalloc.html 获得。

Gingell, R.A., Lee, M., Dang, X.T.，and Weeks, M. S. 1987. “Shared Libraries in SunOS,” Proceedings of the 1987 Summer USENIX Conference, pp. 131-145, Phoenix, AZ.

}    说明SunOS共享库的实现。

Gingell, R.A.，Moran, J.P., and Shannon, W. A. 1987. MVirtual Memory Architecture in SunOS/* Proceedings of the 1987 Summer USENIX Conference, pp. 81-94, Phoenix, AZ.

说明iranap函数的起始实现，以及虎拟存储器设计中的有关问题。

Goodheart, B. 1991. UNIX Curses Explained. Prentice Hall, Englewood Cliffs, NJ.

这本书详细说明terminfo和curses函数库d现已绝版。

Hume, A.G. 1988.“A Tale of Two Greps，” Software Practice and Experience, vol. 18, no.l 1， pp. 1063-1072.

讨论grep性能改进的一篇有价值的论文。

IEEE. 1990. Information Technology~Portable Operating System Interface (POSIX) Part 1: System Application Program Interface (API) [C Language]. IEEE (Dec.).

j 这是第一个POSIX标准，它定义了基于UNIX操祚系统的C语言系统界面标准。这常称为 j POSIX.1。现在它是 Open Group[2008]发布的 Single UNIX Specification 的一部分。

ISO. 1999. International Standard ISO/IEC 9899—Programming Language C. ISO/IEC.

j C语言及标准函数库的官方标准。虽然该标准在2011年被新版本取代，担是本书中描述的系 I统仍然遵循该标准1999年的版本。

ISO. 2011. International Standard ISO/IEC 9899, Information Technology—Programming Languages_ C. ISO/IEC.

C语言及标准库官方标准的最新版，替代1999年版。该标准的PDF版本可以在线购买，购 j 买网址为 <http://www.ansi.org> 或 <http://www.iso.oigo>

Kemighan, B.W., and Pike, R. 1984. The UNIX Programming Environment. Prentice Hall, Englewood Cliffs, NJ.

这本书是对UNIX程序设计附加细节的参考书，包含了许多UNIX命令和实用租序，如grep、 sed、awk 和 Boume shell。

Kemighan, B.W., and Ritchie, D. M. 1988. The C Programming Language, Second Edition. Prentice Hall, Englewood Cliflfe, NJ.

:    这本书说明C程序设计语言的ANSI标准。附录B中包含了 ANSI标准定义的函教库说明。

Kerrisk, M. 2010. The Linux Programming Interface. No Starch Press, San Francisco, CA.

I    如果觉得这本书篇幅太大，这里只是一半的篇幅，但只关注Linux编程接口。

Kleiman, S. R. 1986. “Vnodes: An Architecture for Multiple File System Types in Sun Unix,” Proceedings of the 1986 Summer USENIX Conference^ pp. 238-247, Atlanta, GA.

| 说明了原先的v节点实现。

Knuth, D. E. 1998. The Art of Computer Programming, Volume 3: Sorting and Searching, Second Edition. Addison-Wesley, Boston, MA.

I    描述分类和搜索算法。

Kom, D. G., and Vo, K. P. 1991. “SFIO: Safe/Fast Strmg/File IO,” Proceedings of the 1991 Summer USENIX Conference, pp. 235-255, Nashville, IN.

说明了标准I/O轟数库的一种替代品。这个库可在<http://www.research.att>. com/sw/tools/sf io 获得0

Krieger, O., Stumm, M., and Unrau, R. 1992. “Exploiting the Advantages of Mapped Files for Stream I/O,” Proceedings of the 1992 Winter USENIX Conference^ pp. 27-42, San Francisco, CA.

[9501    一种标准I/O函数库的替代品，它基于映射文件。

Leffler, S. J., McKusick, M. K., Karels, M. J” and Quaiterman, J. S. 1989. The Design and Implementation of the 4.3 BSD UNIX Operatin System. Addison-Wesley, Reading, MA.

这本书对4.3BSD UNIX系统进行完整的说明，所说明的是4.3BSD的Tahoe版。现已绝版。 Lennert, D. 1987. “How to Write a UNIX Daemon,”;login:, vol. 12, no. 4, pp. 17-23 (July/August).

说明如何编写UNIX系统中的守护进程。

Libes, D. 1990. “expect Curing Those Uncontrollable Fits of Interaction,M Proceedings of the 1990 Summer USENIX Conference^ pp. 183-192, Anaheim, CA.

；    对expect程序反其实现的说明。

Libes, D. 1991. “expect: Scripts for Controlling Interactive Processes,” Computing Systems，vol. 4, no.2, pp. 99-125(Spring).

本文提供了很多expect脚本o

Libes, D. 1994. Exploring Expect. O’Reilly & Associates, Sebastopol, CA. i 使用expect程序的一本全书。

Lions, J. 1977. A Commentary on the UNIX Operating System. AT&T Bell Laboratories, Murray Hill, NJ.

:    说明第6版UNIX System的源代码。只供AT&T的雇员、签有合同的人员及内部使用，但在

:AT&T之外也有大量副本流传。

Lions, J. 1996. Lions' Commentary on UNIX6th Edition. Peer-to-Peer Communications, San Jose, CA. 说明第6版UNIX System的源代码，是1977经典著作的公开可用版。

Litwin, W. 1980. “Linear Hashing: A New Tool for File and Table Addressing,M Proceedings of the 6th international Conference on Very Large Databases, pp. 212-223, Montreal, Canada.

j    说明线性散列技术的一篇文章。

McKusick, M. K., Bostic, K., Karels, M. J., and Quarterman, J. S. 1996. The Design and Implementation of the 4.4BSD Operating System. Addison-Wesley, Reading, MA.

一本完整地描述4.4BSD操作系统的著作。

McKusick, M. K., and Neville-Neil, G. V. 2005. The Design and Implementation of the FreeBSD Operating System. Addison-Wesley, Boston, MA.

一本完整地描述FreeBSD操作系统5.2版的著作。

McDougall, R., and Mauro, J. 2007. Solaris Internals: Solaris 10 and OpenSolaris Kernel Architecture, Second Edition. Prentice Hall, Upper Saddle River, NJ.

一本讲解Solaris 10操作系统内部结构的书。书中也包括OpenSolaris的内容。

Morris, R” and Thomopson, K. 1979. “UNIX Password Security,Communications of the ACM，vol. 22, no. 11, pp. 594-597 (Nov.).

丨 说明UNIX 口令方案设计的历史演变。

Nemeth, E., Snyder, G., Seebass, S.，and Hein, T. R. 2001. UNIX System Administration Handbook, Third Edition. Prentice Hall, Upper Saddle River, NJ.

； 一本详细说明了管理UNIX系统的很多细节的书。

The Open Group. 2008. The Single UNIX Specification, Version 4. The Open Group, Berkshire, UK.

j    POSIX和X/Open标准组合成一种规范。其HTML版可在http: / /www. opengroup. org上免

j费阅读。

Pike, R., Presotto, D., Dorward, S., Flandrena, B., Thompson, K., Trickey, H., and Winterbottom, P. 1995. “Plan 9 from Bell Labs，” Plan 9 Programmer's Manual Volume 2. AT&T，Reading, MA.

j    这本书描述Plan9操作系统，Plan9是由研发UNIX系统的同一部门开发的。

Plauger, P. J. 1992. The Standard C Library. Prentice Hall, Englewood Cliffs，NJ.

；    这是一本ANSI C函数库的全书，包含了该库完整的C语言实现。

Presotto, D. L.，and Ritchie, D. M. 1990. “Interprocess Communication in the Ninth Edition UNIX System/' Software Practice and Experience^ vol. 20, no. Sl,pp. S1/3-S1/17 (June).

t    本文说明Research UNIX System第9版提供的IPC设施，它是由AT&T贝尔实验室的信息科

|学研究部开发的。这种IPC的基础是浚输入输出系统，它也包括全双工管道，通过它在进程之间

可以传送文件描述符，还包括对服务器的唯一客户连接。本文的一个副本也刊载在AT&T[19卯b]。 Rago，S.A. 1993. UNIX System V Network Programming. Addison-Wesley, Reading, MA.

j 这本书书描述UNIX System V Release 4的基于STREAMS的网络编程环境。

Raymond, E. S., ed. 1996. The New Hacker’s Dictionary, Third Edition, MIT Press, Cambridge, MA.

{    这本书中定义了大量计算机黑客的术语。

Salus, P. H. 1994.^4 Quarter Century of UNIX. Addison-Wesley, Reading, MA.

|    从1969至1994年间的UNIX系统的历史。

Seltzer, M., and Olson, M. 1992. “LIBTP: Portable, Modular Transactions for UNIX,** Proceedings of the 1992 Winter USENIX Conference, pp. 9-25, San Francisco, CA.

j    说明对db(3)库的修改，它来自实现了事务的4.4BSD。

Seltzer, M., and Yigit, O. 1991. “A New Hashing Package for UNIX,” Proceedings of the 1991 Winter USENIX Conference，pp.173-184, Dallas, TX.

S 说明dtm(3)库及其各种实现，以及一种新的散列处理软件包。

Singh, A. 2006. Mac OSXInternals: A Systems Approach. Addison-Wesley, Upper Saddle River, NJ.

J    关于Mac OS X操作系统设计的1600页的内容。

Stevens, W. R. 1990. UNIX Nerwork Programming. Prentice Hall, Englewood Cliffs, NJ.

!i    详细说明UNIX系统下的网络编程。该书的后续版本的内容与其第1版相比有艮大变动。

Stevens, W. R., Fenner, B., and Rudoff，A. M. 2004. UNIX Network Programming, Volume 1, Third Edition. Addison-Wesley, Boston, MA.

[^1    详细说明UNIX系統下的网络编程。其第2版进行了重新设计并分成两卷，第3版则做了更新。

Stonebraker, M. R. 1981. “Operating System Support for Database Management,'* Communications of

the ACM, vol. 24, no. 7,pp. 412-418 (July).

|    描述操作系统的服务以及它们如何对数据库操作产生影响。

Strang, J. 1986. Programming with curses. O’Reilly & Associates, Sebastopol, CA.

I    一本有关伯克利版本的curses的书。

Strang, J., Mui, L., and O'Reilly, T. 1988. termcap & terminfo, Third Edition. O’Reilly & Associates, Sebastopol, CA.

J    一本有关termcap和terminfo的书0

Sun Microsystems. 2005. STREAMS Programming Guide. Sun Microsystems, Santa Clara, CA. f    说明在Solaris平台上的STREAMS編程。

Thompson, K. 1978. “UNIX Implementation/* The Bell System Technical Journal, vol. 57, no. 6, pp. 1931-1946 (July-Aug.).

说明UNIX第7版的某些实现细节。

Vo, Kiem-Phong. 1996. “Vmalloc: A General and Efficient Memory Allocator，’’ Software Practice and Experience, vol. 26, no. 3, pp. 357-374.

说明一种灵活的存储分配器。

Wei, J., and Pu, C. 2005. “TOCTTOU Vulnerabilities in UNIX_Style File Systems: An Anatomical Study，’’ Proceedings of the 4th USENIX Conference on File and Storage Technologies (FAST'OS), pp. 155-167, San Francisco, CA.

J 说明UNIX文件系统接口中TOCTTOU的弱点。

Weinberger, P. J. 1982. “Making UNIX Operating Systems Safe for Database,” The Bell System Technical Journal, vol. 61，no. 9, pp. 2407-2422 (Nov.).

说明在早期UNIX系统中实现教据库的某些问题。

Weinstock, C. B.，and Wulf, W. A. 1988. “Quick Fit: An Efficient Algorithm for Heap Storage Allocation/，SIGPLANNotices, vol. 23, no. 10, pp. 141-148.

描述了适用于各种应用程序的内存分配算法。

Williams, T. 1989. “Session Management in System V Release 4，” Proceedings of the 1989 Winter USENIX Conference, pp. 365-375, San Diego, CA.

说明POS1X.1接口所基于的在SVR4中的会话计体系结构，包括进程组、作Jk控制和控制终 端。这本书也描述了现存方法的安全性。

X/Open. 1989. X/Opert Portability Guide. Prentice Hall, Englewood Cliffs，NJ.

这本书为七卷本，包括下列各部分内容：命令和公用程序（第1卷）、系统界面和头文件（第 ,2卷）、补充定义（第3卷）、程序设计语言（第4卷）、数据管理（第5卷）、窗口管理（第6卷）

以及网络服务（第7卷）。

标有“definition of’的函数子项指向函数原型出现的地方，当该函数可用时，指向函数的源代 码。文中定义的用于后续例子中的函数也包含在索引中，例如图3〜11中的set_fl函数。较大 例子（第17、19、20和21章）中的某些部分是外部函数的定义，为了便于理解这些大例子，这 些外部函数的定义也包含在本索引中。另外，本索引还包括许多例子中出现的重要函数和常量， 如select和poll，不过几乎每个例子中都会出现的一般函数（如exit）出现在例子中时并没 有为它们建立索引。

本索引中的页码为英文版原书的页码，与书中页边标注的页码对应.
