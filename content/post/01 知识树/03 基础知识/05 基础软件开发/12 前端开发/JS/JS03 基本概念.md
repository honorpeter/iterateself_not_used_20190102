---
title: JS03 基本概念
toc: true
date: 2018-06-12 19:57:19
---
本章内容

□语法

□数据类型

□流控制语句

□理解函数

语言的核心都必然会描述这门语言最基本的工作原理。而描述的内容通常都要涉及这门语 言的语法、操作符、数据类型、内置功能等用于构建复杂解决方案的基本概念。如前所述.

ECMA-262通过叫做ECMAScript的“伪语言”为我们描述了 JavaScript的所有这些基本概念。

冃前，ECMA-262第3版中定义的ECMAScript是各浏览器实现最多的一个版本。ECMA-262第5

版是浏览器接下来实现的版本，但截止到2011年底，还没有浏览器完全实现了这个版本。为此，本章 将主要按照第3版定义的ECMAScript介绍这门语言的基本概念，并就第5版的变化给出说明。

3.1语法

ECMAScript的语法大量借鉴了 C及其他类C语言（如Java和Perl）的语法。因此，熟悉这些语言 的开发人员在接受ECMAScript更加宽松的语法时，一定会有一种轻松自在的感觉。

3.1.1区分大小写

要理解的第一个概念就是ECMAScript中的一切（变量、函数名和操作符）都区分大小写。这也就 意味着，变景名test和变域名Test分别表示两个不同的变量，而函数名不能使用typeof,因为它 是一个关键字（3.2节介绍关键字），但typeOf则完全可以是-个有效的函数名。

3.1.2标识符

所谓标识符，就是指变最、函数、属性的名字，或者函数的参数。标识符可以是按照下列格式规则 组合起来的一或多个字符：

□第一个字符必须是一个字母、下划线（_）或一个美元符号（$）;

□其他字符可以是字母、下划线、美元符号或数字。

标识符中的字母也可以包含扩展的ASCII或Unicode字母字符（如入和疋），但我们不推荐这样做。

按照惯例，ECMAScript标识符采用驼峰大小写格式，也就是第一个字母小写，剰下的每个有意义 的单词的首字母大写，例如：

firstSecond my Car

doSomethinglmportant

虽然没有谁强制要求必须采用这种格式，但为了与ECMAScript内置的函数和对象命名格式保持一 致，可以将其当作一种最佳实践。

不能把关键字、保留字、true、false和null用作标识符。3.2节将介绍更多相 关内容。

3.1.3注释

ECMAScript使用C风格的注释，包括单行注释和块级注释。单行注释以两个斜杠开头，如下所示:

//单行注释

块级注释以一个斜杠和一个星号（/* ）开头，以一个星号和一个斜杠（*/ ）结尾，如下所示：

/*

\*    这是一个多行

\*    （块级）注释 */

虽然上面注释中的第二和第三行都以一个星号开头，但这不是必需的。之所以添加那两个星号，纯 粹是为了提髙注释的可读性（这种格式在企业级应用程序中极其常见）。

3.1.4严格模式

ECMAScript 5引人了严格模式（strict mode）的概念。严格模式是为JavaScript定义了一种不同的 解析与执行模型。在严格模式下，ECMAScript3中的一些不确定的行为将得到处理，而且对某些不安全 的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码：

"use strict";

这行代码看起来像是字符串，而且也没有赋值给任何变量，但其实它是一个编译指示（pragma）, 用于告诉支持的JavaScript引擎切换到严格模式。这是为不破坏ECMAScript 3语法而特意选定的语法。

在函数内部的上方包含这条编译指示，也可以指定函数在严格模式下执行：

function doSomething（）{

■use 白trict";

//函数体

}

严格模式下，JavaScript的执行结果会有很大不同，因此本书将会随时指出严格模式下的区别。支 持严格模式的浏览器包括正10+、Firefox 4+, Safari 5.1+、Opera 12+和Chrome。

3.1.5语句

ECMAScript中的语句以一个分号结尾；如果省略分号，则由解析器确定语句的结尾，如下例所示:

var sum = a + b    //即使没有分号也是有效的语句-不推蓐

var diff = a - b;    //有效的语句 推其

虽然语句结尾的分号不是必需的，但我们建议任何时候都不要省略它。因为加上这个分号可以避免 很多错倒例如不完整的输人)，开发人员也可以放心地通过删除多余的空格来压缩ECMAScript代码(代 码行结尾处没有分号会导致压缩错误)。另外，加上分号也会在某些情况下增进代码的性能，因为这样 解析器就不必再花时间推测应该在哪里插人分号了。

可以使用C风格的语法把多条语句组合到一个代码块中，即代码块以左花括号({)开头，以右花

if (test}{

test = false； alert(test);

}

虽然条件控制语句(如if语句)只在执行多条语句的情况下才要求使用代码块，供最佳实践是始 终在控制语句中使用代码块——即使代码块中只有一条语句，例如：

if (test)

alert (test) ；    //有效钽落易出错，不要使用

if (test) {    //推蒋使用

alert{test);

)

在控制语句中使用代码块可以让编码意图吏加清晰，而且也能降低修改代码时出错的儿率。

3.2关键字和保留字

ECMA-262描述了~-组具看特定用途的关键字，这些关键字可用于表示控制语句的开始或结束，或 者用于执行特定操作等。按照规则，关键字也是语言保留的，不能用作标识符。以下就是ECMAScript 的全部关键字(带*号上标的是第5版新增的关键字)：

| break     | do       | instanceof | typeof |
| --------- | -------- | ---------- | ------ |
| case      | else     | new        | var    |
| catch     | finally  | return     | void   |
| continue  | for      | switch     | while  |
| debugger* | function | this       | • with |
| default   | if       | throw      |        |
| delete    | in       | try        |        |

ECMA-262还描述丫另外一组不能用作标识符的保留宇。尽管保留字在这门语言中还没有任何特定 的用途，但它们有可能在将来被用作关键字。以下是ECMA-262第3版定义的全部保留字：

| abstract | enum       | int       | short        |
| -------- | ---------- | --------- | ------------ |
| boolean  | export     | interface | static       |
| byte     | extends    | long      | super        |
| char     | final      | native    | synchronized |
| class    | float      | package   | throws       |
| const    | goto       | private   | transient    |
| debugger | implements | protected | volatile     |
| double   | import     | public    |              |

第5版把在非严格模式下运行时的保留字编减为下列这些:

class    enum    extends    super

const    export    import

在严格模式下，第5版还对以下保留字施加了限制：

implements    package    public

interface    private    static

let    protected    yield

注意，let和yield是第5版新增的保留字；其他保留字都是第3版定义的。为了最大程度地保 证兼容性，建议读者将第3版定义的保留字外加let和yield作为编程时的参考。

在实现ECMAScript 3的JavaScript引擎中使用关键字作标识符，会导致"Identifier Expected"错误。 而使用保留字作标识符可能会也可能不会导致相同的错误，具体取决于特定的引擎。

第5版对使用戈键字和保留字的规则进行了少许修改，关键字和保留字虽然仍然不能作为标识、符使 用，但现在可以用作对象的属性名。一般来说，最好都不要使用关键字和保留字作为标识符和属性名， 以便与将来的ECMAScript版本兼容。

除了上面列出的保留字和关键字，ECMA-262第5版对eval和arguments还施加了限制。在严 格模式下，这两个名字也不能作为标识符或屈性名，否则会抛出错误。

3.3变量

ECMAScrjpt的变量是松敗类型的，所谓松散类型就是可以用来保存任何类型的数据。换句话说， 每个变量仅仅是一个用于保存值的占位符而已。定义变量时要使用var操作符(注意var是一个关键 字)，后跟变泉名(即一个识符)，如下所乐：

var message；

这行代码定义了一个名为message的变量，该变量可以用来保存任何值(像这样未经过初始化的 变量，会保存一个特殊的值——undefined,相关内容将在3.4节讨论)。ECMAScript也支持直接初始 化变量，W此在定义变量的同时就可以设置变量的值，如下所示：

var message = "hi";

在此，变message中保存了一个字符串值，hi •。像这样初始化变量并不会把它标记为字符串类型; 初始化的过程就是给变量赋一个值那么简单。因此，可以在修改变量值的同时修改值的类型，如下所示：

var message = "hi";

message a 100;    //有效，住不推莕

在这个例子中.变童message 一开始保存了一个字符串值＞hi •,然后该值又被一个数字值100取 代。虽然我们+建议修改变fl•所保存值的类型，似这种操作在ECMAScript中完全有效。

有一点必须注意，即使用var操作符定义的变量将成为定义该变量的作用域中的局部变量。也就是 说，如果在函数中使用var定义一个变量，那么这个变量在函数退出后就会被销毁，例如：

function test(){    #

var message = "hi■; //局部变量

)

test()；

alert (message} ； // 姆误！

这里，变量message是在函数屮使用var定义的。当函数被调用时，就会创建该变量并为其赋值。 而在此之后，这个变fi又会立即被销毁，因此例子中的下一行代码就会导致错误。不过，可以像下面这 样省略var操作符，从而创建一个全局变.坡：

function test(){

message » "hi"; // 全南变责

)

test();

alert(message)? // "hi"

这个例子省略了 var操作符，因而message就成丫全局变量。这样，只要调用过一次test (＞函 数，这个变ft就宥了定义，就町以在函数外部的任何地方被访问到。

![img](E:/11.ProgramFiles/Typora/JavaScriptd8a70b8fbea1082c34809-12.jpg)

 

虽然省略var操作符可以定义全局变量，但这也不是我们推荐的做法。因为在局 部作用域中定义的全局变量很难维护，而且如果有意地忽略了 var操作符，也会由于 相应变量不会马上就有定义而导致不必要的混钆。给未经声明的交量賦值在严格模式 下会导致抛出ReferenceError钳误。

可以使用一条语句定义多个变量，只要像下面这样把每个变量(初始化或不初始化均可)用逗号分 隔开即可：

var message = *hi"r found = false, age = 29;

这个例子定义并初始化了 3个变泔。同样由于ECMAScript是松散类型的，因而使用不同类型初始 化$量的操作可以放在一条语句中来完成。虽然代码里的换行和变量缩进不是必需的，但这样做可以提 髙可读性。

在严格模式下，不能定义名为eval或arguments的变量，否则会导致语法错误。

3.4数据类型

ECMAScript中有5种简单数据类型(也称为基本数据类型):Undefined、Null、Boolean、Number.

和String。还有丨种复杂数据类姻-Object,Object本质上是由一组无序的名值对组成的。ECMAScript

不支持任何创建自定义类型的机制，而所有值最终都将是上述6种数据类型之一。乍一看，好像只有6 种数据类型不足以表示所有数据；但是，由于ECMAScript数据类型具有动态性，因此的确没有再定义 其他数据类型的必要了。

3.4.1 typeof 操作符

鉴于ECMAScript是松散类型的，因此需要有一种手段来检测给定变量的数据类型一typeof就 是负责提供这方面信息的操作符。对一个值使用typeof操作符可能返回下列某个字符串：

□    "undefined"-如果这个值未定义；

□    "boolean"-如果这个值是布尔值；

口 "string"-如果这个值是字符串；

□    "number"-如果迭个值是数值；

□    -object-——如果这个值是对象或null;

□    "function-——如果这个值是函数。

下面是几个使用typeof操作符的例子：

var message = "some string";

alert(typeof message)；    // "string"

alert (typeof (message));    // "string1*

alert(typeof 95);    // •number"

'JfypeoJExampleOl • htm

这几个例子说明，typeof操作符的操作数可以是变量(message),也可以是数值字面fi。注意， typeof是一个操作符而不是函数，因此例子中的圆括号尽管可以使用，但不是必需的。

有些时候，typeof操作符会返回一些令人迷惑但技术上却正确的值。比如，调用typeof null 会返回-obj ec t ‘•，因为特殊值nu 11被认为是~个空的对象引用。Safari 5及之前版本、Chrome 7及之 前版本在对正则表达成调用typeof操作符时会返冋"function”，而其他浏览器在这种情况下会返回 "object",

从技术角度讲，函数在ECMAScript中是对象，不是一种数据类型。然而，函数也 确实有一些特殊的属性，因此通过typeof搡作符来区分函数和其他对象是有必要的。

3.4.2 Undefined 类型

Undefined炎型只有一个值，即特殊的undefined。在使用var声明变量但未对其加以初始化时， 这个变贵的值就是undefined,例如：

, var message；

alert(message == undefined)； //true

UndefinedExampleOl .htm

这个例子只声明了变量message，但未对其进行初始化。比较这个变最与undefined字面量，结 果表明它们是相等的。这个例子与下面的例子是等价的：

var message s undefined;

alert(message == undefined)； //true

UndefinedExampleO2. htm

这个例子使用undefined值显式初始化了变量message。但我们没有必要这么做，因为未经初始 化的值默认就会取得undefined值。

一般而言，不存在需要星式地把一个变f设置为undefined值的情况。字面值 undefined的主要目的是用于比较，而ECMA-262第3版之前的版本中并没有规定 这个值。第3版U入这个值是为了正式区分空对象指针与未经初始化的变堂。

不过，包含undefined值的变量与尚未定义的变贵还是不一样的。看看下面这个例子: var message； //这•个变量声明之后默认取拜了 undefined值

//下面这个变量并没有声明

// var age

alert(message) ；    // "undefined"

alert (age) ；    // 产生铁误

 

UndefinedExampleO3. him

运行以上代码，第一个警告框会显示变量message的值，即’undefined-。而第二个警告框一 由于传递给alert ()函数的是尚未声明的变駐age—则会导致•个错误。对于尚未声明过的变量，只 能执行一项操作，即使用typeof操作符检测其数据类型(对未经声明的变量调用delete不会导致错 误，但这样做没什么实际意义，而&在严格模式下确实会导致错误)。

然而，令人困惑的是：对未初始化的变.厨执行typeof操作符会返冋undefined值，而对未声明 的变景执行typeof操作符同样也会返回undefined值。来看下面的例子：

var message; //这个变黃声明之后默认取拜了 undefined值

//下面这个变量并没有声明

// var age

alert (typeof message);    // "undefined11

alert(typeof age)/    /Z "undefined"

UndefinedExampleO4. htm

结果表明，对未初始化和未声明的变量执行typeof操作符都返回了 undefined值；这个结果有 其逻辑上的合理性。因为虽然这两种变量从技术角度看有本质区别，但实际上无论对哪种变量也不可能 执行真正的操作。

即便未初始化的变量会自动被賦子undefined值，担農式城初始化变量依然是 明货的选择。如果能够做到这一点，那么当typeof操作符返因"undefined"值时， 我们就知道被检測的变量还没有被声明，而不是尚未初始化。

3.4.3 Null 类型

Null类型是第二个只有一个值的数据类型，这个特殊的值是mill。从逻辑角度来看，null值表 示一个空对象指针，而达也正是使用typeof操作符检测null值时会返回"object"的原因，如下面 的例子所示：

var car = null； alert(typeof car);

// •object.

 

NullExampleOl. htm

如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为mill而不是其他值。这样 —来，只要立接检査null值就可以知道相应的变*是否已经保存了一个对象的引用，如下面的例子 所示：

if (car != null){

//对car对象执行某些操作

)

实际上，undefined值是派生A null值的，因此ECMA-262规定对它们的相等性测试要返回true： alert(null == undefined); //true

NuUExampleO2. htm

这里，位于null和undefined之间的相等操作符(==)总是返回true,不过要注意的是，这个 操作符出于比较的目的会转换其操作数(本章后面将详细介绍相关内容)。

尽管null和undefined有这样的关系，但它们的用途完全不同。如前所述，无论在什么情况下 都没有必要把一个变量的值城式地设置为undefined,可是同样的规则对null却不适用。换句话说， 只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值。这样做不仅可以 体现null作为空对象指针的惯例，而且也有助于进一步区分null和undefined。



3.4.4 Boolean 类型

Boolean类型是ECMAScript中使用得最多的一种类塑，该类型只有两个字面值：true和false。 这两个值与数字值不是一回事，因此true不一定等于1,而false也不一定等于0。以下是为变量賦 Boolean类型值的例子：

var found = true; var lost = false；

需要注意的是，Boolean类型的字面值true和false是区分大小写的。也就是说,True和False (以及其他的混合大小写形式)都不是Boolean值，只是标识符。

虽然Boolean类型的字面值只有两个，但ECMAScript中所有类型的值都有与这两个Boolean值 等价的值。要将一个值转换为其对应的Boolean值，可以凋用转型函数Boolean ()，如下例所示：

、 var message = "Hello world!■；

f var messageAsBoolean = Boolean(message);

BooleanExample01.htm

在这个例子中，字符串message被转换成了一个Boolean值，该值被保存在messageAsBoolean 变量中。可以对任何数据类瑠的值调用Boolean ()函数，而&总会返回一个Boolean值。至于返回的 这个值是true还是false,取决于要转换值的数据类型及其实际值。下表给出了各种数据类型及艽对 应的转换规则。

| 数据类型 | 转换为true的值 | 转换为false的值 |
| -------- | -------------- | --------------- |
| Boolean  | true           | false           |
| String   | 任何非空字符串 | • •(空字符串)   |

|           |                              | （续）                               |
| --------- | ---------------------------- | ------------------------------------ |
| 数据类型  | 转换为true的值               | 转换为false的值                      |
| Number    | 任何非零数字值（包括无穷大） | 0和NON （参见本章后面有关NaN的内容） |
| Object    | 任何对象                     | null                                 |
| Undefined | n/a①                         | undefined                            |

这些转换规则对理解流控制语句（如if语句）自动执行相应的Boolean转换非常重要，请看下面

var message = "Hello world!*； if (message){

alert ("Value is true”；

}

BooleanExample02. htm

运行这个示例，就会显示一个警告框，W为字符串message被自动转换成了对应的Boolean值 （true）。由于存在这种自动执行的Boolean转换，因此确切地知道在流控制语句中使用的是什么变量 至关重要。错误地使用一个对象而不是■•个Boolean值，就有可能彻底改变应用程序的流程。

3.4.5 Number 类型

Number类型应该是ECMAScript中最令人关注的数据类型了，这种类型使用IEEE754格式来表示 整数和浮点数值（浮点数值在某典语言中也被称为双精度数值）。为支持各种数值类型，ECMA-262定 义了不同的数值字面盘格式。

最基本的数值字面量格式是十进制整数，十进制整数可以像下面这样直接在代码中输人： var intNum = 55；    // 整数

除了以十进制表示外，整数还可以通过八进制（以8为基数）或十六进制（以16为基数）的字面值 来表示。其中，八进制字面值的第一位必须是零（0），然后是八进制数字序列（0~7）。如果字面值中的 数值超出了范围，那么前导零将被忽略，后面的数值将被当作十进制数值解析。请看下面的例子：

var octalNuml    =    070；    //    八进制的 56

var octalNum2    =    079；    //无效的八进制数值-解析为79

var octalNum3    =    08?    //无效的八进制数值——解析为8

八进制字面量在严格模式下是无效的.会导致支持的JavaScript引擎抛出错误u

十六进制字面值的前两位必须是Ox,后跟任何十六进制数字（0~9及A~F）。其中，字母A-F

可以大写，也可以小写。如下面的例子所示：

var hexNuml = OxA；    // 十六进制的 10

var hexNum2 = Oxlf ；    // 十六进制的 31

在进行算术计算时，所有以Aja制和十六进制表示的数值最终都将被转换成十进制数值。

①n/a （率N/A）,是not applicable的缩写，意思是“不适用”。

鉴于JavaScript中保存数值的方式，可以保存正零（+0）和负零（-0）。正零和 负零被认为相等，但为了读者更好地理解上下文，这里特别做此说明。

1 J孚点数值

所谓g点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。虽然小 数点前面可以没有整数，但我们不推荐这种写法。以下是浮点数值的几个例子：

var    floatNuml    =    1.1；

var    floatNum2    =    0.1；

var    floatNum3    =    .1；    // 有效，位不推其

由于保存浮点数值需要的内存空间是保存整数值的两倍,因此ECMAScript会不失时机地将浮点数值 转换为整数值。显然，如果小数点后面没有跟任何数宇，那么这个数值就可以作为整数值来保存。同样 地，如果浮点数值本身表示的就是一个幣数（如1.0）, 么该值也会被转换为整数，如下面的例子所示:

var floatNuml = 1.;    If小数点后面没有数字-解析为1

var floatNum2 = 10.0;    // 整数-解析为 10

对于那些极大或极小的数值，可以用e表示法（即科学计数法）表示的浮点数值表示。用6表示法 表示的数值等于e前面的数值乘以10的指数次蕃。ECMAScript中e表示法的格式也是如此，即前面是 一个数值（可以是整数也可以是浮点数），中间是一个大写或小写的字母E,后面是10的幂屮的指数， 该幂值将用来与前面的数相乘。下面是一个使用e表示法表示数值的例子：

var floatNum = 3.125e7;    // 等于 31250000

在这个例子中，使用e表示法表示的变量floatNum的形式虽然简洁，但它的实际值则是31250000。 在此，e表示法的实际含义就是“3.125乘以107”。

也可以使用e表示法表示极小的数值，如0.00000000000000003,这个数值可以使用更简洁的3e-17 表示。在默认情况下，ECMASctipt会将那些小数点后面带有6个零以上的浮点数值转换为以e表示法 表示的数值（例如，0.0000003会被转换成3e-7\,

浮点数值的最髙精度是17位小数，但在进行算术计算时其精确度远远不如整数。例如，0.1加0.2 的结果不是0.3,而是0.30000000000000004。这个小小的舍人误差会导致无法测试特定的浮点数值。 例如：

i£ (a + b == 0.3) {    //不*做这样的測试!

alert{"You got 0.3."};

}

在这个例子中，我们测试的是两个数的和是不是等于0.3。如果这两个数是0.05和0.25,或者是0.15 和0.15都不会有问题。而如前所述，如果这两个数是0.1和0.2,那么测试将无法通过。因此，永远不 要测试某个特定的浮点数值。

关于浮点数值计算会产生舍入误差的问题，有一点需要明确：这是使用基于 IEEE754数值的浮点计算的通病，ECMAScript并非独此一家；其他使用相同数值格 式的语言也存在这个问题。

2.数值范围

由于内存的限制.ECMAScript并不能保存世界上所有的数值。ECMAScript能够表示的最小数值保 存在Number.MIN_VALUE中一在大多数浏览器中，这个值是5e-324；能够表示的最大数值保存在 Number.MAX_VALUE中——在大多数浏览器中，这个值是1.7976931348623157e+308。如果某次计算的 结果得到了一个超出JavaScript数值范围的值，那么这个数值将被自动转换成特殊的infinity值。具 体来说，如果这个数值是负数，则会被转换成-infinity （负无穷），如果这个数值是正数，则会被转 换成Infinity （正无穷）。

如上所述，如果某次计算返回了正或负的Infinity值，那么该值将无法继续参与下一次的计算， 因为infinity不是能够参与计算的数值。要想确定-个数值是不是有穷的（换句话说，是不是位于最 小和最大的数值之间），可以使用isFiniteU函数。这个函数在参数位于最小与最大数值之间吋会返 回true,如下面的例子所示：

var result = Number.MAX_VALUE + Number.MAX„VALUE; alert（isFinite（result））； //false

尽管在汁算中很少出现某些值超出表示范围的情况，但在执行极小或极大数值的计算时，检测监控 这些值是可能的，也是必需的。

![img](E:/11.ProgramFiles/Typora/JavaScriptd8a70b8fbea1082c34809-13.jpg)

 

访问 Number • NEGATIVB_INFINITY 和 Number. POSITXVE_INFINITY 也可以 得到负和正Infinity的值。可以想见，这两个属性中分别保存着-Infinity和 Infinityo

3. NaN

NaN,即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操 作数未返冋数值的情况（这样就不会抛出错误了）。例如，在其他编程语言中，任何数值除以0都会导 致错误，从而停止代码执行。但在ECMAScript中，任何数值除以0会返回NaN,因此不会影响其他代 码的执行。

NaN本身有两个非同寻常的特点。首先，任何涉及NaN的操作（例如NaN/10 ）都会返冋NaN,这 个特点在多步计算中有可能导致问题。其次，NaN与任何值都不相等，包括NaN本身。例如，下面的代 码会返回false：

alert（KaN == NaN）; //false

针对NaN的这两个特点，ECMAScript定义了 isNaNG函数。这个函数接受一个参数，该参数可以 是任何类型，而函数会帮我们确定这个参数是否“不是数值"。isNaNU在接收到一个值之后，会尝试 将这个值转换为数值。某些不是数值的值会It接转换为数值，例如字符串。10•或Boolean值。而任何 不能被转换为数值的值都会导致这个函数返回true。请看下面的例子：

alert(isNaN(NaN))； alert(isNaN(lO))? alert(isNaN<■10•"; alert(isNaN("blue"))； alert(isNaN(true})；

 

"true

//false （10是一个数值） //false （可以祓特捩成数值10） //true （不能转换成数值） //false （可以被转换成数值1）

这个例子测试了 5个不同的值。测试的第--个值是NaN本身，结果当然会返间true。然后分别测 试了数值10和字符串-10、，结果这两个测试都返回I false. W为前者本身就是数值，而后者可以被 转换成数值。但是，字符串-blue•不能被转换成数值，因此函数返冋了 true。由于Boolean值true 可以转换成数值1,因此函数返回false。

尽管有点儿不可思议，但iBNaN＜）确实也适用于对象。在基于对象调用iaNaKO %/函数时，会首先调用对象的valueOfO方法，然后确定该方法返回的值是否可以转

换为数值。如果不能，则基于这个返因值再调用tostring＜＞方法，再测试返回值。 而这个过程也是ECMAScript中内置函数和操作符的一般执行流程，更详细的内容请 参见3.5节。

4.数值转换

有3个困数可以把非数值转换为数值：Number （＞、parselnt （）和parseFloat ＜）。第一•■"h函数， 即转型函数则mberO可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。这3个 函数对于同样的输人会有返回不同的结果。

Number （）函数的转换规则如下。

□如果是Boolean值，true和false将分别被转换为1和0。

□如果是数字值，只是简单的传人和返回。

□如果是null值，返回0。

□如果是undefined,返间NaN。

□如果是字符串，遵循下列规则：

■如果字符申中只包含数宇（包括前面带正号或负号的情况），则将其转换为十进制数值，即” 1-会变成1, -123”会变成123,而-011•会变成11 （注意：前导的零被忽略了）；

■如果字符串中包含有效的浮点格式，如》1.1%则将K转换为对应的浮点数值（同样，也会忽 略前导零）；

■如果字符串中包含有效的十六进制格式，例如™0xf»，则将其转换为相同大小的十进制整 数值；

■如果字符串是空的（不包含任何字符），则将其转换为0;

■如果字符串中包含除上述格式之外的字符，则将其转换为NaN。

□如果是对象，则调用对象的valueOf（＞方法，然后依照前面的规则转换返回的值。如果转换 的结果是NaN,则调用对象的toStringO方法，然后再次依照前面的规则转换返回的字符 串值。

根据这么多的规则便用Number （）把各种数据类型转换为数值确实有点复杂。下面还是给出几个異 体的例子吧。

var numl = Number("Hello world!");    //NaN

首先，字符串” Hello world!”会被转换为NaN,因为其中不包含任何有意义的数字值。空字符申 会被转换为0。字符串》000011»会被转换为11,因为忽略T其前导的零。最后，true值被转换为1。

![img](E:/11.ProgramFiles/Typora/JavaScriptd8a70b8fbea1082c34809-14.jpg)

 

一元加操作符（3.5.1节将介绍）的操作与Number （）品数相同。

由于Number!）函数在转换字符串时比较复杂而且不够合理，因此在处理整数的时候更常用的是 parselnt ＜）函数。parselnt （＞闲数在转换字符率时，更多的是看其是否符合数值模式。它会忽略字 符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parselnCO 就会返问NaN;也就是说，用parselnt （）转换空字符串会返回NaN （ Number （）对空字符返间0 ）。如 果第一个字符是数字字符，parselntl）会继续解析第二个字符，直到解析完所有后续字符或者遇到了 一个非数字字符。例如，■1234blue11会被转换为1234,因为-blue•会被完全忽略。类似地，-22.5» 会被转换为22,因为小数点并不是有效的数字字符。

如果字符串中的第一个字符是数字字符，parselntO也能够识别出各种整数格式（即前面讨论的 十进制、八进制和十六进制数）。也就是说，如果字符串以lx-开头且后跟数字字符，就会将其当作一 个十六进制整数；如果字符串以，0■•开头且后跟数字字符，则会将其当作_个八进制数来解析。

为7•更好地理解parseint （）函数的转换规则，下面给出—些例子：

| var numl : | =parselnt("1234blue"); | // 1234              |
| ---------- | ---------------------- | -------------------- |
| var num2 : | =parselnt(”■);         | // NaN               |
| var num3 : | =parselnt("OxA")；     | // 10 （十六进剌数） |
| var num4 : | =parselnt(22.5);       | "22                  |
| var num5 : | =parselnt("070■＞；    | // 56 （八进釗数）   |
| var num6 : | =parselnt("70")；      | // 70 （十进制数）   |
| var num7 : | =parselnt("Oxf•)；     | // 15 （十六进制数） |

Number ExampleO 5. htm

在使用parselnt（）解析像八进制字面的字符串时，ECMAScript 3和5存在分歧。例如：

//ECMAScript 3认为是56 （八进制），ECMAScript 5认为是0 （十进制） var num = parselnt{"070"）;

在ECMAScript 3 JavaScript引擎中，’’070 •被3成八进制字面fi，因此转换后的值是十进制的56。 而在ECMAScript 5 JavaScript引擎中,+ parselnt （）已经不具有解析八进制值的能力，因此前导的零会 被认为无效，从而将这个值当成，0«,结果就得到十进制的0。在ECMAScript5中.即使是在严格模式 下也会如此。

为了消除在使用parselnt （＞函数时可能导致的上述困惑，可以为这个函数提供第二个参数：转换 时使用的基数（即多少进制）。如果知道要解析的值是十六进制格式的字符串，那么指定基数16作为第 二个参数，可以保证得到正确的结果，例如：

var num = parselnt （■ OxAF" / 16） ;    "175

实际上，如果指定了 16作为第二个参数，字符串可以不带前面的-0x»,如下所示：

var numl = parselnt("AF* z 16); var num2 = parselnt{"AFfl)；

//175

//NaN

 

Number Examp le06. htm

这个例子中的第一个转换成功了，而第二个则失败了。差别在于第-个转换传人了基数，明确吿诉 parseint（）要解析一个十六进制格式的字符串；而第二个转换发现第一个字符不是数字字符，W此就 自动终止了。

指定基数会影响到转换的输出结果。例如：

| var  | numl =   | =parselnt(*10,， | 2H    | "2   | （按二进制解析）   |
| ---- | -------- | ---------------- | ----- | ---- | ------------------ |
| var  | nui(i2 s | =parselnt("10",  | 8};   | "8   | （按八进制解析）   |
| var  | num3 :   | =parselnt("10",  | 10);  | "10  | （按十进制解析）   |
| var  | num4 :   | =parselnt("10",  | 16)； | "16  | （按十六进制解析） |

NumberExampleO7.htm

不指定基数意味着让parselntU决定如何解析输人的字符串，因此为了避免错误的解析，我们建 议无论在什么悄况下都明确指定基数。

多数情况下，我们要解析的都是十进制数值， 非常必要的。

因此始终将10作为第二个参教是

 

与parseint （）困数类似，parseFloat ＜）也是从第一^t•字符（位置0）开始解析每个字符。而且 也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。也就是说，字符串中的第 一个小数点是有效的，而第二个小数点就是无效的丁，因此它后面的字符串将被忽略。举例来说， "22.34.5 ”将会被转换为22.34。

除了第一个小数点有效之外，parseFloat （）与parselntf）的第二个区别在于它始终都会忽略前导 的零。parseFloat （）可以识别前面讨论过的所有浮点数值格式，也包括十进制整数格式。但十六进制格 式的字符串则始终会被转换成0。由于parseFloat 0只解析I •进制值，因此它没有用第二个参数指定基 数的用法。最后还要注意一点：如果字符串包含的是一4"可解析为整数的数（没有小数点，或者小数点后 都焉零），parseFloat 0会返问整数。以下是使用parseFloat （）转换数值的几个典型示例。

var numl var num2 var niun3 var nun4 var num5 var nuin6

 

parseFloat( parseFloat( parseFloat( parseFloat( parseFloat( parseFloat(

 

"1234blue"); "OxA");

"22.51*); "22.34.5"); -0908.5*); -3.125e7n);

 

//1234 (整数) //0

//22.5

//22.34

//908.5

//31250000

 

NumberExampleO8. htm

3.4.6 String 类型

String类型用于表示由零或多个16位Unicode卞符组成的字符序列，即卞符串。字符串可以由双 引号（"）或单引号（|）表示，W此下面两种字符串的写法都是有效的：

var firstName = "Nicholas"； var lastName = 'Zakas';

与PHP中的双引号和单引号会影响对字符串的解释方式不同，ECMAScript屮的这两种语法形式没 有什么区别=用双引号表示的字符申和用单引号表示的字符串完全相同。不过，以双引号开头的字符串

也必须以双引号结尾，而以单引号开头的字符串必须以单引号结尾。例如，下面这种字符串表祐法会导 致语法错误：

var firstName = 'Nicholas"; //语法错误（左右引号必煉疚纪）

1.字符字面量

String数据类型包含一些特殊的字符字面ft，也叫转义序列，用于表示非打印字符，或者具有其 他用途的字符。这些字符字面tt如下表所示：

 

字面量______含 义

\n    换行

\t    制表

\b    空格

\r    回车

\f    进纸

\\    斜杠

V    单引号（•）.在用单引号表示的字符申中使用。例如：，He    said.    Vhey.\，•

\"    双引号（■）,在用双引号表示的字符串中使用。例如：-He    said，\-hey.\-"

\xnn    以十六进制代码nr表示的一个字符（其中n^/0〜F）。例如，\x41表示-A，

\unnnn    以十六进制代码nnnn表示的一个Unicode字符（其中0为0 ~ F）。例如，\u03a3表示希腊字符S

这些字符字面量可以出现在字符串中的任意位置，而且也将被作为一个字符来解析，如下面的例子 所示：

var text = "This is the letter sigma： \u03a3.■;

这个例子中的变量text有28个字符，其中6个字符长的转义序列表示I个字符。

任何字符串的长度都可以通过访问其length属性取得，例如： alert（text.length）; // ■出 28

这个属性返回的字符数包括16位字符的数目。如果字符串中包含双字节字符，那么length属性 可能不会精确地返回字符串中的字符数目。

2.字符串的特点

ECMAScript中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变 某个变最保存的宇符串，首先要销毁原来的宇符串，然后再用另一个包含新值的字符串填充该变景， 例如：

var lang = •Java"; lang = lang + "Script"；

以上示例中的变量lang开始时包含字符串-Java ■。而第二行代码把lang的值重新定义为-Java-与-Scrip.t••的组合，即1‘JavaScript’％实现这个操作的过程如下：首先创建一个能容纳10个字符的 新字符串，然后在这个字符串中填充-Java■和-Script■，敁后一步是销毁原来的字符串-Java•和字 符串-Script。，因为这两个字符串已经没用了。这个过程是在后台发生的，而这也是在某些旧版木的 浏览器(例如版本低于1.0的Firefox、IE6等)中拼接字符串时速度很慢的原因所在。但这些浏览器后 来的版本已经解决了这个低效率问题。

3.转换为字符$

要把一个值转换为一个字符串有两种方式。第一种是使用几乎每个值都有的toStringU方法(第 5章将讨论这个方法的特点)。这个方法唯一要做的就是返间相应值的字符申表现。来看下面的例子：

var age = 11；

var ageAsString = age, toString () ；    // 字符串 ”11"

var found = true；

var foundAsSLring - f ound. toString (, ；    // 字符亊•true”

SthngExample01.htm

数值、布尔值、对象和字符串值(没错.每个字符申也都有一个toString()方法，该方法返同字 符串的一个副本)都冇toString (＞方法。但null和undefined值没有这个方法。

多数悄况下，调用：.03匕1叩()方法不必传递参数。但是，在调用数值的toString ()方法时，可 以传递一个参数：输出数值的基数，默认情况下，toString ()方法以十进制格式返回数值的字符串表 示。而通过传递基数，toString ＜)可以输出以二进制、八进制、十六进制，乃至其他任意有效进制格 式表示的字符芈值、下而给出几个例了-：

| var num - 10;               |      |       |
| --------------------------- | ---- | ----- |
| alert(num.toString());      | //   | "10"  |
| alert{num.toString(2));     | //   | -1010 |
| alert (num. toString (8” ； | //   | "12"  |
| alert(num.toString(10));    | //   | -io-  |
| alert(num.toString(16))；   | //   | "a"   |

StringExampleO2. htm

通过这个例子可以看出，通过指定基数，toString ()方法会改变输出的值。而数值10根据基数的 不同.呵以在输出时被转换为不同的数值格式。注意，駄认的(没有参数的)输出值与指定基数10时 的输出倂相同。

在不知道要转换的值是不是null或undefined的情况下，还可以使用转型函数String。，这个 函数能够将任何类型的ffi转换为字符申。String ()函数遵循下列转换规则：

□如果值有toString (＞方法，则调用该方法(没侖参数)并返回相应的结果；

| □如果值是null，则返回"null*;□如果值是undefined,则返回"undefined 下面再看几个例子： |                |
| ------------------------------------------------------------ | -------------- |
| var valuel - 10; var value2 = true; var value3 = null； var value4; |                |
| alert(String(valuel))；                                      | // "10*        |
| alert(String(value2))；                                      | ""true"        |
| alert(String(value3));                                       | // "null"      |
| alert(String(value4));                                       | // "undefined" |

StringExampleO3. htm

这里先后转换了 4个值：数值、布尔值、null和undefined。数值和布尔值的转换结果与调用 toString()方法得到的结果相同。因为null和undefined没有toString (>方法，所以String<> 函数就返回了这两个值的字面量。

要把某个值特换为字符串，可以使用加号操作符(3.5节讨论)把它与一个字符 串(”《 )加在一起。

3.4.7 Object 类型

ECMAScript中的对象其实就是一组数据和功能的集合。对象可以远过执行new操作符后跟要创建 的对象类型的名称來创建。而创建Object类型的实例并为其添加属性和(或)方法，就可以创建fl定 义对象.如下所示：

var o : new Object()；

这个语法与Java中创建对象的语法相似；但在ECMAScript中，如果不给构造函数传递参数，则可 以省略后面的那一对圆括号。也就是说，在像前面这个示例一样不传递参数的情况下，完全可以省略那 对圆括号(但这不是推荐的做法)：

var o = new Object; //有效，位不抽荐省略圆托号

仅仅创建Object的实例并没有什么用处，似关键是要理解一个重要的思想：即在ECMAScript中， (就像Java中的java.lang.Object对象•样> Object类®!是所有它的实例的基础。换句话说， Object类型所具有的任何属性和方法也同样存在于更具体的对象中。

Object的每个实例都具有下列属性和方法。

□    Constructor：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数(constructor) 就是 Object (｝。

□    hasOwnProperty (propertyName):用于检査给定的屈性在当前对象实例中(而不是在变例 的原型中)是否存在。其中，作为参数的属性名(propertyWajne )必须以字符串形式指定(例 如：o.hasOwnProperty ("name") )o

□    isPrototypeOf (object):用于检査传入的对象是否是另一个对象的原型(第5章将讨论原 型)。

口 propertylsEnumerable (propertyName):用于检查给定的属性是卉能够使用for-in语句 (本章后面将会讨论)来枚举。与hasOwnProperty ()方法一样，作为参数的屈性名必须以字符 串形式指定。

□    toLocaleStringO：返回对象的字符串表示，该字符串与执行环境的地区对应。

□    toStringO :返回对象的字符串表示。

□    valueOfO：返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值 相同。

由于在ECMAScript中Object是所冇对象的基础，因此所有对象都具有这些基本的属性和方法。 第5章和第6章将详细介绍Obj ect与其他对象的关系。

从技术角度讲，ECMA-262中对象的行为不一定适用于JavaScript中的其他对象。 浏览器环境中的对象，比如BOM和DOM尹的对象，都属于宿主对象，因为它们是 由宿主实现提供和定义的。ECMA-262不资责定义宿主对象，因此宿主对象可能会也 可能不会继承Object。

3.5操作符

ECMA-262描述了一组用于操作数据值的操作符，包括算术操作符（如加号和减号）、位操作符、 关系操作符和相等操作符。ECMAScript操作符的与众不同之处在于，它们能够适用于很多值，例如字 符串、数字值、布尔值，茲至对象。不过，在应用于对象时,相应的操作符通常都会调用对象的valueOfO 和（或）toStringO方法，以便取得可以操作的值。

3.5.1 一元操作符

只能操作一个值的操作符叫做一元操作符。一元操作符是ECMAScript中最简单的操作符。

1.递增和递减操作符

递增和递减操作符直接借鉴自C,而且各有两个版本：前置型和后置型。顾名思义，前置型应该位 于要操作的变量之前，而后置型则应该位于要操作的变量之后。因此，在使用前置递增操作符给_个数 值加1时，要把两个加号（^）放在这个数值变量前面，如下所示：

var age = 29;

++age；

在这个例子中，前置递增操作符把age的值变成了 30 （为29加上了 1 ）。实际上，执行这个前置递 增操作与执行以下操作的效果相同：

var age = 29；

age a age <*> 1；

执行前置递减操作的方法也类似，结果会从一个数值中减去1。使用前置递减操作符时，要把两个 减号（--）放在相应变最的前面，如下所示：

var age - 29;

--age；

这样，age变量的值就减少为28 （从29中减去了 1 ）。

执行前置递增和递减操作时，变量的值都是在语句被求值以前改变的。（在计算机科学领域，这种 情况通常被称作副效应。）清看下面这个例子。

var age » 29;

var anotherAge = --age + 2；

alert(age); alert(anotherAge)；

//榆出28 //榆出30

 

IncrementDecrementExampleOl. htm

这个例子中变量anotherAge的初始值等于变量age的值前置递减之后加2。由于先执行了减法操 作，age的值变成了 28,所以再加上2的结果就是30。

由于前置递增和递减操作与执行语句的优先级相等，因此整个语句会从左至右被求值。再看一个例子:

var numl =2；

var num2 = 20;

var num3 = --numl + num2;    // 等于 21

var num4 = numl + niun2；    / / 等于 21

IncrementDecrementExampleO2. htm

在这里，num3之所以等于21是因为numl先减去了 1才与num2相加。而变量num4也等于21是 因为相应的加法操作使用了 numl减去1之后的值。

后置型递增和递减操作符的语法不变（仍然分别是w和--），只不过要放在变量的后面而不是前面。 后置递增和递减与前置递增和递减有一个非常重要的区别，即递增和递减操作是在包含它们的语句被求 值之后才执行的。这个区别在某些情况下不是什么问题，例如：

var age = 29；

age++/

把递增操作符放在变最后面并不会改变语句的结果，因为递增是这条语句的唯一操作。但是，当语 句中还包含其他操作时，上述区别就会非常明显了。请看下面的例子：

var numl =2; var num2 = 20;

var num3 - numl-- + num2;    // 等于 22

var nuin4 = numl + num2;    // 等于 21

IncrementDecrementExampleO3 .htm

这里仅仅将前置递减改成了后S递减，就立即可以看到差别。在前面使用前置递减的例子中，num3 和num4最后都等于21。而在这个例子屮，num3等于22, num4等于21。差别的根源在于，这里在计 算mm3时使用了 numl的原始值（2 ）完成了加法汁算，而num4则使用了递减后的值（1 ）。

所冇这4个操作符对任何值都适用，也就是它们不仅适用于整数，还可以用于字符串、布尔值、浮 点数值和对象。在应用于不同的值时，递减和递减操作符遵循下列规则。

□在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，再执行加减1的操作。字 符串变量变成数值变量。

□在应用于一个不包含有效数字字符的字符串时，将变量的值设置为NaN （第4章将详细讨论）。 字符串变量变成数值变量。

□在应用于布尔值false时，先将其转换为0再执行加减1的操作。布尔值变量变成数值变量。

□在应用于布尔值true ft-t,先将其转换为1再执行加减1的操作。布尔值变量变成数值变ft。

□在应用于浮点数值时，执行加减1的操作。

□在应用于对象时，先调用对象的valueOf （＞方法（第5章将详细讨论）以取得一个可供操作的 值。然后对该值应用前述规则。如果结果是NaN,则在调用toStringl）方法后再应用前述规 则。对象变量变成数值变量。

以下示例展示了上面的一些规则：

var si = "2";

var s2 = "z"；

var b = false;

var f = 1.1；

var o = {

valueOf: function() { return -1;

|       |      |                                                  |
| ----- | ---- | ------------------------------------------------ |
| sl++; | //   | 值变成数值3                                      |
| s2++; | //   | 值变成NaN                                        |
|       |      | 值变成数值i                                      |
| f —； |      | 值变成0.10000000000000009 (由于浮点舍人错误所致) |
| o——;  | //   | 值变成敫值-2                                     |

IncrementDecrementExampleO4、htm

2. •-元加和减操作符

绝大多数开发人员对•元加和减操作符都不会陌生，而且这两个ECMAScript操作符的作用与数学 书上讲的完全一样。一元加操作符以一个加号(+ )表示，放在数債前面，对数值不会产生任何影响， 如下面的例子所示：

var niun 25；

num = +num；    // 仍然是 25

不过，在对非数值应用一元加操作符时，该操作符会像Number ()转型函数一样对这个值执行转换。 换句话说，布尔值false和true将被转换为0和1，字符串值会被按照一组特殊的规则进行解析，而 对象是先调用它们的valueOf ()和(或)toStringO方法，挥转换得到的值。

下面的例子展示了对不同数据类型应用一元加操作符的结果：

var si = "01*; var s2 = °1,1"； var s3 = "z"; var b = false； var f s 1.1; var o = {

valueOf: function() { return -1;

}

| };si | =+sl;  |      | 值变成数值1       |
| ---- | ------ | ---- | ----------------- |
| s2   |        | //   | 值变成数值1.1     |
| s3   | =+s3； |      | 值变成NaN         |
| b =  | +b；   | //   | 值变成数值0       |
| f =  | 十f;   | //   | 值未变，仍然是1.1 |
| o -  |        | H    | 值变成数值-1      |

UnaryPhisMinusExampleOl. htm

~元滅操作符主要用于表示负数，例如将I转换成-1。下面的例子演示了这个简单的转换过程：

var num = 25; num = -num；

//变成了-25

 

在将一元减操作符应用于数值时，该值会变成负数（如上面的例子所示）。而当应用于非数值时， 一元减操作符遵循与一元加操作符相同的规则，最后再将得到的数值转换为负数，如下面的例子所示:

var si = "01";

var s2 = "1.1"；

var s3 = "z"；

var b = false；

var f = 1.1；

var o = {

valueOf: function. () { return -1；

}

| };   |         |      |                  |
| ---- | ------- | ---- | ---------------- |
| si   | =-sl;   | //   | 值变成了数值-1   |
| s2   | =ua2 ； | //   | 值窆成了数值-1.1 |
| s3   | =-s3;   | //   | 值变成了 NaN     |
| b =  | -b;     | //   | 值变成了数植0    |
| f =  | -f;     | //   | 变成T-1.1        |
| O s  | -o；    | //   | 值变成了数值1    |

UnaryPlusMinusExampleO2. htm

一元加和减操作符主要用于基本的算术运算，也可以像前面示例所展示的一样用于转换数据类型。

3.5.2位操作符

位操作符用于在最基本的层次上，即按内存中表示数值的位来操作数值。ECMAScript中的所有数 值都以IEEE-75464位格式存储，但位操作符并不直接操作64位的值。而是先将64位的值转换成32位 的整数，然后执行操作，最后再将结果转换冋64位。对于开发人员来说，由于64位存储格式是透明的， 因此整个过程就像是只存在32位的整数一样。

对于有符号的整数，32位中的前31位用于表示整数的值。第32位用于表示数值的符号：0表示正 数，1表示负数。这个表示符号的位叫做符号位，符号位的值决定了其他位数值的格式。其中，正数以 纯二进制格式存储，31位中的每一位都表示2的幂。第一位（叫做位0）表示2°,第二位表示21，以此 类推。没有用到的位以0填充，即忽略不计。例如，数值18的二进制表示是 00000000000000000000000000010010,或者更简洁的10010。这是5个有效位，这5位本身就决定了实 际的值（如图3-1所示）。

| 1    | 0    | 0    | 1    | 0    |
| ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |

(24xl) + (23x0) + (22x0) + (21xl) + (2°x0) 16+0 + 0 + 2 + 0

18

图3-1

负数同样以二进制码存储，但使用的格式是二进制补码。计箅一个数值的二进制补码，需要经过下 列3个步骤：

（1）    求这个数值绝对值的二进制码（例如，要求-18的二进制补码，先求18的二进制码）;

（2）    求二进制反码，即将0替换为1，将1替换为0;

（3）    得到的二进制反码加1。

要根据这3个步骤求得-18的二进制码，首先就要求得18的二进制码，BP:

0000 0000 0000 0000 0000 0000 0001 0010

然后，求其-二进制反码，即0和1互换：

mi mi mi mi mi mi mo noi

最后，二进制反码加1:

1111 1111 11X1 1111 1111 1111 1110 1101 1

1111 1111 1111 1111 1111 1111 1110 1110

这样，就求得了-18的二进制表示，BP 11111111111111111111111111101110。要注意的是，在处理有 符号整数时，是不能访问位31的。

ECMAScript会尽力向我们隐藏所有这些信息。换句话说，在以二进制字符串形式输出一个负数时, 我们看到的只是这个负数绝对值的二进制码前面加上了一个负号。如下面的例子所示：

var nuin = -18?

alert(num.toString(2));    // "-10010"

要把数值-18转换成二进制字符串时，得到的结果是《-10010%这说明转换过程理解了二进制补+ 码并将其以更合乎逻辑的形式展示r出来。

默认倩况下，ECMAScript中的所有整數都是有符号整数。不过，当然也存在无 符号整数。对于无符号整數来说，第32位不再表示符号，因为无符号整数只能是正 数。而且，无符号整数的值可以更大，因为多出的一位不再表示符号，可以用来表示 数值。

在ECMAScript中，当对数值应用位操作符时，后台会发生如下转换过程：64位的数值被转换成32 位数值.然后执行位操作，最后再将32位的结果转换回64位数值。这样，表面上看起来就好像是在操 作32位数值，就跟在其他语言中以类似方式执行二进制操作一样。但这个转换过程也导致了一个严重 的副效应，即在对特殊的NaN和Infinity值座用位操作时，这两个值都会被当成0来处理。

如果对非数值应用位操作符，会先使用Number （＞函数将该值转换为一个数值（自动完成），然后 再应用位操作。得到的结果将是一个数值。

1.按位非（NOT）

按位非操作符由_个波浪线（~）表示，执行按位非的结果就是返回数值的反码。按位非是 ECMAScript操作符中少数几个与二进制计算有关的操作符之一。下面看一个例子：

var numl = 25; var nura2 = ~numl； alert(num2);

 

// 二进制 00000000000000000000000000011001 It 二进制 11111111111111111111111111100110 // -26

BihviseNotExampleOl .htm

这里，对25执行按位非操作，结果得到了-26。这也聆证f按位非操作的本质：操作数的负值减1。 因此，下面的代码也能得到相同的结果：

var numl = 25;

var num2 = -numl - 1;

alert(num2);    // "-26*

虽然以上代码也能返回同样的结果，但由于按位非是在数值表示的最底层执行操作，因此速度更快。 2.按位与（AND〉

按位与操作符由一个和号字符（&）表示，它有两个操作符数。从本质上讲，按位与操作就是将两 个数值的每一位对齐，然后根据下表中的规则，对相同位置上的两个数执行AND操作：

| 第一个数值的位 | 第二个数值的位 | 结果 |
| -------------- | -------------- | ---- |
| 1              | 1              | 1    |
| I              | 0              | 0    |
| 0              | 1              | 0    |
| 0              | 0              | 0    |

简而言之，按位与操作只在两个数值的对应位都是1时才返回1,任何一位是0,结果都是0。 下面看一个对25和3执行按位与操作的例子：

var result = 25 & 3; alert(result);    //I

BitwiseAndExampleOl. htm

可见，对25和3执行按位与操作的结果是1。为什么呢？请看其底层操作.•

25 = 0000 0000 0000 0000 0000 0000 0001 1001 3 = 0000 0000 0000 0000 0000 0000 0000 0011

AND = 0000 0000 0000 0000 0000 0000 0000 0001

原来，25和3的二进制码对应位上只有一位同时是1,而其他位的结果fi然都是0,因此最终结果 等于1。

3.按位或（OR）

按位或操作符由一个竖线符号（I）表示，同样也有两个操作数。按位或操作遵循下面这个真值表。

| 第一个数值的位 | 第二个败值的位 | 结    果 |
| -------------- | -------------- | -------- |
| 1              | 1              | 1        |
| ]              | 0              | 1        |
| 0              | 1              | 1        |
| 0              | 0              | 0        |

由此可见，按位或操作在有--4•位是1的情况下就返间1,而只有在两个位都是0的情况下才返回0。 如果在前面按位与的例子中对25和3执行按位或操作，则代码如下所示：

var result =25 I 3; alert(result)；    //27

BitwiseOrExampleOl. htm

25与3按位或的结果是27:

25 = 0000 0000 0000 0000 0000 0000 0001 1001 3 = 0000 0000 0000 0000 0000 0000 0000 0011

OR 0000 0000 0000 0000 0000 0000 0001 1011

这两个数值的都包含4个1,因此可以把每个1直接放到结果中。二进制码11011等于十进制值27。

4.按位异或（XOR）

按位异或操作符由一个插人符号（A）表示，也有两个操作数。以下是按位异或的真值表。

| 第一个救值的位 | 第二个数值的位 | 结    果 |
| -------------- | -------------- | -------- |
| 1              | 1              | 0        |
| 1              | 0              | 1        |
| 0              | 1              | 1        |
| 0              | 0              | 0        |

按位异或与按位或的不同之处在于，这个操作在两个数值对应位t只有一个1时才返回1,如果对 应的两位都是1或都是0,则返回0。

对25和3执行按位异或操作的代码如下所示：

var result =25    3;

alert（result）；    //26

Bit^iseXorExampleOl .htm

25与3按位异或的结果是26,其底层操作如下所示：

25 = 0000 0000 0000 0000 0000 0000 0001 1001 3 = 0000 0000 0000 0000 0000 0000 0000 0011

XOR = 0000 0000 0000 0000 0000 0000 0001 1010

这两个数值都包含4个1,但第一位上则都是1,因此结果的第一位变成了 0。而其他位上的1在另 _个数值中都没有对应的1,可以直接放到结果中。二进制码11010等于十进制值26（注意这个结果比 执行按位或时小1 ）。

5.左移

左移操作符由两个小于号（《）表示，这个操作符会将数值的所有位向左移动指定的位数。例如， 如果将数值2 （二进制码为10）向左移动5位，结果就是64 （二进制码为1000000）,代码如下所示：

var oldValue = 2;    // 淨于二进制的 10

var newValue = oldValue « 5;    // 等于二进制的 1000000，十进制的 64

LeftShiftExampleO 1. htm

注意，在向左移位后，原数值的右侧多出了5个空位。左移操作会以0来填充这些空位，以便得到 的结果是一个完整的32位二进制数（见图3-2 ）。

隐藏的符号位    数值2

I ........1    ■

| \|o\|o\|o\|o\| | H    | o\|o\| | H    | o\|o\| | o\|o\|o\| | H    | loH  | H    | H    | \|o\|o\|o\| | H    | 0丨o\|o\| | H    | H    | 0    | H    | H    | N    | H    |
| -------------- | ---- | ------ | ---- | ------ | --------- | ---- | ---- | ---- | ---- | ----------- | ---- | --------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|                |      |        |      |        |           |      |      |      |      |             |      |           |      |      |      |      |      |      |      |

将数值2向左移动5位（得到64）



|ojo|o|o|o|o|o|o|o|ojo|o[o|o|o|o丨o|o|o|o|o|ojojo|o|i|i

以0填充

图3-2

注意，左移不会影响操作数的符号位。换句话说，如果将-2向左移动5位，结果将是-64,而非64。

6.有符号的右移

有符号的右移操作符由两个大于号（》）表示，这个操作符会将数值向右移动，但保留符号位（即 正负号标记）。有符号的右移操作与左移操作恰好相反，即如果将64向右移动5位，结果将变回2:

var oldValue = 64,-    // 等于二进制的 1000000

var newValue = oldValue » 5；    // 等于二进制的10，即十进釗的2

SignedRightShifiExampleO]. htm

同样，在移位过程中，原数值中也会出现空位。只不过这次的空位出现在原数值的左側、符号位的 右侧（见图3-3）。而此时ECMAScript会用符号位的值来填充所有空位，以便得到一个完整的值。

隐藏的符号位    数值64

|o|o|ojo[o|o|o|o|o|o|o丨o|o|o|o|o|o|o|o|o丨o|o丨0丨0丨0丨l|o丨0丨0丨0丨0丨0|

将数值64向右移动5位（得到2）

o|olo|olololo|olo|o!o|olo|o|o|olololololo,o|o|o|i|o

以0填充（符号位的值）

围3-3

7.无符号右移

无符号右移操作符由3个大于号（》>）表示，这个操作符会将数值的所有32位都向右移动。对正 数来说，无符号右移的结果与有符号右移相同。仍以前面有符号右移的代码为例，如果将64无符号右 移5位，结果仍然还是2:

var oldValue = 64:    // 等于二进制的 1000000

var newValue = oldValue »> 5;    // 等于二进制的10，即十进制的2

UnsignedRightShifiExampleOl. htm 但是对负数来说，情况就不一样了。首先，无符号右移是以0来填充空位，而不是像有符号右移那 样以符号位的值来填充空位。所以，对正数的无符号右移与有符号右移结果相同，但对负数的结果就不

-样了。其次，无符号右移操作符会把负数的二进制码当成正数的二进制码。而且，由于负数以其绝对 值的二进制补码形式表示，因此就会导致无符号右移后的结果非常之大，如下面的例子所示：

vor oldValue = -64;    // 等于二进制的 11111111111111111111111111000000

var newValue = oldValue »> 5;    // 等于十进制的 134217726

L/nsignedRightShiftExampleO2 .htm

这里，当对-64执行无符号右移5位的操作后，得到的结果是134217726。之所以结果如此之大， 是因为-64的二进制码为11111111111111111111111111000000,而且无符号右移操作会把这个二进制码当 成正数的二进制码，换算成十进制就是4294967232。如果把这个值右移5位，结果就变成了 00000111111111111111111111111110,即十进制的 134217726。

3.5.3布尔操作符

在一门编程语言中，布尔操作符的重要性堪比相等操作符。如果没有测试两个值关系的能力，那么 诸如if...else和循环之类的语句就不会有用武之地了。布尔操作符一共有3个:非（NOT ）、与（AND） 和或（OR）。

1.逻辑非

逻辑非操作符由一个叹号（！）表示，可以应用于ECMAScript中的任何值。无论这个值是什么数据 类型，这个操作符都会返回一个布尔值。逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再 对其求反。也就是说，逻辑非操作符遵循下列规则：

□如果操作数是一个对象，返回false;

□如果操作数是一个空字符串，返回true;

□如果操作数是一个非空字符申，返回false;

□如果操作数是数值0,返回true;

口如果操作数是任意非0数值（包括infinity ）,返回false;

□如果操作数是null,返回true;

□如果操作数是NaN，返回true;

□如果操作数是undefined,返回true。

下面几个例子展示了应用上述规则的结果：

| alert(!false);   | //   | true  |
| ---------------- | ---- | ----- |
| alert(!"blue")； | //   | false |
| alert(!0);       | //   | true  |
| alert(!NaN);     | //   | true  |
| alert (!'"*)；   | //   | true  |
| alert(112345);   | //   | false |

LogicalNotExampleO 1 .htm

逻辑操作符也可以用于将一个值转换为与其对成的布尔值。而同时使用两个逻辑非操作符，实际 上就会模拟Boolean （>转型函数的行为。其中，第一个逻辑非操作会基于无论什么操作数返回一个布 尔值，而第二个逻辑非操作则对该布尔值求反，于是就得到了这个值真正对应的布尔值。当然，最终结 果与对这个值使用Boolean!）函数相同，如下面的例子所示：

alert(!!"blue")；    //true

alert(!!0);    //false

alert(1!NaN)；    //false

alert{!!"");    //false

alert(!!12345);    //true

LogicalNotExample02. htm

2.逻辑与

逻辑与操作符由两个和号(&&)表示，有两个操作数，如下面的例子所示: var result = true && false;

逻辑与的真值表如下:

| 第一个操作数 | 第二个操作数 | 结 果 |
| ------------ | ------------ | ----- |
| true         | true         | true  |
| true         | false        | false |
| false        | true         | false |
| false        | false        | false |

逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况 下，逻辑与操作就不一定返M布尔值；此时，它遵循K列规则：

□如果第一个操作数是对象，则返回第二个操作数；

□如果第二个操作数是对象，则只有在第一个操作数的求值结果为true的情况下才会返冋该 对象；

□如果两个操作数都是对象，则返回第二个操作数；

□如果有一^操作数是null,则返回null;

□如果有一个操作数是NaN,则返回NaN;

□如果有一个操作数是undefined,则返回undefined。

逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。 对于逻辑与操作而言，如果第一个操作数是false,则无论第二个操作数是什么值，结果都不再可能是 true 了。来看下面的例子：

var found = true；

1 var result = (found && someUndefinedVariable);    "这里会发生错误

alert {result};    //这一行不会执行

LogicalA ndExampleOl. htm

在上面的代码中，巧执行逻辑与操作时会发生错误，因为变量someundefinedvariable没有声 明。由于变量found的值是true,所以逻辑与操作符会继续对变量someUndefinedVariable求值。 但someundefinedvariable尚未定义，因此就会导致错误。这说明不能在逻辑与操作中使用未定义 的值。如果像下面这个例中一样，将found的值设罝为false，就不会发生错误了：

var found ■ false;

//不会发生嫌误

 

var result = (found && someundefinedvariable); alert (result) ；    // 会执行(*false*)

LogicalA ndExampleO2. htm

在这个例中，警告框会显示出来。无论变量someUndefinedVariable有没有定义，也永远不 会对它求值，因为第一个操作数的值是false。而这也就意味着逻辑与操作的结果必定是false,根本 用不着再对&&右侧的操作数求值了。在使用逻辑与操作符时要始终铭记它是一个短路操作符。

3.逻辑或

逻辑或操作符由两个竖线符号(II)表示，有两个操作数，如下面的例子所示： var result = true I I false;

逻辑或的真值表如下：

| 第一个操作数 | 第二个操作数 | 结    果 |
| ------------ | ------------ | -------- |
| True         | true         | true     |
| True         | false        | true     |
| false        | true         | true     |
| false        | false        | false    |

与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返冋布尔值；此时，它遵循下 列规则：

□如果第一个操作数是对象，则返回第一个操作数；

□如果第-个操作数的求值结果为false,则返回第二个操作数；

□如果两个操作数都是对象，则返回第一个操作数；

口如果两个操作数都是null,则返回null;

□如果两个操作数都是NaN,则返回NaN;

□如果两个操作数都是undefined，则返回undefined。

与逻辑与操作符相似，逻辑或操作符也是短路操作符。也就是说，如果第一个操作数的求值结果为 true,就不会对第二个操作数求值了。下面看一个例子：

var found = true;

丨 var result = {found II someUndefinedVariable);    "不会发生辕误

alert (result); /Z 会执行

Logical OrExampleOl. htm

这个例子跟前面的例子一样，变量someUndefinedVariable也没有定义。但是，由于变量found 的值是true,而变量someUndefinedVariable永远不会被求值，因此结果就会檢出"true"。如果 像下面这个例子一样，把found的值改为false,就会导致错误：

var fouztd - false;

var result = (found I I someUndefinedVariable) ;    // 达里会发生嫌误

alert (result) ;    //这一行不会执行

LogicalOrExample02.htm

我们可以利用逻辑或的这一行为来避免为变量賦mill或undefined值。例如： var myObject = preferredObject II backupObject；

在这个例子中，变量myObject将被赋予等号后面两个值中的一个。变量pref erredObj ect中包 含优先IS给变量myObject的值，变量backupObj ect负责在pref erredObj ect中不包含有效值的

情况下提供后备值。如果preferredObject的值不是null,那么它的值将被賦给町Object;如果 是null,则将backupObject的值赋给myObjectoECMAScript程序的赋值语句经常会使用这种模式， 本书也将采用这种模式。

3.5.4乘性操作符

ECMAScript定义了 3个乘性操作符：乘法、除法和求模。这些操作符与Java、C或者Perl中的相 应操作符用途类似，只不过在操作数为非数值的情况下会执行自动的类型转换。如果参与乘法U货的某 个操作数不是数值，后台会先使用Number ()转型函数将其转换为数值。也就是说，空字符串将被当作 0,布尔值true将被当作1。

1.乘法

乘法操作符由一个星号(*)表示，用于计算两个数值的乘积。其语法类似于C,如下面的例7

所示:

var result = 34 * 56;

在处理特殊值的悄况下，乘法操作符遵循下列特殊的规则：

□如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而 如果只有一个操作数有符号，那么结果就是负数。如果乘积超过了 ECMAScript数值的表示范围， 则返回 Inf inity 或-Infinity;

□如果有一个操作数是NaN，则结果是NaN;

□如果是Inf inity与0相乘，则结果是NaN;

□如果是Inf inity与非0数值相乘，则结果是Infinity或-Infinity,取决于有符号操作数 的符号；

□如果是Infinity与Infinity相乘，则结果是Infinity;

□如果有-•个操作数不是数值，则在后台调用Number ()将其转换为数值，然后再应用上面的 规则。

2.除法

除法操作符由一个斜线符号(/)表示，执行第二个操作数除第一个操作数的计算，如下面的例子 所示：

var result = 66 / 11;

与乘法操作符类似，除法操作符对特殊的值也有特殊的处理规则。这些规则如下：

□如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而 如果只有一个操作数有符号，那么结果就是负数。如果商超过了 ECMAScript数值的表示范围， 则返岡 Inf inity 或-Infinity;

□如果有一个操作数是NaN,则结果是NaN;

U如果是Inf inity被Infinity除，则结果是NaN;

□如果是零被零除，则结果是NaN;

□如果是非零的有限数被零除，则结果是Infinity或-Infinity,取决于有符号操作数的符号； □如果是Infinity被任何非零数值除，则结果是Infinity或-Infinity,取决于有符号操作

数的符号；

□如果有一个操作数不是数值，则在后台调用Number ()将其转换为数值，然后再应用上面的规则。

3.求模

求模(余数)操作符由一个百分号(％)表示，用法如下：

var result = 26 % 5t    // 等于 1

与另外两个乘性操作符类似，求模操作符会遵循下列特殊规则來处理特殊的值：

□如果操作数都是数值，执行常规的除法计算，返回除得的余数；

□如果被除数是无穷大值而除数是有限大的数值，则结果是NaN;

□如果被除数是有限大的数值而除数是零，则结果是NaN;

□如果是Inf inity被Infinity除，则结果是NaN;

□如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数；

口如果被除数是零，则结果楚零；

□如果奋一个操作数不是数值，则在后台凋用Number ()将其转换为数值，然后再成用上面的规则。

3.5.5加性操作符

加法和减法这两个加性操作符应该说是编程语言中最简单的算术操作符了。但是在ECMAScript中， 这两个操作符却都有一系列的特殊行为。与乘性操作符类似，加性操作符也会在后台转换不同的数据类 型。然而，对于加性操作符而言，相应的转换规则还稍微有点复杂。

1.加法

加法操作符(+ )的用法如F所示：

' var result -1+2;

如果两个操作符都是数值，执行常规的加法计算，然后根据下列规则返回结果：

□如果有一个操作数是NaN,则结果是NaN;

□如果楚 Infinity 加 Infinity,则结果是 Infinity;

□如果是-Infinity 加-Inf inity,则结果是-Inf inity;

□如果是Infinity加-Infinity,则结果是NaN;

□如果是+o加+o,则结果是+0;

□如果是-0加-0,则结果是-0;

口如果是+0加-0,则结果是+0。

不过，如果有一个操作数是字符串，那么就要应用如下规则：

□如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；

□如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接 起來。

如果有•-个操作数是对象、数值或布尔值，则调用它们的tostringu方法取得相应的字符串值， 然后再应用前面关于字符串的规则。对于undefined和null,则分別调用String ()函数并取得字符 南"undefined"和"nul 1 •。

下面来举几个例子：

var resultl = 5 + 5；    //两个数值相加

alert{resultl);    // 10

var result2 = 5 + "5*; alert(result2)；

 

// 一个数值和一个字符申相加

// -55-

 

AddExampleOLhtm

以上代码演示了加法操作符在两种模式K的差别。第一行代码演示了正常的情况，即5+5等于10 （数值），但是，如果将一个操作数改为字符串》5•,结果就变成了。55-（字符串值〉，因为第一个操作

数也被转换成了 ”5”。

忽视加法操作中的数据类型是ECMAScript编程中错常见的一个错误。再来看一个例子: var numl = 5;

var num2 = 10；

var message = "The sum of 5 and 10 is ■+ numl + num2; alert(message)；    // "The sum of 5 and 10 is 510"

 

AddExampleO2. htm

在这个例子中，变ft message的值是执行两个加法操作之后的结果。有人可能以为最后得到的字 符串是*The sum of 5 and 10 is 15",但实际的结果却是wThe sum of 5 and 10 is 510*。 之所以会这样，是因为每个加法操作是独立执行的。第一个加法操作将一个字符串和一个数值（5）拼 接了起来，结果是一个字符串。而第二个加法操作又用这个字符串去加另一个数值（10）,当然也会得 到一个字符串。如果想先对数值执行算术计算，然后再将结果与字符串拼接起来，应该像下面这样使用 圆括号：

var numl = 5；

var num2 = 10;

var message = "The sum of 5 and 10 is " + (aiusl -t- suza2) /

alert(message)；    //"The sum of 5 and 10 is 15*

AddExampleO3. htm

在这个例子中，一对岡括号把两个数值变fi括在了一起，这样就会告诉解析器先计算其结果，然后 再将结果与字符串拼接起来。因此，就得到了结果-The sum of 5 and 10 is 15%

2威法

减法i作符（-）是另一个极为常用的操作符，其用法如下所示： var result =2-1；

与加法操作符类似，ECMAScript中的减法操作符在处理各种数据类型转换时，同样需要遵循一些 特殊规则，如下所示：

□如果两个操作符都是数值，则执行常规的算术减法操作并返回结果；

□如果有一个操作数是NaN，则结果是NaN;

□如果是Infinity减Infinity,则结果是NaN;

□如果是-Infinity减-Infinity,则结果是NaN;

□如果是 Infinity 减-Infinity,则结果是 Infinity;

□如果是-Infinity 减 Infinity,则结果是-Infinity;

□如果是+0减+0,则结果是+0;

□如果是+0减-0,则结果是-0;

□如果是-0减-0,则结果是+0;

□如果有一个操作数是字符串、布尔值、null或undefined,则先在后台调用Number （＞函数将 其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是NaN,则减法的结果 就是NaN;

□如果有一个操作数是对象，则调用对象的valueOfO方法以取得表示该对象的数值。如果得到 的值是NaN,则减法的结果就是NaN。如果对象没有valueOf （＞方法，则调川其toString （＞ 方法并将得到的字符串转换为数值。

下面几个例子展示了上面的规则：

| var  | resultl | =5 - | true;  | //   | 4,   | 因为true被柃换成了 1 |
| ---- | ------- | ---- | ------ | ---- | ---- | -------------------- |
| var  | results | =NaN | -1;    | //   | NaN  |                      |
| var  | result3 | =5 - | 3;     |      | 2    |                      |
| var  | result4 | =5 - | • •.»  |      | 5,   | 因为• •祓转挨成了 0  |
| var  | result5 | =5 - | "2*;   | //   | 3,   | 因为"2•被特换成了 2  |
| var  | result6 | =5 - | null； | //   | 5,   | 因为null被转换成了 0 |

SubtractExample01.htm

3.5.6关系操作符

小于（＜）、大于（＞）、小于等于（＜=）和大于等于（＞=）这几个关系操作符用于对两个值进行比

较，比较的规则与我们在数学课上所学的一样。这几个操作符都返回一个布尔值，如下面的例子所示：

var resultl = 5 ＞ 3;    //true

var result2 = 5 ＜ 3；    //false

RelationalOperatorsExampleOI.    中包含本节所有的代码片段

与ECMAScript中的其他操作符一样，当关系操作符的操作数使用了非数值时，也要进行数据转换 或完成某些奇怪的操作。以下就是相应的规则。

□如果两个操作数都是数值，则执行数值比较。

□如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。

□如果一个操作数是数值.则将另一个操作数转换为一个数值，然后执行数值比较。

□如果一个操作数是对象，则调用这个对象的valueOf（）方法，用得到的结果按照前面的规则执 行比较。如果对象没有valueOfO方法，则调川toString （）方法，并用得到的结果根据前面 的规则执行比较。

□如果个操作数是布尔值，则先将其转换为数值，然后再执行比较。

在使用关系操作符比较两个字符串时，会执行一种奇怪的操作。很多人都会认为，在比较字符串值 时，小于的意思是“在字母表中的位置靠前”，而大于则意味着"在字母表中的位置靠后”，但实际上完 全不是那么回事。在比较字符串时，实际比较的是两个字符串中对应位置的每个字符的字符编码值。经 过这么一番比较之后，押返回一个布尔值。由于大写字母的字符编码全部小于小写字母的字符编码，因 此我们就会看到如下所示的奇怪现象：

var result

 

"Brickn < "alphabet"；

 

//true

 

在这个例子中，宇符串-BricV被认为小于字符串-alphabet%原因是字母B的字符编码为66, 而字母a的字符编码是97。如果要真正按字母表顺序比较字符串，就必须把两个操作数转换为相同的大 小写形式（全部大写或全部小写），然后再执行比较，如下所示：

var result = "Brick".toLowerCase（） < "alphabet■.toLowerCase（）； //false

通过将两个操作数都转换为小写形式，就可以得出-alphabet”按字母表顺序排在-Brick•之前的

正确判断了。

另•-种奇怪的现象发生在比较两个数字卞符串的情况下，比如下面这个例子: var result = ■23* < "3"； //true

确实，当比较字符串”23•是否小于-3•时，结果居然是true。这是W为两个操作数都是字符串， 而字符串比较的是字符编码（-2■的字符编码是50,而”3•的字符编码是51 ）。不过，如果像下面例子 中一样，将一个操作数改为数值，比较的结果就正常了：

var result = "23" < 3; //false

此时，字符串”23”会被转换成数值23,然后再与3进行比较，因此就会得到合理的紹果。在比较 数值和字符串时，字符串都会被转换成数值，然后再以数值方式与另一个数值比较。当然，这个規则对 前面的例子是适用的a可是，如果那个字符串不能被转换成-个合理的数值呢？比如：

var result = Ba" < 3；    // false,因为"a"被特换成了 NaN

由于字母a •不能转换成合理的数值，因此就被转换成了 NaN。根据规则，任何操作数与NaN进行 关系比较，结果都是false。于是，就出现了下面这个有意思的现象：

var resultl = NaN < 3; //false var result2 = NaN >= 3; //false

按照常理，如果一个值不小于另一个值，则一定是大于或等于那个值。然而，在与NaN进行比较时， 这两个比较操作的结果都返冋了 false。

3.5.7相等操作符

确定两个变量是否相等是编程中的一个非常甫要的操作。在比较字符串、数值和布尔值的相等性时, 问题还比较简单。但在涉及到对象的比较时，问题就变得复杂了。最早的ECMAScript中的相等和不等 操作符会在执行比较之前，先将对象转换成相似的类型。后来，有人提出了这种转换到底是否合理的质 疑。最后，ECMAScript的解决方案就是提供两组操作符：相等和不相等~先转换再比较，全等和不 全等一（X比较而不转换。

1.相等和不相等

ECMAScript中的相等操作符由两个等于兮（==）表禾，如果两个操作数相等，则返回true。而不 相等操作符由叹号后跟等于号（！=）表示，如果两个操作数不相等，则返冋true。这两个操作符都会 先转换操作数（通常称为强制转型），然后再比较它们的相等性。

在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则：

□如果有--个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0,而 true转换为1;

□如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值； □如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf(＞方法，用得到的基本类

型值按照前面的规则进行比较；

这两个操作符在进行比较时则要遵循下列规则。

□ null和undefined是相等的。

□要比较相等性之前，不能将null和undefined转换成其他任何值。

□如果有一个操作数是NaN，则相等操作符返回false，而不相等操作符返回true。重要提示： 即使两个操作数都是NaN,相等操作符也返回false;因为按照规则，NaN不等于NaN。

□如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象， 则相等操作符返网true;否则，返回false。

下表列出了一些特殊情况及比较结果：

|          | 表达式    | 值             | 表达式  | 值   |       |
| -------- | --------- | -------------- | ------- | ---- | ----- |
| null     | undefined | true           | true == | 1    | true  |
| ■NaN"    | ==NaN     | false          | true == | 2    | false |
| 5 == NaN | false     | undefined == 0 | false   |      |       |
| NaN =    | NaN       | false          | null == | 0    | false |
| NaN !    | :NaN      | true           | "5"==5  |      | true  |
| false    | ==0       | true           |         |      |       |

2.全等和不全等

除了在比较之前不转换操作数之外，全等和不全等操作符与相等和不相等操作符没有什么区别。全 等操作符由3个等于号(===)表示，它只在两个操作数未经转换就相等的情况下返回true,如下面的 例子所示：

var resultl = ("55* == 55);    //true,因为转换后相等

1 var result2 = ("55" === 55) ；    //false*因为不同的数据类型不相等

Equality Operators Example02. him

在这个例子中，第一个比较使用的是相等操作符比较字符串，55,和数值55,结果返回了 true。如 前所述，这是因为字符串-55••先被转换成了数值55,然后再与另一个数值55进行比较。第二个比较使 用了全等操作符以不转换数值的方式比较同样的字符串和值。在不转换的情况下，字符串当然不等于数 值，因此结果就是false。

不全等操作符由一个叹号后跟两个等于号(！==)表示，它在两个操作数未经转换就不相等的情况 下返回true。例如：

var resultl = ("55" 1= 55);    //false,因为转换后相等

1 var result2 ®    55) ; //true,因为不同的数据类焚不相等

EqualityOperatorsExample03. htm

在这个例子中，第一个比较使用了不相等操作符，而该操作符会将字符串”55”转换成55,结果就 与第二个操作数(也足55)相等了。而由于这两个操作数被认为相等，因此就返回了 false。第二个 比较使用了不全等操作符。假如我们这样想：字符串55与数值55不相同吗？，那么答案一定是：是的 (true )o

记住：null == undefined会返回true,因为它们是类似的值；但null === undefined会返

冋false,因为它们是不同类型的值。

由于相等和不相等操作符存在类型转换问題，而为了保持代码中数据类型的完整 我们推荐使用全等和不全等操作符。

3.5.8条件操作符

条件操作符应该其是ECMAScript中最灵活的一种操作符了，而且它遵循与Java中的条件操作符相 同的语法形式，如下面的例子所示：

variable = boolean_expression ? true_value : false_value；

本质上，这行代码的含义就是基于对boolean_expression求值的结果，决定给变量variable 陚什么值。如果求值结果为true,则给变量variable赋true_value值；如果求值结果为false, 则给变量variable轼false_value值。再看-个例子：

var max = （numl > num2） ? numl : num2；

在这个例子中，max中将会保存一个最大的值。这个表达式的意思是：如果numl大于num2 （关 系表达式返回true ），则将numl的值赋给max;如果numl小于或等于num2（关系表达式返回false ）, 则将num2的值轼给maxo

3.5.9赋值操作符

简单的賦值操作符由等于号（=）表示，其作用就是把右侧的倩賦给左侧的变量，如下面的例子所示: var num = 10?

如果在等于号（=）前面再添加乘性操作符、加性操作符或位操作符，就可以完成复合赋值操作。 这种复合拭值操作相当于是对下面常规表达式的简写形式：

var num = 10； num = num + 10;

其中的第二行代码可以用一个复合赋值来代替：

var num = 10； num += 10；

每个主要算术操作符（以及个别的其他操作符）都有对应的复合赋值操作符。这些操作符如下所示: □繡值（*=）;

□除/赋值（/=）;

□模/赋值“=）;

□加/赋值（+=）;

□减/赋值（-=）;

□左移/赋值（«=）;

□有符号右移/賦值（>>=）;

□无符号右移/赋值（»>= ）□

设计这些操作符的主要H的就是简化赋值操作。使用它们不会带来任何性能的提升。

3.5.10逗号操作符

使用逗号操作符可以在一条语句中执行多个操作，如下面的例子所示： var numl=l, nura2=2, num3=3;

逗号操作符多用于声明多个变量；但除此之外，逗号操作符还可以用于赋值。在用于赋值时，逗号 操作符总会返回表达式中的最后一项，如卜面的例子所东：

var nun = （5, 1, 4, 8, 0）; // num 的值为 0

由于0是表达式中的嚴沿一项，因此nwn的值就足0。虽然逗号的这种使用方式并不常见，但这个 例子可以帮我们理解逗号的这种行为。

3.6语句

ECMA-262规定了一组语句（也称为流控制语句）。从本质上看，语句定义了 ECMAScript中的主要 语法，语句通常使用一或多个关键字来完成给定任务。语句可以很简单，例如通知函数退出；也可以比 较复杂，例如指定重复执行某个命令的次数。

3.6.1 if 语句

大多数编程语言中最为常用的-十语句就足-if语句。以下是if语句的语法：

if （condition） statement! else statement2

其中的condition （条件）可以是任意表达式；而且对这个表达式求值的结果不一定是布尔值。 ECMAScript会自动调用Boolean （）转换阐数将这个表达式的结果转换为一个布尔值。如果对condition 求值的结果是true,则执行statement 1（语句1 ）,如果对condition求值的结果是false,则执行statement2 （语句2 ）。而且这两个语句既可以是一行代码，也可以是一个代码块（以一对花括号括起来的多行代碑）。 请看下面的例子。

if (i > 25)

alert ("Greater than 25.”；    // 单行语句

else {

alert ("Less than or equal to 25.");    // 代姆块中的语句

}

IfStatementExampleOl，htm

不过，业界普遍推崇的最佳实践是始终使川代码块，即使要执行的只有一行代码。W为这样可以消 除人们的误解，否则可能让人分不清在不同条件下要执行哪些语句。

另外，也可以像下面这样把整个if语句写在一行代码中：

if (conditionl) statementl else if (condiLion2) stateraent2 else statements

但我们推荐的做法则是像下面这样：

if (i > 25) {

alert ( "Greater than 25.”；

} else if (i < 0) {

alert(■Less than 0.”)；

} else {

alert("Between 0 and 25, inclusive.");

}

IfStatementExampleO2. htm

3.6.2 do-while 语句

do-while语句娃一种后测试循环语句，即只有在循环体中的代码执行之后，才会测试出口条件。 换句话说，在对条件表达式求值之前，循环体内的代码至少会被执行-次。以下是do-while语句的 语法：

do {

statement

} while (expression);

下面是一个示例：

var i = 0； do {

i += 2;

} while (i < 10);

alert(i);

Do WhileSiatementExampleQl.htm

在这个例子中，只要变tt i的值小于10,備环就会一直继续下去。而且变量i的值最初为0,每次 循环都会递增2。

情形

 

do-while这种后测试循环语句最常用于循环体中的代码至少要被执行一次的

3.6.3 while 语句

while语句属于前测试循环语句，也就是说，在循环体内的代码被执行之前，就会对出口条件求值。 因引，循环体内的代码有可能永远不会被执行。以下是while语句的语法：

while(expression) statement 下面是一个示倒：

var i = 0； while (i < 10) {

i += 2 ；

}

WhileStatementExampleOL htm

在这个例子中，变量i开始时的值为0,每次循环都会递增2。而只要i的值小于10,循环就会继 续下去。

3.6.4 for 语句

for语句也是一种前测试循环语句，但它具有在执行循环之前初始化变量和定义循环后要执行的代 码的能力。以下是for语句的语法：

for {initialization； expression; post-loop-expression) statement 下面是一个示例： var count = 10;

for (var i = 0； i < count；    {

alert(i);

}

ForStatementExampleOl. htm

以上代码定义了变fi i的初始值为0。只有当条件表达式(i<count )返回true的情况下才会进 入for循环，因此也有可能不会执行循环体中的代码。如果执行了循环体屮的代码，则一定会对循环后 的表达式(i++)求值，即递增i的值。这个for循环语句与下面的while语句的功能相同：

var count = 10； var i = 0; while (i < count){

alert ⑴； i++；

}

使用while循环做不到的，使用for循环同样也做不到。也就是说，for循环只是把与循环有关 的代码集中在了一个位置。

有必要指出的是，在for循环的变量初始化表达式中，也可以不使用var关键字。该变量的初始 化可以在外部执行，例如：

var count = 10;

var if

for (1=0/ i < count; i++){

alert(i);

}

ForSiatementExampie02. htm

以上代码与在循环初始化表达式中声明变量的效果是一样的。由于ECMAScript中不存在块级作用 域(第4章将进一步讨论这一点)，因此在循环内部定义的变量也可以在外部访问到。例如：

var count = 10;

for (var i = 0； l < count； i++){

alert ⑴；

}

alert (i);    "10

ForStatementExample03. htm

在这个例子中，会有一个警吿框显示循环完成后变量i的值，这个值是10。这是因为，即使i是 在循环内部定义的一个变量，但在循环外部仍然可以访问到它。

此外，for语句中的初始化表达式、控制表达式和循环后表达式都是可选的。将这两个表达式全部 省略，就会创建一个无限循环，例如：

for (；；) {    //无限掮坏

doSomething()；

}

而只给出控制表达式实际上就把for循环转换成了 while循环，例如:

var count = 10; var i = 0;

for (; i < count ? H alert ⑴； i++;

\>

For StatementExample04. htm

由于for语句存在极大的灵活性，因此它也是ECMAScript中最常用的一个语句。

3.6.5 for-in 语句

for-in语句是一种精准的迭代语句，可以用来枚举对象的属性。以下是for-in语句的语法： for (property in expression) statement 下面是一个示例：

for (var propName in window) { document.write(propName);

}

ForlnStatemenfExampleOl .htm

在这个例子中，我们使用for-in循环來显示了 BOM中window对象的所有属性。每次执行循环 时，都会将window对象中存在的一个属性名赋值给变ft propName。这个过程会一直持续到对象中的 所有属性都被枚举一遍为止。与for语句类似，这里控制语句中的var操作符也不是必需的。但是, 为了保证使用局部变量，我们推荐上面例子中的这种做法。

ECMAScript对象的属性没有顺序。因此，通过 for-in循环瑜出的属性名的顺序是不可预测的。 具体来讲，所有属性都会被返回一次，但返凹的先后次序可能会因浏览器而异。

但是，如果表示要迭代的对象的变量值为null或undefined, for-in语句会抛出错误。 ECMAScript5更正了这一行为；对这种情况不再抛出错误，而只是不执行循环体。为了保证最大限度的

兼容性，建议在使用for-in循环之前，先检测确认该对象的值不是null或undefined。

Safari 3以前版本的for-in语句中存在一个bug,该bug会等致某些房性被返固

两次。

3.6.6 label 语句

使用label语句可以在代码中添加标签，以便将来使用。以下是label语句的语法:

label: statement

下面是一个示例.•

start: for (var i=0; i < count; i++) { alert(i);

}

这个例子中定义的start标签可以在将来由break或continue语句引用。加标签的语句一般都 要与for语句等循环语句配合使用。

3.6.7 break 和 continue 语句

break和continue语句用于在循环中精确地控制代码的执行。其中,break语句会立即退出循环， 强制继续执行循环后面的语句。而continue语句虽然也是立即退出檐环，但退出据环后会从循环的顶 部继续执行。请看下面的例子：

var num =0;

for (var i=l; i < 10; i++) { if <i % 5 == 0) {

break;

}

num++；

alert(num)；    Z/4

BreakStatementExampleOl • htm

这个例子中的for循环会将变量i由1递增至10。在循环体内，有一个if语句检査i的值是否 可以被5整除(使用求模操作符)。如果是，则执行break语句退出循环。另一方面，变量num从0开 始，用于记录循环执行的次数。在执行break语句之后，要执行的下一行代码是alert ()函数，结果 显-示4。也就是说，在变量i等于5时，循环总共执行了 4次；而break语句的执行，导致了循环在 num再次递增之前就退出了。如果在这里把break替换为continue的话，则可以看到另一种结果：

var num = 0;

for (var i=l; i < 10； i++) { if (i % 5 == 0) {

continue^

num++;

}

alert(num);    //8

 

ContinueStatementExampleOl. htm

例+的结果显示8,也就是循环总共执行了 8次。当变tti等于5时，循环会在num再次递增之前 退出，但接下来执行的是下一次循环，即i的值等于6的游环。于是，循环又继续执行，直到i等于 10时自然结束。而num的最终值之所以是8,是因为continue语句导致它少递增了一次。

break和continue语句都可以与label语句联合使用，从而返回代码中特定的位置。这种联合 使用的情况多发生在循环嵌套的情况下，如下面的例子所示：

var num = 0；

outermost:

for (var i=0； i <

![img](E:/11.ProgramFiles/Typora/JavaScriptd8a70b8fbea1082c34809-16.jpg)

 

for (var j=0； if (i == 5

break

}

num++；

}

alert(num);    //55

BreakStatementExamp!eO2. htm

在这个例子中，outermost标签表示外部的for语句。如果每个循环正常执行10次，则num+ + 语句就会正常执行100次。换句话说，如果两个循环都自然结束，nun的值应该是100。但内部循环中 的break语句带了一个参数：要返回到的标签。添加这个标签的结果将导致break语句不仅会退出内 部的for语句(即使用变量j的循环)，而旦也会退出外部的for语句(即使用变量i的循环)。为此, 当变量i和：j都等于5时，num的值正好是55。同样，continue语句也可以像这样与label语句联 用，如下面的例子所示：

var num =0;

outermost:

for (var i=0； i < 10; i++) {

for (var j=0; j < 10; j++) {

if (i == 5 && j == 5) {

continue outermost;

}

num++?

.}

alert(num)；    //95

在这种情况下，continue语句会强制继续执行循环一退出内部循环，执行外部循环。当j是5 时，continue语句执行，而这也就意味着内部循环少执行了 5次，因此num的结果是95„

虽然联用break, continue和label语句能够执行复杂的操作，但如果使用过度，也会给调试 带來麻烦。在此，我们建议如果使用label语句，一定要使用描述性的标签，同时不要嵌套过多的循环。

3.6.8 with 语句

with语句的作用是将代码的作用域设置到一个特定的对象中。with语句的语法如下：

with (expression) statement；

定义with语句的目的主要是为了简化多次编写同一个对象的工作，如下面的例子所示:

var qs = location.search.substring(1)；

var hostName = location.hostname；

var url = location.href;

上面几行代码都包含location对象。如果使用with语句，可以把上面的代码改写成如下所示:

with(location){

var qs = search.substring(1)； var hostName = hostname? var url = href;

WithStatementExamp!eO 1. htm

在这个重写后的例子中，使用With语句关联了 location对象。这意味若在with语句的代码块 内部，毎个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变S的定义，就会査询 location对象中是否有同名的《性。如果发现了同名属性，则以location对象属性的值作为变量的值。

严格模式下不允许使用with语句，否则将视为语法错误。

由于大量使用with语句会导致性能下降，同时也会给调试代码造成困难，因此 在开发大型应用程序时，不建议使用with语句。

3.6.9 switch 语句

switch语句与if语句的关系最为密切，而且也是在其他语言中普遍使用的一种流控制语句。 ECMAScript中switch语句的语法与其他基于C的语言非常接近，如下所示：

switch (expression) { case value: statement

break;

case value: statement break;

case value: statement break?

case value： statement break；

default: statement

}

switch语句中的每一种情形(case)的含义是：“如果表达式等于这个值(value),则执行后面的 语句(statement )”。而break关键字会导致代码执行流跳出switch语句。如果省略break关键字， 就会导致执行完当前case后，继续执行下一个case。最后的default关键字则用于在表达式不匹配前 面任何一种情形的时候，执行机动代码(因此，也相当于一个else语句)。

从根本上讲，switch语句就是为了让开发人员免于编写像下面这样的代码：

if (i == 25){ alert("25")；

} else if (i == 35) { alert("35");

} else if (i == 45) { alert{"45");

} else {

alert("Other");

}

而与此等价的switch语句如下所示:

switch (i) { case 25:

alert C25")； break；

case 35:

alert("35"); break；

case 45:

alert(*45"); break?

default:

alert{"Other");

}

SwitchStatementExampleOl. htm

通过为每个case后面都添加一个break语句，就可以避免同时执行多个case代码的情况。假如确 实需要混合几种情形，不要忘了在代码中添加注释，说明你是有意省略了 break关键字，如下所示：

switch (i) { case 25:

/*合并两种锖形*/

case 35:

alert ("25 or 35”； break；

case 45:

alert(”45 ’)； break；

default:

alert("Other");

虽然ECMAScript中的switch语句借鉴自其他语言，但这个语句也有A己的特色。首先，可以在

switch语句中使用任何数据类型(在很多其他语言中只能使用数值)，无论是字符串，还是对象都没有

问题。其次，每个case的值不一定是常量，可以是变量，甚至是表达式。请看下面这个例子：

switch ("hello world") {

case "hello" + " world":

alert("Greeting was found."); break；

case "goodbye":

alert ("Closing was found，)； break;

default:

alert{"Unexpected message was found.*);

}

SwitchStatementExampleOS. htm

在这个例子中，switch语句使用的就是字符串。其中，第一种情形实际上是一个对字符串拼接操 作求值的表达式。由于这个字符串拼接表达式的结果与switch的参数相等，因此结果就会显示 "Greeting was found. 而且，使用表达式作为case值还可以实现下列操作：

var num = 25;

• switch (true) {

case num < 0:

alert("Less than 0.")? break；

case num >= 0 && num <= 10:

alert (■ Between 0 and 10.”； break；

case num > 10 && num <= 20;

alert("Between 10 and 20.")； break；

default:

alert ("More than 20.”；

}

SyvitchStatementExampleO4. htm

这个例子首先在switch语句外面声明了变量num。而之所以给switch语句传递表达式true, 是因为每个case值都可以返回一个布尔值。这样，每个case按照顺序被求值，直到找到匹配的值或者 遇到default语句为止(这正是这个例子的最终结果)。

switch语句在比较值时使用的是全等操作符， 字符串《10•不等于数值10)。

因此不会发生类型转换(例如，

 3.7函数

函数对任何语言来说都是一个核心的概念。通过函数可以封装任意多条语句，而且可以在任何地方、 任何时候调用执行。ECMAScript中的函数使用 function关键字来声明，后跟--组参数以及函数体。 函数的基本语法如下所示：

function functionName(argO, argl, " .,argN) { statements

}

以下是一个函数示例：

function sayHi(name, message) {

alert("Hello • + name + ■,• + message);

}

FunctionExampleOL htm

这个函数可以通过艽函数名来调用，后面还要加上一对圆括号和参数(圆括号中的参数如果有多个， 可以用逗号隔开)。调用sayHiO函数的代砰如下所示：

sayHi("NicholasM, *how are you today?");

这个函数的瑜出结果是"Hello Nicholas, how are you today?•。困数中定义中的命名参数name 和message被用作了字符串拼接的两个操作数，而结果最终通过警告框显示了出来。

ECMAScript中的函数在定义吋不必指定是否返回值。实际上，任何函数在任何时候都可以通过 return语句后跟要返问的值来实现返冋值。请看下面的例子：

function sum(numl, num2) { return numl + num2;

}

FunctionExample02. htm

这个sum<)函数的作用是把两个值加起来返回一个结果。我们注意到，除了 return语句之外，没 有任何声明表示该函数会返回一个值。调用这个函数的示例代码如下：

var result = sun(5, 10);

这个函数会在执行完return语句之后停止并立即退出。因此，位于return语句之后的任何代码 都永远不会执行。例如：

function sum(numl, num2) { return numl + num2 ；

alert (-Hello world");    // 永远不会执行

)

在这个例子中，由于调用alert 0函数的语句位于return语句之后，因此永远不会显示警告框。 当然，一个函数中也可以包含多个return语句，如下面这个例子中所示：

function diff(numl# num2) { if (numl < num2) {

return num2 - numl;

} else {

return numl - num2;

这个例子中定义的diff()函数用P汁算两个数值的差。如果第一个数比第二个小，则用第二个数 减第一个数否则，用第-•个数减第二个数„代码中的两个分支都具有自己的return语句，分别用于 执行正确的计算。

另外，return语句也可以不带有任何返回值。在这种情况下，函数在停止执行后将返回undefined 值。这种用法一般用在需要提前停止函数执行而又不需要返回值的情况下。比如在下面这个例子中，就 不会显示警告框：

function sayHi(name, message) {

return；

alert ("Hello " + name + " f " + message) ?    "永远不会诱用

}

FunctionExample04.htm

推荐的做法是要么让函数始终都返回一个值，要么永远都不要返回值。否则，如 果函数有时候返回值，有时候有不返回值，会给调试代码带来不便。

严格模式对函数有一些限制：

□不能把函数命名为eval或arguments;

□不能把参数命名为eval或arguments;

□不能出现两个命名参数同名的情况。

如果发生以上情况，就会导致语法错误，代码无法执行。

3.7.1理解参数

ECMAScript函数的参数与大多数其他语言中函数的参数有所不同。ECMAScript函数不介意传递进 来多少个参数，也不在乎传进来参数是什么数据类型。也就是说，即便你定义的函数只接收两个参数， 在调用这个函数时也未必一定要传递两个参数。可以传递一个、三个甚至不传递参数，而解析器永远不 会有什么怨言。之所以会这样，原因是ECMAScript中的参数在内部是用一个数组来表示的。函数接收 到的始终都是这个数组，而不关心数组中包含哪些参数(如果有参数的话)。如果这个数组中不包含任 何元素，无听谓；如果包含多个元素，也没有问题。实际上，在函数体内可以通过arguments对象来 i方问这个参数数组，从而获取传递给函数的毎一个参数。

其实，arguments对象只是与数组类似(它并不是Array的实例)，因为可以使用方括号语法访 问它的每一个元素(即第一个元素是arguments [0],第二个元索是argumetns [1],以此类推)，使 用length属性来确定传递进来多少个参数，在前面的例子中，sayHi 0蛾数的第一个参数的名字叫 name,而该参数的值也可以通过访问arguments [0]来获取。W此，那个函数也可以像下面这样重写， 即不显式地使用命名参数：

function sayHi() {

alert("Hello " + arguments[0] +    + arguments f1]);

这个重写后的函数中不包含命名的参数。虽然没有使用name和message标识符，但函数的功能 依旧。这个事实说明rECMAScript函数的一个重要特点：命名的参数只提供便利，但不是必：的。另 外，在命名参数方面，其他语言可能需要事先创建一个函数签名，而将来的调用必须与该签名一致。但 在ECMAScript中，没有这些条条框框，解析器不会验证命名参数。

通过访问arguments对象的length属性可以获知有多少个参数传递给了函数。下面这个函数会 在每次被调用时，输出传入丼中的参数个数：

function howManyArgs() {

alert(arguments.length);

}

howManyArgs(wstring", 45); //2 howManyArgs(); //0 howManyArgs(12); //I

FunctionExample06. htm

执行以上代码会依次出现3个警告•框，分别显示2、0和1。由此可见，开发人员可以利用这一点让 函数能够接收任意个参数并分别实现适当的功能。请肴下面的例子：

function doAdd()    {

if(arguments.length == 1) {

alert(arguments(0] + 10);

} else if (arguments.length == 2) {

alert(arguments[0】+ arguments[1])?

}

＞

doAdd (10》；    "20

doAdd(30, 20)；    //50

FunctionExample07. htm

函数doAdd(＞会在只有一个参数的情况r给该参数加上io;如果是两个参数，则将那个参数简单 相加并返回结果。因此，doAdd (10＞会返回20，而doAdd(30,20＞则返回50。虽然这个特性算不上完 美的重载.但也足够弥补ECMAScript的这一缺憾了。

另一个与参数相关的重要方面，就是arguments对象可以与命名参数-•起使用，如下面的例子所示：

function doAdd(numl, num2) {

if (argxuaents. length 1) ＜

alert(numl + 10);

} else if (argrm&ents. length == 2) {

alert(arguments[0] ♦ num2)；

}

J

FunctionExample08. htm

在重写后的这个doAdd ()函数中，两个命名参数都与arguments对象一起使用。由于numl的值 与arguments [0]的值相同，因此它们可以互换使用(当然，num2和arguments [1 ]也是如此)。

关于arguments的行为，还有一点比较有意思。那就是它的值永远与对应命名参数的值保持同步。 例如：

function doAdd(numlz num2) { arguments 11] = 10; alert(arguments[0] + num2);

}

FuncHonExample09. him

每次执行这个doAdd ()函数都会®写第二个参数，将第二个参数的值修改为10。因为arguments 对象中的值会自动反映到对应的命名参数，所以修改arguments [1],也就修改丫 num2,结果它们的 值都会变成10。不过，这并不是说读取这两个值会访问相同的内存空间；它们的内存空间是独立的，但 它们的值会同步。但这种影响是单向的：修改命名参数不会改变arguments中对应的值。另外还要记 住，如果只传入了一个参数，那么为argtmentsllj设置的值不会反应到命名参数中。这是因为 arguments对象的长度是由传人的参数个数决定的，不是由定义函数时的命名参数的个数决定的。

关于参数还要记住最后一点：没有传递值的命名参数将白动被赋予undefined值。这就跟定义了 变S但又没有初始化一样。例如，如果只给doAdd()函数传递了 •个参数，则num2中就会保存 undefined 值0

严格模式对如何使用arguments对象做出了一S限制。首先，像前面例子中那样的赋值会变得无 效。也就是说，即使把arguments [1]设置为10，num2的值仍然还是undefined^其次，重写 arguments的值会导致语法错误(代码将不会执行)。

ECMAScript中的所有参数传递的都是值，不可能通过引用传递参数。

3.7.2没有重载

ECMAScript函数不能像传统意义t那样实现甫载。而在其他语言(如Java)巾，可以为一个函数 编写两个定义，只要这两个定义的签名(接受的参数的类型和数摄)不同即可。如前所述，ECMAScirpt 函数没有签名，因为其参数是由包含零或多个值的数组来表示的。而没有函数签名，真正的重载是不可 能做到的。

如果在ECMAScript中定义丫两个名字相同的函数,则该名字只展于盾定义的函数。请看下面的例子：

function addSomeNtunber (num) { return num 4- 100；

}

function addSomeNumber(num) { return num + 200；

}

var result = addSomeNumber(100)；    //300

FunctionExample 10. htm

在此，函数addSomeNumber ()被定义了两次。第一个版本给参数加100,而第二个版本给参数加 200。由于后定义的函数覆盖f先定义的函数，因此当在最后一行代码中调用这个函数时，返冋的结果 就是300。

如前所述，通过检査传人函数中参数的类型和数景并作出不同的反应，可以模仿方法的重载。

3.8小结

JavaScript的核心语言特性在ECMA-262中是以名为ECMAScript的伪语言的形式来定义的。 ECMAScript中包含了所有基本的语法、操作符、数据类型以及完成基本的计算任务所必需的对象，但 没有对取得输人和产生输出的机制作出规定。理解ECMAScript及其纷繁复杂的各种细节，是理解其在 Web浏览器中的实现——JavaScript的关键。U前大多数实现所遵循的都是ECMA-262第3版，但很多 也已经着手开始实现第5版了。以下简要总结了 ECMAScript中基本的要素。

□ ECMAScript 中的基本数据类型包括 Undefined、Null、Boolean, Number 和 String。

□与其他语言不同，ECMScript没有为整数和浮点数值分别定义不同的数据类型，Number类型可 用于表示所有数值。

□    ECMAScript中也有一种复杂的数据类坻，即Object类型，该类型是这门语言中所有对象的基 础类型。

□严格模式为这N语言中容易出错的地方施加了限制。

□    ECMAScript提供了很多与C及其他类C语言中相同的基本操作符，包括算术操作符、布尔操作 符、关系操作符、相等操作符及赋值操作符等。

□    ECMAScript从災他语言中借鉴了很多流控制语句，例如if语句、for语句和switch语句等。 ECMAScript中的函数与其他语言中的函数有诸多不同之处。

□无须指定函数的返回值，因为任何ECMAScript函数都可以在任何吋候返回任何值。

□实际上，未指定返回值的函数返回的是--个特殊的undefined值。

□    ECMAScript中也没有函数签名的概念，因为其函数参数是以一个包含零或多个值的数组的形式 传递的。

□可以向ECMAScript函数传-递任意数量的参数，并且可以通过arguments对象来访问这些参数。 □由于不存在函数签名的特性，ECMAScript函数不能重载。