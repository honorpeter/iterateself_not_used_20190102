---
title: JS06 面向对象的程序设计
toc: true
date: 2018-06-12 20:20:14
---
本章内容 □理解对象属性 □理解并创建对象 □理解继承

向对象(Object-Oriented, OO )的语言有一个标志，那就是它们都有类的概念，而通过类可 以创建任意多个具有相同属性和方法的对象。前面提到过，ECMAScript中没有类的概念，因

此它的对象也与基于类的语言中的对象有所不同。

ECMA-262把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者兩数。”严格来讲，

这就相3丁•说对象是一组没有特定顺序的值。对象的每个属件或方法都有一个名字，而每个名字都映射 到一个值。正因为这样(以及其他将要讨论的原因)，我们可以把ECMAScript的对象想象成散列表：无 非就是一组名值对，其中值可以是数据或函数。

每个对象都是基于一个引用类型创建的，这个引用类型可以是第5章讨论的原生类型，也可以是开 发人员定义的类型。

6.1理解对象

上一章曾经介绍过，创建自定义对象的嚴简单方式就是创建一个Object的实例，然后再为它添加 属性和方法，如下所示。

var person = new Object()； person.name = "Nicholas"; person.age = 29?

person.job = "Software Engineer"；

person.sayName = function(){ alert(this.name);

}?

CreatingObjectsExampleOl. htm

上面的例子创建了个名为person的对象，并为它添加jT三个域性(name、age和:job )和一个 方法(sayName () )o其中，sayName ()方法川于显示this.name (将被解析为person.name )的值。 早期的JavaScript开发人员经常使用这个模式创建新对象。几年后，对象字面ft成为创建这种对象的首选 模式。前面的例子用对象字面量语法可以写成这样：

var person = {

name： "Nicholas"r age: 29,

job： "Software Engineer",

sayName: functionO{ alert(this.name)；

}

};

这个例子中的person对象与前面例子中的person对象是一样的，都布相同的属性和方法。这些 属性在创建时都带存一些特征值(characteristic), •JavaScript通过这些特征值来定义它们的行为„

6.1.1属性类型

ECMA-262第5版在定义只有内部才用的特性(attribute )时，描述了属性(property )的各种特征。 ECMA-262定义这衅特性是为了实现JavaScript引擎用的，因此在JavaScript屮不能直接访问它们。为了 表示特性是内部值，该规范把它们放在了两对儿方括号中，例如[[Enumerable]】。尽管ECMA-262

第3版的定义有些不同，但本书只参考第5版的描述3 ECMAScript中有两种属性：数据属性和访问器属性。

1.数据属性

数据属性包含■•个数据值的位置。在这个位置4以读取和写入值。数据屈性有4个描述并行为的

特性。

□ [ [Configurable]]:表示能否通过delete删除属性从而甩新定义属性，能否修改属性的特 性，或者能否把属性修改为访问器屈性。像前面例子中那样直接在对象上定义的属性，它们的 这个特性默认值为true。

□    [ [Enumerable]]:表示能否通过for-in循环返问厲性。像前面例子中那样直接在对象上定 义的属性，它们的这个特性默认值为true。

□    [[writable]：：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的 这个特性默认值为true。

□ ([Value]):包含这个屈性的数据值。读取属性值的时候，从这个位S读；写人属性值的时候, 把新值保存在这个位置。这个特性的默认值为undefined。

对于像前面例子中那样接在对象上定义的属性，它们的[[Configurable] ] , [ [Enumerable]] 和[[Writable]]特性都被设置为true,而[[Value]]特性被设置为指定的值。例如：

var person = {

name： "Nicholas"

};

这里创建了一个名为name的属性，为它指定的值是。虹比01^5 •。也就是说，[[Value】]特性将 被设置为”Nicholas«•,而对这个值的任何修改都将反映在这个位置。

要修改属性默认的特性，必须使用ECMAScript5的Object .def ineProperty (＞方法。这个方法 接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符(descriptor)对象的属 性必须是：configurable、enumerable、writable和value。没置其中的一或多个值，可以修改 对应的特性值。例如：

var person = {}；

Object.defineProperty(person, "name"z { writable： false, value: "Nicholas"

})；

alert(person.name)；    //"Nicholas"

person.name = "Greg"?

alert(person.name)?    //"Nicholas"

DataPropertiesExampleO 1 .htm

这个例子创建了一个名为name的属性，它的值。Nicholas••是只读的。这个属性的值是不可修改 的，如果尝试为它指定新值，则在非严格模式下，赋值操作将被忽略；在严格模式下，赋值操作将会导 致抛出错误。

类似的规则也适用于不可配置的属性。例如： var person = {};

Object.defineProperty{person, •name", { configurable： false, value: "Nicholas"

))；

alert(person.name)； //"Nicholas"

delete person.name;

alert(person.name); //"Nicholas"

DataPropertiesExample02. htm

把conf igurable设置为false,表示不能从对象中删除属性D如果对这个展性调用delete,则 在非严格模式下什么也不会发生，而在严格模式下会导致错误。而且，一旦把属性定义为不可配置的， 就不能再把它变回可配置了。此时，再调用Object .def ineProperty (}方法修改除writable之外 的特性，都会导致错误：

var person = {}；

\-    Object.defineProperty(person, "name", {

configurable： false, value: "Nicholas"

n;

//拋出错误

Object.defineProperty(person, "name", {

configurable: true,

value: "Nicholas"

});

DataPropertiesExampie03. htm

也就是说：可以多次调用Object .defineProperty (}方法修改同一个属性，但在把configurable 特性设置为false之后就会有限制了。

在调用 Object.defineProperty ()方法时，如果不指定，configurable、enumerable 和 writable特性的默认值都是false。多数情况下，可能都没有必要利用Object .defineProperty {) 方法提供的这些髙级功能。不过，理解这些概念对理解JavaScript对象却非常冇用。

IE8是第一个笑现Object .def ineProperty ()方法的浏览器版本。然而，这个 版本的实现存在诸多限制：只能在DOM对象上使用这个方法，而且只能创建访问器 属性。由于实现不彻底，建议读者不要在IE8中使用Object.def ineProperty () 方法。

2.访问器属性

访问器属性不包含数据值；它们包含一对儿getter和setter函数(不过，这两个函数都不是必需的)。 在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器屈性时，会调用 setter函数并传人新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性c

□ [[Configurable]]:表示能否通过delete删除属性从而重新定义属性，能否修改属性的特 性，或荞能否把厲性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为

trueo

□    [[Enumerable]]:表示能否通过for-in循环返问属性。对于直接在对象上定义的®性，这 个特性的默认值为trueo

□    [[Get]]:在读取属性时调用的涵数。默认值为undefined。

![img](E:/11.ProgramFiles/Typora/JavaScriptd8a70b8fbea1082c34809-28.jpg)

 

□    [[Set]]:在写人屈性时调用的喊数。默认值为undefined。

访问器属性不能直接定义，必须使用Object .def ineProperty {)来定义。请看下面的例子。

var book. = {

_year： 2004, edition： 1

}?

Obj ect.def ineProperty(book, "year”，{ get： function(){

return this._year；

}，

set: function(newValue){

if (newValue > 2004) {

this._year = newValue；

this.edition += newValue - 2004；

}

}

});

book.year = 2005；

alert(book.edition)；    112

AccessorPropertiesExampleQl. htm

以上代码创建f 一个book对象，并给它定义两个默认的属性：_year和edition。_year前面 的下划线是-种常用的记号.用于表示只能通过对象方法访问的属性。而访问器屈性year则包含一个 getter函数和一个setter涵数。getter I#数返M_year的值，setter涵数通过计算来确定正确的版本。因此， 把year属性修改为2005会导致_year变成2005,而edition变为2。这是使用访问器属性的常见方 式，即设ft—个属性的值会导致其他属性发生变化。

不一定非要同时指定getter和setter。只指定getter意味着属性是不能写，意试写人属性会被忽略。 在严格模式下，尝试写人只指定了 getter函数的属性会抛出错误。类似地，没有指定setter函数的属性 也不能读，否则在非严格模式下会返回undefined,而在严格模式下会抛出错误。

支持ECMAScript5的这个方法的浏览器有IE9+( IE8只是部分实现)、Firefox4+、Safari 5+、Opera 12+和Chrome。在这个方法之前，要创建访问器屈性，一般都使用两个非标准的方法： _defineGetter_<>和_defineSetter_这两个方法最初是由 Firefox引人的，后来 Safari3、 Chromel和Opera 9.5也给出了相同的实现。使用这两个遗留的方法，可以像下面这样重写前面的例子。

var book = {

_year： 2004, edition: 1

//定义访闲器的旧有方法

book.__de£i neGetter_("year", function(){

return thia, year;

})；

book._defineSetter_("year**, function(newValue> { if (newValue > 2004) {

thie._year - newValue；

this, edit ion •¥= newValue - 2004;

}

}>；

book.year = 2005;

alert(book.edition);    Z/2

A£cessorPfx)pcrtiesExample02. htm

在不支持Object.defineProperty ()方法的浏览器中不能修改[[Configurable]]和 [[Enumerable]]o

6.1.2定义多个属性

由于为对象定义多个属性的可能性很大，ECMAScript 5又定义了一个Object .def inePro-pertiesUTZ法。利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：第一 个对象是要添加和修改其属性的对象，第二个对象的属性与第_个对象中要添加或修改的属性一一对 应。例如：

var book = {};

Object.defineProperties(book, {

_year: {

value： 2004

edition： { value： 1

year： {

get: function(){

return this,_year;

set: function(newValue){ if (newValue > 2004)    {

this._year = newValue；

this.edition += newValue - 2004;

}

})；

MultiplePropertiesExampleOl. htm

以上代码在book对外上定义了两个数据属性(jear和edition)和一个访问器属性(year)。 最终的对象与上一节中定义的对象相同。唯▲的区别是这里的属性都是在同一时间创建的。

支持 Object;.defineProperties ()方法的浏览器有 IE9+、Firefox 4+、Safari 5+、Opera 12+和 Chrome o



6.1.3读取属性的特性

使用ECMAScript 5的Object.getOwnPropertyDescriptor ()力•法，可以取得给定属性的描述 符。这个方法接收两个参数：W性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果 是访问器屈性，这个对象的属性有configurable、enumerable、get和set;如果是数据属性，这 个对象的属性有 configurable、enumerable、writable 和 value。例如：

var book = {}；

Object.defineProperties(book, { _year： {

value： 2004

edition：( value: 1

},

year： {

get: function。{

return this._year；

}，

set: function(newValue){ if (newValue > 2004) {

this._year = newValue；

this.edition += newValue - 2004；

}

}

}

});

var descriptor - Object.getOwaPropertyDescriptor(book, M_year">; alert(descriptor.value)t    //2004

alert(descriptor.confi gurable); //false

alert(typeof descriptor.get); //"undefined"

var descriptor = Object.getOwnPropertyDeflcriptor(book, "year” alert(descriptor.value};    //undefined

alert(descriptor.enumerable); //false alert(typeof descriptor.get);    //"function"

GetPropertyDescriptorExampleO 1. htm

对于数据属性_year, value等于最初的值，configurable是false,而get等于undefined。 对于访问器展性year, value等于undefined, enumerable是false,而get是一个指向getter 函数的指针。

在JavaScript中，可以针对任何对象-fei括DOM和BOM对象，使用Object .getOwnProperty-

Descriptor ()方法。支持这个方法的浏览器有 IE9+、Firefox 4+ x Safari 5+、Opera 12+和 Chrome。

6.2创建对象

虽然Object构造函数或对象字面量都可以用来创建单个对象，佴这些方式有个明显的缺点：使用同 一个接口创逮很多对象，会产生大M的重复代扔。为解决这个问题，人们开始使用工厂模式的一种变体。

6.2.1工厂模式

工厂模式是软件T程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程(本书后 面还将讨论其他设计模式及其在JavaScript中的实现)。考虑到在ECMAScript中无法创建类，开发人员 就发明了一种函数，用函数来封装以特定接U创建对象的细节，如下面的例子所示。

function createPerson(name, age, job}{ var o = new Object:。； o.name = name； o.age = age； o.job = job； o.sayName = function{){

alert{this.name};

};

return o；

}

var personl = createPerson("Nicholas"# 29, "Software Engineer"); var person2 = createPerson("Greg", 27, "Doctor")；

FactoryPattemExampleOl. htm

函数createPerson ()能够根据接受的参数来构建--个包含所夯必要信息的Person对象。可以无 数次地调用这个函数，而每次它都会返回一个包含三个屈性一个方法的对象。工厂模式虽然解决了创建 多个相似对象的问题，但却没有解决对象识别的问题(即怎样知道一个对象的类型)。随着JavaScript 的发展，又一个新模式出现了。

6.2.2构造函数模式

前几章介绍过，ECMAScript中的构造函数卩J•用来创建特定类型的对象。像object和Array这样 的原生构造函数，在运行时会fl动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义 自定义对象类型的属性和方法。例如，可以使用构造函数模式将前面的例子重写如下。

function Person(name, age, job){ this.name - name； this.age = age? this.job : job; this. sayName = function (H

alert(this.name)；

};

}

var personl = new Person("Nicholas", 29, "Software Engineer")；

var person2 = new Person("Greg", 27, ’Doctor");

ConstructorPattemExampleOJ.htm

在这个例子中，Person ()兩数取代f createPerson ()涵数。我们注意到，Person ()中的代码 除了与createPerson()中相同的部分外，还存在以下不同之处：

□没农显式地创建对象；

□直接将属性和方法赋给了 this对象；

此外，还应该注意到函数名Person使川的是大写字母按照惯例，构造函数始终都应该以一个 大写字母开头，而非构造函数则应该以一个小写字母开头。这个做法借鉴自其他00语言，主要是为了 区别于ECMAScript中的其他函数；因为构造函数本身也是函数，只不过可以用来创建对象而已。

要创建Person的新实例，必须使用new操作符。以这种方式调用构造函数实际上会经历以下4 个步骤：

＜1)创建一个新对象；

(2)将构造函数的作用域赋给新对象(因此this就指向了这个新对象)；

(3＞执行构造函数中的代码(为这个新对象添加属性)；

(4＞返回新对象。

在前面例子的最后，personl和person2分别保存游Person的-•个不同的实例。这两个对象都 有一个constructor (构造函数)域性，该屈性指向Person,如下所示。

alert(personl.constructor == Person)； //true alert(person2.constructor == Person)； //true

对象的constructor属性最初是用来标识对象类型的。但是，提到检测对象类型，还是instan-ceof操作符要更可靠一牲。我们在这个例子中创建的所冇对象既是Object的实例，同时也是Person 的实例，这一点通过instanceof操作符可以得到验证。

alert (personl instanceof Object) ; "true alert(personl instanceof Person)； //true alert(person2 instanceof Object); //true alert(person2 instanceof Person); //true

创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正是构造函数模式 胜过工厂模式的地方。在这个例子中，personl和person2之所以同时是Object的实例，是因为所 冇对象均继承自Object (详细内容梢后讨论)。

以这种方式定义的构造函数是定义在Global对象(在浏览器中是window对象) 中的、第8章将详细讨论浏览器对象模型(BOM)。

1.将构造函数当作函数

构造函数与其他函数的唯一区别，就在于调用它们的方式不同。不过，构造函数毕竟也是函数，不 存在定义构造函数的特殊语法。任何函数，只要通过new操作符来调用，那它就可以作为构造函数；而 任何函数，如果不通过new操作符来调用，那它跟普通函数也不会有什么两样。例如，前面例子中定义 的Person!)函数可以通过下列任何一种方式来调用。

//当作构連而数使用

var person = new Person.("Nicholas"# 29, "Software Engineer")； person.sayName{)； //"Nicholas"

//作为普通必数词用

Person(■Greg", 27, "Doctor") ； // 添加利 window

window.sayName{)； //■Greg"

//在另一个对象的作用域中调用

var o = new Object。；

Person.call (o, "Kristen’，25, "Nurse1*);

o.sayName{)? //"Kristen*

GonstructorPattemExample02. htm

这个例子中的前两行代码展示f构造函数的典型用法，即使用new操作符来创建一个新对象。接下 来的两行代码展示了不使用new操作符调用Person ()会出现什么结果:属性和方法都被添加给window 对象了。有读者可能还记得，当在全局作用域中调用一个函数时，this对象总是指向Global对象(在 浏览器中就是window对象)。因此，在调用完函数之后，可以通过window对象来调用sayName ()方 法，并且还返回了 Wreg%最后，也可以使用call()(或者apply ())在某个特殊对象的作用域中 调用Person ()函数。这里是在对象o的作用域中调用的，因此调用后o就拥有了所有属性和sayName () 方法。

2.构造函数的问题

构造函数模式虽然好用，但也并非没有缺点。使用构造函数的主要问题，就是每个方法都要在每个 实例上重新创建一遍。在前面的例子中，personl和person2都有一个名为sayName ()的方法，但那 两个方法不是同一个Function的实例。不要忘了——ECMAScript中的函数是对象，因此每定义一个 函数，也就是实例化了一个对象。从逻辑角度讲，此时的构造函数也可以这样定义。

function Person(name, age, job){ this.name = name; this.age = age； this.job = job;

this.sayName = new Pxmction("alert{thia.name) ") ; // 与声明禹数在遝辑上是等价的

}

从这个角度上来看构造函数，更容易明白每个Person实例都包含一个不同的Function实例(以 显示name属性)的本质。说明甶些，以这种方式创建函数，会导致不同的作用域链和标识符解析，何 创建Function新实例的机制仍然是相同的。因此，不同实例上的同名函数是不相等的，以下代码可以 证明这一点。

alert(personl.sayName person2.sayName)； //false

然而，创建两个完成同样任务的Function实例的确没有必要；况且有this对象在，根本不用在 执行代码前就把函数绑定到特定对象上面。因此，大可像下面这样，通过把函数定义转移到构造函数外 部来解决这个问题s

I function Person(name, age, job){ this.name = name； this.age = age; this.job = job;

thia.sayName ■ aayName;

}

function sayName(){ alert(this.name);

var personl = new Person("Nicholas", 29, "Software Engineer")； var person2 = new Person("Greg", 21, "Doctor");

GonstructofPattemExamp!e03. htm

在这个例子巾，我们把sayName ()函数的定义转移到了构造函数外部。而在构造函数内部，我们 将sayName谋性设置成等于全局的sayName函数。这样一来，由于sayName包含的是-•个指向困数 的指针，因此personl和person2 Xl象就共享了在全局作用域中定义的同一个sayName <)函数。这 样做确实解决了两个函数傲同一件事的问题，可是新问题又来了：在全局作用域中定义的函数实际上只 能被某个对象调用，这让全局作用域有点名不副实。而更让人无法接受的是：如果对象需要定义很多方 法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言丁。好在， 这些问题可以通过使用原型模式来解决。

6.2.3原型模式

我们创建的每个函数都存一个prototype (原型)属性，这个属性是一个指针，指向-•个对象， 而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那 么prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以 让所有对象实例共享它所包含的属性和方法,，换句话说，不必在构造函数中定义对象实例的信息，而是 可以将这些信息直接添加到原型对象中，如下面的例子所示。

function Person(}{

}

Person.prototype.name = "Nicholas";

Person.prototype.age = 29;

Person.prototype.job = "Software Engineer"；

Person.prototype.sayName = function(){ alert(this.name};

};

var personl =： new Person (); personl.sayName(); //"Nicholas"

var person2 = new Person(>;

person2.sayName()； //"Nicholas"

alert(personl.sayName == person2.sayName); //true

PrototypePatternExampleOl. him

在此，我们将sayName＜）方法和所布属性直接添加到了 Person的prototype属性中，构造闲数 变成了空函数。即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属 性和方法。但与构造函数模式不同的是，新对象的这些戚性和方法是由所有实例共亨的。换句话说， personl和person2访问的都是同一组属性和同一个sayName （）函数。要理解原型模式的工作原理， 必须先理解ECMAScript中原型对象的性质。

1.理解原型对象

无论什么吋候，只要创建了 -个新函数，就会根据一组特定的规则为该函数创建-个prototype 属性，这个属性指向函数的原型对象。在默认情况下，所冇原型对象都会自动获将一个constructor （构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。就傘前面的例子来说， Person.prototype. constructor指向Person。而通过这个构造闲数，我们还可继续为原型对象 添加其他屈性和方法。

创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则 都是从Object继承而来的=当调川构造函数创建一个新实例后，该实例的内部将包含一个指针（内部 属性），指向构造函数的原坦对象„ ECMA-262第5版中管这个指针叫[[Prototype]]。虽然在脚本巾 没有标准的方式访问[f Prototype]],但Firefox、Safari和Chrome在每个对象都支持一个属性 _proto_;而在其他实现中，这个属性对脚本则是完全不可见的。不过，要明确的真正重要的一点就 是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。

以前面使用Person构造函数和Person.prototype创建实例的代码为例，图6-1展承了各个对 象之问的关系。

prototype

 

| Person Prototype |                     |
| ---------------- | ------------------- |
| constructor      | •—                  |
| name             | "Nicholas"          |
| age              | 29                  |
| job              | "Software Engineer" |
| sayKame          | (function)          |

peraon2

 

personl

 

[[Prototype]J

[[Prototype]]

 

图6-1

图6-1展示了 Person构造涵数、Person的原型属性以及Person现有的两个实例之间的关系。 在此，Person.prototype 指向了原型对象，而 Person• prototype.constructor 又指回了 Person。 原型对象中除了包含constructor属性之外，还包括后来添加的其他属性。Person的每个实例—— personl和person2都包含一个内部属性，该屈性仅仅指向了 Person.prototype;换句话说，它们 与构造函数没有直接的关系。此外，要格外注意的是，虽然这两个实例都不*包含属性和方法，但我们却

可以调用personl. sayName (>。这足通过查找对象属性的过程来实现的。

虽然在所有实现中都无法访问到[[Prototype]:,但可以通过isPrototypeOf ()方法来确定对象之

间是否存在这种关系。从本质上讲，如果[[Prototype]]指向调用.isProtsotypeOf ()方法的对象 (Per son. prototype ),那么这个方法就返回true,如F所ZK:

alert(Person.prototype.isPrototypeOf(personl))； "true alert(Person.prototype.isPrototypeOf(person2)); "true

这里，我们用原型对象的isPrototypeOf (｝方法测试了 personl和person2。W为它们内部都 有-•个指向Person.prototype的指针，因此都返回了 true。

ECMAScript 5增加了一个新方法，叫Object .getPrototypeOf ()，在所有支持的实现中，这个 方法返回[[Prototype]]的值。例如：

alert(Object.getPrototypeOf(personl) == Person.prototype); //true alert(Object.getPrototypeOf(personl).name)? //"Nicholas"

这里的第一行代码只是确定Object .getPrototypeOf ()返回的对象实际就是这个对象的原型。 第二行代码取得了原型对象中name属性的值，也就是、Nicholas"。使用Object .getPrototypeOf () 可以方便地取得一个对象的原型，而这在利用原型实现继承(本章稍后会讨论)的情况下是非常重要的。 支持这个方法的浏览器有 IE9+、Firefox 3.5+ > Safari 5+、Opera 12+和 Chrome。

每当代码读取某个对象的某个属性吋，都会执行一次搜索，目标是具有给定名字的属性。捜索首先 从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返网该属性的值；如果没有找到， 则继续捜索指针指向的原型对象，在原型对象中査找具好给定名字的属性。如果在原型对象中找到了这 个属性，则返回该属性的值。也就是说，在我们调用personl.sayNameG的时候，会先后执行两次搜 索。首先，解析器会问：“实例personl有3ayName屈性吗？ ”答：“没有。”然后，它继续搜索，再 问："personl的原型有sayName属性吗？ ”答：“有。”于是，它就读取那个保存在原型对象中的函 数。当我们调用person2. sayName ()时，将会重现相同的搜索过程，得到相同的结果。而这正是多个 对象实例共享原型所保存的属性和方法的基本原理。

前面提到过，原型最初只包含constructor康性，而该属性也是共享的，因此 可以通过对象实例访问。

虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们 在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该 属性将会屏蔽原型中的那个属性。来看下面的例子。

function Person(){ )

Person.prototype.name = ^Nicholas"；

Person, proto type, age =： 29；

Person.prototype.job = "Software Engineer"; Person.prototype. sayName = function。{

alert(this.name);

};

var personl = new Person()；

var person2 = new Person()；

persozxl.name » "Greg"/

alert (personl .name);    //"Oreg"-来自夹例

alert (person2 .name);    //*KicholasH-来自摩变

PrototypePattemExample02. htm

在这个例子中，personl的name被一个新值给屏蔽了。但无论访问personl.name还是访问 person2 .name都能够正常地返网值，即分别是”Greg"（来自对象实例）和”Nicholas"（来自原型）o 当在alert （）中访问personl • name时，需要读取它的值，因此就会在这个实例上搜索一个名为name 的属性。这个属性确实存在，于是就返回它的值而不必再搜索原型了。当以同样的方式访问persor^. name时，并没有在实例L发现该属性，因此就会继续捜索原型，结果在那里找到了 name•属性。

当为对象实例添加一个厲性时，这个属性就会屏蔽原型对象中保存的同名属性；换句》说，添加这 个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。即使将这个属性设置为null,也 只会在实例中设置这个厲性，而不会恢复其指向原型的连接。不过，使用delete操作符则可以完全删 除实例属性，从而让我们能够重新访问原型中的属性，如下所示。

function Person（}{

}

Person.prototype.name = "Nicholas'；

Person.prototype.age = 29；

Person.prototype.job = "Software Engineer" Person.prototype.sayName = function(){

alert(this.name);

}；

var personl = new Person()； var person2 = new Person()；

personl.name = "Greg"; alert(personl.name); alert(person2.name)；

delete personl.name； alert(personl.name)t

 

//"Greg"-来自实例

//"Nicholas"- 来自原变

/ /"Nicholas"-来 6 原空

 

PrototypePattemExample03. htm

在这个修改后的例子中，我们使用delete操作符删除了 personl .name,之前它保存的"Greg* 值屏蔽了同名的原型属性。把它删除以后，就恢复了对原型中name属性的连接。因此，接下来再调用 personl .name时，返问的就是原型中name属性的值丫。

使用hasOwnProperty （）方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法（不 要忘了它是从Object继承来的）只在给定属性存在于对象实例中时，才会返回true。来看下面这个例子。

function Person(){ }

Person.prototype.name = "Nicholas";

Person.prototype.age = 29；

Person.prototype.job = "Software Engineer■; Person.prototype.sayName = function(){

alert(this.name)；

)；

var personl - new Person();

var person2 = new Person()?

alert <x>erBonl.hasOwnProperty( "name**)) ; //false

personl.name = "Greg";

alert (personl .name) ;    //"Greg"-来自实例

alert(personl.hasOwnProperty("name"));    //true

alert (person2 .name) ；    //"Nicholas"-来自原型

alert(person2.has0waProperty("name")); //false

delete personl.name；

alert (personl .name) ;    //"Nicholas"-来自原雙

alert(personl.hasOwnProperty("name")); //false

通过使用hasOwnProperty＜）方法，什么时候访问的是实例属性，什么时候访问的是原型属性就 一清二楚了。调用 personl.hasOwnProperty （ "name"）时，只存当 personl 重写 name 属性后才会 返回true,因为只有这时候name才是一个实例属性，而非原型属性。图6。2展示了上面例子在不同情 况下的实现与原型的关系（为了简单起见，图中楫略了与Person构造函数的关系）。

Initially

| personl                   |      |
| ------------------------- | ---- |
| ([Prototype]]    \|    •- |      |
|                           |      |
| person2                   |      |
| [[Prototype]]    \|    •- |      |

 

| Person Prototype |                     |
| ---------------- | ------------------- |
| constructor      | •                   |
| name             | "Nicholas"          |
| age              | 29                  |
| job              | "Software Engineer" |
| sayName          | (function)          |

 

personl. name = "Greg"

| personl       |          |      | Person Prototype |                     |            |
| ------------- | -------- | ---- | ---------------- | ------------------- | ---------- |
| ([Prototype]] | •-       |      |                  | constructor         | •          |
| name          | '•Greg。 |      |                  | name                | "Nicholas" |
|               |          |      |                  | age                 | 29         |
| person2       |          |      | job              | "Software Engineer" |            |
| [(Prototype]] | •-       |      |                  | sayName             | (function) |

delete personl.name

| personl                   |      |
| ------------------------- | ---- |
| [[Prototype]]    \|    •- |      |
|                           |      |
| person2                   |      |
| [[Prototype]1    \|    •  |      |

 

| Person Prototype |                     |
| ---------------- | ------------------- |
| constructor      | •                   |
| name             | "Nicholas"          |
| age              | 29                  |
| job              | "Software Engineer" |
| sayName          | (function)          |

 

图6-2

C^\ ECMAScript 5 的 Object.getOwnPropertyDescriptor()方法只能用于实例属 性，要取得原型康性的描述符，必须直接在原型对象上调用Object .get Own Proper ty-Descriptor ()方法。

2.原型与in操作符

冇两种方式使用in操作符：单独使用和在for-in循环中使用。在单独使用时，in操作符会在通 过对象能够访问给定属性时返回true,无论该属性存在T实例中还是原瑠中。看一看下面的例子。

function Person(){

}

Person.prototype.name = "Nicholas•;

Person.prototype.age = 29;

Person.prototype.job = "Software Engineer* Person.prototype.sayName = function(){

alert{this.name);

};

var personl = new Person()；

var person2 = new Person()；

alert(personl.hasOwnProperty(■name *)); //false

alert("name" in personl)/ //true

personl.name = "Greg"；

alert (personl.name) ； //"Greg"-来自实例

alert(personl.hasOwnProperty("name")); //true

alert("name" in peraonl)f //true

alert (person2.name) ；    //"Nicholas"-来自原型

alert(person2.hasOwnProperty("name"))； //false

alert("name" in person2); //true

delete personl.name;

alert (personl.name) ; //"Nicholas"-来自原免

alert(personl.hasOwnProperty("name"))； //false

alert ("name* in personl) ; "true

PrototypePattemExample04. htm

在以上代码执行的®个过程中，name属性要么是直接在对象上访问到的，要么是通过原型访问到 的。因此，调用"name” in personl始终都返回true,无论该属性存在于实例中还是存在于原型中;, 同时使用hasOwnProperty (＞方法和in操作符，就可以确定该厲性到底是存在于对象中，还是存在于 原型中，如下所示。

function hasPrototypeProperty(object, name){

return J object.hasOwnProperty(name) && (name in object);

)

由于in操作符只要通过对象能够访问到属性就返冋true, hasOwnProperty ()只在属性存在于 实例中时才返回true,因此只要in操作符返回true而hasOwnProperty (}退回false,就可以确 定属性是原型中的属性。下面来看一看上面定义的兩数hasPrototypeProperty ()的用法。

function Person(){ }

Person.prototype.name = "Nicholas";

Person.prototype.age 29；

Person.prototype.job = "Software Engineer" Person.prototype.sayName = function(){

alert(this.name)?

}；

var person = new Person(};

alert(hasPrototypoPropertyfperson, "name")); //true

person.name = "Greg";

alert (hasPrototypeProperty (person, Mname**)) t //false

PrototypePattem£xample05. htm

在这里，name属性先是存在于原型中，因此hasPrototypeProperty ()返回true。当在实例中 重写name属性后，该属性就存在于实例中了，因此hasPrototypeProperty ()返回false。即使原 型中仍然有name属性，但由于现在实例中也有了这个属性，㈥此原型中的name属性就用不到了。

在使用for-in循环时，返回的是所有能够通过对象访问的、可枚举的(enumerated)属性，其中 既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性(即将 [[Enumerable]]标记的属性)的实例属性也会在for-in循环中返冋，因为根据规定，所有开发人员 定义的属性都是可枚举的一只有在IE8及更早版本中例外。

IE早期版本的实现中存在一个bug,即屏蔽不可枚举属性的实例属性不会出现在for-in循环中。 例如：

var o = {

toString : function(){ return "My Object"；

}

};

for (var prop in o){

if (prop == "toString"){

alert ( "Found toString") ;    //在 IE 中不会JS.示

)

}

PrototypePaUemExample06. htm

当以上代码运行时，应该会显示一个警告框，表明找到了 toString ()方法。这里的对象o定义了 一个名为toString ()的方法，该方法屏蔽丫原型中(不可枚举)的toString ()方法。在IE中，由 于其实现认为原迎的toString ()方法被打上了 [ [Enumerable]]标记就应该跳过该属性，结果我们就 不会看到装吿框。该bug会影响默认不可枚举的所有属性和方法，包括：hasOwnProperty () x propertylsEnumerableO x toLocaleString (>、toString (> 和 valueOf () o ECMAScript 5 也将 constructor和prototype属性的[[Enumerable]]特性设置为false,但并不是所有浏览器都照此 实现。

要取得对象上所有可枚举的实例属性，可以使用ECMAScript5的Object, keys ()姚。这个方法

接收一个对象作为参数，返网一个包含所有可枚举厲性的字符串数组。例如： function Person(){

Person.prototype,name = "Nicholas"；

Person.prototype.age = 29;

Person.prototype.job = "Software Engineer"； Person.prototype.sayName = function(){

alert(this.name}?

};

var keys = Obj ect.keys(Person.prototype);

alert{keys)/    //"name,age,job,aayName"

var pi = new Person{};

pi.name = "Rob";

pi.age » 31;

var plkeys «= Object. keys (pi);

alert(plkeya)/ //nnamez age"

ObjectKeysExampieO】.htm

这里，变遺keys中将保存--个数组，数组中是字符串，'name11、"age"、"job"和"sayName**。这 个顺序也是它们在for-in循环中出现的顺序。如果是通过Person的实例调用，则Object. keys () 返冋的数组共包含” namen和"age"这两个实例厲性。

如果你想要得到所有实例属性，无论它是否可枚举，都nj•以使用Object .getOwnPropertyNanes () 方法。

var keys 戰 Object .getOwziPropertyNames (Person.prototype); alert (keys);    //"constructor, name, age, job, sayNajoa*'

ObjectPropertyNamesExampleO 1. htm

注意结果中包含了不可枚举的 constructor 属性。Object.keysU和 Object.getOwnProperty-Names {)方法都可以用来待代for-in循坏。支持这两个方法的浏览器冇IE9+、Firefox4+ > Safari5+ > Opera

和 Chrome o

3.更简单的原型语法

读者大概注意到了，前函例子中每添加一个属性和方法就要敲•，遍Person.prototype,,为减少 不必要的输人，也为了从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的 对象字面量来重写整个原型对象，如下面的例子所示。

function Person()(

}

Person.prototype = { name s "Nicholas", age t 29,

job: '*Software Engineer"/ sayName : function () <

alert(this.name)/

PrototypePatternExample07.htm

在上面的代码中，我们将Person.prototype设置为等于一个以对象字面量形式创建的新对象。 最终结果相同，但有一个例外：constructor属性不再指向Person 了。前面曾经介绍过，每创建一 个函数，就会同时创建它的prototype对象，这个对象也会自动获得constructor属性。而我们在 这里使用的语法，本质上完全重写了默认的prototype对象，因此constructor属性也就变成了新 对象的constructor屁性(指向Object构造函数)，不再指向Person函数。此时，尽管instanceof 操作符还能返间正确的结果，但通过constructor已经无法确定对象的类型了，如下所示。

var friend = new Person();

alert(friend instanceof Object);    //true

alert (friend instanceof Person) ；    "true

alert(friend,constructor == Person);    //false

alert(friend.constructor == Object);    //true

PrototypePatternExample07. htm

在此，用instanceof操作符测试Object和Person仍然返冋true,但constructor属性则 等于Object而不等于Person 了。如果constructor的值真的很重要，可以像下面这样特意将它设 置回适当的值。

function Person(){

}

Person.prototype = {

constructor t Person,

name j "Nicholas", age : 29,

job: "Software Engineer■z sayName : function () {

alert(this.name);

}

PrototypePattemExampleO?. htm

以上代码特意包含了 ••个constructor属性，并将它的值设置为Person,从而确保了通过该属 性能够访问到适当的值。

注意，以这种方式重设constructor属性会导致它的［［Enumerable〕］特性被设置为true。默认 情况下，原生的constructor属性是不可枚举的，因此如果你使用兼容ECMAScript 5的JavaScript引 擎，可以试一试 Object .defineProperty ()。

function Person(){

}

Person.prototype = { name : "Nicholas *, age : 29,

job : "Software Engineer", sayName : function () {

alert(this.name);

//重设构造A数，只追用于ECMAScript5兼容的蜊見》

Objact. defineProperty (Person. prototype, "constructor•', {

enumerable: false, value: Person

))7

4.原型的动态性

由于在原型中査找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上 反映出来——即使是先创建了实例耵修改原铟也照样如此。请看下面的例子。

var friend = new Person();

Person.prototype.sayHi = function{){ alert ("hi1')；

}?

friend.sayHi () ；    //’hi"(没有问题！)

PrototypePatternExample09. htm

以上代码先创建了 Person的一个实例，并将其保存在person中。然后，下一条语句在Person, prototype中添加了一^方法sayHi U。即使person实例是在添加新方法之前创建的，但它仍然可 以访问这个新方法、其原因可以归結为实例与原型之间的松散连接关系。当我们调用person. sayHi () 时，首先会在实例中搜索名为sayHi的属性，在没找到的情况下，会继续搜索原型。因为实例与原型 之间的连接只不过是-•个指针，而非一个副木，因此就可以在原型屮找到新的sayHi属性并返回保存 在那里的函数。

尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重 写幣个原型对象，那么情况就不一样了。我们知道，调用构造函数时会为实例添加一个指向最初原型的 l [Prototype]]指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。 请记住：实例中的指针仅指向原型，而不指向构造函数。看下面的例子。

function Person(}{

}

var friend = new Person()；

Person.prototype = {

constructor： Person, name : "Nicholas", age : 29,    »

job : "Software Engineer*, sayName : function () {

alert(this.name);

}

}；

friend.sayName{)； //error

PrototypePatternExample 10.htm

在这个例子中，我们先创建了 Person的一个实例，然后又策写了其原型对象。然后在调用 friend. sayName ()时发生了错识，因为friend指向的原型中不包含以该名字命名的属性。图6-3展

示了这个过程的内幕。

璽写原型对象之前

重写原型对象之后

图6-3

从图6-3可以肴出，重写原型对象切断f现有原型与任何之前已经存在的对象实例之间的联系；它 们引用的仍然是最初的原型。

5.原生对象的原型

原增模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式 创建的。所有原生引用类型(Object、Array, String,等等)都在其构造函数的原型上定义了方法。 例如，在Array.prototype中可以找到sort (｝方法，而在String.prototype中可以找到 substring (｝方法，如下所示。

alert(typeof Array.prototype.sort);    //"function*

alert(typeof String.prototype.substring);    //"function"

通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法。可以像修改自 定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。下面的代码就给基本包装类型 String添加了一个名为startsWith ()的方法。

String.prototype.startsWith = function (text》｛ return this.indexOf(text｝ == 0;

｝;

var msg = "Hello world!■;

alert(msg.startsWith("Hello"))；    //true

PrototypePatternExamplell.htm

这里新定义的startswith(＞方法会在传人的文本位于一^h字符串开始时返回true。既然方法被 添加给了 String.prototype,那么当前环境中的所有字符串就都可以调用它。由于msg是字符串， 而且后台会调用String基本包装函数创建这个':戶符串，因此通过mgs就可以调用startsWith()方法。

尽管可以这样做,但我们不推荐在产品化的程序中修改原生对象的原型。如果因 某个实现中缺少某个方法，就在原生对象的原蜇中添加这个方法，那么当在另一个支 持该方法的实现中运行代码时，就可能会年致命名冲突。而且，这样做也可能会意外 地重写原生方法。

6.原型对象的问题

原型模式也不是没有缺点。首先，它省略r为构造函数传递初始化参数这一环节，结果所有实例在 默认情况下都将取得相同的属性值。虽然这会在某种程度上带来一些不方便，但还不是原型的最大问题。 原型模式的最大问题是由其共享的本性所导致的。

原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那牲包含基本值的属性倒 也说得过去，毕竟(如前面的例子所示)，通过在实例上添加一个同名属性，可以隐藏原型中的对应属 性。然而，对于包含引用类型值的属性来说，问题就比较突出了。来看下面的例子。

function Person(){

}

Person.prototype = {

constructor: Person, name : "Nicholas", age : 29,

job : "Software Engineer", friends : [11 Shelby", "Court"],

sayName : function () { alert(this.name);

}

}；

var personl = new Person()； var person2 = new Person()；

pereonl.friends.push("Van")j

alert(personl.friends)；    //"Shelby,Court,Van"

alert(person2.friends)；    //"Shelby,Court,Van"

alert(personl.friends === person2.friends)t //true

Prototype PatternExample 12.htm

在此，Person.prototype对象有一个名为friends的属性，该属性包含一个字符串数组。然后， 创建了 Person的两个实例。接着，修改了 personl. friends引用的数组，向数组巾添加了一个字符 申0由于friends数组存在于Person .prototype而非personl中，所以刚刚提到的修改也会通过 persons . friends (与personl. friends指向同一个数组)反映出来。假如我们的初衷就是像这样 在所有实例中共享-个数组，那么对这个结果我没有话可说。可是，实例一般都是要有属于自己的全部 厲性的。而这个问题正是我们很少看到有人单独使用原型模式的原因所在。

6.2.4组合使用构造函数模式和原型模式

创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实 例属性，而原型模式用于定义方法和典享的属性。结果，每个实例都会有自己的一份实例属性的副本， 但同时又共享着对方法的引用，坡大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参 数；可谓是集两种模式之长。下面的代码重写了前面的例子。

function Person{name, age, job){ this.name = name; this.age = age; this.job = job；

this.friends = [*Shelby", •Court”；

}

Person.prototype - {

constructor : Person, sayName : function。{

alert (this.name)；

}

}

var personl = new Person("Nicholas■, 29, "Software Engineer");

var person2 new Person("Greg", 27, "Doctor")；

personl.friends.push("Van")；

alert(personl.friends)；    //"Shelby,Count,Van"

alert(person2.friends);    //"Shelby,Count"

alert (personl. friends ===； person2. friends) ; //false

alert(personl.sayName === person2.sayName); //true

HybridPattemExampleOL htm

在这个例子屮，实例属性都是在构造函数中定义的，而由所有实例共享的属性constructor和方 法sayName (＞则是在原型中定义的。而修改了 personl. friends (向其中添加一个新字符串)，并不 会影响到personZ. friends,因为它们分别引用了不同的数组。

这种构造函数与原型混成的模式，是目前在ECMAScript屮使用最广泛、认同度最髙的一种创建自 定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。

6.2.5动态原型模式

有滅他00语言经验的开发人员在看到独立的构造函数和原型时，很可能会感到非常困惑。动态原 型模式正是致力于解决这个问题的一个方案，它把所有信息都封装在了构造函数中，而通过在构造函数 中初始化原型(仅在必要的情况下)，又保持了同时使用构选函数和原型的优点。换句话说，可以通过 检奄某个应该存在的方法是否有效，来决定是否需要初始化原型。来看--个例子。

function Person(name, age, job){

//羼性

this.name = name； this.age = age； this.job = job;

//方法

if (typeof this.sayName != "functionw){

Person.prototype.sayNaae « function(){ alert(this.name);

}

}

var friend = new Person("Nicholas•* f 29, "Software Engineer") ? friend.sayName{);

DynamicPrototypeExampleO 1 .htm

注意构造函数代码中加粗的部分。这里只在sayNameO方法不存在的情况下，才会将它添加到原 型中。这段代码只会在初次调用构造函数时才会执行。此后，原型已经完成初始化，不需要再做什么修 改了。不过要记住，这里对原型所做的修改，能够立即在所有实例中得到反映。因此，这种方法确实可 以说非常完美。其中，if语句检杳的可以是初始化之后应该存在的任何属性或方法~不必用一大堆 if语句检査每个属性和每个方法；只要检査其中一个即可。对于采用这种模式创建的对象，还可以使 用instanceof操作符确定它的类SL

^使用动态原型模式时，不能使用对象字面量重写原型。前面已经解释过了，如果

在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系。

6.2.6寄生构造函数模式

通常，在前述的几种模式都不适用的悄况下，可以使用寄生(parasitic)构造函数模式。这种模式 的基本思想是创建•-个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；但 从表面上看，这个函数又很像是典坳的构造函数。下面是一个例子。

function Person{name, age, job}{ var o = new Object(}； o.name = name; o.age = age； o.job = job; o.sayName = function{){

alert(thi s.name)；

}?

return o；

}

var friend = new Person("Nicholas", 29, "Software Engineer")； friend.sayName()； If "Nicholas"

HybridFactoryPatternExampleOl. htm

在这个例子中，Person函数创建了一个新对象，并以相应的属性和方法初始化该对象，然后又返 回了这个对象。除了使用new操作符并把使用的包装函数叫做构造函数之外，这个模式跟工J ‘模式其实 足一模一样的。构造函数在不返冋值的情况下，默认会返回新对象实例。而通过在构造函数的末尾添加

一个return语句，可以重写调用构造函数时返冋的值。

这个模式可以在特殊的情况下用来为对象创建构造函数。假设我们想创建一个具有额外方法的特殊

数组。由于不能直接修改Array构造函数，因此可以使用这个模式。

function SpecialArray(){

//创建数组

var values = new Array()；

//添加值

values.push.apply(values, arguments);

//添加方法

values.toPipedString = function(}{ return this.join("I")?

}?

//返回数组

return values;

var colors = new SpecialArray("red", "blue", "green");

alert(colors.toPipedString()}； //"red I blue I green"

HybridFactoryPattemExampleOL htm

在这个例子中，我们创建了一个名叫SpecialArray的构造函数。在这个函数内部，首先创建了 -个数组，然后push()方法(用构造函数接收到的所有参数)初始化了数组的值。随后，又给数组实 例添加了一个toPipedString ()方法，该方法返凹以竖线分割的数组值。最后，将数组以函数值的形 式返回。接着，我们调川了 SpecialArray构造函数.向其中传人丁用于初始化数组的值，此后又调

用了 Lo?ipedString()方法。

关于寄生构造函数模式，有一点需要说明：首先，返间的对象与构造函数或者与构造函数的原型屁 性之问没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此， 不能依赖instanceof操作符来确定对象类型。由于存在上述问题，我们建议在可以使用其他模式的情 况下，不要使用这种模式。

6.2.7稳妥构造函数模式

道格拉斯•克罗克福德(Douglas Crockford)发明了 JavaScript中的稳妥对象(durable objects)这 个概念。所谓稳妥对象，指的是没有公共属性，而且K方法也不引用this的对象。稳妥对象最适合在 一些安全的环境中(这些环境中会禁止使用this和new )，或者在防止数据被其他应用程序(如Mashup 程序)改动时使用。稳妥构造函数遵循与寄生构造函数炎似的模式，但冇两点不同：一是新创建对象的 实例方法不引用this;二是不使用new操作符调用构造函数。按照稳妥构造函数的要求，可以将前面 的Person构造函数重写如下。

function Person(name, age, job){

//创建要返回的对象 var o = new Object ◦;

//可以在这里定义私有变量和函数

//添加方法

o.sayName = function(){ alert{name);

//返困对象 return o；

注意，在以这种模式创建的对象中，除f使用sayNameG方法之外，没有其他办法访问name的值。 可以像下面使用稳妥的Person构造函数。

var friend = Person("Nicholas", 29, "Software Engineer")j friend.sayName(); //"Nicholas"

这样，变量person中保存的是一个稳妥对象，而除了调用sayName ()方法外，没有别的方式可 以访问其数据成员。即使有其他代码会给这个对象添加方法或数据成员，但也不可能有别的办法访问传 人到构造闲数中的原始数据。稳妥构造函数模式提供的这种安全性，使得它非常适合在某些安全执行环

境-例如，ADsafe ( [www.adsafe.org](http://www.adsafe.org) )和 Caja ( <http://code.google.eom/p/google-caja/> )提供的环境-

下使用。

与寄生构造函数模式类似，使用稳妥构造函數模式创建的对象与构造函数之间也 没有什么关系，因此instanceof操作符对这种对象也没有意义。

6.3继承

继承是00语言中的一个最为人津津乐道的概念。许多OO语言都支持两种继承方式：接口继承和 实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。如前所述，由于函数没有签名， 在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且其实繼承主要是依靠原型链 来实现的。

6.3.1原型链

ECMAScript中描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原 型让一个弓I用类型继承另一个弓I用类型的属性和方法。简单回顾一下构造函数、原型和实例的关系：每 个构造函数都有一个原型对象，原型对象都包含-个指向构造函数的指针，而实例都包含-个指向原铟 对象的内部指针。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的 原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另■-个构造函数 的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实 例与原型的链条。这就是所谓原型链的基本概念。

实现原迆链有一种基本模式，其代码大致如下。

function SuperType{){

this.property = true；

SuperType.prototype.getSuperValue = function(){ return this.property；

function SubType(){

this.subproperty = false；

//姓承了 SuperType

SubType.prototype = new SuperType()；

SubType.prototype.getSubValue = function (){ return this.subproperty；

var instance = new SubType();

alert(instance.getSuperValue{));    //true

PrototypeChainingExampleO 1. htm

以上代码定义了两个类型：SuperType和SubType。每个类型分别有一个属性和一个方法。它们 的主要区别是SubType继承了 SuperType,而继承是通过创建SuperType的实例，并将该实例赋给 SubType.prototype实现的。实现的本质是重写原型对象，代之以一个新类型的实例。换句话说，原 来存在于SuperType的实例中的所有属性和方法，现在也存在于SubType .prototype中了。在确立了 继承炎系之后，我们给SubType .prototype添加了一个方法，这样就在继承了 SuperType的属性和方 法的基础上又添加了一个新方法。这个例子中的实例以及构造函数和原型之间的关系如图M所示。

prototype

 

SuperType

 

| SuperType Prototype |            |
| ------------------- | ---------- |
| constructor         | 番，       |
| getSuperValue       | (function) |

 

SubType

 

prototype |

| instance      |       |
| ------------- | ----- |
| ([Prototype}] | •-    |
| subproperty   | false |

 

| SubType Prototype |            |
| ----------------- | ---------- |
| I[Prototype]]     | •-         |
| property          | true       |
| getSubValue       | (function) |

 

图6-4

在上面的代码中，我们没有使用SubType默认提供的原型，而是给它换了一个新原型；这个新原型 就是SuperType的实例。于是，新原型不仅具有作为一个SuperType的实例所拥有的全部属性和方法， 而且其内部还有一个指针，指向了 SuperType的原型。最终结果就是这样的：instance指向SubType 的原型，SubType的原型又指向SuperType的原型。getSuperValue ()方法仍然还在 SuperType. prototype 中，但 property 则位于 SubType .prototype 中。这是因为 property 是一 个实例属性，而getSuperValue ()则是一个原型方法。既然SubType.prototype现在是SuperType

的实例，那么property当然就位于该实例中了。此外，要注意instance.constructor现在指向的 是SuperType,这是因为原来SubType.prototype中的constructor被重写了的缘故®。

通过实现原瑠链，本质上扩展了本章前面介绍的原型捜索机制。读者大概还记得，当以读取模式访 问一个实例属性时，首先会在实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原铟。在 通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。就章上面的例子来说，调用 instance.getSuperValue ()会经历三个搜索步骤：1 )搜索实例；2)搜索 SubType.prototype; 3)搜索SuperType.prototype,最后一步才会找到该方法。在找不到属性或方法的情况下，搜索过 程总是要一环一环地前行到原型链末端才会停F来。

1.别忘记默认的原型

事实上，前面例子中展示的原型链还少一环。我们知道，所有引用类型默认都继承了 Object,而 这个继承也足通过原型链实现的。大家要记住，所有函数的默认原型都是Object的实例，因此默认原 型都会包含一个内部指针，指向Object .prototype。这也正是所有自定义类型都会继承toString U、 valueof <)等賦认方法的根本原因。所以，我们说上面例子展示的原型链中还应该包括另外一个继承层 次。图6-5为我们展示了该例子中完整的原型链。

SubType prototype |

 

| SubType Prototype |            |
| ----------------- | ---------- |
| [[Prototype]]     |            |
| property          | true       |
| getSubvalue       | (function} |

 

| instance      |       |
| ------------- | ----- |
| [[Prototype]] |       |
| subpropercy   | false |

 

阁6-5

一句话，SubType继承了 SuperType,而 SuperType 了继承Object。当调用 instance.toString() 时，实际上调用的是保存在Object .prototype中的那个方法o

①实际上，不是SubType的原塑的constructor属性被重写T*，而是SubType的原型指向了另一个对象-

SuperType的原型，而这个质塑对象的constructor属性指向的是Super*Type。

2.确定原型和实例的关系

可以通过两种方式来确定原型和实例之间的关系。第一种方式是使用instanceof操作符，只要用 这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回true。以下几行代码就说明了这

'点。

alert(instance    instanceof    Object);    //true

alert(instance    instanceof    SuperType);    //true

alert(instance    instanceof    SubType);    //true

PrototypeChainingExampleOl. htm

由于殷型链的关系，我们可以说instance是Object、SuperType或SubType中任何一个类型 的实例。㈥此，测试这三个构造函数的结果都返囲了 true。

第二种方式是使用isPrototypeOfU方法。同样，只要是原型链中出现过的原型，都可以说是该 原型链所派生的实例的原型，因此isPrototypeOf()方法也会返回true,如下所示。

alert(Object.prototype.isPrototypeOf(instance));    //true

alert(SuperType.prototype.isPrototypeOf(instance));    //true

alert(SubType.prototype.isPrototypeOf(instance))；    //true

PrototypeChainingExampleO 1 .htm

3.谨慎地定义方法

子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不赞怎 样，给原型添加方法的代码一定要放在替换原型的语句之后。來看下面的例子。

function SuperType(){

this.property = true；

)

SuperType.prototype.getSuperValue = function(){ return this.property;

}；

function SubType(){

this.subproperty = false；

)

//继承了 SuperType

SubType.prototype = new SuperType();

"添加新方法

SubType.prototype.getSubValue = function (){ return this.Bubproperty;

);

//重写超类型中的方法

SubType.prototype.getSuperValue = function <){ return false;

};

var instance = new SubType(>；

alert(instance.getSuperValue())； //false

PrototypeChainingExamp!e02. htm

在以上代好中，加粗的部分■是两个方法的定义。第一个方法getSubValue()被添加到了 SubType 中。第二个方法getSuperValueO是原型链中已经存在的一个方法，但重写这个方法将会屏蔽原来的 那个方法。换句话说，当通过SubType的实例调用getSuperValueG时，调用的就是这个重新定义 的方法；但通过SuperType的实例调用getSuperValue<)时，还会继綾调用原来的那个方法。这里 要格外注意的是，必须在用SuperType的实例替换原型之后，再定义这两个方法。

还有一点耑要提醒读者，即在通过原型链实现继承时，不能使用对象字面傲创建原型方法。因为这 样做就会重写原型链，如下面的例子所示。

function SuperType()｛

this.property = true；

SuperType.prototype.getSuperValue = function。｛ return this.property;

｝；

function SubType(){

this.subproperty = false;

}

"继承了 SuperType

SubType.prototype = new SuperType();

//使用字兩量添加析方法，会导致上一行代码无效 SubType.prototype = {

getSubValue : function (){ return this. oxabproperty;

someOtherMethod : function (){ return false;

}

var instance = new SubType();

alert(instance.gatSuperValue())；    //error1

PrototypeChainingExample03. htm

以上代W展示了刚刚把SuperType的实例赋值给原型，紧接着又将原型替换成一个对象字面量而 导致的问题。由于现在的原型包含的是一个Object的实例，而非SuperType的实例，因此我们设想 中的原型链已经被切断一SubType和SuperType之间已经没有关系了。

4.原型链的问题

原型链虽然很强大，可以用它来实现继承，但它也存在一问题。其中，谅主要的问题来自包含引 用类型值的原型。想必大家还记得，我们前面介绍过包含引用类型值的原型属性会被所有实例共亨而 这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。在通过原型来实现继承吋，原 型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。 下列代码可以用來说明这个问题。

function SuperType(){

this.colors = ["red*, "blue", "green"]；

)

function SubType(){

}

//继承了 SuperType

SubType .prototype = new SviperType (};

var instancel = new SubType()；

instancel.colors.push("black");

alert(instancel.colors)；    //red,blue,green,blackM

var instance2 = new SubType();

alert(instance2.colors);    //"red,blue,green,black"

PrototypeChainingExample04. htm

这个例子中的SuperType构造函数定义了一个colors属性，该属性包含一个数组(引用类型值)。 SuperType的每个实例都会有各自包含自已数组的colors屈性。当SubType通过原型链继承了 SuperType之后，SubType.prototype就变成了 SuperType的一个实例，因此它也拥有了一个它自

己的colors属性-就跟专门创建丫一个SubType.prototype. colors属性-样。但结果是什么

呢？结果是SubType的所有其例都会共享这一个colors属性。而我们对instancel .colors的修改 能够通过instance2 . colors反映出来，就已經充分证实了这一点。

原型链的第二个问题是：在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上， 应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数3有鉴于此，冉加上 前面刚刚讨论过的由于原型中包含引用炎塑值所带来的问题，实践中很少会单独使用原型链。

6.3.2借用构造函数

在解决原型中包含引用类型值所带来问题的过程中，开发人员开始使用一种叫做借用构造函数 (constructor stealing )的技术(有吋候也叫做仿造对象或经典继承)。这种技术的基本思想相当简单，即 在子类沏构造函数的内部调用超类型构造函数。别忘了，函数只不过是在特定环境中执行代码的对象， 因此通过使用apply ()和call ()方法也可以在(将来)新创建的对象上执行构造函数，如下所示：

function SuperType(){

this.colors = ["red", "blue", "green"]；

function SubType(){

//绒承了 SuperType SuperType.call(this);

var instancel = new SubType{)；

instancel.colors.push{"black");

alert(instance!.colors)；    //"red,blue,green,blackn

var instances = new SubType”；

alert(instance2.colors)?    //"red,blue,green"

ConstructorStealingExampleOL htm

代码中加竹景的那一行代码“借调” 了超类型的构造函数。通过使用cal]()方法(或apply()方 法也可以)，我们实际上是在(未来将要)新创建的SubType实例的环境下调用了 SuperType构造函 数。这样一来，就会在新Sub'iype对象上执行SuperiypeO函数中定义的所有对象初始化代码。结果， SubType的每个实例就都会具有自己的colors属性的副本了。

1.传递参数

相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函 数传递参数。看下面这个例子。

function SuperType(name){ this.name = name；

}

function SubType(){

//谜承了 SuperType,同时还传速了参数 SuperType.call(this, "Nicholas")?

//实例属性 this.age = 29;

}

var instance = new SubType()；

alert(instance.name)；    //"Nicholas";

alert(instance.age)；    //29

ConstructorStealingExampie02 • htm

以上代码中的SuperType只接受-个参数name,该参数会直接赋给一个属性。在SubType构造 函数内部调用SuperType构造函数吋，实际上是为SubType的实例设置了 name属性。为丫确保 SuperTVpe构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中 定义的调性。

2.借用构造函数的问题

如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定 义，因此函数复用就无从谈起了。而且，在超类型的原遨中定义的方法，对子类型而言也是不可见的，结 果所有类型都只能使用构造函数模式。考虑到这些问题，借用构造函数的技术也是很少单独使用的。

6.3.3组合继承

组合继承(combinationinheritance)，有时候也叫做伪经典继承，指的是将原型链和借用构造函数的 技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现Xt原型属性和方 法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数 复用，又能够保证每个实例都有它自己的属性。下面来看一个例子。

function SuperType(name){ this.name = name；

this.colors = [-red", "blue", "green"]；

SuperType.prototype.sayName 二 function{){ alert(this.name)；

}；

function SubType(name, age){

//继承爲性

Supei*Type.call (this, name);

this.age = age;

//继承方法

SubType.prototype = new SuperType();

SubType.prototype.sayAge = function(){ alert(this.age)；

}；

var instancel = new SubType(’Nicholas", 29)；

instancel.colors.push("black")；

alert(instancel.colors);    //"red,blue,green,black"

instancel.sayNaroe()?    //"Nicholas";

instancel.sayAge();    //29

var instance2 = new SubType( alert(instance2.colors); instance2.sayName(); instance2.sayAge();

"Greg"、 27)；

//"red,blue,green //■Greg"；

//27

 

CombinationlnheritanceExampleO l. htm

在这个例子中，SuperType构造函数定义了两个属性：name和colors。SuperType的原细定义 了一个方法sayName ()。SubType构造兩数在调用SuperType构造困数时传人了 name参数，紧接着 又定义了它自己的属性age。然后，将SuperType的实例賦值给SubType的原型，然后又在该新原型

上定义了方法sayAge () o这样一来，就可以让两个不同的SubType实例既分别拥有自己属性-包

括colors属性，又可以使用相同的方法广。

组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为JavaScript中最常用的继 承模式。而且，instanceof和isPrototypeOf ()也能够用于识别基于组合继承创建的对象o

6.3.4原型式继承

道格拉斯•克罗克福德在2006年写了--篇文章，题为Prototypal Inheritance in JavaScript ( JavaScript 中的原型式继承)。在这篇文章中，他介绍了 •种实现继承的方法，这种方法并没有使用严格意义上的 构造函数。他的想法是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。为 了达到这个目的，他给出了如下函数。

function object(o){ function F(){}

F.prototype = o; return new F();

}

在object ()函数内部，先创建了一个临时性的构造函数，然后将传人的对象作为这个构造函数的 原型，最后返间了这个临时类型的一个新实例。从本质上讲，objects)对传人其中的对象执行了一次

浅复制。来养下面的例子。

var person = {

name: "Nicholas'

friends： ["Shelby", MCourt*, "Van"J

var anotherPerson = object(person)；

anotherPerson.name - "Greg";

anotherPerson.friends.push("Rob*)；

var yetAnotherPerson = object(person)；

yet AnotherPerson. name = •■Linda";

yetAnotherPerson.friends.push t"Barbie");

alert(person.friends);    //"Shelby,Court,Van,Rob,Barbie"

PrototypaUnheritanceExampleO !. htm

克罗克福徳主张的这种原型式继承，要求你必须有一个对象可以作为另一个对象的基础。如果有这么 一个对象的话，可以把它传递给object ()函数，然后冉根据具体摇求对得到的对象加以修改即可。在这 个例子中，可以作为另一个对象基础的是person对象，于是我们把它传人到object ()函数中，然沿该 函数就会返回•个新对象。这个新对象将person作为原型，所以它的原型中就包含一个基本类型值属性 和一个引用炎型值厲性。这意味者person, friends不仅属于person所有，而且也会被anotherPerson 以及yetAnotherPerson共享。实际上，这就相当丁•又创建了 person对象的两个副本。

ECMAScript 5通过新增Obj ect. create ()方法规范化了原型式继承。这个方法接收两个参数：一 个用作新对象原型的对象和(可选的)一个为新对象定义额外W性的对象。在传人一个参数的情况下， Object. create 0与object ()方法的行为相同。

var person = {

name： •'Nicholas",

friends: ("Shelby", "Court", "Van"J

};

var anotherPerson = Object.create(person);

anotherPerson.name = "Greg”；

anotherPerson. friends .push {"Rob'1);

var yetAnotherPerson = Object.create(person)j

yetAnotherPerson.name = "Linda";

yetAnotherPerson.friends.push("Barbie");

alert(person.friends); //"Shelby,Court#Van,Rob,Barbie"

PrototypalInheritanceExample02.htm

Object. create ()方法的第二个参数与Object.def ineProperties ()方法的第二个参数格式相 同•-每个属性都是通过肉己的描述符定义的。以这种方式指定的任何属性都会覆盖原迆对象上的同名属 性。例如：

var person = {

name： "Nicholas*,

friends： ["Shelby", "Court", "Van"]

)；

var. anotherPereon « Object.create(person, { name: {

value: "Grog"

}

});

alert(anotherPerson.name)； //"Greg"

PrototypalInheritanceExample03.htm

支持 Object .create (>方法的浏览器有 IE9+、Firefox 4+, Safari 5+、Opera 12+和 Chrome。

在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的悄况下，原型式

继承是完全可以胜任的。不过别忘了，包含引用类型值的属性始终都会共享相应的值，就像使用原型模 式一样。

6.3.5寄生式继承

寄生式(parasitic)继承是与原型式继承紧密相关的一种思路，并且同样也是由克罗克福德推而广 之的。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该 函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。以下代码示范了寄 生式继承模式。

function createAnother(original){

var clone = object (original) ;    //通过讲用函数创建一个新对象

clone. sayHi = function () {    //以某种方式来靖强这个对象

alert("hi");

}；

return clone;    //返因这个对象

}

在这个例7中，createAnotherU函数接收了一个参数，也就是将要作为新对象基础的对象。然 后，把这个对象(original)传递给object ()函数，将返回的结果賦值给clone。再为clone对象 添加一个新方法sayHi (),最后返回clone对象。可以像下面这样来使用createAnother ()函数：

var person = {

name： "Nicholas",

friends: [ "Shelby", "Court" , "Van"].

)?

var anotherPerson = createAnother(person)； anotherPerson.sayHi<); //"hi"

这个例子中的代码基于person返回了一个新对象-anotherPerson。新对象不仅具有person

的所有属性和方法，而还有自己的sayHi ()方法。

在主耍考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示 范继承模式时使用的object ()函数不是必需的；任何能够返回新对象的函数都适用于此模式。

使用寄生式继承来为对象添加函数，会由于不拖做到函数复用而降低效率；这一 点与构造函数模式类似。

6.3.6寄生组合式继承

前面说过，组合继承是JavaScript最常用的继承模式；不过，它也有0己的不足。组合继承最大的 问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是 在子类型构造函数内部。没错，子类型最终会包含超类遨对象的全部实例属性，但我们不得不在调用子 类型构造函数时重写这些属性。冉来看一看下面组合继承的例子。

function SuperType(name){ this.name = name；

this.colors = ["red", "bluew, "green"];

)

SuperType.prototype.sayName    function(){

alert(this.name)；

}?

function SubType(name, age){

SuperType.call (this, name) /    //第二次调用 SuperType()

this.age = age；

SubType.prototype = new SuperType();    //第一次谓用 SuperType()

SubType.prototype.constructor = SubType；

SubType.prototype.sayAge = function(){ alert(this.age);

};

加粗字体的行中是调用SuperType构造函数的代码。在第一次调用SuperType构造函数时， SubType .prototype会得到两个域性：name和colors;它们都是SuperType的实例屈性，只不过 现在位于SubType的原型中。当调用SubType构造函数吋，乂会调用一次SuperType构造函数，这 一次乂在新对象上创建了实例属性name和colors。于是，这两个属性就屏蔽了原型中的两个同名厲 性。图卜6展示了上述过程。

如阁6-6所示，有两组name和colors属性：一组在实例上，-*组在SubType原型中。■这就是调 用两次SuperlVpe构造函数的结果。好在我们已经找到了解决这个问题方法一寄生组合式继承。

所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背 后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型 原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的厣型，然后再将结果指定给子类型 的原型。寄生组合式继承的基本模式如下所示。

function inheritPrototype(SubType, SuperType){

var prototype = object (SuperType.prototype) t    //创建对象

prototype, constructor = SubType;    //i養强对象

subType. prototype = prototype:    //拍史对象

}

这个示例中的inheritPrototype <)兩数实现了奇生组合式继承的最简单形式。这个涵数接收两 个参数：子类型构造函数和超类型构造函数。在函数内部，第一步是创建超类型原羽的-个副本。第二 步是为创建的副本添加constructor屈性，从而弥补因重写原坳而失去的默认的constructor属性。 最后一步，将新创建的对象(即副木)赋值给了类型的原铟。这样，我们就町以用调用inheritPrototype () 函数的语句，去替换前面例子中为子类型原型赋值的语句了，例如：

function SuperType(name){ this.name = name?

this.colors = ["red", "blue"# "green"];

}

SuperType.prototype.sayName = function(){ alert(this.name);

}；

function SubType(name, age){

SuperType.call(this, name)；

this.age = age；

}

inheritPrototype(SubType# SuperType)j

SubType.prototype.sayAge = function(){ alert(this.age)；

ParasiticCombinationInheritanceExample01.htm

 

SubType.prototype = new SuperType()

 

prototype

 

SuperType

 

SuperType Prototype

 

SubType

 

prototype |

 

cons 匕：rue tor |

r*

| SubType Prototype |             |
| ----------------- | ----------- |
| [[Prototype]}     |             |
| name              | (undefined) |
| colors            | (array)     |

 

var instance = new SubType("Nicholas，， 29)

 

prototype

 

SuperType

 

r->-

 

SuperType Prototype

 

constructor

 

SubType

 

prototype |

 

| instance      |            |
| ------------- | ---------- |
| [(Protorype]] |            |
| name          | "Nicholas" |
| colors        | (array)    |
| age           | 29         |

 

| SubType Prototype |             |
| ----------------- | ----------- |
| [[Prototype]J     |             |
| name              | (undefined) |
| colors            | (array)     |

 

图6-6

这个例子的高效率体现在它只调用了一次SuperT/pe构造函数，并旦因此避免了在SubT/pe. prototype上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；W此，还能够正常使用 instanceof和isPrototypeOf () o开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。

YUI的YAHOO, lang.extend()方法采用了寄生组合继承，从而让这种模式首次 出现在了 一个应用非常广泛的JavaScript库中。要了解有关YUI的更多信息，请访问 <http://developer>. yahoo.com/yui/□

6.4小结

ECMAScript支持面向对象(00)编程，但不使用类或者接口。对象可以在代码执行过程中创建和 坩强，因此具有动态性而非严格定义的实体。在没有类的情况下，可以采用下列模式创建对象。

□工厂模式，使用简单的函数创建对象，为对象添加属性和方法，然后返回对象。这个模式后来 被构造函数模式所取代。

□构造函数模式，可以创建Q定义引用类型，可以像创建内置对象实例一样使用new操作符。不 过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数可以不局 限于任何对象(即与对象具有松散耦合的特点)，因此没有理由不在多个对象间共享函数。

□原型模式，使用构造函数的prototype属性来指定那些应该共享的属性和方法。组合使用构造 函数模式和原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。

JavaScript主要通过原型链实现继承。原型链的构建是通过将一个类型的实例赋值给另一个构造函 数的原型实现的。这样，子类型就能够访问超类型的所冇属性和方法，这一点与基于类的继承很相似。 原型链的问题是对象实例共享所冇继承的属性和方法，因此不适宜单独使用。解决这个问题的技术是借 用构造函数，即在子类型构造函数的内部调用超类甩构造函数。这样就可以做到每个实例都具右自己的 属性，同时还能保证只使川构造函数模式来定义类型。使用巖多的继承模式是组合继承，这种模式使用 原型链继承共享的属性和方法，而通过借用构造函数继承实例属性。

此外，还存在下列可供选择的继承模式。

□原铟式继承，可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅 复制。而复制得到的副本还可以得到进一步改造。

□寄生式继承，与原型式继承非常相似，也是基F某个对象或某些信息创建一个对象，然后增强 对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问 题，可以将这个模式与组合继承一起使用。

□寄生组合式继承，集寄生式继承和组合继承的优点与一身，是实现基于类型继承的最有效方式。