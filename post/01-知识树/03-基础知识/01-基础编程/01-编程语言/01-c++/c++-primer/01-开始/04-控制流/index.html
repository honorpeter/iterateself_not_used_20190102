<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>04 控制流 - 迭代自己</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="iterateself" />
  <meta name="description" content="4 控制流 语句一般是顺序执行的：语句块的第一条语句首先执行，然后是第二条语句，依此类推。当然，少数程序，包括我们解决书店问题的程序，都可以写成" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.47.1" />


<link rel="canonical" href="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01-c&#43;&#43;/c&#43;&#43;-primer/01-%E5%BC%80%E5%A7%8B/04-%E6%8E%A7%E5%88%B6%E6%B5%81/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="04 控制流" />
<meta property="og:description" content="4 控制流 语句一般是顺序执行的：语句块的第一条语句首先执行，然后是第二条语句，依此类推。当然，少数程序，包括我们解决书店问题的程序，都可以写成" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01-c&#43;&#43;/c&#43;&#43;-primer/01-%E5%BC%80%E5%A7%8B/04-%E6%8E%A7%E5%88%B6%E6%B5%81/" /><meta property="article:published_time" content="2018-08-03T17:57:05&#43;00:00"/>
<meta property="article:modified_time" content="2018-08-03T17:57:05&#43;00:00"/>
<meta itemprop="name" content="04 控制流">
<meta itemprop="description" content="4 控制流 语句一般是顺序执行的：语句块的第一条语句首先执行，然后是第二条语句，依此类推。当然，少数程序，包括我们解决书店问题的程序，都可以写成">


<meta itemprop="datePublished" content="2018-08-03T17:57:05&#43;00:00" />
<meta itemprop="dateModified" content="2018-08-03T17:57:05&#43;00:00" />
<meta itemprop="wordCount" content="5725">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="04 控制流"/>
<meta name="twitter:description" content="4 控制流 语句一般是顺序执行的：语句块的第一条语句首先执行，然后是第二条语句，依此类推。当然，少数程序，包括我们解决书店问题的程序，都可以写成"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">迭代自己</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">最新</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/catalog/">
        <li class="mobile-menu-item">完整目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">迭代自己</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">最新</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/catalog/">完整目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">04 控制流</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-08-03 </span>
        
        <span class="more-meta"> 5725 words </span>
        <span class="more-meta"> 12 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#4-控制流">4 控制流</a>
<ul>
<li><a href="#4-1-while-语句">4.1 while 语句</a>
<ul>
<li><a href="#练习">练习</a></li>
</ul></li>
<li><a href="#4-2-for-语句">4.2 for 语句</a>
<ul>
<li><a href="#练习-1">练习</a></li>
</ul></li>
<li><a href="#4-3-读取数量不定的输人数据">4.3 读取数量不定的输人数据</a>
<ul>
<li><a href="#从键盘输入文件结束符">从键盘输入文件结束符</a></li>
<li><a href="#再探编译">再探编译</a></li>
<li><a href="#练习-2">练习</a></li>
<li><a href="#关键概念-c-程序的缩进和格式">关键概念：C++程序的缩进和格式</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      

<h2 id="4-控制流">4 控制流</h2>

<p>语句一般是顺序执行的：语句块的第一条语句首先执行，然后是第二条语句，依此类推。当然，少数程序，包括我们解决书店问题的程序，都可以写成只有顺序执行的形式。 似程序设计语言提供了多种不同的控制流语句，允许我们写出更为复杂的执行路径。</p>

<h3 id="4-1-while-语句">4.1 while 语句</h3>

<p>while语句反复执行一段代码，直至给定条件为假为止。我们可以用 while 语句编写一段程序，求 1 到 10 这 10 个数之和：</p>

<pre><code class="language-cpp">#include &lt;iostream&gt;
int main()
{
    int sum = 0, val = 1;
    // 只要val的值小于等于10，while循环就会持续执行
    while (val &lt;= 10) {
        sum += val; // 将 sum + val 赋予 sum
        ++val;    // 将 val 加 1
    }
    std::cout &lt;&lt; &quot;Sum of 1 to 10 inclusive is &quot; &lt;&lt; sum &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<p>我们编译并执行这个程序，它会打印出</p>

<pre><code>Sum of 1 to 10 inclusive is 55
</code></pre>

<p>与之前的例子一样，我们首先包含头文件 iostream，然后定义 main。在 main 中 我们定义两个 <code>int</code> 变量：<code>sum</code>用来保存和；<code>val</code>用來表示依次的从 1 到 10 。我们将 <code>sum</code> 的初值设置为 0 ，<code>val</code> 从 1 开始。</p>

<p>这个程序的新内容是while语句。while语句的形式为</p>

<pre><code class="language-cpp">while (condition)
    statement
</code></pre>

<p>while语句的执行过程是交替地检测 condition 条件和执行关联的语句 statement，直至 condition 为假时停止。所谓条件(condition)就是一个产生真或假的结果的表达式。只要 condition 为真，statement 就会被执行。当执行完 statement ，会再次检测 condition ，如果 condition 仍为真，statement 再次被执行。while语句持续地交替检测 condition 和执行 statement，直到 condition 为假为止。</p>

<p>在本程序中，while语句是这样的</p>

<pre><code class="language-cpp">    // 只要val的值小于等于10，while循环就会持续执行
    while (val &lt;= 10) {
        sum += val; // 将 sum + val 赋予 sum
        ++val;    // 将 val 加 1
    }
</code></pre>

<p>条件中使用了小于等干运算符(&lt;=)来比较<code>val</code>的当前值和10。只要<code>val</code>小于等于10, 条件即为真。如果条件为真，就执行<code>while</code>循环体。在本例中，循环体是由两条语句组成的语句块：</p>

<pre><code class="language-cpp">{
    sum += val; // 将 sum + val 赋予 sum
    ++val;    // 将 val 加 1
}
</code></pre>

<p>所谓语句块（block）,就是用花括号包围的零条或多条语句的序列。语句块也是语句的一种，在任何要求使用语句的地方都可以使用语句块 。在本例中，语句块的第一条语句使用了复合赋值运算符（+=）。此运算符将其右侧的运算对象加到左侧运算对象上，将结果保存到左侧运算对象中。它本质上与一个加法结合一个赋值 (assignment) 是相同的：</p>

<pre><code class="language-cpp">sum = sum + val; // 将 sum + val 赋予 sum 因此，语句块中第一条语句将 val 的值加到当前和 sum 上，并将结果保存在 sum 中。
</code></pre>

<p>下一条语句</p>

<pre><code class="language-cpp">++val; // 将val 加 1
</code></pre>

<p>使用前缀递增运算符（++）。递增运算符将运算对象的值增加1。<code>++val</code>等价于 <code>val=val+1</code>。</p>

<p>执行完 while 循环体后，循环会再次对条件进行求值。如果 val 的值（现在已经增加了）仍然小于等于10，则 while 的循环体会再次执行。循环连续检测条件、执行循环体，直至 val 不再小于等于10为止。</p>

<p>一旦 val 大于10，程序跳出 while 循环，继续执行 while 之后的语句。在本例中，继续执行打印输出语句，然后执行 return 语句完成 main 程序。</p>

<h4 id="练习">练习</h4>

<p>练习1.9:编写程序，使用while循环将50到100的整数相加。</p>

<p>练习1.10：除了<code>++</code>运算符将运算对象的值增加1之外，还有一个递减运算符（<code>--</code>）实现将值减少1。编写程序，使用递减运算符在循环中按递减顺序打印出 10 到 0 之间的整数。</p>

<p>练习1.11:编写程序，提示用户输入两个整数，打印出这两个整数所指定的范围内的所有整数。</p>

<h3 id="4-2-for-语句">4.2 for 语句</h3>

<p>在我们的while循环例子中，使用了变量 <code>val</code> 来控制循环执行次数。我们在循环条件中检测<code>val</code>的值，在<code>while</code>循环体中将<code>val</code>递增。</p>

<p>这种在循环条件中检测变量、在循环体中递增变量的模式使用非常频繁，以至于C++ 语言专门定义了第二种循环语句： <code>for</code> 语句，来简化符合这种模式的语句。可以用 <code>for</code> 语句来重写从1加到10的程序：<span style="color:red;">嗯，才知道 for 语句是由 while 的这种情况独立出来的。以前没有明确这一点。</span></p>

<pre><code class="language-cpp">#include &lt;iostream&gt;

int main()
{
    int sum = 0;
    //从1加到10
    for (int val = 1; val &lt;= 10; ++val)
    {
        sum += val; // 等价于 sum = sum + val
    }
    std::cout &lt;&lt; &quot;Sum of 1 to 10 inclusive is &quot; &lt;&lt; sum &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<p>与之前一样，我们定义了变量sum，并将其初始化为0。在此版本中，<code>val</code>的定义是 <code>for</code> 语句的一部分：</p>

<pre><code class="language-cpp">for (int val = 1; val &lt;= 10; ++val)
{
    sum += val;
}
</code></pre>

<p>每个for语句都包含两部分：循环头和循环体。循环头控制循环体的执行次数，它由三部分组成：</p>

<ul>
<li>一个初始化语句(init-statement)</li>
<li>一个循环条件(condition)</li>
<li>以及一个表达式 (expression)</li>
</ul>

<p>在本例中，初始化语句为</p>

<pre><code class="language-cpp">int val = 1
</code></pre>

<p>它定义了一个名为<code>val</code>的<code>int</code>型对象，并为其赋初值1。变量<code>val</code>仅在<code>for</code>循环内部存 在，在循环结束之后是不能使用的。初始化语句只在for循环入口处执行一次。循环条件</p>

<pre><code class="language-cpp">val &lt;=10
</code></pre>

<p>比较<code>val</code>的值和10。循环体每次执行前都会先检查循环条件。只要<code>val</code>小于等于10, 就会执行for循环体。表达式在for循环体之后执行。</p>

<p>在本例中，表达式</p>

<pre><code class="language-cpp">++val
</code></pre>

<p>使用前缀递增运算符将<code>val</code>的值增加1。执行完表达式后，for语句重新检测循环条件。 如果<code>val</code>的新值仍然小于等于10,就再次执行for循环体。执行完循环体后，再次将 val的值增加1。循环持续这一过程直至循环条件为假。</p>

<p>在此循环中，for循环体执行加法</p>

<pre><code class="language-cpp">sum += val; // 等价于 sum = sum + val
</code></pre>

<p>简要重述一下for循环的总体执行流程：</p>

<ol>
<li>创建变量<code>val</code>,将其初始化为1。</li>
<li>检测<code>val</code>是否小于等于10。若检测成功，执行for循环体。若失败，退出循环, 继续执行for循环体之后的第一条语句。</li>
<li>将<code>val</code>的值增加1，</li>
<li>重复第 2 步中的条件检测，只要条件为真就继续执行剩余步骤，</li>
</ol>

<h4 id="练习-1">练习</h4>

<p>练习1.12:下面的for循环完成了什么功能？ sum的终值是多少？ int sum = 0;</p>

<pre><code class="language-cpp">for (int i = -100; i &lt;= 100; ++i) sum += i;
</code></pre>

<p>练习1.13：使用for循环重做 4.1 节中的所有练习</p>

<p>练习1.14:对比 for 循环和 while 循环，两种形式的优缺点各是什么？<span style="color:red;">优缺点是什么？</span></p>

<p>练习1.15:编写程序，包含第14页&rdquo;再探编译”中讨论的常见错误。熟悉编译器生成的错误信息。</p>

<h3 id="4-3-读取数量不定的输人数据">4.3 读取数量不定的输人数据</h3>

<p>在前一节中，我们编写程序实现了 1 到 10 这10个整数求和。扩展此程序一个很自然的方向是实现对用户输入的一组数求和。在这种情况下，我们预先不知道要对多少个数 求和，这就需要不断读取数据直至没有新的输入为止：</p>

<pre><code class="language-cpp">#include &lt;iostream&gt;
int main()
{
    int sum=0,value=0;
    // 读取数据直到遇到文件尾，计算所有读入的值的和
    while(std::cin&gt;&gt;value)
        sum+=value;
    std::cout&lt;&lt; &quot;Sum is : &quot;&lt;&lt; sum &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<p>如果我们输入：<span style="color:red;">这个地方我有点不确定，我一直以为是回车才是真正的输入。现在是空格是真正的输入吗？看了下面的几个小节，感觉又不像。要确认下。</span></p>

<pre><code>3 4 5 6
</code></pre>

<p>则程序会输出</p>

<pre><code>Sum is: 18
</code></pre>

<p>main 的首行定义了两个名为<code>sum</code>和<code>value</code>的int变量，均初始化为 0 。我们使用 <code>value</code> 保存用户输入的每个数，数据读取操作是在 while 的循环条件中完成的：</p>

<pre><code>while (std::cin &gt;&gt; value)
</code></pre>

<p>while循环条件的求值就是执行表达式</p>

<pre><code class="language-cpp">std::cin &gt;&gt; value
</code></pre>

<p>此表达式从标准输入读取下一个数，保存在value中。输入运算符(参见1.2节，第7 页)返回其左侧运算对象，在本例中是 <code>std::cin</code> 。因此，此循环条件实际上检测的是 <code>std::cin</code> 。</p>

<p><strong>当我们使用一个 istream 对象作为条件时，其效果是检测流的状态。如果流是有效 的，即流未遇到错误，那么检测成功。当遇到文件结束符(end-of-file)，或遇到一个无效输入时(例如读入的值不是一个整数)，istream 对象的状态会变为无效。处于无效状态的 istream 对象会使条件变为假。</strong> <span style="color:red;">嗯，OK，那么文件结束符怎么输入？是直接回车吗？空格是输入的触发条件吗？</span></p>

<p>因此，我们的 while 循环会一直执行直至遇到文件结束符(或输入错误)。while 循环体使用复合赋值运算符将当前值加到 <code>sum</code> 上。一旦条件失败，while循环将会结束。 我们将执行下一条语句，打印<code>sum</code>的值和一个<code>endl</code>。</p>

<blockquote>
<h4 id="从键盘输入文件结束符">从键盘输入文件结束符</h4>

<p>当用键盘向程序输入数据时，对于如何指出文件结束，不同操作系统有不同的约定。 在Windows系统中，输入文件结束符的方法是敲 <code>Ctrl+Z</code> (按住Ctrl键的同时按Z键)， 然后按<code>Enter</code>或<code>Return</code>键。在UNIX系统中，包括 MacOSX 系统中，文件结束符输入是用 <code>Ctrl+D</code>。<span style="color:red;">嗯。</span></p>

<h4 id="再探编译">再探编译</h4>

<p>编译器的一部分工作是寻找程序文本中的错误。编译器没有能力检查一个程序是否 按照其作者的意图工作，但可以检查形式(form)上的错误。下面列出了一些最常见的 编译器可以检查出的错误、</p>

<p><strong>语法错误(syntax error)</strong>:程序员犯了 C++ 语言文法上的错误。下面程序展示了一些常见的语法错误；每条注释描述了下一行中语句存在的错误：</p>

<pre><code>&gt; //错误：main的参数列表漏掉了
&gt; int main (
&gt; {
&gt;     //错误：endl后使用了冒号而非分号
&gt;     std::cout &lt;&lt; &quot;Read each file.&quot; &lt;&lt; std::endl:
&gt;     //错误：字符串字面常量的两侧漏掉了引号
&gt;     std::cout &lt;&lt; Update master. &lt;&lt; std::endl;
&gt;     //错误：漏掉了第二个输出运算符
&gt;     std::cout &lt;&lt; &quot;Write new master.&quot;  std::endl;
&gt;     //错误：return 语句漏掉了分号
&gt;     return 0
&gt; }
&gt; ```
&gt;
&gt; **类型错误(type error)**: C++ 中每个数据项都有其类型。例如，10 的类型是`int` (或者 更通俗地说，“10是一个int型数据”)。单词&quot;hello&quot;,包括两侧的双引号标记，则是一个字符串字面值常量。一个类型错误的例子是，向一个期望参数为int的函数传递了一个字符串字面值常量。
&gt;
&gt; **声明错误(declaration error)**: C++ 程序中的每个名字都要先声明后使用。名字声明失败通常会导致一条错误信息。两种常见的声明错误是：对来自标准库的名字忘记使用 `std::`、标识符名字拼写错误：
&gt;
&gt; ```cpp
&gt; #include &lt;iostream&gt;
&gt;
&gt; int main()
&gt; {
&gt;     int vl = 0, v2 = 0;
&gt;     std: :cin &gt;&gt; v &gt;&gt; v2; // 错误：使用了 &quot;v&quot; 而非 &quot;vl&quot;
&gt;     // 错误：cout 未定义；应该是std::cout
&gt;     cout &lt;&lt; vl + v2 &lt;&lt; std::endl;
&gt;     return 0;
&gt; }
&gt; ```
&gt;
&gt; 错误信息通常包含一个行号和一条简短描述，描述了编译器认为的我们所犯的错 误。按照报告的顺序来逐个修正错误，是一种好习惯。&lt;span style=&quot;color:red;&quot;&gt;嗯。&lt;/span&gt;因为一个单个错误常常会具有传递效应，导致编译器在其后报告比实际数量多得多的错误信息，另一个好习惯是在每修正一个错误后就立即重新编译代码，或者最多是修正了一小部分明显的错误后就重新编译。这就是所谓的 “编辑-编译-调试” (edit-compile-debug )周期。&lt;span style=&quot;color:red;&quot;&gt;嗯。&lt;/span&gt;

#### 练习

练习1.16:编写程序，从cin读取一组数，输出其和。

### 4.4 if 语句

与大多数语言一样，C++ 也提供了 if语句來支持条件执行。我们可以用if语句写一个程序，来统计在输入中每个值连续出现了多少次：

```cpp
#include &lt;iostrea&gt;
int main(){
    // currVal是我们正在统计的数；我们将读入的新值存入val int currVal =0, val = 0;
    int currVal=0,val=0;
    //读取第一个数，并确保确实有数据可以处理
    if (std::cin&gt;&gt;currVal){
        int cnt=1;                //保存我们正在处理的当前值的个数
        while(std::cin&gt;&gt;val){     //读取剩余的数
            if (val == currVal)
                ++cnt;
            else{             //否则，打印前一个值的个数
                std::cout &lt;&lt; currVal &lt;&lt; &quot; occurs &quot;
                          &lt;&lt; cnt &lt;&lt;&quot; times &quot;&lt;&lt; std::endl;
                currVal=val;
                cnt=1;
            }
        }
        // 记住打印文件中最后一个值的个数
        std::cout &lt;&lt; currVal &lt;&lt; &quot; occurs &quot;
                  &lt;&lt; cnt &lt;&lt; &quot; times &quot; &lt;&lt; std::endl;
    }
    return 0;
}
</code></pre>
</blockquote>

<p>如果我们输入如下内容:</p>

<pre><code>42 42 42 42 42 55 55 62 100 100 100
</code></pre>

<p>则输出应该是：</p>

<pre><code>42 occurs 5 times 55 occurs 2 times 62 occurs 1 times 100 occurs 3 times
</code></pre>

<p>有了之前多个程序的基础，你对这个程序中的大部分代码应该比较熟悉了。程序以两个变量<code>val</code>和<code>currVal</code>的定义开始：<code>currVal</code>记录我们正在统计出现次数的那个数； <code>val</code>则保存从输入读取的每个数。与之前的程序相比，新的内容就是两个if语句。第一条if语句</p>

<pre><code class="language-cpp">if (std::cin&gt;&gt;currVal){
    // ...
} //最外层的if语句在这里结束
</code></pre>

<p>保证输入不为空。与 while 语句类似，if 也对一个条件进行求值。第一条if语句的条件是读取一个数值存入<code>currVal</code>中。如果读取成功，则条件为真，我们继续执行条件之后的语句块。该语句块以左花括号开始，以 return 语句之前的右花括号结束。</p>

<p>如果需要统计出现次数的值，我们就定义<code>cnt</code>,用来统计每个数值连续出现的次数。 与上一小节的程序类似，我们用一个 while 循环反复从标准输入读取整数。</p>

<p>while的循环体是一个语句块，它包含了第二条if语句：</p>

<pre><code class="language-cpp">if (val == currVal)
    ++cnt;
else{             //否则，打印前一个值的个数
    std::cout &lt;&lt; currVal &lt;&lt; &quot; occurs &quot;
              &lt;&lt; cnt &lt;&lt;&quot; times &quot;&lt;&lt; std::endl;
    currVal=val;
    cnt=1;
}
</code></pre>

<p>这条if语句中的条件使用了相等运算符（<code>==</code>）来检测<code>val</code>是否等于<code>currVal</code>。如果是, 我们执行紧跟在条件之后的语句。这条语句将<code>cnt</code>增加1，表明我们再次看到了 <code>currVal</code> 。</p>

<p>如果条件为假，即<code>val</code>不等于<code>currVal</code>,则执行else之后的语句。这条语句是一个由一条输出语句和两条赋值语句组成的语句块。输出语句打印我们刚刚统计完的值的出现次数。赋值语句将<code>cnt</code>重置为1，将<code>currVal</code>重置为刚刚读入的值val。</p>

<p><strong>注意：C++ 用 <code>=</code> 进行赋值，用 <code>==</code> 作为相等运算符。两个运算符都可以出现在条件中。一个常见的错误是想在条件中使用<code>==</code>（相等判断），却误用了<code>=</code>。</strong></p>

<h4 id="练习-2">练习</h4>

<p>练习1.17:如果输入的所有值都是相等的，本节的程序会输出什么？如果没有重复值， 输出又会是怎样的？</p>

<p>练习1.18:编译并运行本节的程序，给它输入全都相等的值。再次运行程序，输入没有 重复的值。</p>

<p>练习1.19：修改你为1.4.1节练习1.10（第11页）所编写的程序（打印一个范围内的数）, 使其能处理用户输入的第一个数比第二个数小的情况。</p>

<blockquote>
<h4 id="关键概念-c-程序的缩进和格式">关键概念：C++程序的缩进和格式</h4>

<p>C++ 程序很大程度上是格式自由的，也就是说，我们在哪里放置花括号、缩进、注 释以及换行符通常不会影响程序的语义。例如，花括号表示 main 函数体的开始，它可以放在main的同一行中；也可以像我们所做的那样，放在下一行的起始位置；还可以放在我们喜欢的其他任何位置，唯一的要求是左花括号必须是 main 的形参列表后第一个非空、非注释的字符。</p>

<p>虽然很大程度上可以按照自己的意愿自由地设定程序的格式，但我们所做的选择会影响程序的可读性。例如，我们可以将整个 main 函数写在很长的单行内，虽然这样是合乎语法的，但会非常难读。</p>

<p>关于 C/C++ 的正确格式的辩论是无休止的。我们的信条是，不存在唯一正确的风格，但保持一致性是非常重要的。例如，大多数程序员都对程序的组成部分设置恰当的缩进， 就像我们在之前的例子中对main函数中的语句和循环体所做的那样。对于作为函数界定符的花括号，我们习惯将其放在单独一行中。我们还习惯对复合 IO 表达式设置缩进，以使输入输出运算符排列整齐。其他一些缩进约定也都会令越来越复杂的程序更加清晰易读。</p>

<p>我们要牢记一件重要的事情：其他可能的程序格式总是存在的。当你要选择一种格式风格时，思考一下它会对程序的可读性和易理解性有什么影响，而一旦选择了一种风格，就要坚持使用、</p>
</blockquote>

<p><span style="color:red;">感觉最后这一段关于C++ 的缩进的好像没说什么。</span></p>

    </div>

    
    

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01-c&#43;&#43;/c&#43;&#43;-primer/01-%E5%BC%80%E5%A7%8B/05-%E7%B1%BB%E7%AE%80%E4%BB%8B/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">05 类简介</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01-c&#43;&#43;/c&#43;&#43;-primer/01-%E5%BC%80%E5%A7%8B/02-%E5%88%9D%E8%AF%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/">
            <span class="next-text nav-default">02 初识输入输出</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="iteratelyd@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/iterateself" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/thebegin/activities" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/68028070/" class="iconfont icon-douban" title="douban"></a>
  <a href="http://iterate.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">iterateself</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>








</body>
</html>
