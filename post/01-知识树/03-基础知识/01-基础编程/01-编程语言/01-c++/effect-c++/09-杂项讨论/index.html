<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>09 杂项讨论 - 迭代自己</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="iterateself" />
  <meta name="description" content="9 杂项讨论 Miscellany 欢迎来到大杂烩的一章。本章只有3个条款，但千万别被低微的数字或不迷人 的布景愚弄了，它们都很重要！ 第一个条款强调不可以轻忽编译器警" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.47.1" />


<link rel="canonical" href="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01-c&#43;&#43;/effect-c&#43;&#43;/09-%E6%9D%82%E9%A1%B9%E8%AE%A8%E8%AE%BA/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="09 杂项讨论" />
<meta property="og:description" content="9 杂项讨论 Miscellany 欢迎来到大杂烩的一章。本章只有3个条款，但千万别被低微的数字或不迷人 的布景愚弄了，它们都很重要！ 第一个条款强调不可以轻忽编译器警" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01-c&#43;&#43;/effect-c&#43;&#43;/09-%E6%9D%82%E9%A1%B9%E8%AE%A8%E8%AE%BA/" /><meta property="article:published_time" content="2018-06-26T21:59:56&#43;00:00"/>
<meta property="article:modified_time" content="2018-06-26T21:59:56&#43;00:00"/>
<meta itemprop="name" content="09 杂项讨论">
<meta itemprop="description" content="9 杂项讨论 Miscellany 欢迎来到大杂烩的一章。本章只有3个条款，但千万别被低微的数字或不迷人 的布景愚弄了，它们都很重要！ 第一个条款强调不可以轻忽编译器警">


<meta itemprop="datePublished" content="2018-06-26T21:59:56&#43;00:00" />
<meta itemprop="dateModified" content="2018-06-26T21:59:56&#43;00:00" />
<meta itemprop="wordCount" content="9578">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="09 杂项讨论"/>
<meta name="twitter:description" content="9 杂项讨论 Miscellany 欢迎来到大杂烩的一章。本章只有3个条款，但千万别被低微的数字或不迷人 的布景愚弄了，它们都很重要！ 第一个条款强调不可以轻忽编译器警"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">迭代自己</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">最新</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/catalog/">
        <li class="mobile-menu-item">完整目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">迭代自己</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">最新</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/catalog/">完整目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">09 杂项讨论</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-06-26 </span>
        
        <span class="more-meta"> 9578 words </span>
        <span class="more-meta"> 20 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#9">9</a>
<ul>
<li><a href="#杂项讨论">杂项讨论</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      

<h3 id="9">9</h3>

<h4 id="杂项讨论">杂项讨论</h4>

<p>Miscellany</p>

<p>欢迎来到大杂烩的一章。本章只有3个条款，但千万别被低微的数字或不迷人 的布景愚弄了，它们都很重要！</p>

<p>第一个条款强调不可以轻忽编译器警告信息。至少，如果你希望你的软件有适 当行为的话，别太轻忽它们。第二个条款带你综览C++标准程序库，其中覆盖由 TR1引进的重大新机能。最后一个条款带你综览Boost,那是我认为最重要的一个 C++泛用型网站。如果你尝试写出高效C++软件，却没有参考这些条款所提供的 信息，那么充其量也只是一场事倍功半的恶战。</p>

<p>条款53:不要轻忽编译器的警告</p>

<p>Pay attention to compiler warnings.</p>

<p>许多程序员习惯性地忽略编译器警告。他们认为，毕竟，如果问题很严重，编</p>

<p>译器应该给一个错误信息而非警告信息，不是吗？这种想法对其他语言或许相对无</p>

<p>害，但在C++，我敢打赌编译器作者对于将会发生的事情比你有更好的领悟。举个</p>

<p>例子，下面是多多少少都会发生在每个人身上的一个错误：</p>

<p>class B { public:</p>

<p>virtual void f( ) const;</p>

<p>}；</p>

<p>class D: public B { public:</p>

<p>virtual void f();</p>

<p>聯c如e C++中文版，第三版</p>

<p>这里希望以D::f重新定义virtual函数B::f,但其中有个错误：B中的f是个 const成员函数，而在D中它未被声明为const。我手上的一个编译器于是这样说 话了，</p>

<p>warning: D::f() hides virtual B::f()</p>

<p>太多经验不足的程序员对这个信息的反应是：“噢当然，D::f遮掩了 B::f, 那正是想象中该有的事I ”错，这个编译器试图告诉你声明于B中的f并未在D中 被重新声明，而是被整个遮掩了(条款33描述为什么会这样)。如果忽略这个编 译器警告，几乎肯定导致错误的程序行为，然后是许多调试行为，只为了找出编译 器其实早就侦测出来并告诉你的事情。</p>

<p>一旦从某个特定编译器的警告信息中获得经验，你将学会了解，不同的信息意 味什么——那往往和它们“看起来”的意义十分不同！尽管一般认为，写出一个在 最髙警告级别下也无任何警告信息的程序最是理想，然而一旦有了上述的经验和对 瞀告信息的深刻理解，你倒是可以选择忽略某些警告信息。不管怎样说，在你打发 某个警告信息之前，请确定你了解它意图说出的精确意义。这很重要。</p>

<p>记住，瞀告信息天生和编译器相依，不同的编译器有不同的警告标准，所以， 草率编程然后倚赖编译器为你指出错误，并不可取。例如上述发生“函数遮掩&rdquo;的 代码就可能通过另一个编译器，连半句抱怨和抗议也没有。</p>

<p>请记住</p>

<p>■严肃对待编译器发出的警告信息。努力在你的编译器的最高(最严苛)警告级 别下争取“无任何警告”的荣誉。</p>

<p>■不要过度倚赖编译器的报警能力，因为不同的编译器对待事情的态度并不相同。 一旦移植到另一个编译器上，你原本倚赖的警告信息有可能消失。</p>

<p>条款54:让自己熟悉包括TR1在内的标准程序库</p>

<p>Familiarize yourself with the standard library, including TRI.</p>

<p>C++ Standard-定义C++语言及其标准程序库的规范-早在1998年就被</p>

<p>标准委员会核准了。标准委员会又于2003年发布一个不很重要的“错误修正版”， 并预计于2008年左右发布C++ Standard2.0。日期的不确定性使得人们总是称呼下 一版 C++ 为&rdquo;C++0x&rdquo;,意指 200x 版的 C++。</p>

<p>Effective C++中文版，第三版</p>

<p>C++0x或许会覆盖某些有趣的语言新特性，但大部分新机能将以标准程序库的 扩充形式体现。如今我们已经能够知道某些新的程序库机能，因为它被详细叙述于 一份称为TR1的文档内。TR1代表&rdquo;Technical Report 1&rdquo;,那是C++程序库工作小 组对该份文档的称呼。标准委员会保留了 TR1被正式铭记于C++0x之前的修改权， 不过目前已不可能再接受任何重大改变了。就所有意图和目标而言，TR1宣示了一 个新版C++的来临，我们可能称之为Standard C++1.1。不熟悉TR1机能而却奢望 成为一位高效的C++程序员是不可能的，因为TR1提供的机能几乎对每一种程序 库和每一种应用程序都带来利益。</p>

<p>在概括论述TR1有些什么之前，让我们先回顾一下C++98列入的C++标准程 序库有哪些主要成分：</p>

<p>■    STL (Standard Template Library,标准模板库)，覆盖容器(conffl/ners 如 vector, string, map)、迭代器(iterators) &gt; 算法(algorithms 如 find, sort, transform)、 函数对象(function ofy’ects 如 less, greater)、各种容器适配器 C container fldapfers 如 stack, priority_queue)和函数对象适配器(fMnrttonofy&rsquo;ecf adfltpcrs 如 mem_fun, notl)。</p>

<p>■    Iostreams，覆盖用户自定缓冲功能、国际化I/O,以及预先定义好的对象cin, cout, cerr 和 clog。</p>

<p>■国际化支持，包括多区域(multiple active locales)能力。像wchar_t (通常是 16 bits/char)和 wstring(由 wchar_ts 组成的 strings)等类型都对促进 Unicode 有所帮助。</p>

<p>■数值处理，包括复数模板(complex)和纯数值数组(valarray)。</p>

<p>■异常阶层体系(exception hierarchy),包括 base class exception 及其 derived classes logic_error 和 runtime_error,以及更深继承的各个 classes。</p>

<p>■    C89标准程序库。1989 C标准程序库内的每个东西也都被覆盖于C++内。</p>

<p>如果你对上述任何一项不很熟悉，我建议你好好排出一些时间，带着你最喜爱 的C++书籍，把情势扭转过来。</p>

<p>TR1详细叙述了 14个新组件(components,也就是程序库机能单位)，统统 都放在std命名空间内，更正确地说是在其嵌套命名空间tri内。因此，TR1组件 shared_ptr的全名是std::tri::shared_ptr»本书通常在讨论标准程序库组件时 略而不写std::,但我总是会在TR1组件之前加上tri::。</p>

<p>Effective C++中文版，第三版</p>

<p>本书展示以下TR1组件实例：</p>

<p>■智能指针(smart pointers) tri::shared_ptr 和 tri::weak_ptr&lt;&gt; 前者的作用 有如内置指针，但会记录有多少个tri: :shared_ptrs共同指向同一个对象。这 便是所谓的re/erencecotwriwg (引用计数)。一旦最后一个这样的指针被销毁， 也就是一旦某对象的引用次数变成0,这个对象会被自动删除。这在非环形</p>

<p>(acyclic)数据结构中防止资源泄漏很有帮助，但如果两个或多个对象内含 trl::shared_Ptrs并形成环状(cycle),这个环形会造成每个对象的引用次数 都超过0_即使指向这个环形的所有指针都已被销毁(也就是这一群对象整体 看来己无法触及)。这就是为什么又有个tri:: weak_ptrs的原因。 tri: :weak_ptrs的设计使其表现像是“非环形tri: : shared_j&gt;tr-based数据结 构”中的环形感生指针(cycle-inducing pointers)。tri::weak_ptrs 并不参与 引用计数的计算；当最后一个指向某对象的trl::Shared_ptr被销毁，纵使还 有个trl::Weak_PtrS继续指向同一对象，该对象仍旧会被删除。这种情况下的 tri::weak_ptrs会被自动标不无效。</p>

<p>trl::Shared_ptr或许是拥有最广泛用途的TR1组件。本书多次使用它，条款 13解释它为什么如此重要=本书并未示范使用tri: :weak_ptr，抱歉。</p>

<p>■ tri::function,此物得以表示任何caWaWe (可调用物，也就是任何函数 或函数对象)，只要其签名符合目标。假设我们想注册一个callback函数，该 函数接受一个int并返回一个string,我们可以这么写：</p>

<p>void registerCallback(std::string func(int));</p>

<p>//参数类型是函数，该函数接受一个int并返回一个string</p>

<p>其中参数名称func可有可无，所以上述的registerCallback也可以这样声明： void registerCallback( std: : string (int)); //与上同；参数名称略而未写</p>

<p>注意这里的&rdquo;std: :string (int)&ldquo;是个函数签名。</p>

<p>Effective C++中文版，第三版</p>

<p>tri:: function使上述的RegisterCallback有可能更富弹性地接受任何可调用 物(callable entity),只要这个可调用物接受一个int或任何可被转换为int的 东西，并返回一个string或任何可被转换为string的东西。tri:: function 是个template，以其目标函数的签名(target function signature)为参数：</p>

<p>void registerCallback(std::tri::function<std::string (int) > func); //参数&rdquo;fhnc&rdquo;接受任何可调用物(callable entity)</p>

<p>//只要该“可调用物”的签名与”std::string (int)” 一致</p>

<p>这种弹性真令人惊讶，我尽最大的努力在条款35示范了它的用法。</p>

<p>■    tri::bind，它能够做STL绑定器(binders) bindlst和bind2nd所做的每一件 事，而又更多。和前任绑定器不同的是，tri::bind可以和const及non-const 成员函数协同运作，可以和bK-reference参数协同运作。而且它不需特殊协助就 可以处理函数指针，所以我们调用tri: :bind之前不必再被什么ptr_fun， mem_fun或mem_fun_ref搞得一团混乱了。简单地说，tri::bind是第二代绑定 工具(binding facility),比其前一代好很多。我在条款35示范过它的用法。</p>

<p>我把其他TR1组件划分为两组。第一组提供彼此互不相千的独立机能：</p>

<p>■    Hash tables,用来实现 sets, multisets，maps 和 multi-maps。每个新容器的接口都 以其前任(TR1之前的)对应容器塑模而成、最令人惊讶的是它们的名称•• tri:: unordered_setf tri::unordered._multiset, tri:: unordered_map 以及 tri: :unordered_multimap。这些名称强调它们和 set, multiset，map 或 mviitimp不同•.以hash为基础的这些TR1容器内的元素并无任何可预期的次 序。</p>

<p>■正则表达式(Regularexpressions)，包括以正则表达式为基础的字符串査找和 替换，或是从某个匹配字符串到另一个匹配字符串的逐一迭代(iteration)等等。</p>

<p>■    Tuples (变量组)，这是标准程序库中的pair template的新一代制品。pair只 能持有两个对象，trl::tUple可持有任意个数的对象。漫游于Python和Eiffel 的程序员，额手称庆吧！你们前一个家园的某些好东西现在己经纳入C++。</p>

<p>Effective C++中文版,第三版</p>

<p>■    tri::array,本质上是个“STL化”数组，即一个支持成员函数如begin和end 的数组。不过trizarray的大小固定，并不使用动态内存。</p>

<p>■    tri:    这是个语句构造上与成员函数指针(member fhnction pointers)</p>

<p>一致的东西。就像tri: :bind纳入并扩充C++98的bindlst和bind2nd的能 力一样,tri::mem_fn 纳入并扩充了 C++98 的 mem_fun 和 mem_fun_ref 的能力。</p>

<p>■    tri::refecence_ia:^per) 一■个“让references的行为更像对象”的设施。它 可以造成容器&rdquo;犹如持有references”。而你知道，容器实际上只能持有对象或 指针。</p>

<p>■随机数(random number)生成工具，它大大超越了 rand.那是C++继承自C 标准程序库的一个函数。</p>

<p>■数学特殊函数，包括Laguerre多项式、Bessel函数、完全楠圆积分(complete elliptic integrals),以及更多数学函数。</p>

<p>■    C99兼容扩充。这是一大堆函数和模板(templates),用来将许多新的C99程 序库特性带进C++。</p>

<p>第二组TR1组件由更精巧的template编程技术(包括template metaprogramming,也就是模板元编程，见条款48)构成：</p>

<p>■    Type traits, 一组traits classes (见条款47)，用以提供类型(types)的编译期信 息。给予一个类型T, TR1的type traits可以指出T是否是个内置类型，是否提 供virtual析构函数，是否是个empty class (见条款39)，可隐式转换为其他类 型U吗……等等。TR1的type traits也可以显现该给定类型之适当齐位(proper alignment),这对定制型内存分配器(见条款50)的编写人员是十分关键的信 息。</p>

<p>■    tri::result_of,这是个template,用来推导函数调用的返回类型。当我们编 写templates时，能够“指涉(refer to、函数(或函数模板)调用动作所返回的 对象的类型”往往很重要，但是该类型有可能以复杂的方式取决于函数的参数 类型。trl::reSUlt_of使得“指涉函数返回类型”变得十分容易。它也被TR1 自身的若干组件采用。</p>

<p>虽然若干TR1成分(特别是tri:: bind和tri: :mem_fn)纳入了某些“前TR1 ” 组件能力，但其实TR1是对标准程序库的纯粹添加，没有任何TR1组件用来替换 既有组件，所以早期(写于TR1之前的)代码仍然有效。</p>

<p>Effective C++中文版，第三版</p>

<p>TR1自身只是一份文档夂为了取得它所规范的那些机能，你还需要取得实现 代码。这些代码最终会随编译器出货。在我下笔的2005年此刻，如果你在你手上 的标准程序库实现版本内寻找TR1组件，极可能有某些遗漏。幸运的是你可以补齐 它们：TR1的14个组件中的10个奠基于免费的Boost程序库（见条款55），所以 对TRl-like机能而言，Boost是个绝佳资源。我说&rdquo;TRl-like&rdquo;是因为虽然许多TR1 机能奠基于Boost程序库，但毕竟有些Boost机能并不完全吻合TR1规蒗。当你阅 读这一段文字，说不定Boost已经不只提供与TR1 —致的实现（对于那些奠基于 Boost程序库的10个TR1组件），还供应4个不以Boost为基础的TR1组件实现。</p>

<p>在编译器附带TR1实现品的那一刻到来之前，如果你喜欢以Boost的TRl-like 程序库作为一时权宜，或许你会愿意以一个命名空间上的小伎俩让自己将来好过 些。所有Boost组件都位于命名空间boost内，但TR1组件都置于std::tri内。 你可以这样告诉你的编译器，令它对待references to std::tri就像对待references to boost -■样：</p>

<p>namespace std {</p>

<p>namespace tri = ::boost;    //namespace std::trl是</p>

<p>}    //namespace boost 的一个别名</p>

<p>纯就技术而言，这简直是把你流放到“未定义行为”的国土去了，因为就如条 款25所言，任何人不得加任何东西到std命名空间去。然而实际上你很可能不会 有任何麻烦。一旦将来你的编译器提供它们自己的TR1实现品，你需要做的唯一事 情就是消除上述的namespace别名，而后指涉std:: tri的代码继续生效，好极了。</p>

<p>非以Boost程序库为基础的那些TR1组件之中，最重要的或许是hash tables。 其实 hash tables 早已行之有年，分别以名称 hash_set, hash_multiset, hash_map 和hash_multimap为人熟知。也许你的编译器已经附带那些templates实现码。如 果没有，请启动你最喜欢的查找引擎，査找那些名称（及其TR1称号），你一定可 以找到若干来源，包括商业产品和免费产品。</p>

<p>1在我下笔此刻的2005年初，这份文件尚未定稿，其URL常有变化。我建议你咨询 Effective C++ TR1 信息网页，<a href="http://aristeia.com/EC3E/TRl_mfo.html%c2%bb">http://aristeia.com/EC3E/TRl_mfo.html»</a> 这个 URL 很稳定。 Effective C++中文版，第三版</p>

<p>请记住</p>

<p>■ C++标准程序库的主要机能由STL、iostreams、locales组成。并包含C99标准 程序库。</p>

<p>■    TR1添加了智能指针(例如trl::shared_ptr)、一般化函数指针(tri:: function)、hash-based 容器、正则表达式(regular expressions)以及另外 10 个组件的支持。</p>

<p>■    TR1自身只是一份规范。为获得TR1提供的好处，你需要一份实物。一个好的 实物来源是Boost。</p>

<p>条款55:让自己熟悉Boost</p>

<p>Familiarize yourself with Boost.</p>

<p>你正在寻找一个高质量、源码开放、平台独立、编译器独立的程序库吗？看看 Boost吧。有兴趣加入一个由雄心勃勃充满才干的C++开发人员组成的社群，致力 发展(设计和实现)当前最髙技术水平之程序库吗？看看Boost吧！想要一瞥未来 的C++可能长相吗？看看Boost BE!</p>

<p>Boost是一个C++开发者集结的社群，也是一个可自由下载的C++程序库群。 它的网址是<a href="http://boost.org。现在你应该把它设为你的桌面书签之一。">http://boost.org。现在你应该把它设为你的桌面书签之一。</a></p>

<p>当然，世上多得是C++组织和网站，但Boost有两件事是其他任何组织无可 匹敌的。第一，它和C++标准委员会之间有着独一无二的密切关系，并且对委员 会深具影响力。Boost由委员会成员创设，因此Boost成员和委员会成员有很大的 重叠。Boost有个目标：作为一个“可被加入标准C++之各种功能”的测试场。这 层关系造就的结果是，以TR1 (见条款54)提案进入标准C++的14个新程序库 中，超过三分之二奠基于Boost的工作成果。</p>

<p>Boost的第二个特点是：它接纳程序库的过程。它以公开进行的同僚复审(public peer review)为基础。如果你打算贡献一个程序库给Boost,首先要对Boost开发者 电邮名单(mailing list)投递作品，让他们评估这个程序库的重要性，并启动初步 审査程序。然后开始这个网站所谓的“讨论、琢磨、再次提交”循环周期，直到一 切都获得满足为止。</p>

<p>最后，你准备好你的程序库，要正式提交了。会有一位复审管理员出面确认你 的程序库符合Boost最低要求。例如它必须通过至少两个编译器(以展现至此仍还 微不足道的可移植性)，你必须证明你的程序库在一个可接受的授权许可下是可用</p>

<p>Effective C++中文版，第三版</p>

<p>的（例如这个程序库必须允许免费的商业化和非商业化用途）。然后你的提交正式 进入Boost社群，等待官方复审。复审期间会有志愿者察看你的程序库各种素材（例 如源码、设计文档、使用说明等等），并考虑诸如此类的问题：</p>

<p>■这一份设计和实现有多好？</p>

<p>■这些代码可跨编译器和操作系统吗？</p>

<p>■这个程序库有可能被它所设定的目标用户——也就是在这个程序库企图解决问 题的领域中工作的人们——使用吗？</p>

<p>■文档是否清楚、齐备，而且精确？</p>

<p>所有批注都会被投寄至一份Boost邮件列表，所以复审者和其他人可以看到并 响应其他人的评论。复审最后周期结束之后，复审管理员便表决你的程序库被接受、 被有条件接受，或被拒绝。</p>

<p>同僚复审对于阻挡低劣的程序库很有贡献，同时也教育程序库作者认真考虑一 个工业强度、跨平台的程序库的设计、实现和文档工程。许多程序库在被Boost接 受之前，往往经历了一次以上的官方复审。</p>

<p>Boost内含数十个程序库，而且还不断有更多添加进来。偶尔也会有程序库被 从中移除，通常那是因为它们的机能已被新程序库取代，而新程序库提供了更多、 更好的机能，或更好的设计（例如更弹性或更有效率）。</p>

<p>Boost各程序库之间的大小和作用范围有很大变化。举一个极端例子，某些程 序库概念上只需数行代码（但在加入错误处理和可移植性后往往变长很多）。例如 Conversion程序库，提供较安全或较方便的转型操作符，其numeric_cast函数在 将数值从某类型转换为另一类型而导致溢出（overflow）或下溢（underflow）或类 似问题时会抛出异常。lexical cast则使我们得以将任何类型（只要支持 operator«）转换为字符串，对程序的诊断和运转志记（logging）都十分有用。另 一个极端例子是某些程序库提供大面积能力，甚至可以写成一整本书，这类程序库 包括 Boost Graph Library （用于编写任意 graph 结构）和 Boost MPL Library （一个 元编程程序库，metaprogramming library）。</p>

<p>Effective C++中文版，第三版</p>

<p>Boost程序库对付的主题非常繁多，区分数十个类目，包括：</p>

<p>■字符串与文本处理，覆盖具备类型安全(type-safe)的printf-like格式化动作、 正则表达式(此为TR1同类机能的基础，见条款54)，以及语汇单元切割</p>

<p>(tokenizing)和解析(parsing)。</p>

<p>■容器，覆盖“接口与STL相似且大小固定”的数组(见条款54)、大小可变的 bitsets以及多维数组。</p>

<p>■函数对象和离級编程，覆盖若干被用来作为TR1机能基础的程序库。其中一个 有趣的程序库是Lambda,它让我们得以轻松地随时随地创建函数对象，但是你 颇有可能不太了解你正在做什么：</p>

<p>using namespace boost:: lambda;    //让 boost:: lambda 的机能曝光</p>

<p>std::vector<int> v;</p>

<p>std:: for_each (v.begin (), v.end() r    //针对 v 内的每一个兀素 x，</p>

<p>stci::cout « _1 * 2 + 10 « n\nn) ； //印出 x * 2+10;</p>

<p>//其中是Lambda程序库 //针对当前元素的一个 //占位符号(placeholder)</p>

<p>■泛型编程(Generic programming)，覆盖一大组 traits classes。关于 traits 请见条 款47。</p>

<p>■模板元编程(Template metaprogramming，TMP，见条款48)，覆盖一个针对编 译期assertions而写的程序库，以及Boost MPL程序库。MPL提供了极好的东 西，其中支持编译期实物(compile-time entities)诸如卯es的STL-like数据结 构，等等。</p>

<p>//创建一个list-like编译期容器，其中收纳三个类型：</p>

<p>// (float, double, long double),并将此容器命名为&rdquo;floats&rsquo;*</p>

<p>typedef boost::mpl::list&lt;float, double, long double〉 floats;</p>

<p>//再创建一个编译期间用以收纳类型的list，以”floats”内的类型为基础，</p>

<p>//最前面再加上&rdquo;int&rdquo;。新容器取名为&rdquo;types&rdquo;。</p>

<p>typedef boost::mpl::push_front<floats, int>::type types;</p>

<p>这样的“类型容器”(常被称为typelist3——虽然它们也可以以一个mpl::vector 或mpl: :list为基础)开启了一扇大门，通往大范围、火力强大且重要的TMP 应用程序。</p>

<p>■数学和数值(Math and numerics) »包括有理数、八元数和四元数(octonions and quaternions)、常见的公约数(divisor)和少见的多重运算、随机数(又一个影</p>

<p>Effective C++中文版，第三版</p>

<p>响TR1内部相关机能的程序库）。</p>

<p>■正确性与測试（Correctness and testing），覆盖用来将隐式模板接口（implicit template interfaces,见条款41）形式化的程序库，以及针对“测试优先”编程 形态而设计的措施。</p>

<p>■数据结构，覆盖类型安全（type-safe）的unions （存储各具差异之“任何”类型）， 以及tuple程序库（它是TR1同类机能的基础）。</p>

<p>■语言间的支持（Inter-language support），包括允许C++和Python之间的无缝 互操作性（seamless interoperability）。</p>

<p>■内存，覆盖Pool程序库，用来做出高效率而区块大小固定的分配器（见条款50）, 以及多变化的智能指针（smartpointers,见条款13）,包括（但不仅仅是）TR1 智能指针。另有一个non-TRl智能指针是scoped_array,那是个auto_ptr-like 智能指针，用来动态分配数组；条款44曾经示范其用法。</p>

<p>■杂项，包括CRC检验、日期和时间的处理、在文件系统上来回移动等等。</p>

<p>请记住，这只是可在Boost中找到的程序库抽样，不是一份详尽清单。</p>

<p>Boost提供的程序库可以做很多很多事，但它并未覆盖整套编程风光。例如其 中就没有针对GUI开发而设计的程序库,也没有用以连通数据库的程序库——至少 在我下笔此刻没有。然而当你阅读本书时就有了也说不定。到底有没有，唯一可以 确定的办法是常常上网检核。我建议你现在就去访问：<a href="http://boost.org。纵使你">http://boost.org。纵使你</a> 没能找到刚好符合需求的作品，也一定会在其中发现一些有趣的东西。</p>

<p>请记住</p>

<p>■    Boost是一个社群，也是一个网站。致力于免费、源码开放、同僚复审的C++程 序库开发。Boost在C++标准化过程中扮演深具影响力的角色。</p>

<p>■    Boost提供许多TR1组件实现品，以及其他许多程序库。</p>

<p>Effective C++中文版，第三版</p>

<p>Linux公社（LinuxIDC.com）是包括Ubuntu,Fedora,SUSE技术，最亲斤IT资讯等Linux专业类网站。</p>

    </div>

    
    

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01-c&#43;&#43;/effect-c&#43;&#43;/08-%E5%AE%9A%E5%88%B6-new-%E5%92%8C-delete/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">08 定制 new 和 delete</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01-c&#43;&#43;/effect-c&#43;&#43;/10-%E5%85%B6%E4%BB%96/">
            <span class="next-text nav-default">10 其他</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="iteratelyd@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/iterateself" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/thebegin/activities" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/68028070/" class="iconfont icon-douban" title="douban"></a>
  <a href="http://iterate.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">iterateself</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>








</body>
</html>
