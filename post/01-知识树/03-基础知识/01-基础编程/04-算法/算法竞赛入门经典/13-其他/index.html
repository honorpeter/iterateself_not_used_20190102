<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>13 其他 - 迭代自己</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="iterateself" />
  <meta name="description" content="A.1 命令行 A.2 操作系统脚本编程入门 A.3 编译器和调试器 A.4 浅谈IDE 附录A开发环境与方法 合适的开发环境和开发方法能大大提高编程的速度和正确性，但却常常" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.47.1" />


<link rel="canonical" href="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/04-%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/13-%E5%85%B6%E4%BB%96/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="13 其他" />
<meta property="og:description" content="A.1 命令行 A.2 操作系统脚本编程入门 A.3 编译器和调试器 A.4 浅谈IDE 附录A开发环境与方法 合适的开发环境和开发方法能大大提高编程的速度和正确性，但却常常" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/04-%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/13-%E5%85%B6%E4%BB%96/" /><meta property="article:published_time" content="2018-06-27T08:40:48&#43;00:00"/>
<meta property="article:modified_time" content="2018-06-27T08:40:48&#43;00:00"/>
<meta itemprop="name" content="13 其他">
<meta itemprop="description" content="A.1 命令行 A.2 操作系统脚本编程入门 A.3 编译器和调试器 A.4 浅谈IDE 附录A开发环境与方法 合适的开发环境和开发方法能大大提高编程的速度和正确性，但却常常">


<meta itemprop="datePublished" content="2018-06-27T08:40:48&#43;00:00" />
<meta itemprop="dateModified" content="2018-06-27T08:40:48&#43;00:00" />
<meta itemprop="wordCount" content="10759">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="13 其他"/>
<meta name="twitter:description" content="A.1 命令行 A.2 操作系统脚本编程入门 A.3 编译器和调试器 A.4 浅谈IDE 附录A开发环境与方法 合适的开发环境和开发方法能大大提高编程的速度和正确性，但却常常"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">迭代自己</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/catalog/">
        <li class="mobile-menu-item">完整目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">迭代自己</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/catalog/">完整目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">13 其他</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-06-27 </span>
        
        <span class="more-meta"> 10759 words </span>
        <span class="more-meta"> 22 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    
  </div>
</div>

    
    

    
    <div class="post-content">
      <nav>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#a-1-命令行">A.1 命令行</a></li>
<li><a href="#a-2-操作系统脚本编程入门">A.2 操作系统脚本编程入门</a></li>
<li><a href="#a-3-编译器和调试器">A.3 编译器和调试器</a></li>
<li><a href="#a-4-浅谈ide">A.4 浅谈IDE</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</nav>

<p>附录A开发环境与方法</p>

<p>合适的开发环境和开发方法能大大提高编程的速度和正确性，但却常常被人忽视。本附</p>

<p>录介绍命令行、脚本编程和编译器以及调试器的基本使用方法，希望能给读者带来帮助。</p>

<h6 id="a-1-命令行">A.1 命令行</h6>

<p>在图形用户界面(Graphical User Interface , GUI)日益发达的今天，命令行使用得越来越 少。但笔者仍然认为命令行操作是每一位编程竞赛的选手必须掌握的技能。它不仅可以让你</p>

<p>看起来很专业，而且确实能帮你很大的忙。</p>

<p>首先，进入命令行。在Windows XP中，可以选择“开始”菜单中的“运行”命令，在弹出 的“运行”对话框中输入“cmd”，然后按Enter键，将出现类似下面的提示信息：</p>

<p>Microsoft Windows XP <a href="C">版本 5.1.2600</a> 版权所有 1985-2001 Microsoft Corp.</p>

<p>C:\Documents and Settings\Administrator&gt;</p>

<p>其中，C:\Documents and Settings\Administrator是当前路径，而后的“〉”符号是命令提示 符，紧跟其后的是闪烁的光标(cursor)。在文本界面中，所输入的任何信息都将出现在光标 的所在位置。输入命令之后不要忘记按Enter键。</p>

<p>在Linux中，打开终端(terminal)即可进行命令行操作。Linux终端并不一定会显示当前路 径，可以用pwd命令将其显示。无论是Windows还是Linux ,都可以用上下箭头来翻阅并使用 历史记录。Windows和Linux下都可以用Tab键补全命令，但在细节上存在一些差异，读者可</p>

<p>以自己实践或查阅相关资料。</p>

<p>A.1.1 文件系统</p>

<p>学习命令行的第一步是理解文件系统。相信读者对“文件”这一概念已经有所认识，但除 此之外还需要清楚文件所在的位置。 “位置”的表达方式有两种，一种是相对路径，另一种是 绝对路径。</p>

<p>相对路径(relative path)是相对当前路径(current path)而言的，它在命令行中已有所体现。 例如，在上面的例子中，当前路径是C:\Documents and Settings\Administrator。在这种情况 下，命令type abc.txt即为试图显示C:\Documents and Settings\Administrator\abc.txt。</p>

<p>除了直接给出文件名外，还可以借助当前目录“.”和父目录“..”进行更为灵活的相对路径 引用。例如，在上面的命令行提示符下输入type....\Windows\123.txt，实际上是在试图显示 c:\Windows\123.txt。</p>

<p>在命令行中可以用“cd    ＜目录名〉”的方式改变当前路径。例如，“cd..”会进入父目录，</p>

<p>而“cd aaa”会进入当前目录的aaa子目录。</p>

<p>绝对路径和相对路径的区别是，前者给出了“起点”，其实际指向不随当前路径变化。在 算法竞赛中，不要在提交的源代码中引用绝对路径，但在操作和调试程序的过程中可以随意 使用绝对路径。另外，Linux中的路径分隔符是正斜线“/”，而非反斜线“\”。</p>

<p>如果在程序中读写文件，则当前路径一般和该程序位于同一个目录，但也可以更改。如 果在执行程序时出现“找不到文件”的错误，而文件确实存在，则极有可能是程序的“当前路 径”与所想的不一致。一个笨（但有效）的方法是用freopen（&rdquo;test.txt&rdquo;，”w”，stdout）的方法创建文件 test.txt。 找到了这个文件，就知道当前路径是什么了。如果要在freopen或者fopen中使 用“.UWindows\123.txt”这样的相对路径，应注意反斜线字符在C语言的正确表示方法 是“\”。不过，即使在调试中也尽量不要使用路径名。如果在提交程序前忘记把路径名删 除，将导致程序得0分。事实上，这样的例子并不少见。当然，如果只在条件编译中使用路 径名，则是没有问题的。</p>

<p>最后一个小问题是：你不一定有存取文件的权限。如果出现类似于“Permission Denied”的错误信息，需确认当前用户是否拥有想访问的目录或者文件的访问/修改权。在现 场比赛中，这可能是因为没有使用比赛指定账户，而是改用guest登录了。</p>

<p>A.1.2 进程</p>

<p>简单地说，进程是一个程序正在执行时的实体。它消耗CPU资源且占用内存。进程一般 都有名字，同时还有一个编号（称为PID）。</p>

<p>在Windows和Linux中都能方便地列出进程。在Windows下可以使用Ctrl+Alt+Del组合键打 开任务管理器，或者在命令行下用tasklist命令。在Linux下可以用top命令查看当前占用CPU资 源最多的一些进程，而ps命令类似于Windows下的tasklist命令，它是使用列表的方式给出当 前进程。在默认情况下，ps命令并不会列出系统进程，用ps ax命令可以列出更多的进程。</p>

<p>强行终止进程有很多方法。在Windows下，可以用任务管理器直接终止，也可以在命令 行下用taskkill/pid ＜PID＞或taskkill/im〈映像名〉终止进程，可以通过执行taskkill/?查看更多选</p>

<p>项。</p>

<p>在Linux下可以用kill命令终止命令，还可以用killall &lt;进程名〉命令把某个进程名对应的 所有进程终止。一个典型情况是，如果pascal选手的Lazarus    IDE不响应，就可以用killall</p>

<p>l azarus把它们终止。</p>

<p>作为一个好习惯，当程序非正常终止，或者系统表现异常时，应检查进程。例如，若系</p>

<p>统反应特别慢，可能是有一些看似运行结束，但其实残留在系统中继续占用系统资源的进</p>

<p>程。</p>

<p>A.1.3 程序的执行</p>

<p>在命令行下执行一个程序比在IDE中执行要方便和灵活得多。基本的方法很简单：只需 直接输入程序名即可。</p>

<p>例如，在Windows下执行abc.exe，可以进入它所在目录后直接输入abc并按Enter键。系 统为什么能找到abc.exe呢，因为在Windows下，当前目录是最先搜寻可执行文件的位置，并 且扩展名.exe在搜索之前会被自动添加。如果当前目录没有abc.exe，是否会报错呢？不一 定。运行path命令，会看到一连串目录。如果当前目录没有abc.exe，系统会继续在这些目录 中寻找，全部查找完毕仍没找到时才会报错。在搜索文件时并不会检查上述目录下的子目 录。</p>

<p>Linux有一些不同。首先，它的可执行文件名并不是以“exe”为扩展名的，因此g++ abc.cpp -o abc编译出的文件是abc，而非abc.exe（当然，如果一定要将其取名为abc.exe，也无 不可）。另外，当前目录并不在搜索路径中，因此，即使abc已经在当前目录中，仍需要 用./abc这样的方式告诉Linux“可执行文件abc就在当前目录”。</p>

<p>A.1.4 重定向和管道</p>

<p>很多比赛要求选手直接读写标准输入输出（即用print^scanf或cin/cout读写，且不用 freopen）， 难道在评分时裁判要将输入数据一一用键盘输入，等程序运行结束之后看着屏 幕，逐个对照手中的标准答案吗？当然不是。可以使用重定向的技巧将输入文件塞到程序的 标准输入中，然后再将程序输出保存在文件中。</p>

<p>在Windows下可以使用 abc &lt; abc.in〉abc.out。而在Linux下则可以使用./abc &lt; abc.in〉 abc.out。当然，如果可执行文件和输入输出文件不在同一个目录，则需要进行相应调整。但</p>

<p>基本方法是不变的：在输入文件名前面加一个“&lt;”符号，而在输出文件名前面加一个“〉”符</p>

<p>号。注意，此时的输出文件将被覆盖。如果希望只是把输出附加在文件末尾，则可用“〉〉”代</p>

<p>替“〉”。此外，如果有大量的文本输出到标准错误输出，还可以用“2〉”将它们重定向，但需</p>

<p>注意，尽量不要在正式提交的程序中输出到标准错误输出，这样不仅可能会违反比赛规定，</p>

<p>还可能会因为大量文本的输出而占用宝贵的CPU资源，甚至导致超时。</p>

<p>Windows和Linux均提供“管道”机制，用于把不同的程序串起来。例如，如果有一个程序 aplusb从标准输入读取两个整数和^ ,计算并输出^+^ ,还有一个程序sqr从标准输入读取一 个整数a ,计算并输出a2 ,则可以这样计算(10+20)2 : echo 10 20 | aplusb | sqr。尽管也可以用 重定向来完成这个任务，但用管道明显要简单得多。</p>

<p>另一个常见用法是分页显示一个文本文件的内容。在Windows下可以用type    abc.txt |</p>

<p>more ,在Linux下则是用 cat abc.txt | more。</p>

<p>A.1.5 常见命令</p>

<p>在Linux中，可以用time命令计时。例如，运行time ./abc会执行abc并输出运行时间。但 Windows中并没有这样的命令，幸好在大多数情况下只是在对自己编写的程序计时，因此只 需在程序的最后打印出clock()/(double)CLOCKS_PER_SEC即可(需要包含time.h)。</p>

<p>附表A-1中给出了一些常见命令的Linux版本和Windows版本，供读者查阅。</p>

<p>附表A-1常见的Linux命令和Windows命令</p>

<table>
<thead>
<tr>
<th>分类</th>
<th>Linux命令</th>
<th>Windows 命令</th>
</tr>
</thead>

<tbody>
<tr>
<td>文件列表</td>
<td>ls</td>
<td>dir</td>
</tr>

<tr>
<td>改变/创建/删除目录</td>
<td>cd/mkdir/rmdir</td>
<td>cd/md/rd</td>
</tr>

<tr>
<td>显示文件内容</td>
<td>cat/more</td>
<td>type/more</td>
</tr>

<tr>
<td>比较文件内容</td>
<td>diff</td>
<td>fc</td>
</tr>

<tr>
<td>修改文件属性</td>
<td>chmod</td>
<td>attrib</td>
</tr>

<tr>
<td>复制文件</td>
<td>cp</td>
<td>copy/xcopy</td>
</tr>

<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th>删除文件</th>
<th>rm</th>
<th>del</th>
</tr>
</thead>

<tbody>
<tr>
<td>文件改名</td>
<td>mv</td>
<td>ren</td>
</tr>

<tr>
<td>回显</td>
<td>echo</td>
<td>echo</td>
</tr>

<tr>
<td>关闭命令行</td>
<td>exit</td>
<td>exit</td>
</tr>

<tr>
<td>在文件中查找字符串</td>
<td>grep</td>
<td>find</td>
</tr>

<tr>
<td>查看/修改环境变量</td>
<td>set</td>
<td>set</td>
</tr>

<tr>
<td>帮助</td>
<td>man ＜命令〉</td>
<td>help ＜命令〉</td>
</tr>
</tbody>
</table>

<h6 id="a-2-操作系统脚本编程入门">A.2 操作系统脚本编程入门</h6>

<p>读者如果不学习脚本的编写，就无法让命令行发挥最大威力。编写脚本和编写C语言程 序有几分相似，但也有一些不同。下面先来看一个常见任务：不停地随机生成测试数据，分 别运行两个程序并对比其结果。这个任务被形象地称为“对拍”。</p>

<p>A.2.1 Windows下的批处理</p>

<p>Windows下的批处理程序如下：</p>

<dl>
<dt>@echo off</dt>
</dl>

<p>:again</p>

<p>;生成随机输入</p>

<p>;比较文件</p>

<p>; 相同时继续循环</p>

<p>r &gt; input</p>

<p>a &lt; input &gt; output.a</p>

<p>b &lt; input &gt; output.b</p>

<p>fc output.a output.b &gt; nul</p>

<p>if not errorlevel 1 goto again</p>

<p>第1行表明接下来的各个命令本身并不会回显。如果不理解，试着把这一行去掉就明白 了。第2行是一个标号，后面的goto语句用得上。接下来调用数据生成器r，把输入数据写到 文件input中，然后分别执行和^，得到相应的输出，然后用命令fc比较它们。注意，fc命令 有输出，但我们对此不感兴趣，因此重定向到一个名为nul的设备中，它就好比一个黑洞。</p>

<p>另一个有意思的设备是con，代表标准输入输出。例如，命令copy con con的含义是直接把标 准输入复制到标准输出（尽管有些傻）。试一试，建立一个只包含一条语句的“C程序”： #include&lt;con〉 ， 用命令行编译一下试试——很不幸，看上去编译器“死掉”了，尽管它其实是 在读键盘。如果在设计一个基于Windows的在线评测系统，小心好事者用它来愚弄你的系 统！另一方面，千万不要在正式比赛中使用这个伎俩——它很可能让你失去比赛资格。</p>

<p>最后一行是整个批处理程序的关键——只有当比较文件相同时才执行goto，否则立刻终 止程序。这样，就有机会好好研究一下这个input文件，看看两个程序的输出到底为什么不 同。读者也许会问，这个if not errorlevel 1到底是什么意思呢？它是在测试上一个程序（在本 例中，就是fc程序）的返回码。 if errorlevel num的意思是“如果返回码大于或者等于num”，因 此if not errorlevel 1的意思是，“如果返回码小于1”。事实上，当且仅当文件相同时，fc程序 返回0。如果不确定程序的返回码是多少，可以在程序执行完毕后用echo °%errorlevel°%命令</p>

<p>输出返回码。</p>

<p>你自己编写的程序的返回码是多少呢？这要看在main函数的最后return的是多少。返回 码0往往代表“正常结束”，因此本书的正文部分才建议用return 0。典型的评分程序将在执行 选手程序之后判断它的返回码，如果非0，则直接认为程序非正常退出，根本不去理会输出 是否正确。说到这里，你也许已经想到一种故意让返回码非0的情况了——输出检查器。对 于答案不唯一的情况（例如，走迷宫时要求输出最短路径，但不必是字典序最小的），对拍时 不能简单地用fc命令比较文本内容，而应该单独编写一个程序，这个程序应当在答案不一致 时返回1，以便上面的批处理程序及时终止。</p>

<p>上面的程序应以.bat为扩展名保存，并且在执行时也可以省略扩展名。如果同时存在 abc.bat和abc.exe，将执行abc.exe。但如果主文件名和系统命令重名，则连exe文件也无法执 行，如 path.exe。</p>

<p>A.2.2 Linux 下的 Bash 脚本</p>

<p>下面是上述程序的Linux版：</p>

<p>#!/bin/bash</p>

<table>
<thead>
<tr>
<th>while</th>
<th>true; do</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td>./r</td>
<td>&gt; input</td>
<td></td>
<td></td>
<td># 生成随机数据</td>
</tr>

<tr>
<td>./a</td>
<td>&lt; input</td>
<td>&gt;</td>
<td>output.a</td>
<td></td>
</tr>

<tr>
<td>./b</td>
<td>&lt; input</td>
<td>&gt;</td>
<td>output.b</td>
<td></td>
</tr>

<tr>
<td>diff</td>
<td>output.</td>
<td>a</td>
<td>output.b</td>
<td># 文件比较</td>
</tr>

<tr>
<td>if [</td>
<td>$? -ne</td>
<td>0</td>
<td>] ; then break; fi</td>
<td># 判断返回值</td>
</tr>
</tbody>
</table>

<p>done</p>

<p>和Windows版没有太大的不同，但需要注意的是，Linux中的设备名和Windows有所不 同，而且也没有必要执行类似@echo off的命令——命令本来就不会回显。需要注意的是，如 果在Windows下编写Linux脚本，复制到Linux后需要去掉所有的\r字符，否则解释器会报错。</p>

<p>把上述程序保存成test.sh后，再执行chmod+x test.sh，即可用./test.sh来执行它。当然，扩 展名也不是必需的，完全可以以不带扩展名的test命名。</p>

<p>上面的程序不是最简洁的（例如，可以直接把diff命令放在if语句中），但展示了bash脚本 的一些其他用法。例如，while循环是“while ＜命令集〉；do ＜命令集〉；done”，而if语句的基本 是“if ＜命令集〉;do ＜命令集〉;”。不管是while还是if ,判断的都是命令集中最后一条语句的返 回码（exit code）是否为0。例如，若把上面的脚本改成if diff output.a output.b; then break; fi ,则 当两个文件相同（diff返回码为0）时退出循环（这个不是我们所期望的）。如果忘记了命令格 式，可以用help if和help while获取帮助。</p>

<p>上面的“true”和“[”都是程序。前者的作用是直接返回0 ;而后者的作用是计算表达式（该 程序要求最后一个参数必须是“]”），其中“$?”是bash内部变量，表示“上一个程序的返回码”。</p>

<p>A.2.3 再谈随机数</p>

<p>如果做过测试，可能会发现上面的方法有一个问题：如果程序执行太快，随机数生成器 在相邻两次执行时，time（NULL）函数返回值相同，因而产生出完全相同的输入文件。换句话 说，每隔一秒才能产生出一个不同的随机数据。一个解决方案是利用系统自带的随机数发生 器：在Windows下是环境变量。%random。％ ,而在bash中是$RANDOM。它们都是0 ~ 32767之间 的随机整数。可以直接用脚本编写随机数生成器，也可以把它们传递到程序中。</p>

<h6 id="a-3-编译器和调试器">A.3 编译器和调试器</h6>

<p>既然编译器和调试器都是程序，执行方法和普通程序大致相同。在安装时，系统会自动 把编译器和调试器程序所在路径加到搜索路径中，因此在执行时不必像./gcc这样加上路径 名。</p>

<p>A.3.1 gcc的安装和测试</p>

<p>尽管在现场比赛中，编译器都已安装好，但如果平时练习，一般需要自己安装。如果使 用Linux，在安装操作系统时即可选择安装gcc、g++、binutils等包，但若要在Windows中使用 C/C++语言，需要手工安装编译器。</p>

<p>本书推荐使用MinGW环境下的gcc，它的好处是和Linux下的gcc—致性较好，而且是免费 的。可以到www.mingw.com中下载最新的安装包，然后在安装时选择g++编译器。</p>

<p>安装完毕后，在命令行中执行gcc命令。如果显示gcc: no input files ，则安装成功；如果 提示不存在这个命令，可能是因为没有把gcc所在目录加到搜索路径中。可以双击控制面板 的“系统”图标，并在“高级”选项卡中设置环境变量。在“系统变量”中找到“PATH”（大小写无 所谓），它就是可执行程序的搜索路径。请在它的最后加入MinGW安装路径的bin子目录，如 C:\MinGW\bin（在安装时记住MinGW的安装路径），保存后重新启动命令行，gcc就应该可以正 常工作了。</p>

<p>A.3.2 常见编译选项</p>

<p>先建立一个test.c，试试常见的编译选项。</p>

<p>#include<stdio.h></p>

<p>main（）</p>

<p>{</p>

<p>int a, b;</p>

<p>scanf(&ldquo;%d%d&rdquo;, &amp;a, &amp;b); int c = a+b;</p>

<p>printf(&ldquo;%d%d\n&rdquo;, c);</p>

<p>编译一下，命令为gcc    test.c。程序没有输出，代表一切均好。检查目录(Windows下用</p>

<p>dir，Linux下用ls)，会发现多了 一^个a.exe(Windows)或a.out(Linux)，这就是程序的编译结果。</p>

<p>gcc test.c-o test命令会让编译出的可执行程序名为test.exe(Windows)或test(Linux)。这样， 就能用test(Windows)或./test(Linux)方式运行程序。</p>

<p>也许读者已经看出了上述代码中的一些问题，不过当程序更加复杂时，人眼就不一定能 快速找到错误了。在这样的情况下，编译选项能起作用：gcc -test.c -o test -Wall。这次，编 译器指出了3个警告：main函数没有返回类型、没有返回值、print啪格式字符串可能有问 题。还可以进一步用-ansi-pedantic，它会检查代码是否符合ANSI标准(-ansi只是判断是否和 ANSI冲突，而-pedantic更加严格)。它进一步指出了上述代码中的另外一个问题：ANSI C中 不允许临时声明变量，而必须在语句块的首部声明变量。</p>

<p>在C语言中，另一个常用的编译选项是-lm，它让编译器连接数学库，从而允许程序使用 math.h中的数学函数。C++编译器会自动连接数学库，但如果程序的扩展名是.c，且不连接数 学库，有时会出现意想不到的结果。</p>

<p>另一个有用的选项是-DDEBUG，它在编译时定义符号DEBUG (可以换成其他，如-DLOCAL将定义符号LOCAL )，这样，位于#ifdef DEBUG*#endi沖间的语句会被编译。而 在通常情况下，这些语句将被编译器忽略(注意，不仅是不会执行，连编译都没有进行)。</p>

<p>可以用-01、-O2和-O3对代码进行速度优化。一般情况下，直接编译出的程序比用-O1 编译出的程序慢，而后者比-02慢。尽管理论上-03编译出的程序更快，但由于某些优化可能 会误解程序员的意思，一般比赛中不推荐使用。另外，如果你的程序中有一些不确定因素 (如使用了未初始化的变量)，运行结果可能会和编译选项有关——用-01和-02编译出的程序 也许不仅是速度有差异，答案甚至都有可能不同！当然，这种情况出现的前提是程序有瑕 疵。如果是一个规范的程序，运行结果不会和优化方式有关。</p>

<p>既然编译选项可以影响程序的行为，在正规比赛中，组织方应提前公布编译选项。如果</p>

<p>没有公布，选手最好尽早询问。</p>

<p>A.3.3 gdb 简介</p>

<p>gdb尽管只是一个文本界面的调试器，但功能十分强大。不管是Linux和Windows下的 MinGW，gcc和gdb都是最佳拍档。</p>

<p>gdb的使用方法很简单-用gcc编译成test.exe之后，执行gdb test.exe即可。不过，如果</p>

<p>要用gdb调试，编译时应加上-g选项，生成调试用的符号表。</p>

<p>接下来使用l命令，将看到部分源程序清单。如果用l 15 ,将会显示第15行（以及它前后 的若干行）。除此之外，还可以用函数名来定义，如l    main将显示main函数开头的附近10</p>

<p>行。如果不加参数执行l ,将显示下10行；list    -将显示上10行。所有这些操作都可以用help</p>

<p>list命令来查看。gdb中的命令可以简写（例如list简写成l ）,大家可以多尝试（提示：试一 下命令的前若干个字母）。</p>

<p>运行程序的命令是r（run）,但会一直执行到程序结束。如何让它停下来呢？方法是用 b（break）命令设置断点。例如，b main命令将在main函数的开始处设置一个断点，则用r命令 执行时会在这里停下来。如果想继续运行，请用c（continue）命令，而不是继续用r命令。和list 命令类似，b命令既可以指定行号，也可以在指定函数的首部停下来。笔者在调试很多程序 时都是以命令b main和r开头的。</p>

<p>如果希望逐条语句地执行程序，不停地用b和c命令太麻烦。gdb提供了一些更加方便的 指令，其中最常用的有两个：next（简写为n）和step（简写为s）。其作用都是执行当前行，区别 在于如果当前行涉及函数调用，则next是把它作为一个整体执行完毕，而step是进入函数内 部。尽管n和s都只有一个字母，但有时还是稍显繁琐。在gdb中，如果在提示符下直接按 Enter键，等价于再次执行上一条指令，因此如果需要连续执行s或者n ,只需要第一次输入该 命令，然后直接连按Enter键即可。另外，和命令行一样，可以按上下箭头来使用历史记录。</p>

<p>另一个常用命令是until （简写为u）,让程序执行到指定位置。例如，u 9就是执行到第9 行，u doit就是执行到doit函数的开头位置。</p>

<p>停下来以后便打印一些函数值，看看是否和想象的一致。用p（print）命令可以打印出一些 变量的值，而info locals（可以简写为i lo）可以显示所有局部变量。如果希望每次程序停下 来，则可以用display（简写为disp）命令。例如，display i+1就可以方便地读取i+1的值。它往往 和n、s和u等单步执行指令配合使用。如果需要列出所有display ,可以用info display（简写为i disp）;还可以删除或者临时禁止/恢复一些display ,相应的命令为delete display（d    disp）、</p>

<p>disable display（dis disp）和enable display（en disp）。类似地，也可以根据断点编号删除、禁止 和恢复断点，还可以用clear（cl）命令，像b命令一样根据行号或者函数名直接删除断点。</p>

<p>在多数情况下，灵活运用上述功能已经能高效地调试程序了。下面把涉及的命令列出， 供读者参考，如附表A-2所示。</p>

<table>
<thead>
<tr>
<th>简写</th>
<th>全称</th>
<th>备注</th>
</tr>
</thead>

<tbody>
<tr>
<td>l</td>
<td>list</td>
<td>显示指定行号或者指定函数附近的源代码</td>
</tr>

<tr>
<td>b</td>
<td>break</td>
<td>在指定行号或者指定函数开头处设置断点。如b main</td>
</tr>

<tr>
<td>r</td>
<td>run</td>
<td>运行程序，直到程序结束或者遇到断点而停下</td>
</tr>

<tr>
<td>c</td>
<td>continue</td>
<td>在程序中断后继续执行程序，直到程序结束或者遇到断点而 停下。注意在程序开始执行前只能用r，不能用c</td>
</tr>

<tr>
<td>n</td>
<td>next</td>
<td>执行一条语句。如果有函数调用，则把它作为一个整体</td>
</tr>

<tr>
<td>s</td>
<td>step</td>
<td>执行一条语句。如果有函数调用，则进入函数内部</td>
</tr>

<tr>
<td>u</td>
<td>until</td>
<td>执行到指定行号或者指定函数的开头</td>
</tr>

<tr>
<td>p</td>
<td>print</td>
<td>显示变量或表达式的值</td>
</tr>

<tr>
<td>disp</td>
<td>display</td>
<td>把一个表达式设置为display，当程序每次停下来时都会显示 其值</td>
</tr>

<tr>
<td>cl</td>
<td>clear</td>
<td>取消断点，和b的格式相同。如果该位置有多个断点，将同时 取消</td>
</tr>

<tr>
<td>i</td>
<td>info</td>
<td>显示各种信息。如i b显示所有断点，i disp显示display，而i lo 显示所有局部变量</td>
</tr>
</tbody>
</table>

<p>如果对上述解释有疑问，可输入help以获得详尽的帮助信息。</p>

<p>A.3.4 gdb的高级功能</p>

<p>gdb的功能远不止刚才所讲述的那些。尽管很多功能是专为系统级调试所设，但还有很 多功能也能为算法程序的调试带来很大方便。</p>

<p>首先是栈帧的相关命令，其中最常用的是bt，其他命令可以通过help stack来学习。接下 来是断点控制命令。commands(comm)命令可以指定在某个断点处停下来后所执行的gdb命 令，ignore(ig)命令可以让断点在前count次到达时都不停下来，而condition则可以给断点加一</p>

<p>个条件。例如，在下面的循环中：</p>

<p>10 for(i = 0; i &lt; n; i++)</p>

<p>11 printf(&ldquo;%d\n&rdquo;, i);</p>

<p>首先用b 11设置断点(假设编号为2)，然后用cond 2 i = =5让该断点仅当i = 5时有效。这 样的条件断点在进行细致的调试时往往很有用。</p>

<p>另外，gdb还支持一种特殊的断点-watchpoint。例如，watch a (简写为wa a )可以在</p>

<p>变量a修改时停下，并显示出修改前后的变量值，而awatch a (简写为aw a )则是在变量被读 写时都会停下来。类似地，rwatch a(rw a)则是在变量被读时停下。</p>

<p>最后需要说明的是，gdb中可以自由调用函数(不管是源程序中新定义的函数还是库函 数)。第一种方法是用call命令。例如，如果想给包含10个元素的数组a排序，可以像这样直 接调用STL中的排序函数call sort(a, a+10)。</p>

<p>遗憾的是，如果真的做过这个实验，会发现刚才所说完全是骗人的。gdb会显示不存在 函数sort。怎么会这样呢？如果学过宏和内联函数就会知道，很多看起来是函数的却不一定 真的是函数，或者说，不一定是调试器识别的函数。为了在gdb中调用sort，可以将它打包：</p>

<p>void mysort(int*p, int*q)</p>

<p>{</p>

<p>sort(p, q);</p>

<p>}</p>

<p>这样，就可以用call mysort(a, a+10)来给数组a排序了。print、condition和display命令都可 以像这样使用C/C++函数。例如，可以用p rand()来输出一个随机数，或是专门编写一个打印 二叉树的函数，然后在print或者display命令中使用它，还可以编写一个返回bool值的函数， 并作为断点的条件。</p>

<p>至此是不是觉得gdb很强大呢？注意，过分地依赖于gdb的调试功能让敏锐的直觉变得迟 钝。事实上，笔者建议读者尽量只使用A.3.3节提到的基本功能，甚至尽量不要使用gdb—— 用输出中间变量的方法，加上直觉和经验来调试算法程序。如果是这样，编程速度和准确性 将大大提高。</p>

<h6 id="a-4-浅谈ide">A.4 浅谈IDE</h6>

<p>所谓IDE，是指集成开发环境(Integrated Development Environment)。顾名思义，开发程序 所用到的各种功能都应该被集成到IDE中，包括编辑(edit)、编译(compile)、运行(run)、调试 (debug)等。但工具始终总是工具，读者必须懂得如何使用它，才能发挥出它的最大威力。</p>

<p>可以用来编写C/C++程序的IDE有很多，如Linux下的Anjuta，Windows下的Dev-Cpp，以 及跨平台的Eclipse和Code::Blocks，还有一些强大的通用编辑器也可以用来编写C/C++程序， 如 vi、emacs、EditPlus 等。</p>

<p>也许和很多读者所期望的不同，笔者在这里不打算介绍任何一个IDE。事实上，如果读 者对本章所介绍的命令行、脚本、编译选项和gdb都能很好地掌握，IDE是非常容易学习的</p>

<p>——只需要熟悉它的编辑特色(语法高亮、代码折叠、查找与替换和代码补全等)和常用快</p>

<p>捷键即可。</p>

<p>多数IDE会引入“工程”的概念，所以读者需要花一点时间来掌握工程的基本知识。例 如，在编写算法程序时，工程类别需要的是命令行程序(console application )，而不是图形 界面程序(GUI application)或其他。如果熟练掌握了gcc编译参数和gdb的常见命令，在IDE 下编译和调试会更容易。</p>

<p>主要参考书目</p>

<p>[1 ]Thomas H. Cormen， Charles E. Leiserson ， Ronald L. Rivest， Clifford Stein. Introduction to Algorithms， Second Edition， The MIT Press， 2001</p>

<p>[2 ] Jon Kleinberg , Eva Tardos. Algorithm Design. Addison Wesley , 2005</p>

<p>[3]Sanjoy Dasgupta. Christos Papadimitriou ， Umesh Vazirani. Algorithms. McGraw Hill Higher Education， 2006</p>

<p>[ 4]Ronald L. Graham， Donald E. Knuth， Oren Patashnik. Concrete Mathematics. Addison-Wesley Professional， 1994</p>

<p>[ 5]Joseph O&rsquo;Rourke. Computational Geometry in C， second edition， Cambridge University Press， 1998</p>

<p>[ 6]Mark de Berg， Otfried Cheong， Marc van Kreveld， Mark Overmars， Computational Geometry: Algorithms and Applications ， 3rd Edition， Springer-Verlag Berlin and Heidelberg GmbH &amp; Co. K， 2008</p>

<p>[ 7]G. Polya. How to Solve It: A New Aspect of Mathematical Method. Princeton University Press2nd Edition ， 1971</p>

<p>[ 8]Philip Schneider， David H. Eberly. Geometric Tools for Computer Graphics. Morgan Kaufmann， 2002</p>

<p>[ 9]周培德．计算几何——算法分析与设计．北京：清华大学出版社， 2000</p>

<p>[ 10]中国计算机学会（执行主编王宏）．全国信息学奥林匹克年鉴．河南：中原出版</p>

<p>传媒集团， 2006—2010</p>

<p>[11 ]中国计算机学会.IOI国家集训队资料，2002—2010</p>

    </div>

    
    

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/02-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/01-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/03-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/01-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/03-%E8%AF%AF%E5%B7%AE%E9%80%86%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">03 误差逆传播算法</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/04-%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/05-c&#43;&#43;-%E4%B8%8E-stl-%E5%85%A5%E9%97%A8/">
            <span class="next-text nav-default">05 C&#43;&#43; 与 STL 入门</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="iteratelyd@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/iterateself" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/thebegin/activities" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/68028070/" class="iconfont icon-douban" title="douban"></a>
  <a href="http://iterate.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">iterateself</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>








</body>
</html>
