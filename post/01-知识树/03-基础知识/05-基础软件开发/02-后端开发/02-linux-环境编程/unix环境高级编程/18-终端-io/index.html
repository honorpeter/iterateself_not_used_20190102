<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>18 终端 IO - 迭代自己</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="iterateself" />
  <meta name="description" content="第18章 18.1引言 无论在哪种操作系统中，终端I/O的处理都是非常繁琐的一部分，UNIX系统也不例外。在 大多数版本的编程手册中，终端I/O手" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.47.1" />


<link rel="canonical" href="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05-%E5%9F%BA%E7%A1%80%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/02-%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/02-linux-%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/18-%E7%BB%88%E7%AB%AF-io/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="18 终端 IO" />
<meta property="og:description" content="第18章 18.1引言 无论在哪种操作系统中，终端I/O的处理都是非常繁琐的一部分，UNIX系统也不例外。在 大多数版本的编程手册中，终端I/O手" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05-%E5%9F%BA%E7%A1%80%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/02-%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/02-linux-%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/18-%E7%BB%88%E7%AB%AF-io/" /><meta property="article:published_time" content="2018-06-26T19:06:05&#43;00:00"/>
<meta property="article:modified_time" content="2018-06-26T19:06:05&#43;00:00"/>
<meta itemprop="name" content="18 终端 IO">
<meta itemprop="description" content="第18章 18.1引言 无论在哪种操作系统中，终端I/O的处理都是非常繁琐的一部分，UNIX系统也不例外。在 大多数版本的编程手册中，终端I/O手">


<meta itemprop="datePublished" content="2018-06-26T19:06:05&#43;00:00" />
<meta itemprop="dateModified" content="2018-06-26T19:06:05&#43;00:00" />
<meta itemprop="wordCount" content="27308">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="18 终端 IO"/>
<meta name="twitter:description" content="第18章 18.1引言 无论在哪种操作系统中，终端I/O的处理都是非常繁琐的一部分，UNIX系统也不例外。在 大多数版本的编程手册中，终端I/O手"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">迭代自己</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">最新</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/catalog/">
        <li class="mobile-menu-item">完整目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">迭代自己</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">最新</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/catalog/">完整目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">18 终端 IO</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-06-26 </span>
        
        <span class="more-meta"> 27308 words </span>
        <span class="more-meta"> 55 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#第18章">第18章</a>
<ul>
<li>
<ul>
<li><a href="#18-1引言">18.1引言</a></li>
<li><a href="#18-2综述">18.2综述</a></li>
<li><a href="#18-6-stty-命令">18.6 stty 命令</a>
<ul>
<li><a href="#18-9终端标识">18.9终端标识</a></li>
<li><a href="#18-10规箔模式">18.10规箔模式</a></li>
<li><a href="#18-11非规范模式">18.11非规范模式</a></li>
</ul></li>
<li><a href="#18-13-tecmcap-tezminfo-和-curses">18-13 tecmcap、tezminfo 和 curses</a></li>
<li><a href="#18-14小结">18.14小结</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      

<h3 id="第18章">第18章</h3>

<h5 id="18-1引言">18.1引言</h5>

<p>无论在哪种操作系统中，终端I/O的处理都是非常繁琐的一部分，UNIX系统也不例外。在 大多数版本的编程手册中，终端I/O手册页常常是最长的几个部分之一。</p>

<p>在20世纪70年代后期，系统m在V7的基础上发展出一套不同的终端例程，由此使得UNIX 终端I/O处理分立为两种不同的风格。一种是系统in的风格，由System V沿续下来，另一种是 V7的风格，它成为BSD派生的系统终端I/O处理的标准。如同信号一样，POSIX.1在这两种风 格的基础上制定了终端1/0标准。本章将介绍POSIX.1的所有终端函数，以及某些平台特有的増 加部分。</p>

<p>终端I/O系统之所以如此复杂，部分原因是人们将其应用在众多的事物上：终端、计算机之 间的直接连接、调制解调器以及打印机等。</p>

<h5 id="18-2综述">18.2综述</h5>

<p>终端I/O有两种不同的工作模式。</p>

<p>ci）规范模式输入处理。在这种模式中，对终端输入以行为单位进行处理。対于每个读请求， 终端驱动程序最多返回一行。</p>

<p>岡 （2）非规范模式输入处理。输入字符不装配成行。</p>

<p>如果不做特殊处理，则默认模式是规范模式。例如，若shell将标准输入重定向到终端，并用</p>

<p>read和write将标准输入复制到标准输出，则终端以规范模式进行工作，每次read最多返回 一行。处理整个屏幕的程序（如vi编辑器）使用非规范模式，原因是它的命令可能是由单个字 符组成的，并且不以换行符终止。另外，该编辑器并不希望系统対特殊字符进行处理，因为这些 字符很可能与编辑命令中使用的字符重叠。例如，Ctrl+D字符通常是终端的文件结束符，但在vi 中它是向下滚动半个屏幕的命令。</p>

<p>V7和较早的BSD风格类的终端驱动程序支持3种终埔输入模式：（a）精细加工模式（輪入 装&amp;成行，并对特殊字符进行处理（b）原始模式（徐入不装纪成行，也不对特殊字符进行处理）；</p>

<p>1 （c） cbreak模式（格■入不装配成行，但对某些特殊字符进行处理）。图18-20显示了将终端设置为</p>

<p>cbreak或原始模式的POSIX.1函數。</p>

<p>POSIX.1定义了 11个特殊输入字符，其中9个可以更改。本书已经用到了其中几个，例</p>

<p>如文件结束符（通常是Ctrl+D）和挂起字符（通常是Ctrl+Z）。18.3节将対这些字符逐一进行 说明。</p>

<p>可以认为终端设备是由通常位于内核中的终端驱动程序控制的。每个终端设备都有一个输入 队列和一个输出队列，如图18-1所示。</p>

<p>进程写的下一个字符    进程读的下一个字符</p>

<p>输出队列</p>

<p>如果打开回显功能</p>

<p>输入队列</p>

<p>传送到设备的 下一个字符</p>

<p>^1-MAX_INPUT</p>

<p>从设备中读取的 下-个字符</p>

<p>图18-1终端设备的输入、输出队列的逻辑结构</p>

<p>对此图要说明以下几点。</p>

<p>•如果打开了回显功能，则在输入队列和输出队列之间有一个隐含的连接。</p>

<p>•输入队列的长度MAX_INPUT （见图2-11）是有限值。当一个特定设备的输入队列己经填 满时，系统的行为将依赖于实现。这种情况发生时大多数UNIX系统回显响铃字符。    [672]</p>

<p>■图中没有显示另一个输入限制MAX_CANON»这个限制是一个规范输入行的最大字 节数，</p>

<p>•虽然输出队列的长度通常也是有限的，但是程序并不能获得这个定义其长度的常量，因 为当输出队列将要填满时，内核便直接使写进程休眠，直至写队列中有可用的空间。</p>

<p>•我们将说明如何使用冲洗函数tcflush冲洗输入或输 出队列。与此类似，在说明tcsetattr函数时，将会 了解到如何通知系统只有在输出队列为空时，才能改变 一个终端的属性。（例如，想要改变输出属性时就要这样 做。〉也可以通知系统，让它在改变终端属性时丢弃输入 队列中的所有东西，（如果正在改变输入属性，或者在规 范模式和非规范模式之间进行转换，就需要这样做，以 免以错误的模式对以前输入的字符进行解释。）</p>

<p>大多数UNIX系统在一个称为终鴻行规程（terminal line discipline）的模块中进行全部的规范处理D可以将这个模块设想 成一个盒子|位于内核通用读、写函数和实际设备驱动程序之间 （见图 18-2）。</p>

<p>由于将规范处理分离为单独的模块，所有的终端驱动程序 都能够一致地支持规范处理。在第19章讨论伪终端时还将使用 此图。</p>

<p>所有可以检测和更改的终端设备特性都包含在termios结 构中。该结构定义在头文件＜termios.h＞中，本章使用这一头</p>

<p>用户进程</p>

<p>实际设备</p>

<p>图18-2终端行规程</p>

<p>文件。</p>

<p>struct termios { tcflag_t c_iflag; tcflag_t c_oflag; tcflag_t c_cflag; tcflag_t c_lflag; cc„t    c_cc【NCCS];</p>

<p>/* input flags */</p>

<p>/* output flags */</p>

<p>/* control flags */</p>

<p>/* local flags */</p>

<p>/* control characters */</p>

<p>};</p>

<p>粗略地说，输入标志通过终端设备驱动程序控制字符的输入（例如，剥除输入字节的第8位， 允许输入奇偶校验），输出标志则控制驱动程序输出（例如，执行输出处理、将换行符转换为 CR/LF）,控制标志影响RS-232串行线（例如，忽略调制解调器的状态线、每个字符的一个或两 个停止位），本地标志影响驱动程序和用户之间的接口（例如，回显打开或关闭、可视地擦除字 符、允许终端产生的信号以及对后台输出的作业控制停止信号）。</p>

<p>类型tcflag_t的丧度足以保存每个标志值，它经常被定义为unsigned int或者unsigned long. c_cc数组包含了所有可以更改的特殊字符=NCCS是该数组中元素的数量.其典型值在15-20 （因为大多数UNIX实现支持的特殊字符都比POSIX.1所定义的11个要多）。型的长 度足以保宿每个特殊字符，典型的是unsigned char。</p>

<p>POSIX标准之前的System V板本有一个名为＜termio. h＞的头文件和一个名为termio的數 丨据结构。为了与先前版本有所区别，POSIX.1在这些名字后加了一个S。</p>

<p>图18-3至图18-6列出了所有可以更改以影响终端设备特性的终端标志。注意，虽然Single UNIX Specification定义了供所有平台启动所用的公共子集，但所有实现都有自己的扩充部分，这 些扩充部分大多来自各系统之间的历史差异。18.5节将对这些标志值进行详细的讨论。</p>

<table>
<thead>
<tr>
<th>标志</th>
<th>说明</th>
<th>POSIX.1</th>
<th>FreeBSD8.0</th>
<th>Linux3.2,0</th>
<th>Mac OSX 10.6.8</th>
<th>Solaris10</th>
</tr>
</thead>

<tbody>
<tr>
<td>CBAUDEXT</td>
<td>扩充的波特率</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>•</td>
</tr>

<tr>
<td>CCAR_OFLOW</td>
<td>输出的DCD流控制</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>CCTS_OFLOW</td>
<td>输出的CTS流控制</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>•</td>
</tr>

<tr>
<td>CDSR_OFLOW</td>
<td>输出的DSR流控制</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>CDTR_IFLOW</td>
<td>输入的DTR流控制</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>CIBAUDEXT</td>
<td>扩充输入波特率</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>•</td>
</tr>

<tr>
<td>CIGNORE</td>
<td>忽略控制标志</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>CLOCAL</td>
<td>忽略调制解调器状态行</td>
<td>•</td>
<td></td>
<td></td>
<td></td>
<td>•</td>
</tr>

<tr>
<td>CMSPAR</td>
<td>标记或空奇偶性</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>CREAD</td>
<td>启用接收装置</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>•</td>
</tr>

<tr>
<td>CRTSCTS</td>
<td>启用硬件流控制</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>•</td>
</tr>

<tr>
<td>CRTS_IFLOW</td>
<td>输入的RTS流控制</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>•</td>
</tr>

<tr>
<td>CRTSXOFF</td>
<td>启用输入硬件流控制</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>•</td>
</tr>

<tr>
<td>CSIZE</td>
<td>字符大小屏蔽字</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>•</td>
</tr>

<tr>
<td>CSTOPB</td>
<td>发送两个停止位，否则发送1位</td>
<td></td>
<td></td>
<td>•</td>
<td></td>
<td>•</td>
</tr>

<tr>
<td>HUPCL</td>
<td>最后关闭吋挂断</td>
<td></td>
<td></td>
<td>•</td>
<td></td>
<td>•</td>
</tr>

<tr>
<td>MDMBUF</td>
<td>与 CCAR_OFLOW 相同</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>PARENB</td>
<td>启用奇偶校验</td>
<td></td>
<td></td>
<td>•</td>
<td></td>
<td>•</td>
</tr>

<tr>
<td>PAREXT</td>
<td>标记或空奇偶性</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>•</td>
</tr>

<tr>
<td>PARODD</td>
<td>奇校验，否则为偶校验</td>
<td></td>
<td></td>
<td>•</td>
<td></td>
<td>•</td>
</tr>
</tbody>
</table>

<p>图 18-3</p>

<p>c_cflag终端标志</p>

<table>
<thead>
<tr>
<th>碱</th>
<th>说明</th>
<th>POSIX.1</th>
<th>FreeBSD8.0</th>
<th>Linux3.2.0</th>
<th>Mac OS X 10.6.8</th>
<th>Solaris10</th>
</tr>
</thead>

<tbody>
<tr>
<td>BRKINT</td>
<td>接到BREAK时产生SIGINT</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>ICRNL</td>
<td>将输入的CR转换为NL</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>IGNBRK</td>
<td>忽略BREAK条件</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>IGNCR</td>
<td>忽略CR</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>IGNPAR</td>
<td>忽略奇偶校验出错的字符</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>IMAXBEL</td>
<td>在输入队列满时振铃</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>INLCR</td>
<td>将输入的NL转换为CR</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>INPCK</td>
<td>打开输入奇偶校验</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>ISTRIP</td>
<td>剥除输入字符的第8位</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>IUCLC</td>
<td>将瑜入的大写字符转換成小写字符</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>IUTF8</td>
<td>输入是UTF-8</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>IXANY</td>
<td>使任何字符都重新启动输出</td>
<td>-</td>
<td>•</td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>IXOFF</td>
<td>使启用糜用输入流持制起作用</td>
<td>•</td>
<td>•</td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>IXON</td>
<td>使启用/禁用输出流控制起作用</td>
<td>•</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>PARMRK</td>
<td>标记奇偶检验错误</td>
<td>•</td>
<td>•</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

<p>图184 c_iflag终端标志</p>

<table>
<thead>
<tr>
<th>标志</th>
<th>说明</th>
<th>POSIX.I</th>
<th>FreeBSD8.0</th>
<th>Linux3.2.0</th>
<th>Mac OS X 10.6.8</th>
<th>Solaris10</th>
</tr>
</thead>

<tbody>
<tr>
<td>ALTWERASEECHO</td>
<td>使用替换WERASE算法 启用回显</td>
<td>•</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>ECHOCTL</td>
<td>回显控制字符为A (Char)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>ECHOE</td>
<td>可视地擦除字符</td>
<td>•</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>ECHOK</td>
<td>回显杀死符</td>
<td>•</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>ECHOKE</td>
<td>杀死的可见擦除</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>ECHONL</td>
<td>回显NL</td>
<td>帝</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>ECHOPRT</td>
<td>硬拷贝的可见擦除方式</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>EXTPROCFLUSHO</td>
<td>外部字符处理 冲洗输出</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>ICANON</td>
<td>规范输入</td>
<td>•</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>IEXTEN</td>
<td>使扩充的输入字符处理起作用</td>
<td>•</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>ISIG</td>
<td>使终端产生的信号起作用</td>
<td>•</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>NOFLSH</td>
<td>在中断或退出后不冲洗</td>
<td>•</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>NOKERNINFOPENDIN</td>
<td>无来自STATUS的内核输出 重新键入未决输入</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>TOSTOP</td>
<td>对于后台输出发送SIGTTOU</td>
<td>•</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>XCASE</td>
<td>规范的丈/小写表示</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

<p>图18-5 c_lflag终端标志</p>

<p>给出了所有可用的选项后，如何才能检测和更改终端设备的这些特性呢？图18。7总结并 列出了 Single UNIX Specification所定义的对终端设备进行操作的各个函数。(列出的所有函 数都是POSIX基本规范的组成部分，9.7节已说明了 tcgetpgrp、tcgetsid和tcsetpgrp 函数。)</p>

<p>注意，对终端设备，Single UNIX Specification没有使用经典的ioctl,而是使用了图18-7 中列出的13个函数。这样做的理由是：对于终端设备的ioctl函数，其最后一个参数的数据类 型随执行动作的不同而改变。因此，不可能对参数进行类型检査。</p>

<table>
<thead>
<tr>
<th>标志</th>
<th>说明</th>
<th>POSIX.1</th>
<th>FreeBSD8.0</th>
<th>Linux3.2.0</th>
<th>Mac OS X 10.6.8</th>
<th>Solaris10</th>
</tr>
</thead>

<tbody>
<tr>
<td>BSDLY</td>
<td>退格延迟屏蔽字</td>
<td>XSI</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>CRDLY</td>
<td>CR延迟屏蔽字</td>
<td>XS1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>FFDLY</td>
<td>换页延迟屏蔽字</td>
<td>XSI</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>NLDLY</td>
<td>NL延迟屏蔽字</td>
<td>XSI</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>OCRNL</td>
<td>将输出的CR映射为NL</td>
<td>XS1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>OFDEL</td>
<td>填充符为DEL,否则为NUL</td>
<td>XSI</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>OFILL</td>
<td>延迟使用填充符</td>
<td>XSI</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>OLCUC</td>
<td>将输出的小写字符陕射为大写字符</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>ONLCR</td>
<td>将NL映射为CR-NL</td>
<td>XSI</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>ONLRET</td>
<td>NL执行CR功能</td>
<td>XSI</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>ONOCR</td>
<td>在0列不输出CR</td>
<td>XSI</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>ONOEOT</td>
<td>在输出中丢弃EOT字符（AD）</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>OPOST</td>
<td>执行输出处理</td>
<td>•</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>OXTABS</td>
<td>将制表符扩充为空格</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>TABDLY</td>
<td>水平制表符延迟屏敵字</td>
<td>XSI</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>VTDLY</td>
<td>垂直制表符延迟屏蔽字</td>
<td>XSI</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

<p>图18-6 c_of lag终端标志</p>

<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>tcgetattr</td>
<td>获取属性（termios结构）</td>
</tr>

<tr>
<td>tcsetattr</td>
<td>设置属性（termios结构）</td>
</tr>

<tr>
<td>cfgetispeed</td>
<td>获得输入速度</td>
</tr>

<tr>
<td>cfgetospeed</td>
<td>获得输出速度</td>
</tr>

<tr>
<td>cfsetispeed</td>
<td>设置输入速度</td>
</tr>

<tr>
<td>cfaetospeed</td>
<td>设置输出速度</td>
</tr>

<tr>
<td>tcdrain</td>
<td>等待所有输出都被传输</td>
</tr>

<tr>
<td>tcflow</td>
<td>挂起传输或接收</td>
</tr>

<tr>
<td>tcflush</td>
<td>冲洗未决输入和/或输出</td>
</tr>

<tr>
<td>tcsendbreak</td>
<td>发送BREAK字符</td>
</tr>

<tr>
<td>tcgetpgrp</td>
<td>获得前台进程组ID</td>
</tr>

<tr>
<td>tcsetpgrp</td>
<td>设置前台进程组ID</td>
</tr>

<tr>
<td>tcgetsid</td>
<td>得到控制TTY的会话首进程的进程组ID</td>
</tr>
</tbody>
</table>

<p>图18-7终端I/O函数汇总</p>

<p>虽然在终端设备上进行操作的只有13个函数，但是图18-7中的前两个函数（tcgetattr 和tcsetattr）能处理大约70种不同的标志（见图18-3至图18-6）。终端设备有大量选 项可供使用，此外，对于某个特定设备（假设其为终端、调制解调器、打印机或任何其他 设备），决定其需要哪些选项对我们来说也是一种挑战，这些都使得对终端设备的处理变 得异常复杂。</p>

<p>图18-7中列出的13个函数之间的关系如图18-8所示。</p>

<p>1    POSIX.1没有指定将波特率信息存储在termios结构中的什么地方，它依核于实现的细节。</p>

<p>I某些系统，如Solaris,将此信息存储在0_0£139字段中。Linux和BSD派生的系统，如FreeBSD</p>

<p>和MacOSX,则在此结构中有两个分开的字段：一个存借检入速度，另一个存储输出速度。</p>

<p>struct</p>

<p>termios</p>

<p><img src="UNIXaf83d8a7160b-70.png" alt="img" /></p>

<p>图18-8与终端有关的各函数之间的关系</p>

<p>674</p>

<p>I</p>

<p>677</p>

<p>18.3特殊输入字符</p>

<p>POSIX.1定义了 11个在输入时要特妹处理的字符。実现定义了另外一些特殊宇符。图18-9 总结井列出了这些特殊字符。</p>

<table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
<th>c_cc下标</th>
<th>由…</th>
<th>启用</th>
<th>麵值</th>
<th>POSDC1</th>
<th>FreeBSD8.0</th>
<th>Linux32.0</th>
<th>Mac OS X 10.6.8</th>
<th>Solsis10</th>
</tr>
</thead>

<tbody>
<tr>
<td>字段</td>
<td>标志</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>CR</td>
<td>回车</td>
<td>（不能更改）</td>
<td>c_lflag</td>
<td>ICANON</td>
<td>\r</td>
<td>-</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>DISCARDDSUSP</td>
<td>丢弃输出（SIGTSTP）</td>
<td>VDISCARDVDSUSP</td>
<td>c_lflagc_lflag</td>
<td>IEXTENISIG</td>
<td>X)AY</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>EOF</td>
<td>文件结束</td>
<td>VEOF</td>
<td>c_lflag</td>
<td>ICANON</td>
<td>AD</td>
<td>•</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>EOLEOL2</td>
<td>鴻束備换的概束</td>
<td>VEOLVEOL2</td>
<td>c_lflagc_lflag</td>
<td>ICANONICANON</td>
<td></td>
<td>*</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>ERASEERASE2</td>
<td>向m除辨 供替换的向前擦 鮮符</td>
<td>VERASEVERASE2</td>
<td>c_lflagc_lflag</td>
<td>ICANONICANON</td>
<td>aH,a?AH,A?</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>INTR</td>
<td>中断信号 （SIGINT）</td>
<td>VINTR</td>
<td>c_lflag</td>
<td>ISIG</td>
<td></td>
<td>•</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>KILL</td>
<td></td>
<td>VKILL</td>
<td>c_lflag</td>
<td>ICANON</td>
<td></td>
<td>•</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>LNEXT</td>
<td>下一个字符的字 面值</td>
<td>VLNEXT</td>
<td>c_lflag</td>
<td>IEXTEN</td>
<td>aV</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>NL</td>
<td>鮪</td>
<td>（不能更改）</td>
<td>c_lflag</td>
<td>ICANON</td>
<td>\n</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>QUIT</td>
<td>退出信号 （SIGQUIT）</td>
<td>VQUIT</td>
<td>c_lflag</td>
<td>ISIG</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>REPRINT</td>
<td>再打印金部输入</td>
<td>VREPRINT</td>
<td>c_lflag</td>
<td>ICANON</td>
<td>AR</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>START</td>
<td>恢复输出</td>
<td>VSTART</td>
<td>c_iflag</td>
<td>工 XON/ IXOFF</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

<p>图18-9终端特殊输入字符汇总</p>

<table>
<thead>
<tr>
<th>铺</th>
<th>说明</th>
<th>c_cc下标</th>
<th>由••…</th>
<th>启用</th>
<th>典型值</th>
<th>POSIX.1</th>
<th>FreeBSD8.0</th>
<th>Lirnxx3^.0</th>
<th>Mac OS X 10.6.8</th>
<th>Solaris10</th>
</tr>
</thead>

<tbody>
<tr>
<td>字段</td>
<td>标志</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>STATUS</td>
<td>状态清求</td>
<td>VSTATUS</td>
<td>c_lflag</td>
<td>ICANON</td>
<td>AT</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td>STOP</td>
<td>停止输出</td>
<td>VSTOP</td>
<td>c_iflag</td>
<td>IXON/IXOFF</td>
<td>AS</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>•</td>
</tr>

<tr>
<td>SUSP</td>
<td>概信号(SIGTSTP)</td>
<td>VSUSP</td>
<td>c_lflag</td>
<td>ISIG</td>
<td>AZ</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>•</td>
</tr>

<tr>
<td>WERASE</td>
<td>向前擦除一个字</td>
<td>VWERASE</td>
<td>c lflag</td>
<td>ICANON</td>
<td>AW</td>
<td></td>
<td>•</td>
<td>•</td>
<td></td>
<td>•</td>
</tr>
</tbody>
</table>

<p>图18-9终端特殊输入字符汇总（续）</p>

<p>在POSIX.1的11个特殊字符中，其中有9个字符的值可以任意更改。不能更改的两个特殊 字符是换行符和回车符（分别是\^和\1），也可能是STOP和START字符（依赖于实现）。为了 更改，只需要修改termios结构中c_cc数组的相应项。该数组中的元素都用名字作为下标进 行引用，每个名字都以字母V开头（见图18-9中的第3列）。</p>

<p>POSIX.1允许禁止使用这咎字符。若将c_cc数组中的某项设置为_POSIX_VDISABLE的值， 则禁止使用相应特殊字符。</p>

<p>在Single UNIX Specification的早期版本中，支持_POSIX_VDISABLE是可选项，现在则是必选项。 本书讨论的4种平台都支持此特性。Linux32.0和Solaris 10^POSIX_VDISABLE定义为0，而</p>

<dl>
<dt>I FreeBSD 8.0 和 Mac OS X 10.6.8 则将其定义为 Oxf f。</dt>
</dl>

<p>:&rsquo;    某些早期的UNIX系统所用的方法是：若与某一特性相应的特殊檢入字符是0,则禁止使用该特性。</p>

<p>画</p>

<p>■实例</p>

<p>在详细说明各特殊字符之前，先看一个更改特殊字符的小程序。图18-10所示的程序禁用中 断字符，并将文件结束符设置为Ctrl+B。</p>

<p>林include &ldquo;apue.h&rdquo; #include <termios.h></p>

<p>int</p>

<p>main &lt;void)</p>

<p>1</p>

<p>struct termios    term;</p>

<p>long    vdisable;</p>

<p>if (isatty(STDIN_FILENO) = 0)</p>

<p>err_quit(&ldquo;standard input is not a terminal device&rdquo;);</p>

<p>if ((Vdisable = fpathconf(STDIN_FILENO, _PC_VDISABLE)) &lt; 0)</p>

<p>err_quit(&ldquo;fpathconf error or _POSXX_VDISABLE not in effect&rdquo;);</p>

<p>if (tcgetattr(STDIN_FILENO, sterm) &lt; 0J /* fetch tty state */ err_sys(&ldquo;tcgetattr error&rdquo;);</p>

<p>term.c_cc[VINTRI = vdisable; /* disable INTR character <em>/ term.c_cc[VEOF] =2;    Z</em> EOF is Control-B */</p>

<p>if (tcsetattr(STDIN_FILENO, TCSAFLUSH, iterm) &lt; 0&gt;</p>

<p>err_sys(&ldquo;tcsetattr error&rdquo;);</p>

<p>exit{0);</p>

<p>图18-10禁用中断字狩并更改文件结束符 対此程序要说明以下几点。</p>

<p>.仅当标准输入是终端设备时才修改终職殊字符。调用isatty （见18.9节）对此进行检测=</p>

<p>•用 fpathconf 获取_POSIX_VDISABLE 值。</p>

<p>•函数tcgetattr （见18.4节）从内核获取termios结钩。在修敌了此结构后，调 用tcsetattr函数设置属性，只有我们所希望修改的属性被更改了，而其他属畦保 持不变。</p>

<p>•禁用中断键与忽略中断信号是不同的。图18-10中的程序所做的只是禁用使终端驱动程序 产生SIGINT信号的特殊字符。我们仍可使用kill函数将该信号发送至进程。    [679]</p>

<p>下面较详细地说明各个特殊字符。我们称这些字符为特殊输入字符，但是其中有两个字 符——STOP和START （Ctri+S和Ctrl+Q）,在输出时也要进行特殊处理。注意，这些字符中的大 多数在被终端驱动程序识别并进行特殊处理后会被丢弃，并不将它们返回给执行读终端操作的进 程。返固给读进程的例外字符是换行符（NL、EOL、EOL2）和回车符（CR）。</p>

<p>CR    回车符。不能更改此字符。以规范模式进行输入时识别此字符。在已设置ICANON</p>

<p>（规范模式）和ICRNL （将CR映射为NL）但并未设置IGNCR （忽略CR）时，CR 字符会被转换成NL,并具有与NL字符相同的作用。此字符返回给读进程（很可 能是在转换为NL之后）。</p>

<p>DISCARD 丢弃符。在扩充模式（IEXTEN）下进行输入时识别此字符。在输入另一个DISCARD 字符之前或在丢弃条件被清除之前（见FLUSHO选项），此字符使后续输出都被丢 弃。此字符在处理后即被丢弃（即不传送给读进程）。</p>

<p>DSUSP    延返挂起作业控制字符（delayed-suspend job-control character）o在扩充模式</p>

<p>（IEXTEN）下，若支持作业控制，并且己设置ISIG标志，则在输入时识别此字符。</p>

<p>与SUSP字符的相同之处是：延迟挂起字符产生SIGTSTP信号，该信号被发送至 前台进程组中的所有进程（见图9-7）。但是，信号产生的时间并不是在键入延迟挂 起字符之时，而是在某个进程从控制终端读到此字符时才产生。此字符在处理后即 被丢弃（即不传送给读进程）。</p>

<p>EOF    文件结束符。以规范模式（ICANON）进行输入时识别此字符。当键入此字符时，</p>

<p>等待被读的所有字节都被立即传送给谏进程。如果没有字节等待读，则返回0。在 行首输入一个EOF字符是向程序指示文件结束的正常方式。此字符在规范模式下 处理后即被丢弃（即不传递给读进程）。</p>

<p>EOL    附加的行定界符，与NL作用相同。以规范模式（ICANON）进行输入时识别此字</p>

<p>符，并将此字符返回给读进程。但是此字符不常用。</p>

<p>EOL2    另一个行定界符，与NL作用相同。对此字符的处理方式与EOL字符相同。</p>

<p>ERASE    向前擦除字符（退格）。以规范模式（ICANON）输入时识别此字符。它擦除行中的</p>

<p>前一个字符，但不会超越行首字符擦除上一行中的字符。此字符在规范模式下处理 后即被丢弃（即不传送给读进程）=    ®</p>

<table>
<thead>
<tr>
<th>ERASE2INTR</th>
<th>供替换的向前擦除字符（退格对此字符的处理与向前擦陵字符（ERASE）完全相同。 中断字符。若已设置ISIG标志，则在输入中识别此字符。它产生SIGINT信号，</th>
</tr>
</thead>

<tbody>
<tr>
<td>KILL</td>
<td>孩信号被送至前台进程组中的所有进程（见图9-7）。此字符在处理后即被丢弃（即 不传送给读进程）。杀死字符。（名字“杀死”在这里又一次被误用，kill函数是用来将某一信号发</td>
</tr>

<tr>
<td>LNEXT</td>
<td>送给进程的，而此字符应被称为行擦除符，它与信号亳无关系。）以规范模式 （ICANON）输入时识别此字符。它擦除一整行，并在处理后即被丢弃（即不传送 给读进程）。下一个字符的字面值（literal-next character）□以扩充方式（IEXTEN）输入时识别</td>
</tr>

<tr>
<td>NL</td>
<td>此字符，它使下一个字符的任何特殊含意都被忽略。这对本节提及的所有特殊字符 都起作用。使用这一字符可向程序键入任何字符。LNEXT字符在处理后即被丢弃， 但输入的下一个字符被传送给读进程。换行字符，也被称为行定界符。不能更改此字符。以规范模式（ICANON）输入时</td>
</tr>

<tr>
<td>QUIT</td>
<td>识别此字符。此字符返回给读进程。退出字符。若已设置ISIG标志，则在输入中识别此字符。它产生SIGQUIT信号， 该信号又被送至前台进程组中的所有进程（见图9-7）。此字符在处理后即被丢弃</td>
</tr>

<tr>
<td>REPRINT</td>
<td>（即不传送给读进程）。回忆图10-b INTR和QUIT的区别是：QUIT字符不仅按默认规则终止进程，而且 还产生一个core文件。再打印字符。以扩充规范模式（设置了 IEXTEN和工CANON标志）进行输入时识别此</td>
</tr>

<tr>
<td>START</td>
<td>字符。它使所有未读的输入被输出（再回显）。此字符在处理后即被丢弃（即不传 送给读进程）。启动字符。若已设置IXON标志，则在输入中识别此字符。若己设置IXOFF标志，</td>
</tr>

<tr>
<td>圆STATUS</td>
<td>则自动产生此字符作为输出。已设置IXON时，接收到的START字符使停止的输 出（由以前输入的STOP字符造成）重新启动。在此情形下，此字符在处理后即被 丢弃（即不传送给读进程）。已设置IXOFF标志时，若新的输入不会使输入缓冲区溢出，则终端驱动程序自动 产生一个START字符来恢复以前被停止的输入。BSD的状态请求字符。以扩充规范模式（设置了工EXTEN和工CANON标志）进行输入</td>
</tr>

<tr>
<td>STOP</td>
<td>时识别此字符。它产生SIGINFO信号，孩信号又被送至前台进程组中的所有进程 （见图9-7）。另外，如果没有设置NOKERNINFO标志，则有关前台进程组的状态信 息也显示在终端上。此字符在处理后即被丢弃（即不传送给读进程）。停止字符。若已设置IXON标志，则在输入中识别此字符。若己设置IXOFF标志， 则自动产生此字符作为输出，已设置IXON时，接收到STOP字符则停止输出。在 此情形下，此字符在处理后即被丢弃（即不传送给读进程）。当输入一个START字</td>
</tr>

<tr>
<td>SUSP</td>
<td>符后，被停止的输出重新启动。已设置IXOFF时，终端驱动程序自动产生一个STOP字符以防止输入缓冲区溢出。 挂起作业控制字符。若支持作业控制并且已设置ISIG标志，则在输入中识别此字 符。它产生SIGTSTP信号，该信号又被送至前台进程组的所有进程（见图9-7）。此 字符在处理后即被丢弃（即不传送给读进程）。</td>
</tr>
</tbody>
</table>

<p>WERASE 字擦除字符。以扩充规范模式（设置了 IEXTEN和ICANON标志）进行输入时识别 此字符。它使前一个字被擦除。首先，它向前尚过任意一个空白字符（空格或制表 符），然后再向前跃过前一记号，使光标处在前一个记号的第一个字符位置上。通 常，前一个记号在碰到一个空白字符时即终止。但是，可通过设置ALTWERASE标 志来改变这个行为。此标志使前一个记号在碰到第一个非字母、非数字字符时即终 止。此字符在处理后即被丢弃（即不传送给读进程），</p>

<p>需要为终端设备定义的另一个“字符”是BREAK字符。BREAK实际上并不是一个字符，</p>

<p>而是在异步串行数据传送时发生的一个条件。根据串行接口的不同，可以有多种方式通知设备驱 动程序发生了 BREAK条件。</p>

<p>大多数早期的串行终端都有一个标记为BREAK的键，用其可以产生BREAK条件，这就是 1为什么大多数人认为BREAK就是一个字符的原因。某些较新的终端键盘没有BREAK键。在PC 1上，BREAK键可能有其他用途。例如，键入Ctrl+BREAK可中断Windows命令解释器。</p>

<p>对于异步串行数据侍送，BREAK是一个0值的位序列’其持续时间长于要求发送一字节的时间。</p>

<p>整个0值位序列被视为是一个BREAK。18.8节将说明如何用tcsendbreak函数发送一个BREAK。</p>

<p>画</p>

<p>18.4获得和设量终端属性</p>

<p>为了获得和没置termios结构，可以调用tcgetattr和tcsetattr函数。这样就可以 检测和修改各种终端选项标志和特殊字符，使终端按我们所希望的方式进行操作。</p>

<p>♦include <termios.h></p>

<p>int tcgetattr{int fd, struct termios *termptr);</p>

<p>int tcsetattr(int fd, int opt, const struct termios *termptr);</p>

<p>两个函数的返回值：若成功，返回0:若出错，返回-1</p>

<p>这两个函数都有一个指向termios结钩的指针作为其参数，它们或者返回当前终端的属性， 或者设置该终端的属性。因为这两个函数只对终端设备进行操作，所以若和没有引用终端设备则 出错返回-1，errno设置为ENOTTY。</p>

<p>tcsetattr的参数使我们可以指定在什么时候新的终端属性才起作用。叩/可以指定为 下列常量中的一个。</p>

<p>TCSANOW    更改立即发生。</p>

<p>TCSADRAIN发送了所有输出后更改才发生。若更改输出参数则应使用此选项。</p>

<p>TCSAFLUSH发送了所有输出后更改才发生。更进一步，在更改发生时未读的所有输入数 据都被丢弃（冲洗乂</p>

<p>Tcsetattr函数的返回状态在使用时易产生混淆。如果它执行了任意一种所要求的动作， 即使未能执行所有要求的动作，它也返回OK （表示成功）》如果该函数返回OK，则我们有责任 检查该函数是否执行了所有要求的动作。这就意味着，在调用tcsetattr设置所希望的属性后， 需调用tcgetattr,然后将实际终端属性与所希望的属性相比较，以检测两者是否有区别。</p>

<p>在终端第一次被打开时，其属性视具体情况而定。一些系统可能会将终端属性初始化为具体 实现所定义的值，另一些系统可能会保留并使用最后一次使用终端时的属性值。通过打开一个带</p>

<p>有O_TTY_INIT标志（见3.3节）的驱动设备，可以确认终端的行为是否遵循标准，这样就能在 调用tcgetattr时，确保初始化termios结构中的任何非标推部分，使得在修改属性和调用 tcgetattr时，终端的表现符合预期。</p>

<p>18.5结端选项标志</p>

<p>本节将列出所有不同的终端选项标志，扩展图18-3至图18-6中的说明。我们将按字母顺序列 出各个选项并指出每个选项出现在4个终端标志字段中的哪一个。（从选项名字中看不出它所处的</p>

<p>[6831字段。）还将说明每个选项是否是Single UNIX Specification定义的，并列出了支持该选项的平台。</p>

<p>列出的所有选项标志（除所谓的屏蔽字标志外）都用一位或多位（设置或清除）表示。屏蔽</p>

<p>字标志定义多个位，它们组合在一起，可以定义一组值。屏蔽字标志有一个定义名，每个值也有 一个名字。例如，为了设置字符长度，首先用字符长度屏蔽字标志CSIZE将表示字符长度的位 清0，然后设置下列值之一：CS5、CS6、CS7或CS8。</p>

<p>由Linux和Solaris支持的6个延迟值也有屏蔽字标志：BSDLY、CRDLY、FFDLY、NLDLY、 TABDLY和VTDLY。对于每个延迟值的长:度请参阅Solaris中的termio （71）手册页。在所有情况 下，延迟屏蔽字为0就表示没有延迟。如果指定了延迟，则由OFILL和OFDEL标志决定是由驱 动器进行实际延迟还是只传输填充字符。</p>

<p>■实例</p>

<p>图18-11演示了如何使用这些屏蔽字标志取一个值或者设置一个值。</p>

<p>♦include &ldquo;apue.h&rdquo;</p>

<p>#include <termios.h></p>

<p>int</p>

<p>main (void)</p>

<p>struct termios term;</p>

<p>if (tcgetattr(STDIN_FILENO, &amp;term) &lt; 0) err_sys(&ldquo;tcgetattr error&rdquo;);</p>

<p>switch (term.c_cflag &amp; CSIZE) { case CS5:</p>

<p>printf (&ldquo;5 bits/byte\n&rdquo;); break;</p>

<p>case CS6:</p>

<p>printf(&ldquo;6 bits/byte\n&rdquo;)； break;</p>

<p>case CS7:</p>

<p>printf(&ldquo;7 bits/byte\n&rdquo;); break;</p>

<p>case CS8:</p>

<p>printf(&ldquo;8 bits/byte\n&rdquo;); break；</p>

<p>default:</p>

<p>printf(&ldquo;unknown bits/byte\n&rdquo;);</p>

<p>term.c_cflag &amp;= -CSIZE;    /* zero out the bits */</p>

<p>term.c_cflag I= CS8;    /* set 8 bits/byte */</p>

<p>if (tcsetattr(STDIN_FILENO, TCSANOW, &amp;term) &lt; 0)</p>

<p>err_sys(&ldquo;tcsetattr error&rdquo;);</p>

<p>exit(0);</p>

<p>图 18-11 tcgetattr 和 tcsetattr 实例</p>

<p>下面说明各选项标志。</p>

<p>ALTWERASE</p>

<p>BRKINT</p>

<p>BSDLY</p>

<p>CBAUDEXT</p>

<p>CCAR_OFLOW</p>

<p>CCTS_OFLOW</p>

<p>CDSR_OFLOW</p>

<p>CDTR_IFLOW</p>

<p>C工BAUDEXT</p>

<p>CIGNORE CLOCAL</p>

<p>CMSPAR</p>

<p>(c_lflag，FreeBSD、Mac OS X)已设置此标志时，若输入WERASE字符， 则使用一个替换的字擦除算法。它不是向前移动到前一个空白字符为止，而是 向前移动到第一个非字母、非数字字符为止。</p>

<p>(c_iflag，POSIX.l、FreeBSD、Linux-. MacOSX、Solaris)若已设置此标志， 而未设置IGNBRK，则在接到BREAK时，冲洗输入、输出队列，并产生一个 SIGINT信号D如果此终端设备是一个控制终端，则此信号就是为前台进程组 产生的。</p>

<p>若未设置IGNBRK和BRKINT，但是设置了 PARMRK,则BREAK被读作一个 3字节序列\377、\0和\0:若也未设置PARMRK,则BREAK被读作单个字 符\0。</p>

<p>(c_oflag，XSI、Linux, Solaris)退格延迟屏蔽字。此屏栽字的值是BS0或BS1。 (c_cflag，Solaris)扩充的波特率。用于允许大于B38400的波特率。(将在 18.7节讨论波特率3</p>

<p>(c_cf lag，FreeBSD、Mac OS X)使用 RS-232 调制解调器 DCD (Data-Camer-Detect,数据载波检测)信号打开输出的硬件流控制。这与早期的MDMBUF标志 相同。</p>

<p>(c_cflag» FreeBSD、Mac OS X&gt; Solaris)使用 RS-232CTS (Clear-To-Send» 清除发送)信号打开输出的硬件流接制，</p>

<p>(c_cflag, FreeBSD、Mac OS X)根据 RS-232 DSR (Data-Set-Ready，数据准 备就绪)信号进行输出的流控制。</p>

<p>(c_cflag，FreeBSD, Mac OS X)根据 RS-232 DTR (Data-Terminal-Ready, 数据终端就绪)信号进行输入的流控制。</p>

<p>(c_cflag, Solaris)扩充的输入波特率。用于允许大于B38400的输入波特率。 (将在18.7节讨论波特率。)</p>

<p>(c_cflag，FreeBSD- Mac OS X)忽略控制标志》</p>

<p>(c_cflag, POSIX.l、FreeBSD、Linux、Mac OS X、Solaris)若设置，则忽 略调制解调器状态线。这通常意味着该设备是直接连接的。例如，若未设置 此标志，则打开一个终端设备常常会遭遇阻塞，直到调制解调器回应呼叫并 建立连接。</p>

<p>(c_oflag( Linux)选择标记或空奇偶校验。若已设置PARODD,则奇偶校验 位总是1 (标记奇偶校验)。否则奇偶校验位总是0 (空奇偶校验)。</p>

<p>CRDLY</p>

<p>函</p>

<p>CREAD</p>

<p>CRTSCTS</p>

<p>CRTS_IFLOW</p>

<p>CRTSXOFF</p>

<p>CSIZE</p>

<p>CSTOPB</p>

<p>ECHO</p>

<p>ECHOCTL</p>

<p>ECHOE</p>

<p>ECHOK</p>

<p>(c^oflag, XSI、Linux、Solaris)回车延迟屏蔽字。此屏蔌字的可能值是CRO、 CR1、CR2 和 CR3。</p>

<p>(c.cflag, POSIX.1、FreeBSD、Linux、Mac OS X, Solaris)若设置，则接收 者被启用，可以接收字符，</p>

<p>Cc_cflag, FreeBSD、Linux、Mac OS X、Solaris)其行为依赖于平台。对于 Solaris,若设置该标志，则允许带外硬件流控制。在另外3个平台上，则既允 许带内硬件流控制，又允许带外硬件流控制(等价于CCTS_OFLOW | CRTS^ I FLOW )。</p>

<p>(c_cflag, FreeBSD、MacOSX、Solaris)输入的 RTS (Request-To~Send，请 求发送)流控制。</p>

<p>(c_cflag，Solaris)若设置，则允许带内硬件流控制，RS-232 RTS信号的状态 控制了流控制。</p>

<p>(c_cflag, POSIX.U FreeBSD、Linux、Mac OS X、Solaris)此字段是一个屏 蔽字标志，它指定发送和接收的每个字节的位数。此长度不包括可能有的奇偶 校验位。由此屏蔽字定义的字段值是CS5、CS6、CS7和CS8,分别表示每个 字节包含5位、6位、7位和8位。</p>

<p>(c.cflag, POSIX.1、FreeBSD、Linux、MacOSX、Solaris)若设置，则使用 两个停止位，否则只使用一个停止位。</p>

<p>(c_lflag，POSIX.U FreeBSD、Linux、Mac OS X、Solaris)若设置，则将输 入字符回显到终端设备。在规范模式和非规范模式下都可以回显输入字符。 (c_lflag. FreeBSD、Linux、Mac OS X、Solaris)若设置并且也设置ECHO， 则除ASCn TAB、ASCII NL以及START和STOP字符外，其他ASCII控制字 符(ASCII字符集中0至八进制37对应的字符)都被回显为其中，Y是相 应控制字符加上八进制100所构成的字符。例如，ASCnCtrl+A字符(八进制1) 被回显为AA。ASCH DELETE字符(八进制177)则回显为若未设置此标 志，则ASCII控制字符按其原样回显》如同ECHO标志，在规范模式和非规范 模式下，此标志对控制字符回显都起作用。</p>

<p>应当了解的是，某些系统以不同方式回显EOF字符，因为EOF的典型值是Ctrl+D (而Ctrl+D是ASCIIEOT字符，它可能使某些终端挂断)。请查看有关手册。 (c_lflag，POSIX.1、FreeBSD、Linux、Mac OS X、Solaris)若设置并且也设 置ICANON,则ERASE字符从显示中擦除当前行中的最后一个字符。这通常是 在终端驱动程序中写一个3字符序列实现的，该序列是：退格、空格、退格。 若支持WERASE字符，则ECH0E用一个或若干个上述3字符序列擦除前一个字。 若支持ECH0PRT标志，则这里说明的关于ECHOE的动作是在假定未设置 ECH0PRT标志的条件下得出的。</p>

<p>(c_lflag» POSIX.l、FreeBSD- Linux、Mac OS X- Solaris)若设置并且也设 置ICANON,则KILL字符从显示中擦除当前行，或者输出NL字符(用以强调 已擦除整个行)。</p>

<p>若支持ECH0KE标志，则关于ECH0K的说明是在假定未设置ECH0KE标志的条 件下得出的。</p>

<p>ECHOKE</p>

<p>ECHONL</p>

<p>ECHOPRT</p>

<p>EXTPROC</p>

<p>FFDLY</p>

<p>FLUSHO</p>

<p>HUPCL</p>

<p>工CANON</p>

<p>ICRNL</p>

<p>IEXTEN</p>

<p>IGNBRK</p>

<p>IGNCR</p>

<p>I GN PAR</p>

<p>IMAXBEL</p>

<p>INLCR</p>

<p>(c_lflag, FreeBSD、Linux、Mac OS X、Solaris)若设置并且也设置 ICANON,</p>

<p>则回显KILL字符的方式是擦除行中的每一个字符。擦除每个字符的方法则由 ECHOE和ECHOPRT标志选择。</p>

<p>(c_lflag, POSEX.U FreeBSD、Linux、Mac OS X&gt; Solaris)若设置并且也设 置ICANON,即使没有设置ECHO,也回显NL字符。</p>

<p>(c_lflag，FreeBSD、Linux&gt; Mac OS X、Solaris)若设置并且也设置 ICANON 和ECHO,则ERASE字符(以及WERASE字符，若受到支持)使所有正被擦 除的字符按它们被擦除的方式被打印。这一方法常在硬拷贝终端上显示其作用，</p>

<p>它可以使我们确切地看到哪些字符正被刪除。</p>

<p>(c_lflag, FreeBSD、Linux、Mac OS X)若设置，规范字符处理在操作系统 之外执行。如果串行通信外设卡能够通过执行某些行规程处理减轻主机处理器 负载，那么就可以这样设置。在使用伪终端时(见第19章)，也可以这样设置。 (c_oflag, XSI、Linux、Solaris)换页延迟屏蔽字。此屏蔽字标志值是FF0或FF1。 (c_lflag，FreeBSD、Linux, Mac OS X、Solaris)若设置，则冲洗输出。当 键入DISCARD字符时设置此标志。当键入另一个DISCARD字符时，此标志 被清除。可以通过设置或清除此终端标志来设置或清除此条件。</p>

<p>(c_cflag，POSIX.1、FreeBSD, Linux、MacOSX、Solaris)若设置，则当最 后一个进程关闭设备时，调制解调器控制线降至低电平(也就是调制解调器的 连接断开)。</p>

<p>(c.lflag, POSIX.K FreeBSD、Linux、MacOSX、Solaris)若设置，则按规 粗模式工作(见18.10节)。这使下列字符起作用：EOF、EOL、EOL2、ERASE、</p>

<p>KILL、REPRINT、STATUS 和 WERASE。输入字符被装配成行。    [687]</p>

<p>如果不以规范模式工作，则读请求直接从输入队列取字符。在至少接到MIN个字 节或两个字节之间的超时值TIME到期时，read才返回。详细情况参见18.11节。 (c_iflag, POSIX.1、FreeBSD、Linux、MacOSX、Solaris)若设置并且未设 置IGNCR,则将接收到的CR字符转换成NL字符。</p>

<p>(c_lflag, POSIX.l、FreeBSD、Linux、Mac OS X、Solaris)若设置，则识别 并处理扩展的、由实现定义的特殊字符。</p>

<p>(c_iflag, POSDL1、FreeBSD、Linux、Mac OS X、Solaris)在已设置时，忽 略输入中的BREAK条件。关于BREAK条件是产生SIGINT信号还是被作为 数据读取，见BRKINT。</p>

<p>Cc_iflag, POSIX.l、FreeBSD、Linux、Mac OS Solaris)若设置，则忽略 接收到的CR字符。若未设置此标志，而设置了 ICRNL标志，则有可能将接收 到的CR字符转换成NL字符，</p>

<p>(c^iflag, POSIX.1、FreeBSD、Linux、Mac OS X、Solaris)在已设置时，忽 略带有结构出错(非BREAK)或奇偶出错的输入字节。</p>

<p>(c^iflag, FreeBSD a Linux、Mac OS X, Solaris)当输入队列满时响铃。</p>

<p>(c_iflag, POSIX.1、FreeBSD. Linux、MacOSX、Solaris)若设置，则将接 收到的NL字符转换成CR字符。</p>

<table>
<thead>
<tr>
<th>INPCK</th>
<th>(c_iflag, POSIX.l、FreeBSD、Linux、Mac OS X、Solaris)在己设置时，使 输入奇偶校验起作用。若未设置INPCK,则使输入奇偶校验不起作用。奇偶“产生和检测”和“输入奇偶校验”是两件不同的事。奇偶位的产生和检 测是由PARENB标志控制的。设置该标志后通常会使串行接口的设备驱动程序 对输出字符产生奇偶位，对输入字符则验证其奇偶性。PARODD标志决定该奇 偶性应当是奇还是偶。如果一个其奇偶性错误的输入字符到来，则检査INPCK 标志的状态。若已设置此标志，则检査IGNPAR标志(以决定是否应忽略带奇 偶出错的输入字节)；若不应忽略此输入字节，则检査PARMRK标志以决定应该 向读进程传送哪些字符。</th>
</tr>
</thead>

<tbody>
<tr>
<td>ISIG</td>
<td>(c_lflag, POSIX.1、FreeBSD、Linux、Mac OS X、Solaris)若设置，则判别 输入字符是否是要产生终端信号的特殊字符(INTR、QUIT. SUSP和DSUSP); 若是，则产生相应信号。</td>
</tr>

<tr>
<td>ISTRIP</td>
<td>(c_iflag, POSIX.1、FreeBSD、Linux、Mac OS X、Solaris)在已设置此标志 时，有效输入字节被剥离为7位，在未设置时，则处理全部8位。</td>
</tr>

<tr>
<td>|688| IUCLC工 UTF8</td>
<td>(c_iflag，Linux、Solaris)将输入的大写字符转换成小写字符。(c_iflag, Linux、Mac OS X)允许使用UTF-8多字节字符进行字符擦除处理。</td>
</tr>

<tr>
<td>IXANY</td>
<td>(c_iflag, XSk FreeBSD、Linux、Mac OS X、Solaris)使任何字符都能重新 启动输出。</td>
</tr>

<tr>
<td>IXOFF</td>
<td>(c_iflag, POSIX.K FreeBSD、Linux、Mac OS X, Solaris)若设置，则使启 动-停止输入控制起作用。当终端驱动程序发现输入队列将要填满时，输出一个 STOP字符。此字符应当由发送数据的设备识别，并使该设备停止。此后，当把 输入队列中的字符处理完毕之后，终端驱动程序将输出一个START字符，使该 设备恢复发送数据。</td>
</tr>

<tr>
<td>IXON</td>
<td>(c_iflag，POSIX.1、FreeBSD、Linux、Mac OS X、Solaris)若设置，则使启 动-停止输出控制起作用。当终端驱动程序接收到一个STOP字符时，输出停止。 在输出停止时，下一个START字符恢复输出。若未设置此标志，则START和 STOP字符由进程作为一般字符谪取。</td>
</tr>

<tr>
<td>MDMBUF</td>
<td>(c_cflag，FreeBSD、Mac OS X)按照调制解调器的载波标志进行输出流控制。 这是CCAR_OFLOW标志的曾用名。</td>
</tr>

<tr>
<td>NLDLY</td>
<td>(c_oflag，XSK Linux、Solaris)换行延迟屏蔽字。此屏蔽字的值是NL0或NL1。</td>
</tr>

<tr>
<td>NOFLSH</td>
<td>(c_lflag, POSIX.1、FreeBSD、Linux、Mac OS X、Solaris)按系统默认，当 终端驱动程序产生SIGINT和SIGQUIT信号时，输入和输出队列都被冲洗。 另外，当它产生SIGSUSP信号时，输入队列被冲洗。若已设置NOFLSH标志，则在这些信号产生时，不对输入、输出队列进行常规冲侁。</td>
</tr>

<tr>
<td>NOKERNXNFO</td>
<td>(c_lflag, FreeBSD、Mac OS X)在已设置时，此标志阻止STATUS字符打印 前台进程组的信息。但是无论是否设置此标志，STATUS字符都会使SIGINFO 信号被发送至前台进程组。</td>
</tr>

<tr>
<td>OCRNL</td>
<td>(c_oflag，XSI、FreeBSD, Linux、Solaris)若设置，则将输出的 CR 字符转 换成NL字符。</td>
</tr>
</tbody>
</table>

<p>OFDEL</p>

<p>OFILL</p>

<p>OLCUC</p>

<p>NLCR</p>

<p>ONLRET</p>

<p>ONOCR</p>

<p>ONOEOT</p>

<p>OPOST</p>

<p>OXTABS</p>

<p>PARENB</p>

<p>PAREXT</p>

<p>PARMRK</p>

<p>PARODD</p>

<p>PENDIN</p>

<p>TABDLY</p>

<p>(c_oflag，XSI、Linux. Solaris)若设置，则输出填充字符是ASCII DEL:否 则是ASCUNUL。见OFILL标志。</p>

<p>(c_oflag, XSI、Linux、Solaris)若设置，则传递填充字符(ASCII DEL 或 ASCn NUL,见OFDEL标志)以实现延迟，而不使用时间延迟。见6个延迟屏 蔽字标志：BSDLY、CRDLY、FFDLY、NLDLY、TABDLY 和 VTDLY。</p>

<p>(c_oflag, Linux、Solaris)若设置，则将小写字符转换成大写字符。    [689)</p>

<p>(c_oflag，XSI、FreeBSD、Linux、Mac OS X、Solaris)若设置，将输出的 NL字符转换成CR-NL字符。</p>

<p>(c_oflag，XSI、FreeBSD、Linux、Solaris)若设置，则假定输出的 NL 字符 执行回车功能。</p>

<p>(c^oflag, XSI、FreeBSD、Linux、Solaris)若设置，则在 0 列不输出 CR字符。 (c_oflag, FreeBSD、Mac OS X)若设置，则在输出中丢弃EOT (AD)字符。</p>

<p>在某些将Ctrl+D解释为挂断的终端上，设置此标志可能是必需的。</p>

<p>(c_oflag，POSIX.1、FreeBSD、Linux, Mac OS X、Solaris)若设置，则进行 实现定义的输出处理。关于c_of lag字段的各种实现定义标志，见图18-6。 (c_oflag, FreeBSD, Mac OS X)若设置，则制表符在输出中被扩展为空格。</p>

<p>这与将水平制表符延迟(TABDLY)设置为XTABS或TAB3所产生的效果相同。 (c^cflag, POSIX.1、FreeBSD、Linux、Mac OS X、Solaris)若设置，则对输出 字符产生奇偶位，对输入字符执行奇偶校验。若已设置PARODD，则奇偶校验是 奇校验；否则是偶校验。另见对INPCK、IGNPAR和PARMRK标志的讨论。</p>

<p>(c_cflag，Solaris)选择标记或空奇偶性。若PARODD设置，则奇偶位总是1 (标记奇偶性)：否则，奇偶位总是0 (空奇偶性)。</p>

<p>(c_iflag，POSIX.l、FreeBSD、Linux、Mac OS X、Solaris)在已设置时，</p>

<p>若未设置IGNPAR，则带有结构出错(非BREAK)的字节或带有奇偶出错的 字节将被进程读作一个3字符序列\377、\0和X其中X是接收到的出错字 节。若未设置ISTRIP，则一个有效的\377被传送给进程时为\377, \377。</p>

<p>若未设置IGNPAR和PARMRK，则带有结构出错误或奇偶出错的字节都被读作 一个字符\0。</p>

<p>(c_cflag, POSK.1、FreeBSD、Linux、Mac OS X. Solaris)若设置，则输出 和输入字符的奇偶性都是奇，否则为偶。注意，PARENB标志控制奇偶性的产 生和检测。</p>

<p>在已设置CMSPAR或PAREXT标志时，PARODD标志也控制是否使用标记或空 奇偶性。</p>

<p>(c_lflag, FreeBSD、Linux、Mac OS X、Solaris)若设置，则在下一个字符 输入时，尚未读的任何输入都由系统重新打印。这一动作与键入REPRINT字符 时的作用相类似。    ®</p>

<p>(c_oflag，XSL Linux&gt; Mac OS X、Solaris)水平制表符延迟屏蔽字。此屏厳 字的值是 TABO、TAB1、TAB2 或 TAB3。</p>

<p>XTABS的值等于TAB3。此值使系统将制表符扩展成空格。系统假定制表符的 长度为8个空格，不能更改此假定。</p>

<p>TOSTOP    (c_lflag, POSIX.K FreeBSD、Linux、Mac OS X, Solaris)若设置，并且该</p>

<p>实现支持作业控制，则将信号SIGTTOU送到试图写控制终端的一个后台进程的 进程组。按默认，此信号暂停该进程组中所有进程。如果写控制终端的后台进 程忽略或阻塞此信号，则终端驱动程序不产生此信号。</p>

<p>VTDLY    (c_oflag, XSI、Linux, Solaris)垂直制表延迟屏蔽字此屏蔽字的值是VT0</p>

<p>和 VT1。</p>

<p>XCASE    (c_lflag，Linux、Solaris)若设置，并且也设置工CANON,则终端被假定为只</p>

<p>支持大写字符，全部输入转换为小写字符。要想输入一个大写字符，要在其前 面加一个反斜杠。与之类似，系统输出大写字符时，也要在其前面加一个反斜 杠。(如今这个选项标志已奔用，因为只支持大写字符的终端即使不是全部，也 是绝大部分都已经不存在了</p>

<h5 id="18-6-stty-命令">18.6 stty 命令</h5>

<p>上节说明的所有选项都可以被检査和更改：在程序中用tcgetattr和tcsetattr函数 (见18.4节)进行检査和更改：在命令行(或shell脚本〉中用stty(l&gt;命令进行检査和更改。简 单地说，stty⑴命令就是图18-7中所列的前6个函数的接口。如果以-a选项执行此命令，则显 示终端的所有选项：</p>

<p>$ stty</p>

<p>speed 9600 baud; 25 rows; 80 columns;</p>

<p>Iflags: icanon isig iexten echo echoe -echok echoke -echonl echoctl</p>

<p>-echoprt -altwerase -noflsh -tostop -flusho pendin -nokerninfo -extproc</p>

<p>iflags: -istrip icrnl -inlcr -igncr ixon -ixoff ixany imaxbel -ignbrk brkint -inpck -ignpar -parmrk</p>

<p>oflags: opost onlcr -ocrnl -oxtabs -onocr -onlret</p>

<p>cflags: cread cs8 -parenb -parodd hupcl -clocal -cstopb -crtscts</p>

<p>-dscflow -dtrflow -mdmbuf</p>

<p>cchars: discard = A0; dsusp = eof = AD; eol = <undef>;</p>

<p>eol2 = <undef>; erase = AH; erase2 = A?; intr = AC; kill = AU; lnext = AV; min = 1; quit = A; reprint = AR; start = AQ; status = AT； stop = AS; susp = AZ; time = 0; werase = ^W;</p>

<p>若在选项名前有一个连字符，表示该选项禁用。最后4行显示各终端特殊字符(见18.3节) 的当前设置。第1行显示当前终端窗口的行数和列数，18.12节将对终端窗口大小进行讨论。</p>

<p>; stty命令使用它的标准输入获得和设置终搞的选项标志。虽然，某些较早的实现使用标准输 1出，但POSIX.1要求使用标准输入=本书讨论的4种实现提供了在标准输入上操作的stty版本。</p>

<p>这意味着如果希望了解名为ttyla的终端的设置，那么可以键入 ;■ stty -a &lt;/dev/ttyla</p>

<p>18.7波特率函数</p>

<p>术语波特率(baudrate)是一个历史沿用的术语，现在它指的是“位/秒” (bit per second).虽然大</p>

<p>多数终端设备对输入和输出使用同一波特率，但是只要硬件许可，可以将它们设置为两个不同值。 ^include <termios.h></p>

<p>speed_t cfgetispeed(const struct termios *termptr); speed_t cfgetospeed (const struct termios *termptr}；</p>

<p>两个函数的返回值：波特率值</p>

<p>int cfsetispeed (struct termios *termptr, speed_t speed}; int cfsetospeed (struct termios *termptr, speed_t speed)；</p>

<p>两个函数的返回值：若成功，返回0:出错，返回-1</p>

<p>两个cfget函数的返回值，以及两个cf set函数的平6«/参数都是下列常量之一，B50、 B75、 B110、 B134、 B150、 B200、 B300、 B600、 B1200、 B1800、 B2400、 B4800、 B9600、 B19200或B38400。常量B0表示“挂断&rsquo; 在调用tcsetattr时，如若将输出波特率指定为 B0,则调制解调器的控制线就不再起作用。</p>

<p>大多数系统定义了另外的波特率值，如B57600以及B115250。</p>

<p>使用这些函数时，必须认识到输入、输出波特率是存储在设备的termios结构中的，如图184 所示。在调用两个cfget函数中的任意一个之前，要先用tcgetattr获得设备的termios结 构。与此类似，在调用两个cfset函数中的任意一个之后，要做的就是在termios结构中设置 波特率。为使这种更改影响到设备，应当调用tcsetattr函数。即使所设置的两个波特率中的 任意•-个出错，在调用tcsetattr之前可能也不会发现这个错误。</p>

<p>这4个波特率函数的存在使应用程序不必考虑具体实现在termios结构中表示波特率的不同 方法。Linux和BSD派生的平台趋向于存储波特率的数值。（即9 600波特率存储成值9 600）,然 而，System V派生的平台（如Solaris）趋向于以位屏蔽方式编码波特率。从cfget函数得至！I的速 度值以及向cfset函数传送的速度值都未转换，与它们存储在termios结构中的表示琅式一样。</p>

<p>18.8行控制函数</p>

<p>下列4个函数提供了终端设备的行控制能力。4个函数都要求参数/rf引用一个终端设备，否 则出错返回-1，errno设置为ENOTTY。</p>

<p>^include <termios.h></p>

<p>int tcdrain （int fd};</p>

<p>int tcflow{int fd, int action）;</p>

<p>int tcflush （int fd, int queue）;</p>

<p>int tcsendbreak {int fd, int duration）；</p>

<p>4个函数的返回值：若成功，返回0:若出错.返回-1 tcdrain函数等待所有输出都被传递。tcflow函数用于对输入和输出流控制进行控制。 action参数必定是下列4个值之一。</p>

<p>TCOOFF    输出被挂起。</p>

<p>TCOON    重新启动以前被挂起的输出。</p>

<p>TCIOFF    系统发送一个STOP字符，这将使终端设备停止发送数据。</p>

<p>TCION    系统发送一个START字符，这将使终端设备恢复发送数据。</p>

<p>tcflush函数冲洗（抛弃）输入缓冲区（其中的数据是终端驱动程序已接收到，但用户程序</p>

<p>尚未读取的）或输出缓冲区（其中的数据是用户程序己经写入，但尚未被传递的）。炉/ewe参数必 定是下列3个常量之一。</p>

<p>TCIFLUSH    冲洗输入队列。</p>

<p>TCOFLUSH    冲洗输出队列。</p>

<p>[6931 TCIOFLUSH    冲洗输入队列和输出队列。</p>

<p>tcsendbreak函数在一个指定的时间匡间内发送连续的0值位流。若duration参数为0,</p>

<p>则此种传递延续0.25〜0.5秒。POSIX.1说明若rfwrorfon非0，则传递时间依赖于实现。</p>

<h6 id="18-9终端标识">18.9终端标识</h6>

<p>历史上，在大多数UNIX系统版本中，控制终端的名字一直是/dev/tty。POSIX.1提供了 一个运行时函数，可用来确定控制终端的名字。</p>

<p>tinclude <stdio.h> char *ctermid（char *ptr）；</p>

<p>返回值：若成功，返回指向控制终竭名的指针；若出错，返回指向空字符串的指针</p>

<p>如果婢非空，则被认为是一个指针，指向长度至少为L.ctermid字节的数组，进程的控 制终端名存储在该数组中。常量L_ctermid被定义在<31;也0.11>中。若p/r是一个空指针，则 该函数为数组（通常作为静态变量）分配空间。同样，进程的控制终端名存储在该数组中。</p>

<p>在这两种情况中，该数组的起始地址都被作为函数值返回，因为大多数UNIX系统都使用 /dev/tty作为控制终端名，所以此函数的主要作用是改善向其他操作系统的可移植性。</p>

<p>『 当调用ctermid函數时，本书说明的所有4种平台都送回字符串/dev/tty。</p>

<p>醐实例：cfcermid函数</p>

<p>图18-12给出的是POSIX.1 ctermid函数的一个实现。</p>

<p>#include    <stdio.h></p>

<p>linclude    <string.h></p>

<p>static char ctermid_name[L_ctermid];</p>

<p>char *</p>

<p>ctermid{char *str)</p>

<p>{</p>

<p>if (str == NULL)</p>

<p>str = ctermid_name;</p>

<p>return(strcpy{str, &ldquo;/dev/tty&rdquo;));    /* atrcpy() returns str */</p>

<p>务</p>

<p>个终端设备，则isatty返回真，ttyname返回的是在该文件描述符上打开的终端设备的路径名。</p>

<table>
<thead>
<tr>
<th>♦include <unistd.h></th>
<th></th>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td>int isatty (int fd};</td>
<td>返回值：若为终端设备，返回1 (真</td>
<td>否则，返回0 (假)</td>
</tr>

<tr>
<td>char *ttyname (int fd};</td>
<td>返回值：指向终端路径名的指针:</td>
<td>若出错，返回NULL</td>
</tr>
</tbody>
</table>

<p>醒实例：isatty函数</p>

<p>如图18-13所示，isatty函数很容易实现。我们只尝试使用了其中一个终端专用函数(如 果成功执行，它不改变任何东西)，并査看了其返回值-#include    <termios.h></p>

<p>int</p>

<p>isatty{int fd)</p>

<p>(</p>

<p>struct termios ts;</p>

<p>return(tcgetattr(fd, &amp;ts) != -1); /* true if no error (is a tty) */ j</p>

<p>图18-13 POSIX.1 isatty函数的实现 使用图18-14中的程序测试isatty函数。</p>

<p>#include &ldquo;apue.h&rdquo;</p>

<p>int</p>

<p>main(voidj</p>

<table>
<thead>
<tr>
<th>printf(</th>
<th>&lsquo;fd</th>
<th>0:</th>
<th>%s\n&rdquo;</th>
<th>isatty(0)</th>
<th></th>
<th>&ldquo;tty&rdquo;</th>
<th>&ldquo;not</th>
<th>a tty&rdquo;);</th>
</tr>
</thead>

<tbody>
<tr>
<td>printf(</td>
<td>fd</td>
<td>1:</td>
<td>%s\n&rdquo;</td>
<td>isatty(1)</td>
<td></td>
<td>&ldquo;tty&rdquo;</td>
<td>&ldquo;not</td>
<td>a tty&rdquo;);</td>
</tr>

<tr>
<td>printf(</td>
<td>•fd</td>
<td>2:</td>
<td>%s\n&rdquo;</td>
<td>isatty(2)</td>
<td></td>
<td>&ldquo;tty&rdquo;</td>
<td>&ldquo;not</td>
<td>a tty&rsquo;，};</td>
</tr>

<tr>
<td>exit(0)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

<p>图 18-14 测试 isatty 函数    |695|</p>

<p>运行图18-14中的程序，得到如下输出：</p>

<p>5 ./a.out</p>

<p>fd 0: tty fd 1: tty fd 2: tty</p>

<p>S ./a.out </atc/passwd 2>/dav/null</p>

<p>fd 0: not a tty fd 1： tty</p>

<p>fd 2: not a tty    ■</p>

<p>M实例：ttynaae垂数</p>

<p>ttyname函数(见图18-15)比较长，因为它要搜索所有设备表项，寻找匹配项。</p>

<p>♦include #include #include ♦include ^include #include tinclude</p>

<p><sys/stat.h></p>

<p><dirent.h></p>

<p>〈limits.h&gt;</p>

<p><string.h></p>

<p><termios.h></p>

<p><unistd.h></p>

<p><stdlib.h></p>

<p>struct devdir {</p>

<p>struct devdir char</p>

<p>*d__next;</p>

<p>*d_name;</p>

<p>static struct devdir static struct devdir static char</p>

<p>★head;</p>

<p>•tail;</p>

<p>pathname [_POSIX_PATH_MAX + 1];</p>

<p>static void</p>

<p>add(char * di rname)</p>

<p>{</p>

<p>struct devdir    *ddp;</p>

<p>int    len;</p>

<p>len = strlen(dirname);</p>

<p>/*</p>

<p>* Skip ., &ldquo;, and /dev/fd.</p>

<p>*/</p>

<p>if ((dirname [len-1] == *.&lsquo;) &amp;&amp; (dirname【len-2] == *&rdquo; I I (dirname[len-2] == <em>.</em> &amp;&amp; dirname[len-3] = &lsquo;/&rsquo;)))</p>

<p>return;</p>

<p>if (strcmp(dirname, &ldquo;/dev/fd&rdquo;) == 0) return;</p>

<p>if ({ddp = malloc{sizeof{struct devdir))I == NULL) return;</p>

<p>if ((ddp-&gt;d_name = strdup(dirname)) == NULL) { free(ddp); return;</p>

<p>ddp-&gt;d_next = NULL; if (tail 坊 NULL) { head = ddp; tail = ddp;</p>

<p>} else {</p>

<p>tail-&gt;d_next = ddp; tail = ddp;</p>

<p>)</p>

<p>}</p>

<p>static void</p>

<p>cleanup(void)</p>

<p>{</p>

<p>struct devdir</p>

<p>★ddp, *nddp;</p>

<p>ddp = head;</p>

<p>while (ddp != NULL) 1 nddp = ddp-&gt;d_next; free{ddp-&gt;d_name); free(ddp);</p>

<p>ddp = nddp;</p>

<p>}</p>

<p>head = NULL;</p>

<p>tail = NULL;</p>

<p>static char *</p>

<p>searchdir (char *d.irname, struct stat *fdstatp)</p>

<p>struct stat</p>

<p>devstat;</p>

<p>*dp;</p>

<p>devlen;</p>

<p>*dirp;</p>

<p>DIR</p>

<p>int</p>

<p>struct dirent strcpy{pathname, dirname)；</p>

<p>if ((dp = opendir(dirname)) == NULL) return(NULL);</p>

<p>strcat {pathname, ••/&ldquo;};</p>

<p>devlen = strlen(pathname);</p>

<p>while {(dirp = readdir(dp)) != NULL) {</p>

<p>strncpy(pathname + devlen, dirp-&gt;d_name,</p>

<p>_POSIX_PATH_MAX - devlen);</p>

<p>* Skip aliases.</p>

<p>*/</p>

<p>if (strcmp(pathname, &ldquo;/dev/stdin&rdquo;) == 0 I I strcmp(pathname, &ldquo;/dev/stdout&rdquo;) == 0 I I strcmp(pathname, &ldquo;Zdev/stderr&rdquo;) == 0)</p>

<p>continue;</p>

<p>if (stat(pathname, &amp;devstat) &lt; 0J continue;</p>

<p>if (S_ISDIR(devstat.st_mode,) { add(pathname); continue;</p>

<p>}</p>

<p>if (devstat.st_ino = fdstatp-&gt;st_ino &amp;&amp; devstat.st_dev == fdstatp-&gt;st_dev) (    /* found a match */</p>

<p>closedir(dp); return{pathname);</p>

<p>)</p>

<p>}</p>

<p>closedir(dp); return{NULL);</p>

<p>char *</p>

<p>ttyname{int fd)</p>

<p>struct stat    fdstat?</p>

<p>struct devdir    *ddp;</p>

<p>char    *rval;</p>

<p>if (isatty(fd) == 0) return(NULL);</p>

<p>if (fstat(fd, &amp;fdstat) &lt; 0) return(NULL);</p>

<p>if (S_ISCHR(fdstat.st_mode) == 0) return(NULL);</p>

<p>rval = searchdir(&ldquo;/dev&rdquo;, Sfdstat); if (rval == NULL) {</p>

<p>for (ddp = head； ddp != NULL; ddp = ddp-&gt;d_next)</p>

<p>if ((rval = searchdir(ddp-&gt;d_name, &amp;fdstat))    != NULL)</p>

<p>break;</p>

<p>}</p>

<p>cleanup (); return(rval);</p>

<p>}</p>

<p>图 18-15 POSIX.l ttyname 函数的实现</p>

<p>此处使用的技术是读/dev目录，寻找具有相同设备号和i节点编号的表项。回忆4.24节， 每个文件系统都有一个唯一的设备号（stat结构中的st_dev字段，见4.2节），文件系统 中的每个目录项都有一个唯一的i节点编号（stat结构中的st_ino字段）。在此函数中，</p>

<p>[698]假定在找到一个匹配的设备号和匹配的i节点号时，就能找到所希望的目录项。也能验证这两 个表项与st_rdev字段（终端设备的主设备号和次设备号）相匹配，还能验证该目录项是一 个字符特殊文件。但是，因为已经验证了文件描述符参数既是一个终端设备，又是一个字符 特殊文件，而且因为在UNIX系统中，匹配的设备号和i节点编号是唯一的，所以不再需要进 行另外的比较。</p>

<p>终端名可能在/dev的子目录中。于是，需要搜索/dev下的整个文件系统树。我们跳过了少 数几个可能会产生不正确结果或奇怪结果的目录：/dev/.、/dev/..和/dev/fd。我们也跳过 了一些另ij名：/dev/stdin、/dev/stdout 以及/dev/stderr，因为它们是/dev/fd 目录中 文件的符号链接。</p>

<p>使用图18-16中的程序测试这一实现。</p>

<p>^include &ldquo;apue.h&rdquo;</p>

<p>int</p>

<p>main(void)</p>

<p>char *name; if (isatty(O)) {</p>

<p>name = ttyname(0); if (name == NULL)</p>

<p>name = &ldquo;undefined&rdquo;;</p>

<p>J else {</p>

<p>name</p>

<p>&ldquo;not a tty&rdquo;;</p>

<p>printf (&ldquo;fd 0: %s\n&rdquo;, name&rdquo;</p>

<p>if (isatty⑴){</p>

<p>name = ttyname(1); if (name == NULL)</p>

<p>name = &ldquo;undefined&rdquo;;</p>

<p>} else {</p>

<p>name = &ldquo;not a tty&rdquo;;</p>

<p>I</p>

<p>printf{&ldquo;fd 1: %s\n&rdquo;, name);</p>

<p>if (isatty(2)) {</p>

<p>name = ttyname(2); if (name == NULL)</p>

<p>name - &ldquo;undefined&rdquo;;</p>

<p>)else (</p>

<p>name = &ldquo;not a tty&rdquo;；</p>

<p>}</p>

<p>printf(&ldquo;fd 2： %s\n&rdquo;, name);</p>

<p>exit(0,;</p>

<p>图 18-16 测试 ttyname 函数    j699|</p>

<p>运行图18-16中的程序，得到：</p>

<p>$ ./a.out &lt; /dev/console 2&gt; /dov/null</p>

<p>fd 0: /dev/console fd 1: /dev/ttys001</p>

<p>fd 2: not a tty    ■</p>

<h6 id="18-10规箔模式">18.10规箔模式</h6>

<p>规范模式很简单：发一个读请求，当一行已经输入后，终端驱动程序即返回。以下几个条件 造成读返回。</p>

<p>•所请求的字节数已读到时，读返回，无需读一个完整的行。如果读了部分行，那么也不 会丢失任何信息，下一次读从前一次读的停止处开始。</p>

<p>•当读到一个行定界符时，读返回=回忆18.3节，在规范模式中，下列字符被解释为“行 结束”：NL、EOL、EOL2和EOF。另外，在18.5节中也曾说明，如若已设置ICRNL，</p>

<p>但未设置IGNCR,则CR字符的作用与NL字符一样，也终止一行。</p>

<p>在这5个行界定符中，只有一个EOF符在终端驱动程序对其进行处理后即被丢弃。其他 4个字符则作为其所处行的最后一个字符返回给调用者。</p>

<p>•如果捕捉到信号，并且该函数不再自动重启(见10.5节)，则读也返回。</p>

<p>I实例：getpass函数</p>

<p>下面说明getpass函数，它读入用户在终端上键入的口令。此函数由login(l)和crypt(l) 程序调用。为了读取口令，该函数必须关闭回显，但仍可使终端以规范模式进行工作，因为不管 键入什么作为口令都能构成一个完整行。图18-17显示了 UNIX系统中的一个典型实现。</p>

<p>#include #include #include</p>

<p><signal.h></p>

<p><stdio.h></p>

<p><terraios.h></p>

<p>ttdefine</p>

<p>MAX_PASS_LEN    8</p>

<p>/* max #chars for user to enter */</p>

<p>char *</p>

<p>getpass(const char {</p>

<p>static char</p>

<p>char</p>

<p>sigset_t</p>

<p>struct termios ts, ots; FILE    *fp;</p>

<p>int    c;</p>

<p>★prompt)</p>

<p>buf[MAX_PASS_LEN + 1J; *ptr;</p>

<p>sig, osig;</p>

<p>/* null byte at end */</p>

<p>if ({fp = fopen{ctermid(NULL), &ldquo;r+&rdquo;)) == NULL) return(NULL);</p>

<p>setbuf(fp, NULL);</p>

<p>sigemptyset(&amp;sig);</p>

<p>sigaddset(ssig, SIGINT); sigaddset &lt;&amp;sig, SIGTSTP); sigprocmask(SIG_BLOCK/ &amp;sig,</p>

<p>tcgetattr(fileno(fp), &amp;ts);</p>

<p>/* block SIGINT */</p>

<p>/* block SIGTSTP */</p>

<p>&amp;osig);    /* and save mask */</p>

<p>/* save tty state */</p>

<p>ots = ts;    /* structure copy */</p>

<p>ts.c_lflag &amp;= -(ECHO | ECHOE | ECHOK | ECHONL); tcsetattr(fileno(fp), TCSAFLUSH, &amp;ts);</p>

<p>fputs(prompt, fp);</p>

<p>ptr = buf;</p>

<p>while ( (c = getc (fp)) ! = EOF &amp;.&amp; c != &lsquo; \n&rsquo;) if (ptr &lt; &amp;buf [MAX_PASS_LEN])</p>

<p>*ptr++ = c;</p>

<p><em>ptr = 0;    /</em> null terminate */</p>

<p>putc(&rsquo;\n&rsquo;, fp);    /* we echo a newline */</p>

<p>tcsetattr(fileno(fp), TCSAFLUSH, &amp;ots); /* restore TTY state <em>/ sigprocmask(SIG_SETMASK, &amp;osig, NULL)；    /</em> restore mask */</p>

<p>fclose (fp)，-    Z* done with /dev/tty */</p>

<p>return(buf)；</p>

<p>图18-17 getpass函数的实现</p>

<p>在此例中，应当考虑以下几个方面。</p>

<p>•调用ctennid函数打开控制终端，而不是直接将/dev/tty写在程序中。</p>

<p>•只是读、写控制终端，如果不能以读、写模式打开此设备则出错返回。还有一些其他的 使用约定。在GNUC函数库版本中，如果不能以读、写模式打开控制终端，则getpass 读取标准输入，写到标准错误。在Solaris版本中，如果不能打开授制终端，则getpass 失败。</p>

<p>•阻塞两个信号SIGINT和SIGTSTP。如果不这样做，在输入INTR字符时就会使程序异</p>

<p>常中止，并使终端仍处于禁止回显状态。与此相类似，输入SUSP字符时将使程序停止，</p>

<p>并且在禁止回显状态下返回到shell。在禁止回显时，我们选择了阻塞这两个信号。如果 这两个信号是在读取口令期间产生的，则它们会一直被保持，直到getpass返回，阻塞 才会解除。也有其他方法来处理这些信号。有些getpass版本忽略SIGINT （保存它以I 前的动作），在返回前将其动作恢复为以前的值。这就意味着，在该信号被忽略期间所发 生的这种信号都会丢失。其他版本捕捉SIGINT （保存它以前的动作），如果捕捉到此信 号，则在恢复终端状态和信号动作后，用kill函数发送此信号。没有一个getpass版 本捕捉、忽略或阻塞SIGQUIT，所以输入QUIT字符就会使程序异常中止，并且很可能 使终端保持在禁止回显状态。</p>

<p>•请注意，某些shell,尤其是Korn shell,在以交互方式读输入时都使终端处于回显状态。 这些shell是提供命令行编耩的shell，因此在每次输入一条交互命令时都处理终端状态。</p>

<p>所以如果在这种shell下调用此程序，并且用QUIT字符使其异常中止，则这种shell可 能会恢复回显状态。其他不提供命令行编舞的shell （如Bourne shell）将使程序异常中 止，并使终端保持在不回显状态。如果对终端做了这种操作，则stty命令能使终端恢 复到回显状态。</p>

<p>•使用标准I/O读、写控制终端。我们特地将流设置为不带缓冲的，否则在流的读、写之间 可能会有某些交叉（这样就需要多次调用fflush）,也可使用不带缓冲的I/O （见第3 章），但是在这种情况下就只能用read来模仿getc函数。</p>

<p>•最多只存储8个字符作为口令。输入的其他多余字符则全部被忽略。</p>

<p>图18-18中的程序调用getpass并且打印我们输入的内容。这是为了验证ERASE和KILL</p>

<p>字符能否正常工作（如同它们在规范模式下应该表现的那样）。</p>

<p>持 include &ldquo;apue.h&rdquo; char *getpass(const char *);</p>

<p>int</p>

<p>main(void)</p>

<p>char *ptr；</p>

<p>if ((ptr = getpasa(&ldquo;Enter password:&ldquo;)) == NULL) err_sys(&ldquo;getpass error&rdquo;);</p>

<p>printf(&ldquo;password: %s\n&rdquo;, ptr);</p>

<p>/* now use password (probably encrypt it) &hellip; */</p>

<p>while (*ptr != 0)</p>

<p><em>ptr++ = 0;    /</em> zero it out when we * re done with it */</p>

<p>exit(0);</p>

<p>们就可能会读到这个明文口令。（“明文”是指我们在getpass打印的提示符处键入的口令。大 多数UNIX系统程序会对这个明文口令进行修改，将它转换成一个“加密” 口令。例如，口令文 件（见6.2节）中的pw^passwd字段包含的是加密口令，而不是明文口令。）    B®</p>

<h6 id="18-11非规范模式">18.11非规范模式</h6>

<p>可以通过兔闭termios结构中c_lflag字段的I CANON标志来指定非规范模式。在非规范 模式中，输入数据不装配成行，不处理下列特殊字符（见18.3节）：ERASE、KILL、EOF、NL、 EOL、EOL2、CR、REPRINT, STATUS 和 WERASE。</p>

<p>如前所述，规范模式很容易理解：系统每次至多返回一行。但在非规范模式下，系统如何 知道在什么时候将数据返回给我们呢？如果它一次返回一个字节，那么系统开销就会过大。（回 忆图3-6,从中可以看到每次读一个字节的开销有多大。如果每次返回的数据加倍，那么系统调 用的开销就可以减半■&gt;）在启动读数据之前，往往不知道要读多少数据，所以系统不能总是一次 返回多个字节。</p>

<p>解决方法是，当己读了指定量的数据后，或者已经超过了给定量的时间后，即通知系统返回， 这种技末使用了 termios结构中c_cc数组的两个变量：MIN和TIME。c_cc数组中的这两个 元素的下标名为VMIN和VTIME。</p>

<p>MIN指定一个read返回前的最小字节数。TIME指定等待数据到达的分秒数（分秒为秒的 1/10）。有下列4种情形。</p>

<p>情形 A: MINX）, TIME&gt;0</p>

<p>TIME指定一个字节间定时器（interbytetimer）,它只在第一个字节被接收时启动。</p>

<p>在该定时器超时之前，若已接到MIN个字节，则read返回MIN个字节，如果在 接到MIN个字节之前，该定时器己超时，则read返回已接收到的字节。（因为定 时器是在第一个字节被接收后启动的，所以在定时器超时时，read至少会返回一 个字节。）在这种情形中，第一个字节被接收之前，调用者会一直阻塞。如果在调 用read时数据已经可用，则就如同在read后数据被立即接收了一样。</p>

<p>情形 B: MINX）, TIME=0</p>

<p>[7031    read在接收到MIN个字节之前不返回。这会造成read无限期阻塞。</p>

<p>情形 C: MIN=0，TIMEX）</p>

<p>TIME指定一个调用read时启动的读定时器。（与情形A相比较，两者是不同的。 在情形A中，非0 TIME表示字节间定时器，该定时器要等到第一个字节被接收时 才启动在接到一个字节或者该定时器超时时，read即返回。如果是定时器超时，</p>

<p>则read返回0。</p>

<p>情形 D: MIN=0, TIME=0</p>

<p>如果有数据可用，则read最多返回所要求的字节数。如果无数据可用，则read 立即返回0。</p>

<p>在所有这巷情形中，MIN只是最小值。如果程序要求的数据多于MIN个字节，那么它或许 能接收到所要求的字节数。这也适用于MIN=0的情形C和情形D。</p>

<p>图18-19总结并列出了非规范模式输入的4种不同情形。在这个图中，是read的第 三个参数（返回的最大字节数）。</p>

<p>MIN&gt;0</p>

<p>MIN = O</p>

<table>
<thead>
<tr>
<th>TIMEX)</th>
<th>A：在定时器超时前，read 返回［MIN, nbytes］-,如果定时器超时，read 返回［1，MIN］。（TIME=^节间定时器。调用者会无限期阻塞。）</th>
<th>C：在定时器超时前，read 返回［1, nbytes}-,如果定时器超时， read返回0。（TIME=read 定时器。）</th>
</tr>
</thead>

<tbody>
<tr>
<td>TIME = 0</td>
<td>B：当有可用数据时，read 返回［MIN, nbytes}.（调用者可无限期阻塞，）</td>
<td>D： read 立即返回［0,</td>
</tr>
</tbody>
</table>

<p>图18-19非规范输入的4种情形</p>

<p>请注意，P0S1X.1允许下标VMIN和VTIME的值分别与VEOF和VEOL的相同。砩实，Solaris就 是这样做的，这样就援供了与SystonV的早期版本的兼容性。但是，这也带来了可移植性问题。从非 規范模式转换为規范模式时，必须恢复VEOF和VEOL。如果VMIN等于VEOF，且不恢复它们的值， 那么当把VMIN的典型值设置为1时，文件结束符就变成了 Ctrl+A。解决这一问题最簡单的方法是： 在要转入非规范模式时，将整个termios结构保存起来，以后再要转回规范模式时恢复它。</p>

<p>鼹■实例</p>

<p>图18-20中的程序定义了函数tty_cbreak和tty_raw，它们将终端好别设置为cbreak模 式（cbreak mode）和原始模式（raw mode）。（术语cbreak卸康始来自于V7的终端驱动程序》） tty_reset函数的功能是将终端恢复到原始的工作状态（也就是调用tty_cbreak或tty_raw 之前的工作状态）6</p>

<p>如果已调用tty_cbreak，那么在调用tty_raw之前需要调用tty_reset。如果已调用 tty_raw,然后又要调用tty_cbreak，那么在此之前同样也要调用tty_reset。这减少了出 错时终端处于不可用状态的机会。    网</p>

<p>读程序述提供了另外两个函数：tty_atexit和tty_termioso tty_atexit可被登记为 退出处理程序，以保证exit恢复终端工作模式。tty_termios则返回一个指向原来规范模式 下termios结构的指针。</p>

<p>finclude &ldquo;apue.h&rdquo;</p>

<p>#include <termios.h></p>

<p>♦include <errno.h></p>

<p>static struct termios    save_terraios;</p>

<p>static int    ttysavefd = -1;</p>

<p>static enum ( RESET, RAW, CBREAK } ttystate = RESET;</p>

<p>int</p>

<p>tty_cbreak(int fd) /* put terminal into a cbreak mode */</p>

<p>int    err;</p>

<p>struct termios buf;</p>

<p>if (ttystate != RESET) { errno = EINVAL; return (-1);</p>

<p>}</p>

<p>if (tcgetattr(fd, &amp;buf) &lt; 0) return(-1);</p>

<p>save_termios = buf; /* structure copy */</p>

<p>/*</p>

<p>*    Echo off, canonical mode off.</p>

<p>*/</p>

<p>buf.c_lflag &amp;= -(ECHO I ICANON);</p>

<p>/*</p>

<p>*    Case B: 1 byte at a time, no timer.</p>

<p>*/</p>

<p>buf.c_cc[VMIN] = 1；</p>

<p>buf.c_cc[VTXME] = Of</p>

<p>if (tcsetattr(fd, TCSAFLUSH, &amp;buf) &lt; 0) return(-1);</p>

<p>*    Verify that the changes stuck, tcsetattr can return 0 on</p>

<p>*    partial success.</p>

<p>*/</p>

<p>if (tcgetattr{fd, &amp;buf) &lt; 0) { err = errno;</p>

<p>tcsetattr(fd, TCSAFLUSH, &amp;save_termios); errno = err; return(-1J;</p>

<p>}</p>

<p>if &lt;(buf.c_lflag &amp; (ECHO | ICANON)) || buf.c_cc[VMIN] != 1 I I buf.c_cc[VTIME] != 0) {</p>

<p>/*</p>

<p>*    Only some of the changes were made. Restore the</p>

<p>*    original settings.</p>

<p>*/</p>

<p>tcsetattr(fd, TCSAFLUSH, &amp;save_termios); errno - EINVAL; return (-1);</p>

<p>}</p>

<p>ttystate = CBREAK;</p>

<p>ttysavefd = fd;</p>

<p>return(0);</p>

<p>int</p>

<p>tty_raw(int fd)    /* put terminal into a raw mode */</p>

<p>t</p>

<p>int    err;</p>

<p>struct termios buf;</p>

<p>if (ttystate != RESET) { errno = EINVAL; return(-1,;</p>

<p>)</p>

<p>if (tcgetattr(fd, &amp;buf) &lt; 0)</p>

<p>return(-1);</p>

<p>save_termios = buf;    /* structure copy */</p>

<p>/*</p>

<p>*    Echo off, canonical mode off, extended input</p>

<p>*    processing off, signal chars off.</p>

<p>*/</p>

<p>buf.c_lflag S= ~(ECHO I ICANON I IEXTEN I ISIG);</p>

<p>*    No SIGINT on BREAK, CR-to-NL off, input parity</p>

<ul>
<li>check off, don&rsquo;t strip 8th bit on input, output</li>
</ul>

<p>*    flow control off.</p>

<p>*/</p>

<p>buf.c_iflag S= ~(BRKINT I ICRNL | INPCK | ISTRIP | IXON);</p>

<p>* Clear size bits, parity checking off. */</p>

<p>buf.c_cflag S=〜(CSIZE I FARENB);</p>

<p>*    Set 8 bits/char.</p>

<p>*/</p>

<p>buf,c_cflag [= CSS;</p>

<p>/*</p>

<p>*    Output processing off.</p>

<p>buf.c_oflag &amp;=〜(OPOST&rdquo;</p>

<p>* Case B: 1 byte at a time, no timer. */</p>

<p>buf.c_cc[VMIN] = 1;</p>

<p>buf.c_cc[VTIME] =0;</p>

<p>if (tcsetattr(fd, TCSAFLUSH, &amp;buf) &lt; 0) return(-1);</p>

<p>*    Verify that the changes stuck, tcsetattr can return 0 on</p>

<p>*    partial success.</p>

<p>*/</p>

<p>if {tcgetattr(fd, &amp;buf&gt; &lt; 0) { err = errno;</p>

<p>tcsetattr(fd, TCSAFLUSH, ssave_termios); errno = err; return (-1);</p>

<p>if ((buf.c.lflag &amp; (ECHO I ICANON I IEXTEN I ISIG)) I I</p>

<p>(buf.C_iflag &amp; (BRKINT | ICRNL I INPCK I ISTRIP 1 IXON&rdquo; I I (buf.c_cflag S (CSIZE | PARENB | CS8)) != CSB I I</p>

<p>(buf.c_oflag &amp; OPOST) || buf.c_cc[VMIN] != 1 I I buf-c_cc[VTIME] != 0) {</p>

<p>*    Only some of the changes were made. Restore the</p>

<p>*    original settings.</p>

<p>*/</p>

<p>tcsetattr(fd, TCSAFLUSH, &amp;save_termios);</p>

<p>errno = EINVAL;</p>

<p>return(-1);</p>

<p>ttystate = RAW; ttysavefd = fd; return(0);</p>

<p>int</p>

<p>tty_reset(int fd)    Z* restore terminal * s mode */</p>

<p>{</p>

<p>if {ttystate == RESET) return(0);</p>

<p>if (tcsetattr(fd, TCSAFLUSH, &amp;3ave_termios) &lt; 0) return(-1);</p>

<p>ttystate = RESET;</p>

<p>_    return(0);</p>

<p>画}</p>

<p>void</p>

<p>tty_atexit(void)    /* can be set up by atexit(tty_atexit) */</p>

<p>if (ttysavefd &gt;= 0)</p>

<p>tty_reset(ttysavefd);</p>

<p>}</p>

<p>struct termios *</p>

<p>tty_termios(void)    /* let caller see original tty state */</p>

<p>{</p>

<p>return(&amp;save_termios);</p>

<p>}</p>

<p>图18-20将终端模式设置为cbreak模式或原始模式 cbreak模式的定义如下。</p>

<p>•非规范模式。如本节开始处所述，这种模式关闭了对某些输入字符的处理。这种模式没 有关闭対信号的处理，所以用户始终可以键入一个能够触发终端产生信号的字符。请注 意，调用者应当捕捉这些信号，否则这种信号就有可能终止程序，并且使终端保持在 cbreak 模式。</p>

<p>作为一般规则，在编写更改终端模式的程序时，应当捕捉大多数信号，以便在程序终止 前恢复终端模式。</p>

<p>•关闭回显。</p>

<p>•每次输入一个字节，为此，将MIN设置为1,将TIME设置为0。这是图18-19中的情形 至少有一个字节可用时，read才返回。</p>

<p>对原始模式的定义如下。</p>

<p>•非规范模式。也关闭了对信号产生字符(ISIG)和扩充输入字符(IEXTEN)的处理。</p>

<p>另外还禁用了 BRKINT字符，使BREAK字符不再产生信号。</p>

<p>•关闭回显。</p>

<p>•禁止输入中的CR到NL映射（ICRNL）、输入奇偶检测（INPCK）、剥离输入字节的第8 位（ISTRIP）以及输出流控制（工XON）。</p>

<p>• 8位字符（CS8）,且禁用奇偶校验（PARENB）。</p>

<p>•禁止所有输出处理（OPOST）。</p>

<p>•每次输入一个字节TIME=0）o 图18-21中的程序测试原始模式和cbreak模式。</p>

<p>#include &ldquo;apue.h&rdquo; static void</p>

<p>sig_catch(int signo)</p>

<p>{</p>

<p>printf(&ldquo;signal caught\n&rdquo;)； tty_reset(STDIN_FILENO); exit(0);</p>

<p>J</p>

<p>int</p>

<p>main(void)</p>

<p>{</p>

<p>int    i;</p>

<p>char    c;</p>

<p>if (signal(SIGINT, sig_catch) == SIG_ERR) /* catch signals */ err_sys(&ldquo;signal{SIGINT) error&rdquo;&gt;;</p>

<p>if (signal(SIGQUIT, sig_catch) = SIG_ERR) err_sys(&ldquo;signal(SIGQUIT) error&rdquo;);</p>

<p>if {signal(SIGTERM, sig_catch) == SIG_ERR) err_sys(&ldquo;signal(SIGTERM) error&rdquo;);</p>

<p>if (tty_raw(STDIN_FILENO) &lt; 0) err_sys(&ldquo;tty_raw error&rdquo;);</p>

<p>printf (&ldquo;Enter raw mode characters, terminate with DELETE\nH) ,• while ((i = read(STDIN_FILENO, &amp;c, 1)) == 1)(</p>

<p>if ((c &amp;= 255) == 0177)    /* 0177 = ASCII DELETE */</p>

<p>break;</p>

<p>printf (&ldquo;%o\n&rdquo;, c);</p>

<p>if &lt;tty_reset(STDIN_FILENO》&lt; 0) err_sys(&ldquo;tty_reset error&rdquo;)；</p>

<p>if (i &lt;= 0)</p>

<p>err_sys(&ldquo;read error&rdquo;); if (tty_cbreak(STDIN_FILENO&gt; &lt; 0)</p>

<p>err_sys(&ldquo;tty_cbreak error&rdquo;);</p>

<p>printf{&rdquo;\nEnter cbreak mode characters, terminate with SIGINT\n&rdquo;); while ((i = read(STDIN_FILENO, &amp;c, 1)) == 1) {</p>

<p>c &amp;= 255;</p>

<p>printf(&ldquo;%o\n&rdquo;, c);</p>

<p>}</p>

<p>if (tty_reset(STDIN_FILENO&gt; &lt; 0)</p>

<p>err_sys(&ldquo;tty_reset error&rdquo;); if (i &lt;= 0)</p>

<p>err_sys(&ldquo;read error&rdquo;);</p>

<p>exit(0);</p>

<p>[709]    图18-21测试原始终端模式和cbreak终端模式</p>

<p>运行图18-21中的程序，可以观察这两种终端工作模式的工作情况。</p>

<p>$ ./a.out</p>

<p>Enter raw mode characters, terminate with DELETE</p>

<p>4</p>

<p>33</p>

<p>133</p>

<p>61</p>

<p>70</p>

<p>176</p>

<p>键入Delete</p>

<p>Enter cbreak    mode characters, terminate with SIGINT</p>

<p>1    键入 Ctrl+A</p>

<p>10    键入退格</p>

<p>signal caught    键入中断键</p>

<p>在原始模式中，输入的字符是Ctri+D (04)和特殊功能键F7。在所用的终端上，此功能键产生5 个字符：ESC (033〉、[ (0133)、1 (061)、8 ( 070)和~ (0176)。注意，在原始模式下关闭了输 出处理(&lsquo;OPOST),所以在每个字符后没有得到回车符。另外还要注意的是，在cbreak模式下， 不对输入特殊字符进行处理(因此没对Ctrl+D、文件结束符和退格进行特殊处理〉，但是仍对终 端产生的信号进行处理。    ■■</p>

<p>18.12终端窗□大小</p>

<p>大多数UNIX系统都提供了一种跟踪当前终端窗口大小的方法，在窗口大小发生变化时，使 内核通知前台进程组。内核为每个终端和伪终端都维护了一个winsize结构：</p>

<p>struct winsize {</p>

<p>unsigned short ws_row；    /* rows, in characters */</p>

<p>unsigned short ws_col;    /* columns, in characters */</p>

<p>unsigned short ws^xpixel; Z* horizontal size, pixels (unused) <em>/ unsigned short ws_ypixel; /</em> vertical size, pixels (unused) */</p>

<p>J；</p>

<p>此结构的规则如下，</p>

<p>•用ioctl (见3.15节)的TIOCGWINSZ命令可以取此结构的当前值。</p>

<p>•用ioctl的TXOCSWINSZ命令可以将此结构的新值存储到内核中=如果此新值与存储</p>

<p>在内核中的当前值不同，则前台进程组会收到SIGWINCH信号。(注意，从图10-1中可 闹    以看出，此信号的系统默认动作是被忽略。)</p>

<p>•除了存储此结构的当前值以及在此值改变时产生一个信号以外，内核对该结构不进行任 何其他操作。对结构中的值进行解释完全是应用程序的工作。</p>

<p>提供这种功能的目的是，当窗口大小发生变化时应用程序能够得到通知(如vi编辑器)。应</p>

<p>用程序接收此信号后，可以获取窗口大小的新值，然后重绘屏幕。</p>

<p>鼸■实例</p>

<p>图18-22所示的程序打印当前窗口大小，然后休眠。每次窗口大小改变时，程序就捕捉到 SIGWINCH信号，然后打印新的窗口大小。我们必须用一个信号终止此程序。</p>

<p>#include &ldquo;apue.h&rdquo;</p>

<p>#include <termios.h></p>

<p>#ifndef TIOCGWINSZ</p>

<p>tfinclude <sys/ioctl.h></p>

<p>番endif</p>

<p>static void</p>

<p>pr_winsize(int fd)</p>

<p>{</p>

<p>struct winsize size;</p>

<p>if (ioctl(fd, TIOCGWINSZ, (char *) &amp;size) &lt; 0) err_sys(&ldquo;TIOCGWINSZ error&rdquo;)；</p>

<p>printf (&ldquo;%d rows, %d columns\n*&lsquo;, size.ws_row, size.ws_col);</p>

<p>}</p>

<p>static void</p>

<p>sig_winch(int signo)</p>

<p>{</p>

<p>printf(&ldquo;SIGWINCH received\n&rdquo;&gt;; pr_winsize(STDIN_FILENO&gt;;</p>

<p>int</p>

<p>main(void)</p>

<p>{</p>

<p>if (isatty(STDIN_FILENO) == 0) exit(l);</p>

<p>if (signal(SIGWINCH, sig_winch) = SIG_ERR) err_sys(&ldquo;signal error&rdquo;)；</p>

<p>pr_winsize(STDIN_FILENO);    /* print initial size ♦/</p>

<p>for ( ; ; }    /* and sleep forever */</p>

<p>pause ();</p>

<p>)</p>

<p>图18-22打印窗口大小 在一个带窗口终端的系统上运行图18-22中的程序得到:</p>

<p>$ ./a.out 35 rows, SIGWINCH 40 rows, SIGWINCH 42 rows.</p>

<p>80 columns received 123 columns received 33 columns</p>

<p>初始大小</p>

<p>更改窗口大小：捕提到信号</p>

<p>再一次</p>

<h5 id="18-13-tecmcap-tezminfo-和-curses">18-13 tecmcap、tezminfo 和 curses</h5>

<p>termcap的意思是终端能力（terminal capability）.它涉及文本文件/etc/termcap和 —套读此文件的例程。termcap这种技术是在伯克利开发的，注意是为了支持vi编辑器。 termcap文件包含了对各种终端的说明：终端支持哪些功能（如行数、列数、终端是否支持 退格），如何使终端执行某些操作（如清屏、将光标移动到给定位置）。把这些信息从编译过 的程序中取出来并把它们放在易于编辑的文本文件中，这样就使得vi编辑器能在很多不同的 终端上运行。</p>

<p>最后，栴支持termcap文件的例程从vi编辑器中抽取出来，放在一个单独的curses库 中。为使这套库可供要进行屏幕处理的任何程序使用，还增加了很多功能。</p>

<p>termcap这种技术并不是很完善。当越来越多的终端被加到数据文件中时，为找到一个特定 的终端，需要花费更长的时间扫描此数据文件。这个数据文件还用两个字符的名字来禄识不同的 终端属性o这坚蚨陪迫使开发人员开发出了 terminfo以及与其相关的curses库。在terminfo 中，终端说明基本上都是文本说明的编译版本，在运行时易于被快速定位。terminfo最初由 SVR2开始使用，此后所有System V的版本都使用它。</p>

<p>历史上，基于System V的系统使用terminfo, BSD派生的系统使用termcap,但是现在， j系统通常两者都提供。然而Mac OS X仅支持terminfo。</p>

<p>Goodheart[1991]对terminfo和curses库进行了详细说明，但此书已不再增印。Strang[1986] 说明了 curses 圍数库的伯克利版本》Strang、Mui 和 O’ReilIy[1988]则对 termcap 和 terminfo 进行了说明。</p>

<p>i    可在 <a href="http://invisible-island.net/ncurses/ncurses.html">http://invisible-island.net/ncurses/ncurses.html</a> 或 <a href="http://www.gnu">http://www.gnu</a>,</p>

<p>org/software/ncurses上找到与SVR4 curses接口兼容的开放版ncurses岛数库。</p>

<p>不论是termcap还是terminfo,它们本身都不处理本章所述及的问题：更改终端的模 闹式、更改终端特殊字符、处理窗口大小等。它们所提供的是在各种终端上执行典型操作（清屏、 移动光标）的方法。另一方面，在本章所述问题方面，curses能提供某种具体细节方面的帮 助。curses提供了很多函数，用来设置原始模式、设置cbreak模式、打开和关闭回显等。注 意，curses库是为基于字符的哑终端设计的，而如今，它们大部分已被以基于像素的图形终</p>

<p>端所代替。</p>

<h5 id="18-14小结">18.14小结</h5>

<p>终端有很多特征和选项，其中大多数都可按需进行更改，本章描述了很多更改终端操作（即 更改特殊输入字符和可选择标志）的函数，还介绍了可对终端设备进行设置或恢复的各个终端特 殊字符以及众多选项。</p>

<p>终端的输入模式有两种一规范的（每次一行）和非规范的。本章中包含了若干这两种工作 模式的实例，也提供了一些函数，它们在POSIX.1终端选项和较早的BSD cbreak模式及原始模 式之间进行映射。本章还说明了如何获取和改变终端窗口大小。</p>

<p>习题</p>

<p>18.1编写一个调用tty_raw并且不恢复终端模式就终止的程序。如果系统提供reset（l）命令 （本书说明的4种平台全都提供），使用该命令恢复终端模式。</p>

<p>18.2 c_cflag字段的PARODD标志允许我们设置奇检验或偶校验，而BSD中的tip程序也允 许奇偶校验位为0或1，它是如何实现的？</p>

<p>18.3如果你系统中的stty（l）命令输出MIN和TIME值，做下面的练习。登录系统两次，其中 —次登录时打开vi编辑器，在另外一次登录中用stty命令确定vi设置的MIN和TIME 值（因为vi将终端设置为非规范模式）。（如果你的终端上有窗口系统正在运行，那么你也 可以进行同样的测试，方法是：登录一次，然后用两个分开的窗口。）    [U3]</p>

    </div>

    
    

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05-%E5%9F%BA%E7%A1%80%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/02-%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/02-linux-%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/16-%E7%BD%91%E7%BB%9C-ipc%E5%A5%97%E6%8E%A5%E5%AD%97/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">16 网络 IPC：套接字</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05-%E5%9F%BA%E7%A1%80%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/02-%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/02-linux-%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/19-%E4%BC%AA%E7%BB%88%E7%AB%AF/">
            <span class="next-text nav-default">19 伪终端</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="iteratelyd@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/iterateself" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/thebegin/activities" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/68028070/" class="iconfont icon-douban" title="douban"></a>
  <a href="http://iterate.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">iterateself</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>








</body>
</html>
