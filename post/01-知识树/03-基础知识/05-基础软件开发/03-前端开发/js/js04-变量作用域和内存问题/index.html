<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>JS04 变量、作用域和内存问题 - 迭代自己</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="iterateself" />
  <meta name="description" content="第4章 、胃&#43;:&#43; 变量、作用域和内存问 本章内容 口理解基本类型和引用类型的值 □理解执行环境 口理解垃圾收集 照ECMA-262的定义，JavaScr" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.47.1" />


<link rel="canonical" href="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05-%E5%9F%BA%E7%A1%80%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/js/js04-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="JS04 变量、作用域和内存问题" />
<meta property="og:description" content="第4章 、胃&#43;:&#43; 变量、作用域和内存问 本章内容 口理解基本类型和引用类型的值 □理解执行环境 口理解垃圾收集 照ECMA-262的定义，JavaScr" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05-%E5%9F%BA%E7%A1%80%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/js/js04-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/" /><meta property="article:published_time" content="2018-06-12T20:04:45&#43;00:00"/>
<meta property="article:modified_time" content="2018-06-12T20:04:45&#43;00:00"/>
<meta itemprop="name" content="JS04 变量、作用域和内存问题">
<meta itemprop="description" content="第4章 、胃&#43;:&#43; 变量、作用域和内存问 本章内容 口理解基本类型和引用类型的值 □理解执行环境 口理解垃圾收集 照ECMA-262的定义，JavaScr">


<meta itemprop="datePublished" content="2018-06-12T20:04:45&#43;00:00" />
<meta itemprop="dateModified" content="2018-06-12T20:04:45&#43;00:00" />
<meta itemprop="wordCount" content="13417">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="JS04 变量、作用域和内存问题"/>
<meta name="twitter:description" content="第4章 、胃&#43;:&#43; 变量、作用域和内存问 本章内容 口理解基本类型和引用类型的值 □理解执行环境 口理解垃圾收集 照ECMA-262的定义，JavaScr"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">迭代自己</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/catalog/">
        <li class="mobile-menu-item">完整目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">迭代自己</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/catalog/">完整目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">JS04 变量、作用域和内存问题</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-06-12 </span>
        
        <span class="more-meta"> 13417 words </span>
        <span class="more-meta"> 27 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    
  </div>
</div>

    
    

    
    <div class="post-content">
      <p>第4章    、胃+:+</p>

<p>变量、作用域和内存问</p>

<p>本章内容</p>

<p>口理解基本类型和引用类型的值 □理解执行环境 口理解垃圾收集</p>

<p>照ECMA-262的定义，JavaScript的变量与其他语言的变量有很大区别。JavaScript变量松散 类型的本质，决定了它只是在特定时间用于保存特定值的一个名字而已。由于不存在定义某</p>

<p>个变量必须要保存何种数据类型值的规则，变量的值及其数据类型可以在脚本的生命周期内改变。尽管 从某种角度看，这可能是一个既冇趣又强大，同时又容易出问题的特性，但JavaScript变量实际的复杂 程度还远不止如此。</p>

<p>4.1基本类型和引用类型的值</p>

<p>ECMAScript变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是 简单的数据段，而引用类型值指那些可能由多个值构成的对象。</p>

<p>在将一个值赋给变景时，解析器必须确定这个值是基本类型值还是引用类型值。第3章讨论了5种 基本数据类型：Undefined、Null、Boolean、Number和String。这5种基本数据类型是按值访问 的，因为可以操作保存在变量屮的实际的值。</p>

<p>引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript不允许龙接访问内存中的位置， 也就是说不能直接操作对象的内存空间。在操作对象时,实际i是在操作对象的引用而不是实际的对象,， 为此.引用类型的值是按引用访问的。</p>

<p>在很多语言中，字符串以对象的形式来表示，因此被认为是引用类型的＜ ECMAScript放弃了这一传统。</p>

<p>4.1.1动态的属性</p>

<p>定义基本类型值和引用类型值的方戎是类似的：创建一个变撤并为该变贵赋值。但是，当这个值保 存到变量中以后，对不同类型值（4以执行的操作则大相径庭。对于引用类型的值，我们可以为其添加属 性和方法，也可以改变和删除其属性和方法。请看下面的例子：</p>

<p>var person. = new Object ()； person.name = &ldquo;Nicholas”；</p>

<p>alert（person.name） i</p>

<p>//&ldquo;Nicholas&rdquo;</p>

<p>DynamicPropertiesExampleOl .htm</p>

<p>以上代碍创建了一个对象并将其保存在了变量person中。然后，我们为该对象添加了一个名为 name的属性，并将字符串值^Nicholas •’赋给了这个属性。紧接着，又通过alert (＞函数访问了这个 新属性。如果对象不被销毁或者这个属性不被删除，则这个属性将一直存在。</p>

<p>但是，我们不能给基本类型的值添加属性，尽管这样做不会导致任何错误。比如：</p>

<p>var name = &ldquo;Nicholas&rdquo;;</p>

<p>name.age = 27;</p>

<p>alert（name.age）;    //undefined</p>

<p>DynamicPropertiesExample02. htm</p>

<p>在这个例子中，我们为字符串name定义了一个名为age的属性，并为该属性赋值27。但在下一 行访问这个属性时，发现该屈性不见了。这说明只能给引用类型值动态地添加属性，以便将来使用。</p>

<p>4.1.2复制变量值</p>

<p>除了保存的方式不同之外，在从一个变量向另一个变量复制基本类型值和引用类型值时，也存在不 同。如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制 到为新变量分配的位置上。来看• •个例子：</p>

<p>var numl = 5; var num2 = numl;</p>

<p>在此，numl中保存的值是5。当使用numl的值来初始化num2时，num2中也保存了值5。但mm2 中的5与numl中的5是完全独立的，该值只是numl中5的一个副本。此后，这两个变量可以参与任 何操作而不会相互影响。图4-1形象地展示了复制基本类型值的过程。</p>

<p>复制前的变量对象</p>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td></td>
<td></td>
</tr>

<tr>
<td>numl</td>
<td>5（Number 类贸）</td>
</tr>
</tbody>
</table>

<p>复制后的变量对象</p>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td>zxuin2</td>
<td>5（Number 类穆）</td>
</tr>

<tr>
<td>numl</td>
<td>5（Number 秃壁）</td>
</tr>
</tbody>
</table>

<p>图4-1</p>

<p>当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到 为新变贽分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一 个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另 一个变景，如下面的例子所示：</p>

<p>var objl = new Object(｝；</p>

<p>var obj2 = objl;</p>

<p>objl.name = &ldquo;Nicholas&rdquo;;</p>

<p>alert (obj2 .name); /&ldquo;Nicholas&rdquo;</p>

<p>首先，变量objl保存了一个对象的新实例。然后，这个值被复制到了 obj2 换句话说，objl 和obj2都指向同一个对象。这样，当为objl添加name属性后，可以通过obj2来访问这个属性， 因为这两个变量引用的都是同一个对象。图4-2屁示了保存在变量对象中的变量和保存在堆中的对象之 间的这种关系。</p>

<p>4.1.3传递参数</p>

<p>ECMAScript中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的參 数，就和把值从一个变量复制到男一个变量一样。基本类型值的传递如同基本类型变量的复制一样，而 引用类型值的传递，则如同引用类型变量的复制一样。有不少开发人员在这一点上可能会感到困惑，因 为访问变ii有按值和按引用两种方式，而参数只能按值传递。</p>

<p>在向参数传递基本类型的值时，被传递的值会被复制给一个局部变捸(即命名参数，或者用 ECMAScript的概念来说，就是arguments对象中的一个元素)。在向参数传递引用类型的值时，会把 这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。清看下面 这个例子：</p>

<p>function addTen(num) { num += 10; return num；</p>

<p>var count = 20;</p>

<p>var result = addTen(count); alert (count) ;    //20，没有变化</p>

<p>alert(result);    //30</p>

<p>FunctionArgumentsExampleOl. htm</p>

<p>这里的函数addTen ()有一个参数nun,,而参数实际上是函数的局部变量。在调用这个函数时，变 14 count作为参数被传递给函数，这个变量的值是20。于是,数值20被复制给参数num以便在addTen () 中使用。在函数内部，参数num的值被加上了 10,但这一变化不会影响函数外部的count变量。参数 num与变量count互不相识，它们仅仅是具有相同的值。假如num是按引用传递的话，那么究量count 的值也将变成30,从而反映威数内部的修改。当然，使用数值等基本类型值来说明按值传递参数比较简 单，但如果使用对象，那问题就不怎么好理解了。再举一个例子：</p>

<p>function setName(obj) {</p>

<p>obj.name = &ldquo;Nicholas&rdquo;?</p>

<p>)</p>

<p>var person. new Object {); setName(person);</p>

<p>alert{person.name);    //&ldquo;Nicholas&rdquo;</p>

<p>FunctionA rgumentsExampleO2, htm</p>

<p>以上代码中创建一个对象，并将保存在丁变量person中。然后，这个对象被传递到setName {) 函数中之后就被复制给了 obj。在这个函数内部，obj和person弓I用的是同一个对象。换句话说，即 使这个对象是按值传递的，ob j也会按引用来访问同一个对象。于是，当在函数内部为obj添加name 属性后，函数外部的person也将有所反映；因为person指向的对象在堆内存中只有一个，而且是全 局对象。有很多开发人员错误地认为：在局部作用域中修改的对象会在全局作用域中反映出来，就说明 参数是按引用传递的=为了证明对象是按值传递的，我们再看一看下面这个经过修改的例子：</p>

<p>function setName(obj) { obj.name = &ldquo;Nicholas&rdquo;;</p>

<p>obj 翼 new Object&lt;); obj•name « &ldquo;Greg&rdquo;;</p>

<p>}</p>

<p>var person = new Object(); setName(person);</p>

<p>alert(person.name); //&ldquo;Nicholas&rdquo;</p>

<p>这个例子与前•-个例子的唯一区别，就是在setName (&gt;函数中添加了两行代码：一行代码为obj 重新定义了一个对象，另一行代码为该对象定义了一个带有不同值的name属性。在把person传递给 setName ()后，其name属性被设覚为-Nicholas”。然后，又将一个新对象赋给变量obj ,同时将其name 属性设置为*Greg&rsquo;。如果person是按引用传递的，那么person就会自动被修改为指向其name属性值 为-Greg-的新对象。但是，当接下来再访问person .name时，显东的值仍然是&rdquo;Nicholas&rsquo;。这说明 即使在函数内部修改了参数的值，但原始的引用仍然保持未变。实际上，当在函数内部重写obj时，这 个变ft引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。</p>

<p><img src="E:/11.ProgramFiles/Typora/JavaScriptd8a70b8fbea1082c34809-18.jpg" alt="img" /></p>

<p>可以把ECMAScript函数的参数想象成局部变量。</p>

<p>4.1.4检测类型</p>

<p>要检测一个变fl是不是基本数据类型？第3章介绍的typeof操作符是最佳的工具。说得更具体一 点，typeof操作符是确定一个变量是字符串、数值、布尔值，还是undefined的最佳T具。如果变 量的值是一个对象或null,则typeof操作符会像下面例子中所示的那样返回-object»:</p>

<p>var s = &ldquo;Nicholas&rdquo;; var b = true； var i = 22; var u；</p>

<p>var n = null;</p>

<p>var o = new Object();</p>

<p>alert(typeof s); alert(typeof i)； alert(typeof b)； alert(typeof u)； alert(typeof n); alert(typeof o);</p>

<p>//string</p>

<p>//number</p>

<p>//boolean</p>

<p>//undefined</p>

<p>//object</p>

<p>//object</p>

<p>DeterminingiypeExampleOl. htm</p>

<p>虽然在检测基本数据类型时typeof是非常得力的助手，但在检测引用类型的值时，这个操作符的 用处不大。通常，我们并不是想知道某个值是对象，而是想知道它是什么类型的对象。为此，ECMAScript 提供了 instanceof操作符，其语法如下所示：</p>

<p>result = variable instanceof constructor</p>

<p>如果变逛是给定引用类型(根据它的原型链来识别；第6章将介绍原型链)的实例，那么 instanceof操作符就会返冋true。请看下面的例子：</p>

<p>alert (person instanceof Object) ;    // 变i person 是 Object 吗？</p>

<p>alert (colors instanceof Array);    // 变量 colors 是 Array *爲？</p>

<p>alert (pattern instanceof RegExp)；&rdquo;变量 pattern 是 RegExp 吗？</p>

<p>根据规定，所有引用类型的值都是Object的炙例。因此，在检测&ndash;个引用类型值和Object构造 函数时，instanceof操作符始终会返回true。当然，如果使用instanceof操作符检测基本类型的 值，则该操作符始终会返回false,因为基本类型不是对象。</p>

<p>使用typeof操作符检&rsquo;测函數时，该操作符会返回•function&rdquo;。在Safari 5及</p>

<p>Sr之前版本和Chrome 7及之前版本中使用typeof检測正则表达式时.由于规范的原 因，这个操作符也返因&rdquo;function”。ECMA-262规定任何在内部实現[[Call]]方法 的对象都应该在应用typeof操作符时返回-function-a由于上述浏览器中的正则 表述式也实现了这个方法，因此对正则表达式应用typeof会送回&rdquo;function•。在 IE和Firefox中，对正则表达式应用typeof会返回&rdquo;object&rdquo;。</p>

<p>4.2执行环境及作用域</p>

<p>执行环境(execution context,为简单起见，有时也称为“环境”)是JavaScript中嚴为重要的一个概 念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个 与之关联的变量对象(variable object),环境中定义的所有变量和函数都保存在这个对象中。虽然我们 编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。</p>

<p>全局执行环境是最外围的一个执行环境，，根据ECMAScript实现所在的宿主环境不同，表示执行环 境的对象也不一样。在Web浏览器中，全局执行环境被认为是window对象(第7章将详细讨论)，W 此所有全局变量和函数都是作为window对象的属性和方法创建的。某个执行环境中的所有代码执行完 毕后，该环境被销毁，保存在其中的所有变屁和函数定义也随之销毁(全局执行环境直到应用程序退 出一例如关闭网页或浏览器一时才会被铺毁)。</p>

<p>每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推人-个环境栈中。 而在函数执行之后，栈将其•环境弹出，把控制权返冋给之前的执行环境。ECMAScript程序中的执行流 正是由这个方便的机制控制着。</p>

<p>当代碑在一个环境中执行时，会创建变童对象的一个作用域链(scopechain)。作用域链的用途，是 保证对执行环境有权访问的所有变St和函数的有序访问。作用域链的前端，始终都是当前执行的代码所 在环境的变撖对象。如果这个环境是函数，则将其活动对象(activation object)作为变量对象。活动对 象在最开始时只包含一个变量，即arguments对象(这个对象在全局环境中是不存在的)。作用域链中 的下一个变幫对象来自包含(外部)环境，而再下一个变量对象则来自下一个包含环境。这样，一直延 续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p>

<p>标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始， 然后逐级地向后回溯，直至找到标识符为止(如果找不到标识符，通常会导致错误发生)。</p>

<p>请看下面的示例代码：</p>

<p>var color = &ldquo;blue&rdquo;；</p>

<p>function changeColor(){</p>

<p>if (color === &ldquo;blue&rdquo;){</p>

<p>color = &ldquo;red&rdquo;；</p>

<p>} else {</p>

<p>color = &ldquo;blue*；</p>

<p>}</p>

<p>)</p>

<p>changeColor()；</p>

<p>alert(&ldquo;Color is now ■ + color)；</p>

<p>ExecutionConfextExampleO] .htm</p>

<p>在这个简单■的例子中，函数changeColor (＞的作用域链包含两个对象：它自己的变量对象(其巾 定义着arguments对象)和全局环境的变量对象。可以在函数内部访问变量coior,就是因为可以在 这个作用域链中找到它。</p>

<p>此外，在局部作用域中定义的变量可以在局部环境中与全局变贵互换使用，如下面这个例子所示：</p>

<p>var color = &ldquo;blue”；</p>

<p>function changeColor(){</p>

<p>var anotherColor = &ldquo;red&rdquo;;</p>

<p>function swapColors(){</p>

<p>var tempColor = anotherColor； anotherColor = color; color = tempColor；</p>

<p>// 这_叉可以话问 color、anotherColor 和 tempColor</p>

<p>}</p>

<p>//这里可以访问color和anotherColor,位不能访问tempColor swapColors()；</p>

<p>}</p>

<p>//这里只能访问color changeColor();</p>

<p>以上代码共涉及3个执行环境：全局环境、changeColor ()的局部环境和swapColors ()的局部 环境。全局环境中有一个变量color和一个兩数changeColor ()。changeColor ()的局部环境中有 一个名为anotherColor的变量和-个名为swapColors &lt;)的函数，但它也可以访问全局环境中的变 量color。swapColors ()的局部环境中有一个变量tempColor,该变量只能在这个环境中访问到。 无论全局环境还是changeColor ()的局部环境都无权访问tempColor。然而，在swapColors ()内部 则可以访问其他两个环境中的所有变量，闪为那两个环境是它的父执行环境。图4-3形象地展示了前面 这个例子的作用域链。</p>

<p>图4-3</p>

<p>阁4»3中的矩形表示特定的执行环境。其中，内部环境可以通过作用域链访问所有的外部环境，但 外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性、有次序的。每个环境都 可以向上搜索作用域链，以査询变量和函数名；但任何环境都不能通过向下搜索作用域链而进人另一个 执行环境。对于这个例子中的swapColors ()而言，其作用域链中包含3个对象：swapColors ()的焚 量对象、changeColor ()的变量对象和全局变量对象。swapColors ()的局部环境开始时会先在自己的 变量对象中搜索变量和函数名，如果搜索不到则再搜索上一级作用域链。changeColor (》的作用域链</p>

<p>中只包含两个对象：它自己的变量对象和全局变量对象。这也就是说，它不能访问swapColors ()的 环境。</p>

<p>函数参数也被当作变童来对待，因此其访问规则与执行环境中的其他变量相同。</p>

<p>4.2.1延长作用域链</p>

<p>虽然执行环境的类型总共只有两种一全局和局部(函数)，但还是有丼他办法来延长作用域链。</p>

<p>这么说是因为有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移M 除。在两种情况下会发生这种现象。具体来说，就是当执行流进人下列任何一个语句时，作用域链就会Q 得到加长：</p>

<p>□    try-catch 语句的 catch 块；</p>

<p>□    with语句。</p>

<p>这两个语句都会在作用域链的前端添加一个变量对象。对with语句来说，会将指定的对象添加到 作用域链中。对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。</p>

<p>下面看一个例子。</p>

<p>I function buildUrl() {</p>

<p>*    var qs = n?debug=true&rdquo;;</p>

<p>with(location){</p>

<p>var url = href + qs；</p>

<p>}</p>

<p>return url;</p>

<p>}</p>

<p>ExecutionContextExample03. htm</p>

<p>在此，with语句接收的是location对象，因此其变量对象中就包含了 location对象的所有属 性和方法，而这个变量对象被添加到了作用域链的前端。buildUrl(＞函数中定义了_个变量qS。当在 with语句中引用变童href时(实际引用的是location, href),可以在当前执行环境的变ft对象中 找到。当引用变量qs时，弓I用的则是在buildUrlO中定义的那个变量，而该变量位于函数环境的变 量对象中。至于with语句内部，则定义了一个名为url的变量，因而url就成了函数执行环境的一 部分，所以可以作为函数的值被返回。</p>

<p>在IE8及之前版本的JavaScript实现中，存在一个与标准不一•致的地方，即在 catch语句中捕获的错误对象会被添加到执行环境的变量对象，而不是catch语句 的变量对象中。换句话说，即使是在catch块的外部也可以访问到错谈对象。IE9修 复了这个问题。</p>

<p>4.2.2没有块级作用域</p>

<p>JavaScript没有块级作用域经常会导致理解上的困惑。在其他类C的语言中，由花括号封闭的代码 块都有自己的作用域(如果用ECMAScript的话来讲，就是它们自己的执行环境)，因而支持根据条件来 定义变量。例如，下面的代码在JavaScript中并不会得到想象中的结果：</p>

<p>i£ (true) {</p>

<p>var color = &ldquo;blue&rdquo;;</p>

<p>}</p>

<p>alert(color); //&ldquo;blue&rdquo;</p>

<p>这里是在一个if语句中定义了变color。如果是在C、C++或Java中，color会在if语句执 行完毕后被销毁。但在JavaScript中，if语句中的变fi声明会将变量添加到当前的执行环境(在这里是 全局环境)中。在使用for语句时尤其要牢记这一差异，例如：</p>

<p>for (var i=0; i &lt; 10; i++){ doSoxnething ⑴；</p>

<p>}</p>

<p>alert ⑴；    &ldquo;10</p>

<p>对f-有块级作用域的语言來说，for语句初始化变量的表达式所定义的变tt,只会存在于循环的环 境之中。而对于JavaScript来说，由for语句创建的变景i即使在for循环执行结束后，也依旧会存在 于循环外部的执行环境中。</p>

<p>1.声明变量</p>

<p>使用var声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部</p>

<p>环境；在with语句中，最接近的环境是函数环境。如果初始化变量时没有使用var声明，该变量会自</p>

<p>动被添加到全局环境。如下所示：</p>

<p>function add(numl, num2) { var sum = numl + num2； return sum；</p>

<p>}</p>

<p>var result = add(10, 20);    //30</p>

<p>alert (sum) ；    //由于sum不是有效的变量，因此会导致错误</p>

<p>Execution ContextExample04. htm</p>

<p>以上代码中的函数add()定义了一个名为sum的局部变量，该变盘包含加法操作的结果。虽然结 果值从函数中返回了，但变《 sum在函数外部是访问不到的。如果省略这个例子中的var关键字，那 么当add ()执行完毕后，sum也将可以访问到：</p>

<p>function add (numl z nxnn2) {</p>

<p>sum * numl ♦ num2 /</p>

<p>return sum；</p>

<p>}</p>

<p>var result = add(10, 20) ；    &ldquo;30</p>

<p>alert(sum) ;    //30</p>

<p>ExecutionContextExample05. htm</p>

<p>这个例子中的变fi sum在被初始化賦值时没有使用var关键字。于是，当调用完add&lt;)之后，添 加到全局环境中的变It sum将继续存在；即使函数已经执行完毕，后面的代码依旧可以访问它。</p>

<p>在编写JavaScript代码的过程中，不声明而直接初始化变童是一个常见的掛误做 法，因为这样可能会导致意外。我们建议在初始化变量之前，一定要先声明，这样就 可以避免类似问题。在严格模式下，初始化未经声明的变量合导致错误。</p>

<p>2.査询标识符</p>

<p>当在某个环境中为了读取或写人而引用一个标识符时，必须通过搜索来确定该标识符实际代表什 么。搜索过程从作用域链的前端开始，向上逐级査询与给定名字匹配的标识符，如果在局部环境中找到 了该标i只符，搜索过程停止，变最就绪。如果在局部环境中没存找到该变名，则继续沿作用域链向上 搜索。搜索过程将一直追溯到全局环境的变tt对象。如果在全局环境中也没有找到这个标识符，则意味 着该变量尚未声明。</p>

<p>通过下面这个示例，可以理解查询标识符的过程：</p>

<p>var color = &ldquo;blue&rdquo;?</p>

<p>function getColor{){ return color；</p>

<p>)</p>

<p>alert(getColor())? //&ldquo;blue&rdquo;</p>

<p>ExecutionContextExample06.htm</p>

<p>调用本例中的函数getColor ()吋会引用变量color。为了确定变量color的值，将开始一个两 步的搜索过程。首先，搜索getColor (&gt;的变量对象，査找其屮是否包含一个名为color的标识符。 在没有找到的情况下，搜索继续到下一个变M对象(全局环境的变量对象)，然后在那里找到了名为 color的标识符。因为搜索到了定义这个变傲的变fl对象，搜索过程宣吿结束。图44形象地展示了上 述搜索过程。</p>

<p>阁</p>

<p>在这个搜索过程中，如果存在一个局部的变量的定义，则搜索会自动停止，不再进人另一个变量对 象。换句话说，如果局部环境中存在右同名标识符，就不会使用位于父环境中的标识符，如下面的例子 所示：</p>

<p>var color = &ldquo;blue&rdquo;;</p>

<p>function getColor(){</p>

<p>var color 3 &ldquo;red&rdquo;;</p>

<p>return color；</p>

<p>}</p>

<p>alert (getColor ⑴；// &ldquo;red&rdquo;</p>

<p>ExecutionContextExampleO 7.htm</p>

<p>修改后的代码在getColorO函数中声明了一个名为color的局部变货。调用函数时，该变量就 会被声明。而当函数中的第二行代码执行时，意味着必须找到并返回变量color的值。搜索过程首先 从局部环境中开始，而且在这里发现了一个名为color的变量，其值为•red，。因为变ft已经找到了， 所以搜索即行停止，return语句就使用这个局部变量，并为函数会返回Wed，。也就是说，任何位于 局部变ft color的声明之后的代碑，如果不使用window, color都无法访问全局color变董。如果有 一个操作数是对象，而另一个不是，就会在对象上调用valueOfO方法以取得基本类型的值，以便根 据前面的规则进行比较。</p>

<p>变量查询也不是没有代价的。•^艮明显，访问局部变量要比访问全局变量更快，因 为不用向上搜索作用域链。JavaScript引擎在优化标识符壹询方面做得不钳，因此这 个差别在将来恐怕就可以忽略不计了。</p>

<p>4.3垃圾收集</p>

<p>JavaScript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。 而在C和C++之炎-的语言中，开发人员的一项基本任务就是手工跟踪内存的使用情况，这是造成许多问 题的一个根源。在编写JavaScript程序吋，开发人员不用再关心内存使用问题，所需内存的分配以及无 用内存的回收完全实现丫自动管理。这种垃圾收集机制的原理其实很简单：找出那些不再继续使用的变 量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔（或代码抉行中预定的收集吋间）， 周期性地执行这一操作。</p>

<p>下面我们来分析一下函数中局部变量的正常生命周期。局部变fl只在函数执行的过程屮存在。而在 这个过程中，会为局部变量在栈（或堆）内存上分配相应的空间，以便存储它们的值。然后在函数中使 用这些变量，直至函数执行结束。此时，局部变量就没有存在的必要了.因此可以释放它们的内存以供 将来使用。在这种情况下，很容易判断变量是否还有存在的必要；但外非所有情况下都这么容易就能得 出结论。垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收 间其占用的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有两 个策略。</p>

<p>4.3.1标记清除</p>

<p>JavaScript中最常用的垃圾收集方式是标记清除（mark-and-swecp ）。当变量进人环境（例如，在函 数中声明一个变量）时，就将这个变量标记为“进人环境”。从逻辑上讲，永远不能释放进人环境的变</p>

<p>i所占用的内存，因为只要执行流进人相应的环境，就可能会用到它们。而当变量离开环境时，则将其 标记为&rdquo;离开环境</p>

<p>可以使用任何方式来标记变量。比如，可以通过翻转某个特殊的位来记录一个变最何时进人环境， 或者使用一个“进人环境的”变卅列表及一个“离开环境的”变fl列表来跟踪哪个变贷发生了变化。说 到底，如何标记变量Jt实并不重要，关键在于采取什么策略。</p>

<p>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记(当然，可以使用任何标记方 式)。然后，它会去掉环境中的变i以及被环境中的变量引用的变的标记。而在此之后冉被加上标记 的变ft将被视为准备删除的变垃，原因是环境中的变垃己经无法访问到这些变量了。最后，垃圾收粢器 完成内存清除T作，销毁那些带标记的值并凹收它们所占用的内存空间c</p>

<p>到2008年为止，IE、Firefox、Opera、Chrome和Safari的JavaScript实现使用的都是标记清除式的 垃圾收集策略(或类似的策略)，只不过垃圾收集的时间问隔互有不同。</p>

<p>4.3.2引用计数</p>

<p>另一种不太常见的垃圾收集策略叫做引用计数(reference counting )o引用计数的含义是跟踪记录每 个值被引用的次数。当声明了一个变fi并将一个引用类型值赋给该变盘时，则这个值的引用次数就是1。 如果同一个值又被赋给另一个变最，则该值的引用次数加1。相反，如果包含对这个值引用的变乂取 得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这 个值丁，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那 些引用次数为零的值所占用的内存。</p>

<p>Netscape Navigator 3.0是最早使用引用计数策略的浏览器，佴很快它就遇到了一个严重的问题：循 环引用。循环引用指的是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的 引用。请看下面这个例子：</p>

<p>function problem{){</p>

<p>var objectA = new Object(); var objectB = new Object。；</p>

<p>obj ectA.someOtherObj ect = objects； obj ectB.anotherObj ect = objectA;</p>

<p>)</p>

<p>在这个例子中，object*和objectB通过各自的属性相互引用；也就是说，这两个对象的引用次 数都是2。在采用标记淸除策略的实现中，由于函数执行之后，这两个对象都离开了作用域，因此这种 相互引用不是个问题。但在采用引用计数策略的实现中，当函数执行完毕后，objectA和objectB还 将继续存在，因为它们的引用次数永远不会是0。假如这个函数被重复多次调用，就会导致大景内存得 不到回收。为此，Netscape在NavigatoM.O中放弃了引用计数方式，转而采用标记清除来实现其垃圾收 集机制。可是，引用计数导致的麻烦并未就此终结:，</p>

<p>我们知道，IE中有一部分对象并不是原生JavaScript对象。例如，其BOM和DOM中的对象就是 使用C++以COM ( Component Object Model,组件对象模型)对象的形式实现的，而COM对象的垃圾 收集机制采用的就是引用计数策略。W此，即使〖E的JavaScript引擎是使用标记清除策略来实现的，但 JavaScript访问的COM对象依然是基于引用计数策略的。换句话说，只要在IE中涉及COM对象，就会 存在循环引用的问题。下面这个简单的例子，展示了使用COM对象导致的循环引用问题：</p>

<p>var element = docunient .getElementById{ &ldquo;some_element&rdquo;）; var myObject = new Object{）; myObject.element = element； e1ement.s omeObj ec t = myObject;</p>

<p>这个例子在一个DOM元素（element ）与一个原生JavaScript对象（myObject ）之间创建了循环 引用。其中，变量myObject有一个名为element的属性指向element对象；而变# element也有 一个属性名叫someObject回指myObject。由于存在这个循环引用，即使将例子中的DOM从页面中 移除，它也永远不会被回收。</p>

<p>为了避免类似这样的循环引用问题，最好是在不使用它们的时候手工断开原生JavaScript对象与 DOM元索之间的连接。例如，可以使用下面的代码消除前面例子创建的循环引用：</p>

<p>myObject.element = null; element.someObject = null;</p>

<p>将变量设贾为nulL意味着切断变贵与它此前引用的值之间的连接。当垃圾收集器下次运行时，就 会删除这些值并回收它们占用的内存。</p>

<p>为了解决t述问题，IE9把BOM和DOM对象都转换成了真正的JavaScript对象。这样，就避免了 两种垃圾收集算法并存导致的问题，也消除了常见的内存泄漏现象。</p>

<p>导致循环引用的情况不止这些，其他一些飧况将在本书中陆续介绍。</p>

<p>4.3.3性能问题</p>

<p>垃圾收集器是周期性运行的，而H如果为变量分配的内存数迸很可观，那么回收工作量也是相当大 的。在这种情况下，确定垃圾收集的时间间隔是一个非常重要的问题。说到垃圾收集器多长时间运行一 次，不禁让人联想到1E因此而声名狼藉的性能问题。1E的垃圾收集器是根据内存分配量运行的，具体 -点说就是256个变fi、4096个对象（或数组）字面和数组元素（slot）或者64KB的字符串。达到 上述任何一个临界值，垃圾收集器就会运行。这种实现方式的问题在于，如果一个脚本中包含那么多变 量，那么该脚本很可能会在其生命周期中一直保有那么多的变量。而这样一来，垃圾收巣器就不得不频</p>

<p>繁地运行。结果，由此引发的严S性能问题促使IE7重写了其垃圾收集例程。</p>

<p>随若IE7的发布，其JavaScript引擎的垃圾收窠例程改变了工作方式：触发垃圾收集的变量分配、</p>

<p>字面tt和（或）数组元素的临界值被调整为动态修正。IE7中的各项临界值在初始时与EE6相等。如果 垃圾收集例程回收的内存分配蛩低于）5%,则变量、字面量和（或）数组元素的临界值就会加倍。如果 例程回收了 85%的内存分配最，则将各种临界值重置回默认值。这一看似简单的调整，极大地提升了 IE 在运行包含大量JavaScript的页面吋的性能„</p>

<p>事实上，在有的浏览器中可以触发垃圾收集过程，但我们不建议读者这样做。在 IE中，调用window.CollectGarbage （＞方法会立即执行短圾收集。在Opera7及更 高版本中，调用window.opera.collect。也会启动垃圾收集例程。</p>

<p>4.3.4管理内存</p>

<p>使用具备垃圾收集机制的语言编写程序，开发人员-般不必操心内存管理的问题。但是，JavaScript 在进行内存管理及垃圾收集时面临的问题还是有点与众不同。其中最主要的一个问题，就是分配给Web 浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是出于安全方面的考虑， 目的是防止运行JavaScript的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变景 分配内存，同时还会影响调用桟以及在一个线程中能够同吋执行的语句数ft。</p>

<p>因此，确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行 中的代码只保存必要的数据。一且数据不再有用，最好通过将其值设置为null来释放其引用——这个 做法叫做解除引用(dereferencing)。这-做法适用于大多数全局变量和全局对象的属性。局部变量会在 它们离开执行环境时自动被解除引用，如下面这个例子所示：</p>

<p>function createPerson(name){</p>

<p>var localPerson = new Object。； localPerson.name = name； return localPerson；</p>

<p>var globalPerson = createPerson(&ldquo;Nicholas&rdquo;)?</p>

<p>//手工解除globalPerson的引用</p>

<p>globalPerson = null；</p>

<p>在这个例子中，变量global Person取得了 createPerson ()函数返回的值。在createPerson {) 函数内部，我们创建了一个对象并将其賦给局部变量localPerson,然后又为该对象添加了一个名为 name的属性。嚴后，当调用这个函数时，localPerson以函数值的形式返间并赋给全局变量 global Person。由于localPerson在createPerson&lt;)函数执行完毕后就离开了其执行环境，因此 无需我们显式地去为它解除引用。但是对于全局变量globalPerson而言，则需要我们在不使用它的 时候手工为它解除引用，这也正是上面例子中最后一行代码的目的。</p>

<p>不过，解除一个值的引用并不意味着自动网收该值所占用的内存。解除引用的真正作用是让值妝离 执行环境，以便垃圾收集器下次运行时将其回收。</p>

<p>4.4小结</p>

<p>JavaScript变量可以用来保存两种类型的值：基本类型值和引用类型值。基本类型的值源自以下5 种基本数据类型：Undefinedx Null、Boolean、Number和String。基本类型值和引用类S?值具 有以下特点：</p>

<p>□基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；</p>

<p>□从一个变最向另一个变量复制基本类型的值，会创建这个值的一个副本；</p>

<p>□引用类型的值是对象，保存在堆内存中；</p>

<p>□包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；</p>

<p>□从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变最最终都指向同 一个对象；</p>

<p>□确定，个值是哪种基木类沏可以使用typeof操作符，而确定一个值是哪种引用类型可以使用 instanceof 操作符。</p>

<p>所有变ft （包括基本类型和引用类型）都存在于-个执行环境（也称为作用域）当中，这个执 行环境决定了变量的生命周期.以及哪一部分代码可以访问其中的变量。以下是关于执行环境的几 点总结：</p>

<p>□执行环境有全局执行环境（也称为全局环境）和函数执行环境之分；</p>

<p>□每次进人_个新执行环境，都会创建一个用丁搜索变量和函数的作用域链；</p>

<p>□函数的局部环境不仅有权访问函数作用域中的变量，而a有权访问其包含（父）环境，乃至全 局环境；</p>

<p>□全局环境只能访问在全w环境中定义的变量和函数，而不能直接访问局部环境中的任何数据；</p>

<p>□变的执行环境有助于确定应该何时释放内存。</p>

<p>JavaScript是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。可 以对JavaScript的垃圾收集例程作如下总结。</p>

<p>□离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。</p>

<p>□ “标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然 后再回收其内存。</p>

<p>口另一种垃圾收集算法是“引用计数&rdquo;，这种算法的思想是跟踪记录所有值被引用的次数。JavaScript 引擎H前都不再使用这种算法；但在IE中访问非原生JavaScript对象（如DOM元素）时，这种 算法仍然可能会导致问题。</p>

<p>□当代码中存在循环引用现象时，“引用计数”筲法就会导致问题。</p>

<p>□解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地凹 收内存，应该及时解除不冉使用的全局对象、全局对象属性以及循环引用变量的引用。</p>

    </div>

    
    

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05-%E5%9F%BA%E7%A1%80%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/js/js05-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">JS05 引用类型</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05-%E5%9F%BA%E7%A1%80%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/js/js03-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">
            <span class="next-text nav-default">JS03 基本概念</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="iteratelyd@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/iterateself" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/thebegin/activities" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/68028070/" class="iconfont icon-douban" title="douban"></a>
  <a href="http://iterate.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">iterateself</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>








</body>
</html>
