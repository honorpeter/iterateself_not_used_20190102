<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>JS14 表单脚本 - 迭代自己</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="iterateself" />
  <meta name="description" content="14 % 表单脚本 本章内容 □理解表单 □文本框验证与交互 □使川其他表单控制 JavaScript最初的一个应用，就是分担服务器处理表单的责任，打破处处" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.47.1" />


<link rel="canonical" href="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05-%E5%9F%BA%E7%A1%80%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/js/js14-%E8%A1%A8%E5%8D%95%E8%84%9A%E6%9C%AC/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="JS14 表单脚本" />
<meta property="og:description" content="14 % 表单脚本 本章内容 □理解表单 □文本框验证与交互 □使川其他表单控制 JavaScript最初的一个应用，就是分担服务器处理表单的责任，打破处处" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://iterate.site/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05-%E5%9F%BA%E7%A1%80%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/js/js14-%E8%A1%A8%E5%8D%95%E8%84%9A%E6%9C%AC/" /><meta property="article:published_time" content="2018-06-12T20:25:10&#43;00:00"/>
<meta property="article:modified_time" content="2018-06-12T20:25:10&#43;00:00"/>
<meta itemprop="name" content="JS14 表单脚本">
<meta itemprop="description" content="14 % 表单脚本 本章内容 □理解表单 □文本框验证与交互 □使川其他表单控制 JavaScript最初的一个应用，就是分担服务器处理表单的责任，打破处处">


<meta itemprop="datePublished" content="2018-06-12T20:25:10&#43;00:00" />
<meta itemprop="dateModified" content="2018-06-12T20:25:10&#43;00:00" />
<meta itemprop="wordCount" content="24479">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="JS14 表单脚本"/>
<meta name="twitter:description" content="14 % 表单脚本 本章内容 □理解表单 □文本框验证与交互 □使川其他表单控制 JavaScript最初的一个应用，就是分担服务器处理表单的责任，打破处处"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">迭代自己</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/catalog/">
        <li class="mobile-menu-item">完整目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">迭代自己</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/catalog/">完整目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">JS14 表单脚本</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-06-12 </span>
        
        <span class="more-meta"> 24479 words </span>
        <span class="more-meta"> 49 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#14">14 %</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      

<h5 id="14">14 %</h5>

<p>表单脚本</p>

<p>本章内容</p>

<p>□理解表单</p>

<p>□文本框验证与交互</p>

<p>□使川其他表单控制</p>

<p>JavaScript最初的一个应用，就是分担服务器处理表单的责任，打破处处依赖服务器的局面。尽 管目前的Web和JavaScript已经有了长足的发展，但Web表单的变化并不明显。由于Web表单</p>

<p>没有为许多常见任务提供现成的解决手段，很多开发人员不仅会在验证表单时使用JavaScirpt,而丑还 增强了一些标准表单控件的默认行为。</p>

<p>14.1表单的基础知识</p>

<p>在HTML中，表.单是由＜£0口11＞元素来表示的，而在JavaScript中，表单对应的则是HTMLForm-Element类型。HTMLFormElement继承了 HTMLElement,因而与其他HTML元素具有相同的默认属 性。不过，HTMLFormElement也有它自己下列独有的属性和方法。</p>

<p>□ acceptCharset ：服务器能够处理的字符集；等价于HTML中的accept-charset特性。</p>

<p>□ action：接受请求的URL;等价于HTML中的action特性。</p>

<p>□ elements：表单中所有控件的集合(HTMLCollection )。</p>

<p>□ enctype:请求的编码类组；等价于HTML中的enctype特性。</p>

<p>□ length：表单中控件的数!！；，</p>

<p>□ method:要发送的HTTP请求类塑，通常是&rdquo;get-或‘ipost”；等价于HTML的method特性。</p>

<p>口 name:表单的名称；等价于HTML的name特性。</p>

<p>□ reset ()：将所有表单域重S为默认值。</p>

<p>□ submit ():提交表单。</p>

<p>□ target:用于发送请求和接收响应的窗口名称；等价于HTML的target特性。</p>

<p>取得索引用的方式布好几种。其中最常见的方式就是将它看成与其他元索一样，并为其 添加id特性，然后再像下面这样使用getElementByldt)方法找到它。</p>

<p>var form = document.getElementById{&ldquo;forml&rdquo;);</p>

<p>其次，通过document, forms可以取得页面中所有的表单。在这个集合中，可以通过数值索引或 name值来取得特定的表单，如下面的例子所示„</p>

<p>var&rsquo; firstForm = document. forms [0];    //取得页面中的第一个表单</p>

<p>var myForm = document. forms [&rdquo; form2&rdquo; J ;    //取得页面+名称为 *form2 &ldquo;的表单</p>

<p>另外，在较早的浏览器或者那些支持向后兼容的浏览器中，也会把每个设置了 name特性的表单作 为属性保存在document对象中。例如，通过document.form2可以访问到名为&rdquo;form2&rdquo;的表单。不 过，我们不推荐使用这种方式：一是容易出错，二是将来的浏览器可能会不支持。</p>

<p>注意，可以同时为表单指定id和name属性，但它们的值不一定相同。</p>

<p>14.1.1提交表单</p>

<p>用户单击提交按钮或图像按钮时，就会提交表单。使用<1叩的>或<13此1；<^>都可以定义提交按钮, 只要将其type特性的值设置为’’submit ”即可，而图像按钮则是通过将<1叩此>的type特性值设置为 ■image••来定义的。因此，只要我们单击以下代码生成的按钮，就可以提交表单。</p>

<!--通用提交按钮-->

<p><input type="submit■ valuer"Submit Form"></p>

<p>&lt;!―自定义提交按缸—&gt;</p>

<p><button type="submit">Submit Form</button></p>

<!--困像按钮

<input type="image" src="graphic.gif">

只要表单中存在上面列出的任何一种按钮，那么在相应表单控件拥有焦点的情况下，按回车键就可 以提交该表单。(textarea是一个例外，在文本区中回车会换行。)如果表单里没有提交按钮，按回车 键不会提交表单。

以这种方式提交表单时，浏览器会在将请求发送给服务器之前触发submit事件。这样，我们就有 机会验证表单数据，并据以决定是否允许表单提交。阻止这个事件的默认行为就可以取消表单提交。例 如，下列代码会阻止表单提交。

var form = document .getEleroentBy工d< "myForm11);

EventUtil.addHandler(form, "submit*, function(event){

//取得事件对象

event = EventUtil.getEvent(event);

//担止默认事件

EventUtil.preventDefault(event);

});

这里使用了第13章定义的EventUtil对象，以便跨浏览器处理事件。调用prevetnDefault () 方法阻止了表单提交。•般来说，在表单数据无效而不能发送给服务器时，可以使用这一技术。

在JavaScript中，以编程方式调用submit ()方法也町以提交表单。而且，这种方式无需表单包含 提交按钮，任何时候都可以正常提交表单。来看一个例子。

var form = document.getElementById("myForra"):

//*交表单 toza. aubnlt ()；

在以调用submit ()方法的形式提交表单时，不会触发submit事件，因此要记得在调用此方法之 前先验证表单数据。

提交表单时可能出现的最大问题，就是重复提交表单。在第一次提交表单后，如果长时间没有反 应，用户可能会变得不耐烦。这时候，他们也许会反复.单击提交按钮。结果往往很麻烦(因为服务器 要处理重a的请求)，或者会造成错误(如果用户是下订单，那么可能会多订好几份)。解决这一问题 的办法#两个：在第一次提交表单肟就禁用提交按钮，或者利用onsubndt事件处理程序取消后续的 表单提交操作。

14.1.2重置表单

在用户单击重置按钮时，表单会被瓊置。使用type特性值为”reset'^J<input;^<button:^ 可以创建®置按钮，如下面的例子所示。

<!—通用重置按相+•->

<input type='reset* value="Reset Form">

< !--自定义重置按钮-胃>

<button type="reset">Reset Form</button>

这两个按钮都可以用來重置表单。在重置表单时，所有表单字段都会恢复到页面刚加载完毕时的初 始值。如果某个字段的初始值为空，就会恢复为空；而带有默认值的字段，也会恢复为默认值。

用户单击_«置按钮屯置表单时，会触发reset事件。利用这个机会，我们可以在必要时取消重置 操作。例如，下面展示f阻止重置表单的代码。

var form = document.getElementById("rnyForm");

EventUtil.addHandler(form, "reset", function(event){

//取得亨件对象

event = EventUtil.getEvent{event);

//阻止表单重置

EventUtil.preventDefault(event)；

});

与提交表单一样，也可以通过JavaScript来熏置表单，如下面的例子所示。 var form = document.getElementById("myForm")；

//重置表单

form.reset()/

与调用submit {)方法不同，调用reset ()方法会像单击重置按钮一样嫩发reset事件。

在Web表单设计中，重置表单通常意味着对已经填写的數据不满意。重置表单 经常会导致用户摸不着头脑，如果意外地触发了表单重置事件，那么用户甚至会很恼 火。事实上，玄置表单的需求是很少见的。更常见的做法是提供一个取消按組，让用 户能够田到苗一个页面，而不是不分青红皂白地重置表单中的所有值。

14.1.3表单字段

可以像访问页面中的其他元素-样，使用原生DOM方法访问表单元素。此外，每个表单都有

elements属性，该属性是表单中所有元素的集合。这个elements集合是一个有序列表，其中包含着 表单中的所有字段，例如＜1叩此＞、＜£6父亡31?63；＞、＜1＞«1:1；011＞和＜€161＜336亡:＞。每个表单字段在elements 集合中的顺序，与它们出现在标记中的顺序相同，可以按照位置和name特性来访问它们。下面来看一 个例子。

var form = document.getElementById(•forrol•)；

//取得表单中的第一个字段

var fieldl = form.elements(0]?

//取评名为"textboxl •的字段

var field2 = form.elements("textboxl");

//取得表单中包念的字役的数量

var fieldCount = form.elements.length;

如果有多个表单控件都在使用一个name （如单选按钮），那么就会返回以该name命名的一个 NodeList。例如，以下面的HTML代码片段为例。

![img](E:/11.ProgramFiles/Typora/JavaScriptd8a70b8fbea1082c34809-81.jpg)

 

<form method="post" id=*myFormn> <ul>

 

</ul>

</form>

 

<lixinput

<lixinput

<lixinput

 

type=-radio" type="radio" type="radio"

 

name="color" name="color" name="color"

 

value=■red">Red</1i > value="green">Green</li> value=*blue">Blue</li>

 

FormFieldsExampleOJ.htm

在这个HTML表单中，有3个单选按钮，它们的name都是”color'意味着这3个字段是一起的。 在访问elements [ "color** ]时，就会返回一下NodeList,其中包含这3个元素；不过，如果访问 elements [0],则只会返回第一个元素。来看下面的例子。

var form = document.getElementById("myForm");

var colorFields = form.elements("color"]? alert (colorFields. length) ；    "3

var firstColorField = colorFields[0]；

var firstFormField = form.elements[0];

alert(firstColorField === firstFormField}; //true

FormFieldsExampleOl. htm

以上代码显示，通过form.elements[0]访问到的第一个表单字段，与包含在form.elements [-color-]中的第一•个元素相同。

也可以通过访问表单的属性来访问元責，例如form[0]可以取得第一个表单字 段，而form[ "color"]则可以取得第一个命名字段。这些爲性与通过elements集 合访问到的元素是相同的。但是，我们应该尽可能使用elements,通过表单属性访 问元素只是为了与旧浏览器向后兼容而保留的一种过渡方式。

1.共有的表单字段厲性

除了＜fieldSet＞元素之外，所有表单字段都拥有相同的一组属性。由于＜input＞^型可以表示多 种表单字段，因此有栈属性只适用于某些字段，但还有一些属性是所有字段所共有的。表单字段共有的 屑性和方法如下。

□    disabled：布尔值，表示当前字段是否被禁用。

□    form：指向当前字段所属表单的指针；只读。

□    name：当前字段的名称。

□    readonly：布尔值，表示当前字段是否只读。

□    tablndex：表示当前字段的切换(tab)序号。

□    type：当前字段的类型，如"checkbox，、"radio",等等。

□    value：当前字段将被提交给服务器的值。对文件字段来说，这个属性是只读的，包含着文件 在计算机中的路径。

除了 form属性之外，可以通过JavaScript动态修改其他任何属性。来看下面的例子：

var form = document.getElementById("myForm"}; var field - form.'elements [0];

//修改value属性

field.value = "Another value"；

//检查form属性的值

alert(field.form    form}; //true

//把焦点设置到当前字段 field.focus()；

//禁用当前字段

field.disabled = true；

//修改type属性(不推荐，但对＜:11^111:＞来说是可行的) field.type = "checkbox"；

能够动态修改表单字段域性，意味着我们可以在任何时候，以任和J方式来动态操作表单。例如，很 多用户可能会重复单击表单的提交按钮。在涉及信用卡消费时，这就是个问题：因为会导致费用翻番。 为此，最常见的解决方案，就是在第一次单击后就禁用提交按钮。只要侦听submit事件，并在该事件 发生时禁用提交按钮即可。以下就是这样一个例子。

//进免多次提交表单

EventUtil.addHandler(form, ■submit", function(event){ event = EventUtil.getEvent(event)； var target = EventUtil.getTarget(event);

//取得提交按钮

var btn = target.elements[*submit-btn"J；

//禁用它

btn.disabled = true；

});

FormFieldsExample02, htm

以上代码为表单的submit事件添加了一个事件处理程序。事件触发后，代码取得了提交按钮 并将其disabled属性没置为true。注意.不能通过onclick事件处理程序来实现这个功能，原 因是不同浏览器之间存在“时差有的浏览器会在触发表单的submit事件之前触发click事件， 而有的浏览器则相反。对于先触发click事件的浏览器，意味赛会在提交发生之前禁用按钮，结果 永远都不会提交表单。因此，最好是通过submit事件来禁用提交按钮。不过，这种方式不适合表 单中不包含提交按钮的情况;如前所述，只有在包含提交按钮的情况下,才有可能触发表单的submit 事件。

除了＜fieldset＞之外，所有表单字段都有type属性。对于＜input＞元素，这个值等于HTML特 性type的值。对于其他元素，这个type属性的值如下表所列。

| 说    明         | HTML示例                           | type厲性的值      |
| ---------------- | ---------------------------------- | ----------------- |
| 单选列表         | <select>...</select>               | •select-one*      |
| 多选列表         | <select raultiple>...</select>     | "select-multiple" |
| 自定义按钮       | <button>...</button>               | "submit"          |
| 自定义非提交按钮 | <button type="button">..,</button> | ■button■          |
| A定义重置按钮    | <button type="reset■>..,</buton>   | ■reset"           |
| 自定义提交按钮   | <button type-"sul»nit■>...</buton> | •submit"          |

此夕卜，＜input;=^＜button＞元素的type属性是可以动态修改的，而＜5616(:(;＞元素的type属性 则是只读的。

2.共有的表单字段方法

每个表单字段都有两个方法：focus (＞和blur (＞。其中，focus ()方法用于将浏览器的焦点设置 到表单字段，即激活表单字段，使其可以响应键盘事件。例如，接收到焦点的文本框会显示插人符号， 随时可以接收输人。使用focus ()方法，可以将用户的注意力吸引到页面中的某个部位。例如，在页面 加载完毕后，将焦点转移到表单中的第-个字段。为此，可以侦听页面的load事件，并在该事件发生 时在表单的第一个字段上调用focus (＞方法，如下面的例子所示。

Eventutil.addHandler{windowz "load"/ function.(event){ document.forms[0].elements[0].focus(＞;

))；

要注意的是，如果第一个表单字段是一个＜input＞元素，且其type特性的值为■hidden，，那么 以上代码会导致错误。另外，如果使用CSS的display和visibility属性隐藏了该字段，同样也会 导致错误。

HTML5为表单字段新增了一个autofocus属性。在支持这个属性的浏览器中，只要设置这个屈性， 不用JavaScript就能自动把焦点移动到相应字段。例如：

＜input type="text" autofocus＞

为了保证前面的代码在设置autofocus的浏览器中正常运行，必须先检测是否设置了该属性，如 果设置了，就不用再调用focus () 了。

EventUtil.addHandler(window, "load", function(eventJ{ var element = document.forms[0].elements[0]；

if (element.autofocus I== true){

element.focus(); console.log(*JS focus");

}

}) ?

FocusExampleOl. htm

因为autofocus是一个布尔值展性，所以在支持的浏览器中它的值应该是true。(在不支持的浏 览器中，它的值将是空字符串。)为此，上面的代码只有在autofocus不等于true的情况下才会调用 focus 0 ,从而保证向前兼容o支持autofocus属性的浏览器有Firefox4+、Safari 5+、Chrome和Opera 9.6o

在默认情况下，只有表单字段可以获得焦点。对于其他元素而言，如果先将其 tablndex属性设置为-1,然后再调用focus (＞方法，也可以让这些元素获得焦点。 只有Opera不支持这种技术。

与focus ()方法相对的是blur ()方法，它的作用是从元素中移走焦点。在调用blur()方法时， 并不会把焦点转移到某个特定的元素上；仅仅是将焦点从调用这个方法的元索上面移走而已。在早期 Web开发中，那时候的表单字段还没有readonly特性，W此就可以使用blur ()方法来创建只读字段《= 现在，虽然需要使用blur ＜)的场合不多了，但必要时还可以使用的。用法如下：

document.forms[0].elements[0].blur(}；

3.共有的表单字段事件

除了支持献标、键盘、更改和IITML事件之外，所有表单字段都支持下列3个事件。

□    blur：当前字段失去焦点时触发。

□    change：对于＜input5^U＜textarea＞元素，在它们失去煤点且value值改变时触发；对于 ＜seleCt＞元素，在其选项改变时触发。

□    focus：当前字段获得焦点时触发。

当用户改变了当前字段的焦点，或者我们调用了 blur ()或focus (＞方法时，都可以触发blur和 focus事件。这两个事件在所有表单字段中都是相同的。但是，change事件在不同表单控件中触发的 次数会有所不同。对于元素，当它们从获得焦点到失去焦点.0. value值改变吋, 才会触发change事件。对于＜select＞元素，只要用户选择了不同的选项，就会触发change事件； 换句话说，不失去焦点也会触发change事件。

通常，可以使用focus和blur事件来以某种方式改变用户界面，要么是向用户给出视觉提示，要 么是向界面中添加额外的功能(例如，为文本框M示一个下拉选项菜单)。而change事件则经常用于 验证用户在字段中输人的数据。例如，假没有一个文本框，我们只允许用户输人数值。此时，可以利用 focus事件修改文本框的背景颜色，以便更清楚地衷明这个字段获得了焦点。可以利用blur事件恢复 文本框的背景颜色，利用change事件在用户输人了非数值字符时再次修改背景颜色。下面就给出了实 现上述功能的代码。

var textbox = document.forms[0).elements(0);

EventUtil.addHandler(textbox, "focus", function(event){ event = EventUtil .getEvent (event)，-

var target = EventUtil.getTarget(event)；

if (target.style.backgroundcolor != "red*){ target.style.backgroundColor = "yellow"；

}

});

EventUtil.addHandler(textbox, "blur", function(event){ event = EventUtil.getEvent(event); var target = EventUti1.getTarget{event);

if (/[^\d]/.test(target.value)){

target.style.backgroundcolor = "red*;

)else {

target.style.backgroundcolor = "•y

)

})；

EventUtil.addHandler(textbox, "change", function(event){ event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event);

if {/[A\d]/.test(target.value)〉{

target.style.backgroundcolor = "red"；

} else {

target.style.backgroundcolor =

}

}) A

FormFieldEventsExampleO l.htm

在此，onfocus事件处理程序将文本框的背景颜色修改为黄色，以清楚地表单当前字段已经激活。 随后，onblur和onchangc事件处理程序则会在发现非数值字符时，将文本框背景颜色修改为红色。 为了测试用户输入的是不是非数值，这里针对文本框的value属性使用了简单的正则表达式。而且， 为确保无论文本框的值如何变化，验证规则始终如一，onblur和onchange事件处理程序中使用了相 同的正则表达式。

关于blur和change事件的关系，并没有戸格的规定。在某些利览器中，blur 事件金先于change事件发生；而在其他浏览器中，则恰好相反。为此，不能假定这 两个事件总会以某种顺序依次触发，这一点要特别注意。

14.2文本框脚本

在HTML屮，有两种方式来表现文本框：一种是使用＜input＞元素的单行文本框，另一种是使用 多行文本框。这两个控件非常相似，而且多数时候的行为也差不多。不过，它们之间仍

然存在一些重要的区别。

要表现文本框，必须将＜input＞元素的type特性设置为"text-。而通过设置size特性，可以指 定文本框中能够显示的字符数。通过value特性，可以设置文本框的初始值，而maxlength特性则用 于指定文本框可以接受的最大字符数。如果要创建一个文本框，让它能够显示25个字符，但输人不能 超过50个字符，可以使用以下代码：

＜inpu二 type=ntext" size="25" maxlength-"50" value="initial value"＞

相对而言,＜textareaxJE索则始终会呈现为一个多行文本框。要指定文本框的大小，可以使用rows 和cols特性。其中，rows特性指定的是文本框的字符行数，而cols特性指定的是文本框的字符列数 (类似于＜1叩11＞元素的size特性)。与＜1叩北＞元素不同，＜textarea＞的初始值必须要放在

之间，如卜面的例子所示。

＜textarea rows-•25" cols="5"＞initial value＜/textarea＞

另一个与＜input:^K别在于，不能在HTML中给＜textarea＞指定最大字符数。

无论这两种文本框在标记中有什么区别，怛它们都会将用户输人的内容保存在value属性中。可

以通过这个属性读取和设置文本框的值，如下面的例子所示：

var textbox = document.forms[0].elements("textboxl"]; alert(textbox.value)；

textbox.value = "Some new value";

我们建议读者像h面这样使用value属性读取或设置文本框的值，不建议使用标准的DOM方法。 换句话说，不要使用setAttribute()设置＜input＞元素的value特性，也不要去修改＜textarea＞ 元素的第一个子节点。原因很简单：对value屑性所作的修改，不一定会反映在DOM中。因此，在处 理文本框的值时，最好不要使用DOM方法。

14.2.1选择文本

卜.述两种文本框都支持select ()方法，这个方法用于选择文本框中的所有文本。在调用select () 方法时，大多数浏览器(Opera除外)都会将焦点设S到文本框中。这个方法不接受参数，可以在任何 时候被调用。下面来看一个例子。

var textbox = document.forms[0].elements["textbox!"]； textbox.select()；

在文本框获得焦点时选择其所有文本，这是一种非常常见的做法，特别是在文本框包含默认值的时 候。因为这样做可以让用户不必一个一个地删除文本。下面展示了实现这-操作的代码。

EventUtil.addHandler{textbox, "focus"# function(event)( event = EventUtil.getEvent(event)； var target EventUtil.getTarget(event);

target.select();

});

TextboxSelectExampleOl. htm

将上面的代码应ffl到文本框之后，只要文木框获得焦点，就会选择其中所有的文本。这种技术能够 较大幅度地提升表单的易用性。

1.选择(select)事件

与select (＞方法对应的，是一个select事件。在选择了文本框中的文本时，就会触发select 事件。不过，到底什么时候触发select事件，还会因浏览器而异。在IE9+、Opera、Firefox、Chrome 和Safari中，只有用户选择了文本(而且要释放鼠标)，才会触发select.事件。而在IE8及更早版本中， 只要用户选择了一个字母(不必释放鼠标)，就会触发select事件。另外，在调用select <)方法时也 会触发select事件。下面是一个简单的例子。

var textbox = document,forms[0].elements[*textboxl”】； EventUtil.addHandler(textbox# "select”， function(event){

var alert("Text selected" + textbox.value);

))；

SelectEventExample01.htm

2.取得选择的文本

虽然通过select事件我们可以知道用户什么时候选择了文本，但仍然不知道用户选择了什么文本。 HTML5通过一些扩展方案解决了这个问题.以便更顺利地取得选择的文本。该规范采取的办法是添加 两个属性： selectionStart 和selectionEndo这两个属性中保存的是基于0的数值，表示柄选择 文本的范围(即文本选区开头和结尾的偏移《〉。因此，要取得用户在文本框中选择的文本，可以使用 如下代码。

function getSelectedText(textbox){

return textbox.value.substring(textbox.selectionStart, textbox,selectionEnd);

因为substring。方法基于字符串的偏移量执行操作，所以将selectionStart和 select ionEnd直接传给它就可以取得选中的文本。

IE9+、Firefox、Safari、Chrome和Opera都支持这两个属性。IE8及之前版本不支持这两个属性， 而是提供了另一种方案。

IE8及更早的版本中有一个document. selection对象，其中保存着用户在整个文档范围内选择 的文本信息；也就是说，无法确定用户选择的是页面中哪个部位的文本。不过，在与select事件一起 使用的时候，可以假定是用户选择了文本框中的文本，因而触发了该事件。要取得选择的文本，首先必 须创建一个范围(第12章讨论过)，然后再将文本从其中提取出来，如下面的例:了•所示。

function getSelectedText(textbox){

if (typeof textbox.selectionStart "number") {

return textbox.value.substring(textbox.selectionStart, textbox.selectionEnd)；

} else if (document.selection){

return document.selection.createRange().text;

TextboxGetSelectedTextExampleOl. htm

这里修改了前面的函数，包括f在IE中取得选择文本的代码。注意，调用document, select ion Bt,不需要考慮textbox参数。

3.选择部分文本

HTML5也为选择文本框中的部分文本提供了解决方案，即最早由Firefox引人的 setSelectionRange ()方法。现在除select {)方法之外，所有文本框都有一个setSelectionRange () 方法。这个方法接收两个参数：要选择的第4字符的索引和要选择的最后一个字符之后的字符的索引 (类似于substring ()方法的两个参数)。来看一个例子。

textbox.value = "Hello world!

//选择所有文本

textbox, set Select ionRange (0 f textbox, value, length) ； /"Hello world!"

//选择前3个字符

textbox.setSelectionRange(0, 3);    //"Hel"

//选择第4到第6个字符

textbox.setSelectionRange(4y 7);    //"o w"

要看到选择的文本，必须在调用setSelect ionRange ()之前或之后立即将焦点设置到文本框。 IE9、Firefox、Safari、Chrome 和 Opera支持这种方案。

IE8及更弔版本支持使用范围(第12章讨论过)选择部分文本。要选择文本框中的部分文本，必须 首先使用IE在所有文本框上提供的createTextRangeO方法创建一个范围，并将苏故在恰当的位置 上。然后，再使用moveStartO和moveEndG这两个范围方法将范围移动到位。不过，在调用这两个 方法以前，还必须使用col lapse ()将范围折叠到文本框的开始位置。此时，moveStarU)将范围的起 点和终点移动到了相同的位置，只要再给moveEndO传人要选择的字符总数即可。最后一•步，就是使 用范围的select ()方法选择文本，如下面的例子所示。

textbox.value = "Hello world!";

var range = textbox.createTextRange();

//选择所有文本

range.collapse(true);

range.movestart("character-, 0);

range.moveEnd("character", textbox.value.length)；    //"Hello world!■

range.select();

//选择前3个字符

range.collapse{true)；

range.moveStart("character", 0);

range.moveEnd("character-, 3)；

range.select();    //"Hel"

//选择第4到第6个字符

range.collapse(true)；

range.moveStart("character"r 4);

range.moveEnd("character"r 3);

range.select()?    //"o w”

与在其他浏览器中一样，要想在文本框中看到文本被选择的效果，必须让文本框获得焦点。 为了实现跨浏览器编程，可以将上述两种方案组合起来，如下面的例子所示。

function selectText(textboxy startIndex, stoplndex){ if (textbox.setSelectionRange){

textbox.setSelectionRange(startIndex, stoplndex);

} else if (textbox.createTextRange){

var range = textbox.createTextRange()? range.collapse(true};

range.moveStart("character", startlndex);

range.moveEnd("character", stoplndex - startIndex};

range.select();

textbox.focus();

}

TextboxPartialSelectionExampleOl. htm

这个selectTextO涵数接收三个参数：要操作的文木框、要选择文本中第一个字符的索引和要选 择文本中最后一个字符之后的索引。首先，函数测试了文本框是否包含setSelectionRangeO方法。 如果有，则使用该方法。否则，检测文本框是否支持createTextRangeO方法。如果支持，则通过创 建范W来实现选择。最后一步，就是为文本框设置焦点，以便用户看到文本框中选择的文本。可以像下 面这#selectText 法。

textbox.value = "Hello world!"

//选择所有文本

selectText (textbox, 0, textbox.value, length); /"Hello world!"

//选择前3个字符

selectText(textbox, 0, 3)?    //"Hel"

//选择第4到第6个字符

selectText(textbox, 4, 7);    //"o w"

选择部分文本的技术在实现髙级文本输入框时很有川，例如提供自动完成建议的文本框就可以使用 这种技术。

14.2.2过滤输入

我们经常会要求用户在文本框中输人特定的数据，或者输人特定格式的数据。例如，必须包含某些 宇符，或者必须匹配某种模式。由于文本框在默认情况K没有提供多少验证数据的手段，因此必须使用 JavaScript来完成此类过滤输人的操作。而综合运用事件和DOM手段，就可以将普通的文本框转换成能 够理解用户输入数据的功能型控件。

1.屏蔽字符

有时候，我们需要用户输人的文本中包含或不包含某些字符。例如，电话号码中不能包含非数值字 符。如前所述，响应向文本框中插人字符操作的是keypress事件。因此，可以通过阻止这个事件的默 认行为来屏蔽此类字符。在极端的情况下，可以通过下列代码屏蔽所有按键操作。

EventUtil.addHandler(textbox, "keypress", function(event){ event = EventUCil.getEvent(event);

EventUtil.preventDefault(event);

})；

运行以上代码后，由于所有按键操作都将被屏蔽，结果会导致文本框变成只读的。如果只想屏蔽特 定的字符，则需要检测keypress ；#件对的字符编码，然后再决定如何响应。例如，下列代硏只允许 用户输人数值。

EventUtil.addHandler(textbox, "keypress", function(event){ event = EventUtil.getEvent(event);

var target 醒 EventUtil.getTarget(event): var charCode = EventUtil.getCharCode(event);

if (I/\d/.teat(String.fromCharCode(charCode))){

RventUtil.preventDefault(event)；

)

});

在这个例子中，我们使用EventUtil.getCharCodeG实现了跨浏览器取得字符编码。然后，使 用String. fromCharCodeG将字符编码转换成字符串，再使用正则表达式八d/来测试该字符串，从 而确定用户输人的是不是数值。如果测试失败，那么就使用EventUtil .preventDefault ()屏蔽按键 事件。结果，文本框就会忽略所有输人的非数值。

虽然埋论上只应该在用户按下字符键时才触发keypress事件，但有些浏览器也会对其他键触发此 事件。Firefox和Safari (3.1版本以前)会对向上键、向下键、退格键和删除键触发keypress事件； Safari 3.1及更新版本则不会对这*键触发keypress事件。这意味着，仅考虑到屏蔽不是数值的字符还 不够，还要避免屏蔽这些极为常用和必要的键。所幸的是，要检测这些键并不困难。在Firefox中，所 有由非字符键触发的keypress事件对应的字符编码为0,而在Safari 3以前的版本中，对应的字符编 码全部为8。为了it代码更通用，只要不屏蔽那些字符编码小于10的键即可。故而，可以将上面的函数 重写成如下所示。

Eventutil.addHandler(textbox, "keypress", function(event){ event = EventUtil.getEvent(event)； var target = EventUtil.getTarget(event); var charCode = EventUtil.getCharCode(event)；

if (1/\d/.teat(String.fromCharCode(charCode)> && charCode > 9){

EventUtil .preventDefault (event) '•

)

}>；

这样，我们的事件处理程序就可以适用所有浏览器了，即可以屏蔽非数值字符，但不屏蔽那些也会 触发keypress事件的基本按键。

除此之外，还有一个问题需要处理：复制、粘贴及其他操作还要用到Ctrl键。在除IE之外的所有 浏览器中，前面的代码也会屏蔽Ctrl+C、Ctrl+V,以及其他使用Ctrl的组合键。因此，最后还要添加一 个检测条件，以确保用户没冇按下Ctrl键，如下面的例子所示。

EventUtil.addHandler{textbox, "keypress", function(event){ event = EventUtil.getEvenc(event); var target = EventUtil.getTarget{event}; var charCode = EventUtil.getCharCode(event);

if (I/\d/.teat(String.froaaCharCode(charCode))    charCode > 9

1event.ctrlKey){

EventUtil.preventDefault(event);

}

TextboxInputFUteringExampleO l.htm

经过最后一点修改，就nf以确保文本框的行为完全正常了。在这个例子的基础上加以修改和调整， 就可以将同样的技术运用于放过和屏蔽任何输人文本框的字符。

2.操作剪貼板

IE是第一个支持与剪贴板相关事件，以及通过JavaScript访问剪貼板数据的浏览器。IE的实现成为 了事实上的标准，不仅Safari 2、Chrome和Firefox 3也都支持类似的事件和剪貼板访问(Opera不支持

通过JavaScript访问剪贴板)，HTML5后来也把剪贴板事件纳人了规范。下列就是6个剪贴板事件。

□    be forecopy ：在发生复制操作前触发。

□    copy:在发生复制操作时触发。

口 beforecut:在发生剪切操作前触发。

□    cut:在发生剪切操作时触发。

□    beforepaste：在发生粘贴操作前触发。

□    paste：在发生粘贴操作时触发。

由于没冇针对剪贴板操作的标准，这些事件及相义对象会因浏览器而异。在Safari、Chrome和Firefox 中，beforecopybeforecut和beforepaste事件只会在拯水针对文本框的上下文菜单(预期将发 生剪贴板事件)的情况下触发。但是，IE则会在触发copy、cut和paste事件之前先行触发这些事件。 至于copy、cut和paste事件，只要是在上下文菜单中选择了相应选项，或者使用了相应的键盘组合 键，所有浏览器都会触发它们。

在实际的事件发生之前，通过beforecopy、be forecut和beforepaste事件可以在向剪贴板发 送数据，或者从剪贴板取得数据之前修改数据。不过，取消这些事件并不会取消对剪贴板的操作——只 有取消copy、cut和paste事件，才能阻ll:相应操作发生。

要访问剪贴板中的数据，可以使用clipboardData对象：在IE中，这个对象是window对象的 属性；而在Firefox 4+、Safari和Chrome巾，这个对象是相应event对象的厲性。'但是，在Firefox、 Safari和Chorme中，只有在处理剪贴板事件期间clipboardData对象才冇效，这是为了防止对剪贴板 的未授权访问；在IE中，则可以随时访问clipboardData对象。为了确保跨浏览器兼容性，最好只 在发生剪贴板事件期间使用这个对象。

这个 clipboardData 对象有三个方法：getData (＞、setData ()和 clearData ()。其中，getData () 用于从剪贴板中取得数据，它接受•个参数，即要取得的数据的格式。在IE中，有两种数据格式："text" 和-URL"。在Firefox、Safari和Chrome中，这个参数是一种MIME类型；不过，可以用"text•代表 ■text/plain"。

类似地，setDataO方法的第一个参数也是数据类型，第二个参数是要放在剪贴板中的文本。对于 第一个参数，IE照样支持lext’1和”URL、而Safari和Chrome仍然只支持MIME类型。但是，与 getData ()方法不同的是，Safari和Chrome的56[03&3()+方法不能识别'呔6*1:"类型＜:这两个浏览器在 成功将文本放到剪贴板中后.都会返囬true;否则，返回falseo为了弥合这些差异，我们可以向 EventUtil中再添加下列方法。

var EventUtil = {

//冰略的代码

gotClipboardText: function(event){

var clipboardData ■ (event.clipboardData II window.clipboardData)t return clipboardData.getData("text");

//省略的代码

setClipboardText: function(event, value){ if (event.clipboardData){

return event.clipboardData.setData("text/plainM, value);

)else if (window.clipboardData){

return window.clipboardData.setData("text"< value)?

)

//省略的代码

EventUtil.js

这里的getClipboardText (}方法相对简单；它只要确定clipboardData对象的位置，然后再 以"text•类型调用getData<)方法即可。相应地，setClipboardText ()方法则要稍微复杂一些。在 取得clipboardData对象之后，需要根据不同的浏览器实现为setData ()传人不同的类型(对于Safari 和 Chrome,是"text/plain";对于 IE,是"text" )o

在需要确保粘贴到文本框中的文本中包含某些字符，或者符合某种格式要求时，能够访问剪贴板是非 常有用的。例如，如果斗文本框只接受数值，那么就必须检测粘贴过来的值，以确保有效。在paste 事件中，可以确定剪贴板中的值是否有效，如果无效，就可以像下面示例中那样，取消默认的行为。

EventUtil.addHandler(textbox, "paste", function(event){

I    event = EventUtil,getEvent(event);

var text = EventUtil.getClipboardText(event):

if (JZz'\d*$/.test(text)) {

EventUtil.preventDefault(event)；

})；

TextboxClipboardExampleOl. htm

在这里，onpaste事件处理程序可以确保只有数值才会被粘貼到文本框中。如果剪贴板的值与正 则表达式不匹配，则会取消粘贴操作。Firefox, Safari和Chrome只允许在onpaste事件处理程序巾访 问 getData ()方法。

由于并非所有浏览器都支持访问剪贴板，所以更简单的做法是屏蔽一或多个剪贴板操作。在支持 copy、cut和paste事件的浏览器中(IE、Safari、Chrome和Firefox 3及更商版本)，很容易阻止这些 事件的默认行为。在Opera中，则需要阻止那些会触发这些事件的按键操作，同时还要阻止在文本框中 显示上下文菜单。

14.2.3自动切换焦点

使用JavaScript可以从多个方面增强表单字段的易用性。艽中，最常见的-种方式就是在用户填写 完当前字段时，自动将焦点切换到下一个字段。通常，在自动切换焦点之前，必须知道用户已经输人了 既定长度的数据(例如电话号码)。例如，美国的电话号码通常会分为三部分：区号、局号和另外4位 数字。为取得完整的电话号码，很多网页中都会提供下列3个文本框：

<input type?text" name="tell * id="txtTellB maxlength= * 3■>

<input type="text" name="tel2" id="txtTel2" maxiength=■3■>

<input type="text" name=-tel3 * id="txtTel3" maxiength=•4■>

Textbox TabForwardExampleOl. htm

为增强易用性，同吋加快数据输人，可以在前一个文本框中的字符达到最大数毡后，自动将焦点切 换到下一个文本框。换句话说，用户在第-•个文本框中输入了 3个数字之后，焦点就会切换到第一个文 本框，再输人3个数字，焦点又会切换到第三个文本框。这种“自动切换焦点”的功能，可以通过下列 代码实现：

{function()(

function tabForward(event){

event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event);

if (target.value.length == target.maxLength){ var form = target.form；

for (var i=0, 1 en.= form.elements.length; i < len； i+ + ) { if (form.elements[i] == target) {

if (form.elements[i+1]){

form.elements[i+l].focus()；

}

return；

}

var textboxl = document.getElementById(’ txtTell*)； var textbox2 = document. get Element By Id (* txtTel2 ••); var textbox3 = document.getElementById("txtTel3")；

EventUtil.addHandler(textboxl, "keyup■, tabForward)； EventUtil.addliandler {textbox2x "keyup", tabForward); EventUtil.addllandler(textbox3# "keyup", tabForward)；

}) 0 ?

TextboxTabForwardExampleOl. htm

开始的tabForward UW数是实现“自动切换焦点”的关键所在。这个函数通过比较用户输人的值 与文本框的maxlength特性，可以确定是否已经达到最大长度。如果这两个值相等（因为浏览器最终 会强制它们相等，因此用户绝不会多输人字符），则耑要査找表单字段集合，直虽找到下一个文本框。 找到下一个文本框之后，则将焦点切换到该文木框。然后，我们把这个函数指定为每个文本框的onkeyup 事件处理程序。由于keyup事件会在用户输人了新字符之后触发，所以此时是检测文本框中内容长度 的最佳时机。这样一来，用户在填写这个简单的表单时，就不必再通过按制表键切换表单字段和提交表 单了。

不过溝记住，这些代码只适用于前面给出的标记，而II没有考應隐藏字段=

14.2.4 HTML5 约束验证 API

为了在将表单提交到服务器之前验证数据，HTML5新增了一些功能。有了这些功能，即便JavaScript 被禁用或者由于种种原因未能加载，也可以确保基本的验证。换句话说，浏览器自己会根据極记中的规 则执行验证，然后自己显示适当的错误消息（完全不用JavaScript插手）。当然，这个功能只有在支持 HTML5这部分内容的浏览器中才有效，这些浏览器有Firefox 4+、Safari 5+、Chrome和Opera 10+。

只有在某些怙况下表单字段冰能进行A动验证。具体来说，就是要在HTML标记中为特定的字段 指定一些约束，然后浏览器才会0动执行表单验证。

\1.    必填字段

第--种情况是在表单字段中指定了 required属性，如下而的例子所示：

<input type="textname="username" required〉

任何标注有required的字段，在提交表单时都不能空着。这个属性适用于〈input〉、<textarea> 和<select>字段（Opera 11及之前版本还不支持〈select>的required屈性）。在JavaScript中，通过 对应的required属性，可以检査某个表单字段是否为必填字段。

var isUsernameRequired = document.forms[0J.elements["username°].required；

另外，使用下面这行代码可以测试浏览器是否支持required属性。

var isRequiredSupported = "required" in document.createElement（"inputM;

以上代码通过特性检测来确定新创建的<input;>%索中是否存在required属性。

对于空着的必填字段，不同浏览器有不同的处理方式。卩1«^»4和01^!»11会阻止表雄提交并在相 应字段下方弹出帮助框，而Safari （5之前）和Chrome （9之前）则什么也不做，而且也不阻止表单提

交。

\2.    其他输入类型

HTML5 *<inPut>元索的type滅性又增加了几个值。这些新的类型不仅能反映数据类型的信息， 而且还能提供一拽默认的验证功能。其屮，和是两个得到支持最多的类型，各浏览器也 都为它们增加丫定制的验证机制。例如：

<input type="email■ name email■>

<input type="url" name="homepage">

顾名思义，"email"类型要求输人的文本必须符合电子邮件地址的模式，而■url•‘类型要求输入的 文本必须符合URL的模式。不过，本节前面提到的浏览器在恰当地匹配模式方面都存在问题。最明显 的是会被当成一个有效的电子邮件地址。浏览器开发商还在解决这些问题。

要检测浏览器是否支持这些新类铟，可以在JavaScript创建一f<input>元素，然后将type属性 设H为-email”或•url»,最后再检测这个域性的值。不支持它们的IH版本浏览器会自动将未知的值设 置为“text”，而支持的浏览器则会返回正确的值。例如：

var input = document.createElement（■input"}; input.type = "email"；

var isSmailSupported = （input.type =- "email"）;

要注意的是，如果不给<1叩此>元素设置required «性，那么空文本框也会验证通过。另一方面， 设置特定的输人类型并不能阻止用户输人无效的值，只是应用某些默认的验证而已。

\3.    数值范围

除了’•email"和“urV，HTML5还定义了另外几个输人元素：，这几个元素都要求填写某种基于数

字的值：•number", "range", "datetime", "datetime-local", ’date”、"month"、"week", 还有•time-。浏览器对这几个类型的支持情况并不好，闪此如果真想选用的话，要特别小心。目前， 浏览器开发商主要关注更好的跨平台兼容性以及更多的逻辑功能。因此，本节介绍的内容某种程度上有 呰超前，不一定马上就能在实际开发中使用。

对所右这些数值类型的输人元索，可以指定min属性(最小的可能值)、max属性(最大的可能值) 和step属性(从min到max的两个刻度间的差值)。例如，想让用户只能输人0到100的值，而且这 个值必须是5的倍数，可以这样写代码：

<input type="number" min="0" max="100" step="5" name="count">

在不同的浏览器中，可能会也可能不会看到能够白动递增和递减的数值调节按钮(向上和向下按

钮)。

以上这驻属性在JavaScript中都能通过对应的元素访问(或修改)。此外，还有两个方法：stepupf) 和stepDownO,都接收一个可选的参数：要在当前值基础上加上或减去的数值。(默认是加或减1。) 这两个方法还没有得到任何浏览器支持，仴下面的例子演示了它们的用法。

input.stepDown(10)； //减10

4.输入模式

HTML5为文本字段新增了 pattern属性。这个属性的值是一个正则表达式，用于匹配文本框中的 值<：例如，如果只想允许在文本字段屮输人数值，可以像下面的代码-样应用约束：

<input type="texc" pattern="\<3+* name= "count">

注意，模式的开头和末尾不用加"和$符号(假定已经有了)。这两个符号表示输人的值必须从头到 尾都与模式闪配。

与其他檢人类型相似，指定pattern也不能阻止用户输人无效的文本。这个模式应用给值，浏览 器来判断值是有效，还是无效。在JavaScript巾可以通过pattern属性访问模式。

var pattern - document.forms[0】.elementsI"count■】.pattern;

使用以下代码可以检测浏览器是否支持pattern属性。

var isPatternSupported = "pattern*1 in document. createSlement (" input")；

5.检測有效性

使用checkValidityO方法可以检測表单中的某个字段是否有效。所有表单字段都有个方法，如 果穿段的值有效，这个方法返冋true,否则返回false。字段的值足否有效的判断依据是本节前面介 绍过的那些约束。换句话说，必填字段中如果没有值就是无效的，而字段中的值与pattern属性不匹 配也是无效的。例如：

if (document.forms[0】.elements[0].checkValidity{)){

//字段有效，继续

} else {

//字段无效

要检测幣个表卑是否有效，可以在表单自身调用checkValidity (>方法<，如果所有表单字段都有 效，这个方法返冋true;即使有-个字段无效，这个方法也会返回Ealseo

if(document.forms[0].checkValidity()){

//表单有效，继续 } else {

//表单无效

}

与checkValidity<)方法简单地吿诉你字段是否布效相比，validity属性则会吿诉你为什么字 段苻效或无效。这个对象巾包含一系列《性，每个属性会返回一个布尔值。

□    customError :如果设置了 setCustomValidity (),则为 true,否贝G返回 false。

□    patternMismatch：如果值与指定的pat tern属性不匹配，返冋true。

口 rangeOverf low：如果值比max值大，返回true。

□    rangeUnderf 1 ow：如果值比min 值小，返回 true。

□    stepMisMatch：如果min和max之间的步长值不合理，返回trueo

□    tooLong：如果值的长度超过了 maxi eng[h属性指定的长度，返回true。有的浏览器(如Firefox4) 会自动约束字符数量，因此这个值可能永远都返回false。

□    typeMismacch：如果值不是"mail ••或Murl”要求的格式，返回true。

□    valid：如果这里的其他/滅性都是false,返回true。checkValidity ()也要求相同的值。

□    valueMissing：如果标注为required的字段中没存值，返回true。

因此，要想得到更具体的信息，就应该使用validity属性来检测表单的有效性。下面是一个例子。

if (input.validity && !input.validity.valid){ if (input.validity.valueMissing){

alert("Please specify a value.")

} else if (input.validity.typeMismatch){

alert ("Please enter an email address. **);

} else {

alert ("Value is invalid.”；

}

6.禁用验证

通过设置invalidate属性，可以吿诉表单不进行验证。

<form method-"post" action="signup.php" novalidate>

< i --这里插入表单元责-->

<p></form></p>

<p>在JavaScript中使用noValidate属性可以取得或设置这个值，如果这个属性存在，值为tsrue, 如果不存在，值为false。</p>

<p>document. forms [0] .noValidate - true； //禁用验证</p>

<p>如果一个表单中有多个提交按钮，为了指定点击某个提交按钮不必验证表单，可以在相应的按钮上 添加 formnova 1 idate 属性。</p>

<form method="post" action="foo.php">

<!--这里插入表单元素一>

<input type-M submit" value="Regular Submit">

<input type="submit" formnova1Idate name«nbtnNoV«lidato" valuer"Non-validating Submit">

</form>

<p>在这个例子中，点击第一个提交按钮会像往常一样验证表单，而点击第二个按钮则会不经过验证而 提交表单。使用JavaScript也可以设置这个属性。</p>

<p>//禁用狯证</p>

<p>document.forms[0].elements【&rdquo;btRNoValidate&rdquo;]•formNoValidate = true；14.3选择框脚本</p>

<p>选择框是通过<3^6011>和<0£)1^011>元素创建的。为了方便与这个控件交互，除了所有表单字段共 有的属性和方法外，HTMLSelectElement类型还提供了下列属性和方法。</p>

<p>□    a&amp;i{neMOption, relCption):向控件中插人新<option>jii素，其位置在相关项(reJOption ) 之前。</p>

<p>□    multiple:布尔值，表示是否允许多项选择；等价于HTML中的multiple特性。</p>

<p>□    options:控件中所有<option>元素的 HTMLCollection。</p>

<p>□    remove (index):移除给定位置的选项。</p>

<p>□    selectedlndex：基于0的选中项的索引，如果没有选中项，则值为-1。对于支持多选的控件,• 只保存选中项中第一项的索引。</p>

<p>□    size：选择框中可见的行数；等价于HTML中的size特性。</p>

<p>选择框的type属性不是-select-one&rdquo;，就是&rdquo;select-multiple”，这取决于HTML代码中有 没有multiple特性。选择框的value属性由当前选中项决定，相应规则如下。</p>

<p>□如果没有选中的项，则选择框的value属性保存空字符串。</p>

<p>□如果有一个选中项，而且该项的value特性已经在HTML中指定，则选择框的value属性等 于选中项的value特性。即使value特性的值是空字符串，也同样遵循此条规则。</p>

<p>□如果有一个选中项，但该项的value特性在HTML中未指定，则选择框的value属性等于该 项的文本。</p>

<p>□如果有多个选中项，则选择框的value属性将依据前两条规则取得第一个选中项的值。</p>

<p>以下面的选择框为例：</p>

<p><select nane="location" id="selLocati.on"></p>

<p><option value:"Sunnyvale, CA">Sunnyvale</option></p>

<p><option value-"Los Angeles, CA">Los Angeles</option></p>

<p><option value= *Mountain View, CA">Mountain View</option></p>

<p><option value="B>China</option></p>

<p><option>Australia</option></p>

<p></select></p>

<p>如果用户选择了其中第一项，则选择框的值就是&rdquo;Sunnyvale, CA&rdquo;。如果文本为”China&rdquo;的选项 被选中，则选择框的值就是、个空字符串，W为其value特性是空的。如果选择了最后一项，那么由 于<option>中没有指定value特性，则选择框的值就是11Australia*。</p>

<p>在DOM中，每个<option>元素都有一个HTMLOptionElement对象表示。为便于访问数据， HTMLOptionElement对象添加了下列属性：</p>

<p>□    index：当前选项在options集合中的索引。</p>

<p>□    label:当前选项的标签；等价于HTML中的label特性。</p>

<p>□    selected：布尔值，表示当前选项是否被选中。将这个属性设置为true可以选中当前选项。</p>

<p>□    text：选项的文本。</p>

<p>□    value：选项的值（等价于HTML中的value特性）:，</p>

<p>其中大部分属性的目的，都是为了方便对选项数据的访问。虽然也可以使用常规的DOM功能来访 问这些信&rsquo;息，但效率是比较低的，如下面的例子所示：</p>

<p>var selectbox = document.forms[0]. elements[&ldquo;location&rdquo;];</p>

<p>//不拉芩</p>

<p>var text = selectbox. opt ions [0] . f irstChild.nodeValue；    //选项的文本</p>

<p>var value = selectbox.options [0] .getAttribute{ &ldquo;value&rdquo;）;    //选^5的值</p>

<p>以上代码使用标准DOM方法，取得了选择框中第~项的文本和值。可以与下面使用选项属性的代 码作一比较：</p>

<p>var selectbox = document.forms[0]. elements[&ldquo;location&rdquo;];</p>

<p>&ldquo;推存</p>

<p>var text = selectbox.options [0] .text;    //选项的文本</p>

<p>var value = selectbox. opt ions [0] .value;    &ldquo;选項的值</p>

<p>在操作选项时，我们建议最好是使用特定于选项的属性，因为所有浏览器都支持这些属性。在将表 单控件作为DOM节点的愔况下，实际的交互方式则会因浏览器而异。我们不推荐使用标准DOM技术 修改<opt ion>JE素的文本或者值。</p>

<p>最后，我们还想提醒读者注意一点：选择框的change事件与其他衷单字段的change事件触发的 条件不一样=其他表单字段的change事件是在值被修改且焦点离开当前字段时触发，而选择框的 change亊件只要选屮了选项就会触发。</p>

<p>不同浏览器下r选项的value属性返回什么值也存在差别。但是，在所有浏览 器中，value属性始终等于value特性。在未指定value特性的情况下，IE8会返 回空字符串，而JE9+、Safari、Firefox、Chrome和Opera则会返回与text特性相同 的值。-</p>

<p>14.3.1选择选项</p>

<p>对于只允许选择一项的选择框，访问选中项的最简单方式，就是使用选择框的selectedindex届 性，如下面的例子所示：</p>

<p>var selectedOption = selectbox.options[selectbox.seleccedlndex];</p>

<p>取得选中项之后，可以像下面这样显示该选项的信息：</p>

<p>var selectedlndex = selectbox.selectedlndex；</p>

<p>var selectedOption = selectbox.options[selectedlndex];</p>

<p>alert(&ldquo;Selected index： • + selectedlndex + 0\nSelected text: * +</p>

<p>selectedOption. text + &ldquo;\nSelected value： &ldquo; +• selectedOption.value)；</p>

<p>SelectboxExample01.htm</p>

<p>这里，我们通过一个警告框显示f选中项的索引、文本和值。</p>

<p>对于可以选择多项的选择框，seleccedfindex属性就好像只允许选择一项一样。设置 selectedlndex会导致取消以前的所有选项并选择指定的那一项，而读取seleccedlndex则只会返 回选中项中第一项的索弓I值。</p>

<p>另一种选择选项的方式，就是取得对某一项的引用，然后将其selected属性设置为true。例如， 下面的代W会选中选择框中的第一项：</p>

<p>selectbox.options(01.selected = true；</p>

<p>与selectedlndex不同，在允许多选的选择框中设置选项的selected属性，不会取消对其他选中项 的选择，因而可以动态选中任意多个项。但是，如果是在单选选择枢中，修改某个选项的selected属性则 会取消对其他选项的选择。需要注意的是，将selected属性设置为false对单选选择框没有影响。</p>

<p>实际上，selected属性的作用主要是确定用户选择了选择框中的哪一项。要取得所冇选中的项， 可以循环遍历选项集合，然后測试每个选项的selected域性。来看下面的例子。</p>

<p>function getSelectedOptions(selectbox){ var result = new Array(); var option = null；</p>

<p>for {var i=0# len=selectbox.options.length； i &lt; len； i++){ option = selectbox.options[i]; if (option.selected){</p>

<p>result.push(option)；</p>

<p>)</p>

<p>}</p>

<p>return result；</p>

<p>}</p>

<p>SelectboxExample03. htm</p>

<p>这个函数可以返回给定选择框中选中项的•个数组。首先，创建一个将包含选中项的数组，然后使 用for循环迭代所有选项，同时检测每一项的selected属性，如果有选项被选中，则将其添加到 result数组中。最后，返回包含选中项的数组。下面是一&rdquo;使用getSelectedOptions (＞函数取得 选中项的示例。</p>

<p>var selectbox = document.getElementByld(&ldquo;selLocation&rdquo;);</p>

<p>var selectedOptions = getSelectedOptions(selectbox)；</p>

<p>var message = M■；</p>

<p>for (var i=0, len=selectedOptions.length； i &lt; len; i++){</p>

<p>message +- &ldquo;Selected index:&ldquo;十 selectedOptions[i].index +</p>

<p>•\nSelected text: &ldquo; + selectedOptions[i].text +</p>

<p>&ldquo;\nSelected value: &ldquo; + selectedOptions[i].value +</p>

<p>}</p>

<p>alert(message);</p>

<p>SelectboxExample03. htm</p>

<p>在这个例子中，我们首先从一个选择框中取得了选中项。然后，使用for循环构建了一条消息，包 含所有选中项的信息：每一项的索引、文本和值。这种技术适用于单选和多选选择框。</p>

<p>14.3.2添加选项</p>

<p>可以使用JavaScript动态创建选项，并将它们添加到选择框中。添加选项的方式有很多，第一种方 式就是使用如下所示的DOM方法。</p>

<p>var newOption = document.createElement(&ldquo;option&rdquo;);</p>

<p>newOption.appendChild(document.createTextNode(&ldquo;Option text&rdquo;));</p>

<p>newOption.setAttribute&lt;&ldquo;value&rdquo;, &ldquo;Option value&rdquo;);</p>

<p>selectbox.appendChild(newOption);</p>

<p>SelectboxExample04. htm</p>

<p>以上代码创建了一个新的＜Option＞元素，然后为它添加了一个文本节点，并设肾其value特性， 最后将它添加到了选择框中。添加到选择框之后，用户立即就可以看到新选项=</p>

<p>第二种方式是使用Option构造函数来创建新选项，这个构造函数是DOM出现之前就有的，一 直遗留到现在。Option构造函数接受两个参数：文本(text)和值(value);第二个参数可选。 虽然这个构造函数会创建一个Object的实例，但兼容DOM的浏览器会返回一个＜option＞元素。 换句话说，在这种情况下，我们仍然可以使用appendChildO将新选项添加到选择框中。来看下面 的例子。</p>

<p>var newOption = new Option(&ldquo;Option text&rdquo;, &ldquo;Option value&rdquo;)； select box. appendChild (newOpt ion);    //在 IE8 及之前版本中有问题</p>

<p>SelectboxExampleQ8. htm</p>

<p>这种方式在除IE之外的浏览器中都可以使用u由于存在bug, IE在这种方式下不能正确设置新选 项的文本。</p>

<p>第三种添加新选项的方式是使用选择框的add ()方法。DOM规定这个方法接受两个参数：要添加 的新选项和将位于新选项之后的选项。如果想在列表的最后添加-•个选项，应该将第二个参数设置为 null。在IE对add ()方法的实现屮，第二个参数是可选的，而且如果指定，该参数必须是新选项之后 选琐的索引。兼容DOM的浏览器要求必须指定第二个参数，因此要想编写跨浏览器的代码，就不能只 传人一个参数。这时候，为第二个参数传人undefined,就可以在所有浏览器中都将新选项插人到列 表最后了。来看-个例子。</p>

<p>var newOption = new Option(&ldquo;Option text *, &ldquo;Option value&rdquo;); selectbox. add (newOption, undefined); //袭值方案</p>

<p>Selectbox£xample04. htm</p>

<p>在IE和兼容DOM的浏览器中，上面的代码都可以正常使用。如果你想将新选项添加到其他位置(不 是最后一个)，就应该使用标准的DOM技术和insertBef ore {)方法。</p>

<p>就和在HTML中一样，此时也不一定要为选项指定值。换句话说，只为option 构造函数传入一个参数(选项的文本)也没有问题„</p>

<p>14.3.3移除选项</p>

<p><img src="E:/11.ProgramFiles/Typora/JavaScriptd8a70b8fbea1082c34809-82.jpg" alt="img" /></p>

<p>与添加选项类似，移除选项的方式也有很多种。首先，可以使用DOM的removeChildO方法, 为传人要移除的选项，如下面的例子所示：</p>

<p>selectbox.removeChiId(selectbox.options[0]};    //移除■第一个选项</p>

<p>其次，可以使用选择框的remove (&gt;方法。这个方法接受一个参数，即要移除选项的索引，如下面 的例子所示：</p>

<p>selectbox.remove{0) ;    //移除第一个选项</p>

<p>圾后一种方式，就是将相应选项设置为null。这种方式也是DOM出现之前浏览器的遗留机制。 例如：</p>

<p>se 1 Get box. options [0] = null;    //移汾第一个选項</p>

<p>要清除选择框中所有的项，需要迭代所有选项并逐个移除它们，如下面的例子所示：</p>

<p>function clearSelectbox(selectbox){</p>

<p>for(var i=0, len=selectbox.options.length； i &lt; len； i++){</p>

<p>selectbox.remove(i)；</p>

<p>}</p>

<p>}</p>

<p>这个函数每次只移除选择框屮的第一个选项。由于移除第一个选项后，所有后续选项都会自动向上 移动一个位S,因此承复移除第一个选项就可以移除所有选项了。</p>

<p>14.3.4移动和重排选项</p>

<p>在DOM标准出现之前，将一个选择框中的选项移动到另一个选择框中是非常麻烦的。整个过程要 涉及从第一个选择框中移除选项，然后以相同的文本和值创建新选项，最后再将新选项添加到第二个选 择框中。而使用DOM的appendChildO方法，就可以将第一个选择框中的选项直接移动到第二个选 择框中。我们知道，如果为appendChildO方法传人一个文梢中已有的元素，那么就会先从该元素的 父节点中移除它，再把它添加到指定的位2。下面的代码展示了将第一个选择框中的第一个选项移动到 第二个选择框屮的过程。</p>

<p>var selectboxl = document.getElementByld(&ldquo;selLocationsl&rdquo;); var selectbox2 = document.getElementByld(*selLocations2&rdquo;)； selectbox2.appendChild{selectboxl.options[0]);</p>

<p>SelectboxExample05. htm</p>

<p>移动选项与移除选项有一个共同之处，即会重置每-•个选项的index属性。</p>

<p>宽排选项次序的过程也十分类似，最好的方式仍然是使用DOM方法。要将选择框中的某一项移动</p>

<p>到特定位置，最合适的DOM方法就是insertBefore (); appendChild()方法只适用于将选项添加 到选择框的最后。要在选择框中向前移动一个选项的位置，可以使用以下代码：</p>

<p>var optionToMove = selectbox.options[1];</p>

<p>selectbox.insertBefore(optionToMove, selectbox.options[optionToMove.index-11}；</p>

<p>SelectboxExample06. htm</p>

<p>以上代码首先选择了要移动的选项，然后将其插人到了排在它前面的选项之前。实际上，第二行代 码对除第一个选项之外的其他选项是通用的。类似地，可以使用下列代码将选择框中的选项向后移动一 个位置。</p>

<p>var optionToMove = selectbox.options[1]；</p>

<p>selectbox.insertBefore（optionToMove, selectbox.options[optionToMove.index+2]）;</p>

<p>SelectboxExample06. htm</p>

<p>以上代码适用于选择框中的所有选项，包括最后一个选项。</p>

<p>IE7存在一个页面重绘问題，有时候会导致使用DOM方法重排的选项不能馬上 正确星示。</p>

<p>14.4表单序列化</p>

<p>随着Ajax的出现，表单序列化已经成为一种常见需求（第21章将讨论Ajax ）。在JavaScript中，可 以利用表单字段的type属性，连同name和value属性一起实现对表单的序列化。在编写代码之前， 有必须先搞清楚在表单提交期间，浏览器是怎样将数据发送给服务器的。</p>

<p>□对表单字段的名称和值进行URL编码，使用和号（&amp;）分隔。</p>

<p>□不发送禁用的表单字段。</p>

<p>□只发送勾选的复选框和单选按钮。</p>

<p>□不发送type为”reset”和&rdquo;button1*的按钮。</p>

<p>□多选选择框中的每个选中的值单独一个条目。</p>

<p>□在单击提交按钮提交表平的情况下，也会发送提交按钮；否则，不发送提交按钮。也包括type 为&rdquo;image&rdquo;的＜ input〉元素。</p>

<p>□ ＜select＞7li^的值，就是选中的＜option＞^J£素的value特性的值。如果＜＜^:1011＞元素没有 value特性，则是＜01）1::1011＞元索的文本值。</p>

<p>在表单序列化过程中，一般不包含任何按钮字段，因为结果字符串很可能是通过其他方式提交的。 除此之外的其他上述规则都应该遵循。以下就是实现表单序列化的代码。</p>

<p>function serialize{form){ var parts =[], field = null,</p>

<p>len,</p>

<p>3.</p>

<p>optLen,</p>

<p>option,</p>

<p>optValue;</p>

<p>for (i=0, len=form.elements.length； i &lt; len； i++){ field = form.elements[i];</p>

<p>switch{field.type}{</p>

<p>case &ldquo;select-one&rdquo;: case &ldquo;select-multiple&rdquo;:</p>

<p>if (field.name.length){</p>

<p>for (j-0, optLen = field.options.length； j &lt; optLen； j++){</p>

<p>option = field.options[j]；</p>

<p><img src="E:/11.ProgramFiles/Typora/JavaScriptd8a70b8fbea1082c34809-83.jpg" alt="img" /></p>

<p>if (option.selected){ optValue = &ldquo;■； if (option.hasAttribute){</p>

<p>optValue = (option.hasAttribute(•value&rdquo;) ?</p>

<p>option.value : option.text)?</p>

<p>} else {</p>

<p>optValue = (option.attributesf&rdquo;value*J.specified ? option.value : option.text)；</p>

<p>}</p>

<p>parts.push(encodeURIComponent(field.name) + ■=• + encodeURIComponent(optValue))；</p>

<p>break；</p>

<p>case undefined: case &ldquo;file&rdquo;: case •submit■: case &ldquo;reset&rdquo;: case &ldquo;button&rdquo;:</p>

<p>//字役集 //文件搶入</p>

<p>//提交按妇 //重置按钽</p>

<p>//白定义按相</p>

<p>break;</p>

<p>case &ldquo;radio*:    //单选按</p>

<p>case &ldquo;checkbox*:    //复选框</p>

<p>if {I field.checked){ break;</p>

<p>}</p>

<p>/<em>执行默认操作</em>/</p>

<p>default:</p>

<p>//不包含没有名字的表单字段 if (field.name.length){</p>

<p>parts.push(encodeURIComponent(field.name) + ■=■ + encodeURIComponent(field.value));</p>

<p>)</p>

<p>}</p>

<p>}</p>

<p>re匕urn parts. join (•*&amp;&ldquo;)；</p>

<p>FormSerlalizationExampleOl. htm</p>

<p>上面这个serialize ()函数首先定义了一个名为parts的数组，用于保存将要创建的字符串的各 个部分。然后，通过for循坏迭代每个表单字段，并将其保存在field变量中。在获得了一个字段的 引用之后，使用switch语句检测其type属性。序列化过程中最麻烦的就是＜Select＞元素，它可能 是单选框也可能是多选框。为此，需要遍历控件中的每一个选项，并在相应选项被选中的情况下向数组 中添加一个值。对于单选框，只可能有一个选中项，而多选框则可能有零或多个选中项。这里的代码适 用T-这两种选择框，至于可选项的数量则是由浏览器控制的。在找到一个选中项之后，需要确定使用什 么值。如果不存在value特性，或者虽然存在该特性，但值为空字符串，都要使用选项的文本来代替。 为检査这个特性，在DOM兼容的浏览器屮需要使用hasAttributeO方法，而在IE中需要使用特性 的 specif ied 属性。</p>

<p>如果表单中包含＜£1么＜3561;＞元素.则该元索会出现在元素集合中，但没有type属性。因此，如果type 属性未定义，则不需要对其进行序列化。同样，对于各种按钮以及文件瑜人字段也是如此(文件输人字段在 表单提交过程中包含文件的内容；但是，这个字段是无法模仿的，序列化时一般都要忽略)。对于单选按钮 和复选框，要检査其checked属性是否被设置为false，如果是则退出switch语句。如果checked域性 为true,则继续执行default语句，即将当前字段的名称和值进行编码，然后添加到parts数组中。函数 的敁后-步，就是使用join()格式化整个宁符串，也就是用和号来分隔每彳表单字段。</p>

<p>最后，serialized函数会以杏询字符申的格式输出序列化之后的7符串。当然，要序列化成其他 格式，也不是什么困难的事。</p>

<p>14.5富文本编辑</p>

<p>富文本编辑，又称为WYSIWYG ( What You See Is What You Get,所见即所得)。在网页中编辑富 文本内容，是人们对Web应用程序最大的期待之一。里然也没布规范，仴在IE最早引人的这一功能基 础上，已径出现了事实标准。而Opera、Safari, Chrome和Firefox都已经支持这一功能c这一技术 的本质，就是在贞面中嵌人一个包含空HTML页面的i£rame。通过设置designMode属性，这个空白 的HTML页面可以被编辑，而编辑对象则是该页面<body>元素的HTML代码。designMode属性有两 个口J能的值：&rdquo;off (默认值)和-on-。在设置为•’on”时，整个文档都会变得可以编辑(显示插人符 号)，然后就可以像使用字处理软件一样，通过键盘将文本内容加粗、变成斜体，等等。</p>

<p>可以给iframe指定一个非常简单的HTML页面作为其内容来源。例如：</p>

<p>&lt;!DOCTYPE hcml&gt;</p>

<p><htrol></p>

<p><head></p>

<p><title>Blank Page for Rich Text Editing</title> </head></p>

<p><body></p>

<p></body></p>

<p>这个页面在iframe中可以像其他页面一样被加载。要让它可以编辑，必须要将designMode设置 为&rdquo;on&rsquo;但只有在页面完全加载之后才能设置这个属性。因此，在包含页面中，需要使用onload事件 处理程序来在恰当的时刻设S designMode,如下面的例子所示：</p>

<p><iframe ncnne="richedit■ style=，heigbt:lOOpx'.width: lOOpx; * src=1,blank.htm*></ifraine></p>

<script type?text/javascript

EventUtil.addHandler(window, "load", function(){ frames f"richedicp.document.designMode = "on"；

});

</script>

<p>等到以上代码执行之后，你就会在页面中看到一个类似文本框的可编辑区字段。这个区字段具有与 其他网页相同的默认样式；不过，通过为空白页面应用CSS样式，可以修改可编辑区字段的外观。</p>

<p>14.5.1 使用 content editable 属性</p>

<p>另一种编辑富文本内容的方或是使用名为contenteditable的特殊属性，这个属性也是由IE最 旱实现的。可以把contenteditable属性应用给页面中的任何元索，然后用户立即就可以编辑该元素。 这种方法之所以受到欢迎，是因为它不需要iframe、空內页和JavaScript,只要为元素设置 contenteditable 域性即可。</p>

<p><div class="editable" id="richedit■ contenteditablax/div></p>

<p>这样，元素中包含的任何文本内容就都可以编辑r,就好像这个元素变成了 ＜textarea＞元索一样。 通过在这个元素上没置contenteditable属性，也能打开或关闭编辑模式。</p>

<p>var div = document.getElementById（&rdquo;richedit&rdquo;）; richedit.contentEditable = &ldquo;true&rdquo;;</p>

<p>contenteditable属性有三个可能的值：&rdquo;true&rdquo;表示打开、&rdquo;false&rdquo;表求关闭，&rdquo;inherit&rdquo;表示 从父元素那里继承（因为可以在contenteditable元尜中创建或删除元索）。支持contenteditable 属性的元素有IE、Firefox、Chrome、Safari和Opera,,在移动设备上，支持contenteditable属性的 浏览器有iOS 5+中的Safari和Android 3+中的WebKit。</p>

<p>14.5.2操作富文本</p>

<p>与富文本编辑器交互的主要方式，就是使用document. execComiuand （）。这个方法可以对文样执 行预定义的命令，而且可以应用大多数格式。可以为document. execCommand ｛）方法传递3个参数： 要执行的命令名称、表示浏览器是否应该为当前命令提供用户界面的一个布尔值和执行命令必须的一个 值（如果不需要值，则传递null）。为了确保跨浏览器的兼容性，第二个参数应该始终设置为false, 因为Firefox会在该参数为true时抛出错误。</p>

<p>不同浏览器支持的预定义命令也不一样。下表列出了那些被支持最多的命令。</p>

<table>
<thead>
<tr>
<th>命    令</th>
<th>值（第三个参数）</th>
<th>说    明</th>
</tr>
</thead>

<tbody>
<tr>
<td>backcolor</td>
<td>颜色字符串</td>
<td>没s文杓的背彔颜色</td>
</tr>

<tr>
<td>bold</td>
<td>null</td>
<td>将选择的文本转换为粗体</td>
</tr>

<tr>
<td>copy</td>
<td>null</td>
<td>将选择的文本复制到剪貼板</td>
</tr>

<tr>
<td>createlink</td>
<td>URL字符串</td>
<td>将选择的文本转换成一个链接，指向指定的URL</td>
</tr>

<tr>
<td>cut</td>
<td>null</td>
<td>将选择的文本剪切到剪貼板</td>
</tr>

<tr>
<td>delete</td>
<td>null</td>
<td>删除选择的文本</td>
</tr>

<tr>
<td>fon:name</td>
<td>字体名称</td>
<td>将选择的文本修改为指定字体</td>
</tr>

<tr>
<td>foncsize</td>
<td>1~7</td>
<td>将选择的文本修改为指定字体大小</td>
</tr>

<tr>
<td>forecolor</td>
<td>颜色字符串</td>
<td>将选择的文本修改为指定的颜色</td>
</tr>

<tr>
<td>forroatblock.</td>
<td>要包闱当前文本块的 HTML^签；ia＜hl＞</td>
<td>使用指定的HTML标签来格式化选择的文本块</td>
</tr>

<tr>
<td>indent</td>
<td>null</td>
<td>缩进文本</td>
</tr>

<tr>
<td>inserthorizontalrule</td>
<td>null</td>
<td>在插入字符处插人一t＜hr＞元索</td>
</tr>

<tr>
<td>insert image</td>
<td>阁像的URL</td>
<td>在插入字符处插人一个阁像</td>
</tr>

<tr>
<td>insertorderedlist</td>
<td>null</td>
<td>在插人字符处插人-个＜ol＞元素</td>
</tr>

<tr>
<td>insertunorderedlist</td>
<td>null</td>
<td>在插人字符处插人一个＜ul＞元索</td>
</tr>

<tr>
<td>insertparagraph</td>
<td>null</td>
<td>在插人字符处插入一个＜P＞元素</td>
</tr>

<tr>
<td>italic</td>
<td>null</td>
<td>将选择的文本转换成斜体</td>
</tr>

<tr>
<td>justifycenter</td>
<td>null</td>
<td>将插入光标所在文本块居屮对齐</td>
</tr>

<tr>
<td>justifyleft</td>
<td>null</td>
<td>将插人光标所在文本块左对齐</td>
</tr>

<tr>
<td>outdent</td>
<td>null</td>
<td>凸排文本（咸少缩进）</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th>（续）</th>
<th></th>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td>命    令</td>
<td>值（第三个参数）</td>
<td>说    明</td>
</tr>

<tr>
<td>paste</td>
<td>null</td>
<td>将剪贴板屮的文本粘贴到选择的文本</td>
</tr>

<tr>
<td>rerooveformat</td>
<td>null</td>
<td>移除插人光杯所在文本块的胃&amp;式。这是撤销formatblock 命令的操作</td>
</tr>

<tr>
<td>seleccall</td>
<td>null</td>
<td>选择文档中的所有文本</td>
</tr>

<tr>
<td>underline</td>
<td>null</td>
<td>为选择的文本添加下划线</td>
</tr>

<tr>
<td>unlink</td>
<td>null</td>
<td>移除文本的链接。这是撤销createlink命令的操作</td>
</tr>
</tbody>
</table>

<p>其中，与剪貼板有关的命令在不同浏览器屮的差异极大。Opera根本没有实现任何剪贴板命令，而 Firefox在默认情况下会禁用它们（必须修改用户的首选项来启用它们）。Safari和Chrome实现了 cut和 copy,假没有实现paste。不过，即使不能通过document .execConwnand （＞来执行这些命令，但却可 以通过相应的快捷键来实现同样的操作。</p>

<p>可以在任何时候使用这些命令来修改富文本区域的外观，如下面的例子所示。</p>

<p>//转换粗体丈本</p>

<p>frames r■richedit&rdquo;].document.execCommand(</p>

<p>&ldquo;bold&rdquo;, false, null);</p>

<p>■italic&rdquo;, false, null);</p>

<p>&ldquo;createlink&rdquo;, false, &ldquo;<a href="http://www.wrox.com">http://www.wrox.com</a>&rdquo;)?</p>

<p>■formatblock&rdquo;, false, &ldquo;<hl>&ldquo;</p>

<p>//转换斜体文本</p>

<p>frames(&ldquo;richedit&rdquo;].document.execCommand(</p>

<p>//创建指向www.wrox.com的健接</p>

<p>frames[*richedit&rdquo;J.document.execCommand{</p>

<p>//格式化为1级标题</p>

<p>frames f■richedit&rdquo;].document.execCommand(</p>

<p>RichTextEditingExampleOl, htm</p>

<p>同样的方法也适用于页面中contenteditable属性为-true。的区块，只要把对框架的引用替换 成当前窗口的document对象即可。</p>

<p>//转换扭体文本</p>

<p>document.execCommand{&ldquo;bold&rdquo;, false, null）;</p>

<p>//转换斜体文本</p>

<p>document.execCommand(&ldquo;italic&rdquo;, false, null);</p>

<p>//刻建拍向www.wrox.com的链接</p>

<p>document.execCommand(&ldquo;createlink&rdquo;, false,</p>

<p>■<a href="http://www.wrox.com&quot;)；">http://www.wrox.com&quot;)；</a></p>

<p>//格式化为1级标题</p>

<p>document.execCommand(&ldquo;formatblock&rdquo;# false, &ldquo;<hl>&rdquo;};</p>

<p>Rich TextEditingExampleOLhfm</p>

<p>需要注意的是，虽然所有浏览器都支持这些命令，但这些命令所产生的HTML仍然有很大不同。 例如，执行bold命令时，IE和Opera会使用＜strong＞#签包陶文本，Safari和Chrome使用＜b＞^签，</p>

<p>而Firefox则使用＜span＞标签。由于各个浏览器实现命令的方式不同，加上它们通过innerHTML实现 转换的方式也不一样，因此不能指望富文本编辑器会产生一致的HTML。</p>

<p>除了命令之外，还有一些与命令相关的方法。第一queryCammandEnabled(),可以用它来检 测是否可以针对当前选择的文本，或者当前插人字符所在位置执某个命令。这个方法接收一4&rdquo;参数，即要 检测的命令。如果当前编辑区域允许执行传人的命令，这个方法返回tme,否则返回false。例如：</p>

<p>var result = frames[&ldquo;richedit&rdquo;].document.queryCommandEnabled(Mbold&rdquo;);</p>

<p>如果能够对当前选择的文本执行•bold”命令，以上代码会返间true。需要注意的是，guery-CommandEnabledU方法返回true,并不意味着实际上就可以执行相应命令，而只能说明对当前选择 的文本执行相应命令是否合适。例如，Firefox在默认情况下会禁用剪切操作，但执行01^17＜；0胃£111＜3-Enabled(&ldquo;cut&rdquo;)也可能会返冋 true。</p>

<p>另外，gueryCommandStateO方法用于确定是否已将指定命令应用到了选择的文本。例如，要确 定当前选择的文本是否已经转换成了粗体，可以使用如下代码。</p>

<p>I var isBold = frames [ &ldquo;richedit&rdquo;] .document.queryCommandStateCbold*);</p>

<p>Rich TextEditingExampleOl .htm</p>

<p>如果此前已经对选择的文本执行r”bold•命令，那么上面的代码会返冋true。一些功能全面的富 文本编辑器，正是利用这个方法来更新担体、斜体等按钮的状态的。</p>

<p>最后一个方法是queryCommandValue (),用于取得执行命令时传人的值(即前面例子中传给 document.execCommand(＞的第」个参数)。例如，在对一段文本成用&rdquo;fontsize&rdquo;命令时如果传人了 7,那么下面的代码就会返回”7•:</p>

<p>var fontSize = frames[&ldquo;richedit&rdquo;J.document.queryCommandValue(&ldquo;fontsize&rdquo;);</p>

<p>RichTextEditingExampleOl .htm</p>

<p>通过这个方法可以确定某个命令是怎样应用到选择的文本的，可以据以确定再对其应用后续命令是 否合适。</p>

<p>14.5.3富文本选区</p>

<p>在富文本编辑器中，使用框架(iframe)的getSelection ()方法，可以确定实际选择的文本。 送个方法是window对象和document对象的属性，调用它会返回一个表示当前选择文本的Selection 对象。每个Selection对象都有下列属性。</p>

<p>□    anchorNode:选区起点所在的节点。</p>

<p>□    anchorOffset:在到达选区起点位置之前跳过的anchorNode中的字符数量。</p>

<p>□    focusNode：选区终点所在的节点。</p>

<p>□    focusOffset: focusNode中包含在选区之内的字符数最。</p>

<p>□    iscollapsed：布尔值，表示选区的起点和终点是否重合。</p>

<p>□    rangeCount：选区中包含的DOM范围的数讀。</p>

<p>Selection对象的这些属性并没有包含多少有用的信息。好在，该对象的下列方法提供了更多信 息，并且支持对选区的操作。</p>

<p>□    addRange (range):将指定的DOM范洞添加到选K中。</p>

<p>□    collapse (node, offset):将选区折魯到指定节/S中的相应的文本偏移位置。</p>

<p>□    collapseToEnd{):将选区折香到终成位置。</p>

<p>□    collapseToStart ():将选区折叠到起点位置。</p>

<p>□    containsNode (node):确定指定的节点是否包含在选区中c</p>

<p>□    deleteFromDocument ():从文档中删險选区中的文本，与document .execCommand( ’’delete&rdquo; z false, null)命令的结果相同。</p>

<p>□    extend (node, offset):通过将focusNode和focusOf fset移动到指定的值来扩展选区。</p>

<p>口 get Rang eAt (index):返M索引对应的选区中的DOM范围。</p>

<p>□    removeAllRangesO：从选区中移除所有DOM范围。实际上，这样会移除选K,因为选区中 至少要有一个范围。</p>

<p>□    reomveRange(range):从选区中移除指定的DOM范围。</p>

<p>Q selectAUChildren (node):清除选区并选择指定节点的所有子节点。</p>

<p>□    toStringO ：返回选区所包含的文本内容。</p>

<p>Selection对象的这些方法都极为实用，它们利用了(第12章讨论过的)DOM范围来管理选区。 由于可以直接操作选择文本的DOM表现，W此访问DOM范围与使用execCommandO相比，能够对富 文本编辑器进行更加细化的控制。下面来看一个例子。</p>

<p>var selection = frames[&ldquo;richedit*].getSelection();</p>

<p>//取得选择的文本</p>

<p>var selectedText = selection.toString();</p>

<p>//取得代表选区的范围</p>

<p>var range = selection.getRangeAt(0);</p>

<p>//突出显示选择的文本</p>

<p>var span = frames[TichediC* ].document.createElement(&ldquo;span&rdquo;); span.style.backgroundColor = &ldquo;yellow&rdquo;; range.surroundContents(span)；</p>

<p>RichTextEditingExampleOL htm</p>

<p>以上代码会为富文本编辑器中被选择的文本添加黄色的背景。这里使用了默认选区中的DOM范围, 通过surroundContents ()方法将选区添加到了带有黄色背景的＜3口311＞元素中。</p>

<p>HTML5 将 getSelection ()方法纳人了标准，而且 1E9、Firefox、Safari、Chrome 和 Opera 8 都实 现Y它。由于历史原因，在Firefox3.64■中调用document .getSelection()会返回一个字符串。为此， 力I以在 Firefox 3.6+中改作调用 window.getSelection{),从而返回 selection 对象。Firefox8 修复 了 document .getSelection ()的 bug,能返回与 window.getSelection ()相同的值。</p>

<p>IE8及更早的版本不支持DOM范围，但我们可以通过它支持的selection对象操作选择的文本。 IE中的selection对象是document的漓性，本章前面曾经讨论过。要取得富文木编辑器中选择的文 本，首先必须创建•个文本范围(请参考第12章中的相关内容)，然后再像下面这样访问其text属性。</p>

<p>var range = frames[&ldquo;richedit•].document.selection.createRangeO; var selectedText = range.text;</p>

<p>虽然使用IE的文木范围来执行HTML操作并不像使用DOM范围那么可靠，但也不失为一种有效 的途径。要像前面使用DOM范围那样实现相同的文本髙亮效果，可以组合使用htmlText属性和 pasteHTML ()方法。</p>

<p>var range = frames[&ldquo;richedit&rdquo;].document.select ion.createRange();</p>

<p>range.pasteHTML(■<span style=\"background-color：yellow\"> ’ + range.htmlText +</p>

<p>•</span>&rdquo;)；</p>

<p>以上代码通过htmlText取得了当前选区中的HTML,然后将其放在了 -对&lt;叩抓&gt;标签中，最后 又使用pasteHTML ()将结果重新插入到了选区中。</p>

<p>14.5.4表单与富文本</p>

<p>由于富文本编辑是使用iframe而非表单控件实现的，因此从技术上说，富文本编辑器并不属于表 单。换句话说，富文本编辑器中的HTML不会被自动提交给服务器，而需要我们手工来提取并提交 HTML。为此，通常可以添加一个隐藏的表单字段，让它的值等于从iframe中提取出的HTML。具体 来说，就是在提交表单之前，从iframe中提取出HTML,并将其插人到隐藏的字段中。下面就是通过 表单的onsubmit事件处理程序实现1•.述操作的代码。</p>

<p>EventUti1.addHandler(form, &ldquo;submit&rdquo;, function(event){ event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event);</p>

<p>target.elements[&ldquo;comments&rdquo;].value = frames[&ldquo;richedit&rdquo;].document.body.innerHTML；</p>

<p>});</p>

<p>Rich TextEditingExampleOl .htm</p>

<p>在此，我们通过文档主体的innerHTML屈性取得了 iframe中的HTML,然后将插人到了名为 •comments•&rsquo;的表单字段中。这样可以确保沿好在提交表单之前填充Comments。字段。如果你想在代 码中通过submit ()来手工提交表单，那么一定不要忘记事先执行上面的操作。对于contenteditable 元素，也可以执行类似操作。</p>

<p>EventUtil.addHandler{form, &ldquo;submit&rdquo;, function(event){ event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event);</p>

<p>target .elements [NcommentaM] .value 囂</p>

<p>docuaent.getBlementByld(&ldquo;richedit*)•izmerHTML；</p>

<p>));</p>

<p>14.6小结</p>

<p>虽然HTML和Web应用自诞生以来已经发生了天翻地覆的变化，但Web表単相对却没有什么改 变。使用JavaScript可以增强已有的表单字段，从而创造出新的功能，或者提升表单的易用性。为此， 表隼、表单字段都引入了相应的展性和方法，以便JavaScript使川。下面是本章介绍的几个概念。</p>

<p>□可以使用一些标准或非标准的方法选择文本框中的全部或部分文本。</p>

<p>□大多数浏览器都采用了 Firefox操作选择文本的方式，但IE仍然坚持自己的实现。</p>

<p>U在文本框的内容变化时，可以通过侦听键盘事件以及检测插人的字符，来允许或禁止用户输人 某些字符。</p>

<p>除Opera之外的所有浏览器都支持剪贴板事件，包括copy、cut和paste。其他浏览器在实现剪 贴板事件吋也4以分为几种不同的情况。</p>

<p>□    IE、Firefox、Chrome和Safari允许通过JavaScript访问剪贴板中的数据，而Opera不允许这种访 问方式。</p>

<p>□即使是IE、Chrome和Safari,它们各ft的实现方式也不相同。</p>

<p>□    Firefox, Safari和Chrome只允许在paste事件发生时读取剪貼板数据，而IE没有这个限制。</p>

<p>□    Firefox、Safari和Chrome只允许在发生剪贴板事件时访问与剪貼板相关的信息，而IE允许在任 何时候访问相关信息。</p>

<p>在文本框内容必须限制为菜些特定字符的情况下，就可以利用剪贴板事件来屏蔽通过粘贴向文本框 中插人内容的操作。</p>

<p>选择框也是经常要通过JavaScript来控制的一个表单字段。由于有TDOM,对选择框的操作比以前 要方便多了。添加选项、移除选项、将选项从一个选择框移动到另一个选择框，甚至对选项进行排序等 操作，都可以使用标准的DOM技术来实现。</p>

<p>富文本编辑功能是通过一个包含空HTML文档的iframe元素来实现的。通过将空文档的 designMode属性设置为”,就可以将该页面转换为可编辑状态，此时其表现如同字处理软件。另外， 也可以将某个元素设置为contenteditableo在默汄情况下，可以将字体加粗或者将文本转换为斜体， 还可以使用剪贴板。JavaScript通过使用execCommand()方法也可以实现相同的一些功能。另外，使用 gueryCommandEnabled () x queryCornmandState (&gt; 和 queryCoitunandValue ()方法则可以取得有关 文本选区的倍息。由于以这种方式构建的富文本编辑器并不是一个表单字段，因此在将其内容提交给 服务器之前，必须将iframe或content editable元素中的HTML复制到一个表单字段中。</p>

    </div>

    
    

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05-%E5%9F%BA%E7%A1%80%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/js/js15-%E4%BD%BF%E7%94%A8canvas%E7%BB%98%E5%9B%BE/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">JS15 使用Canvas绘图</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/01-%E7%9F%A5%E8%AF%86%E6%A0%91/03-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05-%E5%9F%BA%E7%A1%80%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/js/js11-dom%E6%89%A9%E5%B1%95/">
            <span class="next-text nav-default">JS11 DOM扩展</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="iteratelyd@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/iterateself" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/thebegin/activities" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/68028070/" class="iconfont icon-douban" title="douban"></a>
  <a href="http://iterate.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">iterateself</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>








</body>
</html>
